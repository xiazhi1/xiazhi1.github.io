<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiazhi1.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="夏至的个人博客">
<meta property="og:url" content="http://xiazhi1.github.io/index.html">
<meta property="og:site_name" content="夏至的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="夏至">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xiazhi1.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>夏至的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">夏至的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2023/11/09/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/09/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/" class="post-title-link" itemprop="url">数字信号处理考前拾遗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-09 21:53:59" itemprop="dateCreated datePublished" datetime="2023-11-09T21:53:59+08:00">2023-11-09</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/" class="post-title-link" itemprop="url">计算机网络考前拾遗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-09 19:36:21" itemprop="dateCreated datePublished" datetime="2023-11-09T19:36:21+08:00">2023-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-10 19:57:21" itemprop="dateModified" datetime="2023-11-10T19:57:21+08:00">2023-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E5%AD%A6%E5%8A%9F%E8%AF%BE/" itemprop="url" rel="index"><span itemprop="name">大学功课</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>更新中...</p>
<h2 id="前言">前言</h2>
<p>本文只针对华中科技大学电子信息与通信学院计算机网络考试要求进行知识点归纳总结与提炼，内容不保证能满足各位读者的需求。</p>
<h2 id="第一章绪论">第一章：绪论</h2>
<h3 id="计算机网络的定义和发展历史了解">计算机网络的定义和发展历史(了解)</h3>
<p>网络:网络由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成 互联网：多个网络通过路由器互连起来，构成一个覆盖范围更大的网络，即互联网,互联网是网络的网络 因特网：因特网是世界上最大的互连网络 发展历史：计算机网络最早的起源来自美国军方搭建的APANET</p>
<p><strong>简答：列表对比说明互联网(Internet)和互连网(internet)两个概念的异同。</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-35-18.png"></p>
<h3 id="理解设计计算机网络的技术需求理解">理解设计计算机网络的技术需求(理解)</h3>
<ol type="1">
<li>可扩展的连通性</li>
<li>高性价比的资源共享</li>
<li>支持通用服务</li>
<li>可管理性</li>
</ol>
<h3 id="电路交换与分组交换掌握">电路交换与分组交换(掌握)</h3>
<p><strong>简答：简要说明电路交换的要点</strong> 电路交换的要点包括:通信时需要经历三个阶段:建立连接、传送数据、释放连接;通信的双方之间需要建立一个专用的链路;通信过程中,沿着建立链路传输的数据无需路由;通信结束后,连接断开,链路资源被释放</p>
<p><strong>简答：简要说明分组交换的要点</strong> 分组交换的要点包括:将完整的报文分割成为较小的数据段,在每个数据段前面加上必要的控制信息组成首部,就构成了分组;通信过程中,沿途交换机采用“存储-转发”方式,根据分组首部中的目的地信息进行转发;通信过程中,各数据分组被独立路由和转发。</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-45-41.png"></p>
<h2 id="第二章网络体系结构">第二章：网络体系结构</h2>
<h3 id="层次化体系结构的原理掌握">层次化体系结构的原理(掌握)</h3>
<p><strong>简答：简述网络体系结构采用分层设计的好处</strong> 采用分层的网络体系结构的优势包括但不限于: (1)各层之间可以独立设计,便于分工协作,实现产业标准化; (2)层次化设计的灵活性好,一层发生变化不影响上下层; (3)层次化设计的扩展性好,各层可选用不同的技术来适应不同的应用需求。</p>
<h3 id="网络体系结构的相关概念理解">网络体系结构的相关概念(理解)</h3>
<ol type="1">
<li>实体：任何可发送或接收数据的硬件或软件进程</li>
<li>对等实体：收发双方相同层次中的实体</li>
<li>协议：控制两个对等实体进行逻辑通信的规则的集合</li>
<li>协议的三要素：
<ol type="1">
<li>语法,即数据与控制信息的结构或格式。</li>
<li>语义,即需要发出何种控制信息、完成何种动作以及做出何种响应。</li>
<li>同步,即事件实现顺序的详细说明。</li>
</ol></li>
</ol>
<p><strong>简答：层次化网络体系结构中的服务与协议有何区别?</strong> 层次化网络体系结构中,服务是垂直的,定义了该层能够代表它的用户完成的操作。上层是服务用户,下层是服务提供者。协议是水平的,定义的是对等实体间交换数据的格式、内容、时序,协议的实现保证了能够向上层提供服务。</p>
<h3 id="三种体系架构的模型与差异掌握">三种体系架构的模型与差异(掌握)</h3>
<figure>
<img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-00-22.png" alt="三种体系架构"><figcaption aria-hidden="true">三种体系架构</figcaption>
</figure>
<p><strong>简答：简述ISO/OSI参考模型各层功能与协议数据单元</strong> ISO/OSI参考模型各层功能自底向上分别为: (1)物理层:实现数据bitt在物理链路上的传输;数据单元：数据位(Bit) (2)数据链路层:处理相邻网络结点之间数据帧的传输;数据单元：数据帧 (3)网络层:处理互联网络中主机之间的分组传输;数据单元：数据分组 (4)传输层:实现终端主机进程之间的通信;数据单元：数据段 (5)会话层:实现通信的会话管理等功能;数据单元：数据 (6)表示层:实现不同表达形式数据之间的转换;数据单元：数据 (7)应用层:实现应用特定操作,向用户提供相应的服务.数据单元：数据</p>
<p><strong>简答：自上而下简述计算机网络体系结构的五层参考模型</strong> 网络体系结构的五层模型,自上向下依次为应用层、传输层、网络层、数据链路层、物理层。 应用层:为用户的应用进程提供服务 传输层:为两个主机中进程之间的通信提供端到端服务 网络层:为分组交换网上的不同主机提供通信服务 数据链路层:在相邻结点间的链路上透明传送数据 物理层:在传输媒质上实现透明的比特流传送</p>
<h3 id="计算机网络的性能指标的计算方法掌握">计算机网络的性能指标的计算方法(掌握)</h3>
<ol type="1">
<li>速率：连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率，基本单位：bit/s（bps），常用单位:kbps/Mbps <strong>这里的换算需要与计算机存储里面换算做区分，计算速率时:1k=1000,计算内存时：1k=1024</strong></li>
<li>带宽：表示网络的通信线路传送数据的能力，表示单位时间内从网络中某一点到另一点所能通过的<strong>最高数据率</strong>,单位与速率单位相同</li>
<li>吞吐量：表示单位时间内通过某个网络(或信道、接口)的数据量；用于测量实际上到底由多少数据量能通过网络，其受<strong>网络带宽或额定速率的限制</strong></li>
<li>时延：
<ul>
<li>发送时延：<span class="math inline">\(\frac{分组长度}{发送速率}\)</span></li>
<li>传播时延：<span class="math inline">\(\frac{信道长度}{电磁波传播速率}\)</span></li>
<li>处理时延：一般不便于计算</li>
<li>排队时延：一般不考虑 总时延=发送时延+传播时延+处理时延+排队时延</li>
</ul></li>
<li>时延带宽积：其值等于传播时延*带宽，时延带宽积可视为以比特为单位的链路长度,等效于第一个比特到达接收方时发送方可以发送的比特数(链路满载)。</li>
<li>往返时延(RTT):链路双向交互一次的时间</li>
</ol>
<h2 id="第三章直连网络">第三章：直连网络</h2>
<h3 id="直连网络的概念了解">直连网络的概念(了解)</h3>
<p>直连网络：所有的主机通过某种物理媒质直接连接，是最简单的网络形式</p>
<p><strong>物理层的四个特性</strong>： 机械特性：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压表示何意。 规程特性：指明对于不同功能的各种可能事件的出现顺序。</p>
<h3 id="不同组帧方法了解">不同组帧方法(了解)</h3>
<p>组帧方法主要分为以下两种： 1. 面向字节的协议：把每一帧看作一个字节集合，两种方法：字符计数法，起止标记法 2. 面向比特的协议：把数据帧看作比特的集合</p>
<h3 id="差错控制的概念理解">差错控制的概念(理解)</h3>
<p>为什么进行差错检测？ 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错，这称为比特差错，使用差错检测码来检测是否产生比特差错，是数据链路层的重要问题之一。</p>
<p>常用的差错检测方法： 1. 奇偶校验：添加一位奇偶校验位，能检测奇数个比特差错 2. 循环冗余校验(CRC)：检测出一定数量的差错，其主要步骤如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-23-16.png"></p>
<h3 id="可靠传输的概念和基本实现机制掌握">可靠传输的概念和基本实现机制(掌握)</h3>
<p>可靠传输：上文提到的比特差错只是传输差错的一种，传输差错还包括分组丢失，分组失序，分租重复</p>
<p>可靠传输的协议实现主要有以下几种： 停止等待协议（ARQ协议） 连续ARQ协议：包含两种策略：GO-BACK-N 和 选择性重传 滑动窗口协议</p>
<p>停止等待协议示意图 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-40-13.png" alt="停止等待协议示意图"></p>
<p>连续ARQ协议两种策略的优缺点分析： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-44-52.png"></p>
<p>滑动窗口协议的示意图： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-15.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-40.png"></p>
<p><strong>简答：简述数据链路层实现可靠传输的基本方法。</strong> 数据链路层实现可靠传输的基本设计方法包括: l 确认机制:接收方给发送方发送ACK,反馈已正确接收的数据帧; l 超时机制:发送方启动计时器,一旦出现超时则自动重传未确认的数据帧; l 帧序号:标记数据帧,以便识别重复的数据帧</p>
<h3 id="滑动窗口参数的计算方法掌握">滑动窗口参数的计算方法(掌握)</h3>
<p>滑动窗口参数的要求如下图所示 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-48-38.png"></p>
<h3 id="传统共享介质mac协议的设计要点理解">传统共享介质MAC协议的设计要点(理解)</h3>
<p><strong>简答：为什么在传统以太网的协议设计中,数据帧存在最短帧长的限制?</strong> 传统以太网的MAC层协议为CSMA/CD,其中CD称为冲突检测,主要解决信号传播时延导致的媒质接入问题。在争用信道过程中,结点边发送数据边监听信道,如果在一个争用周期范围内未检测到冲突发生,则成功占用信道。IEEE 802.3规定当某个结点完成一帧数据接收后,首先要判断接收的帧长度,如果接收帧长度小于规定的帧最小长度,则表明冲突发生。</p>
<h3 id="csmacd协议的原理掌握">CSMA/CD协议的原理(掌握)</h3>
<p><strong>简答：简述传统以太网的CSMA/CD算法要点</strong> CSMA/CD全称为带有冲突检测的载波侦听多路接入(Carrier Sense Multiple Access with Collision Detect)。其基本思想是载波监听,多点接入,碰撞检测。每个站点发送数据之前必须侦听信道的忙、闲状态;如果信道空闲,立即发送数据,同时进行冲突检测;如果信道忙,站点继续侦听总线,直到信道变成空闲。如果在数据发送过程中检测到冲突,将立即停止发送数据并等待一段随机长的时间,然后重复上述过程。</p>
<h3 id="无线局域网mac协议设计要点理解">无线局域网MAC协议设计要点(理解)</h3>
<p><strong>简答：CSMA/CD算法为何不能应用于无线局域网</strong> CSMA/CD算法需要硬件一边发送数据一边监听共享链路的占用情况,在冲突窗口时间内没有检测出冲突就确定为发送成功。这些设计在无线链路上难以满足。首先,在无线网卡实现信号的同时发送和接收的难度和代价较高;其次,无线通信环境中信号传输路径复杂,存在绕射、折射、反射等多径,难以估算传输延时和判断是否存在冲突。</p>
<h3 id="csmaca协议的原理理解">CSMA/CA协议的原理(理解)</h3>
<p><strong>简答：无线局域网CSMA/CA如何实现冲突避免?</strong> 冲突避免 Collision Avoidance,又称为虚拟载波侦听 (Virtual Carrier Sense),通过信令协商达到实际载波侦听的效果。协议约定在发送数据帧之前交换控制信息,发送方询问“Request to Send” (RTS),接收方收到 RTS后响应 “Clear to Send” (CTS),发送方收到 CTS, 则开始发送数据。在此过程中,如果其他结点收到 RTS或者 CTS,则停止发送,避免冲突。</p>
<h2 id="第四章分组交换网络">第四章：分组交换网络</h2>
<h3 id="数据报交换虚电路交换的原理理解">数据报交换、虚电路交换的原理(理解)</h3>
<p><strong>简答：对比虚电路和数据报两种分组交换技术</strong></p>
<p>数据报交换的思想是网络不负责提供可靠传输保证,分组中包括源/目的地址,沿途交换机根据该地址独立处理和转发分组。 虚电路交换的思想是网络提供可靠传输保证,传输过程包括连接建立、数据传输、连接释放等阶段。在连接建立过程中,交换机协商分配局部的虚电路号并预留资源;数据传输过程中,分组首部内包含有本地交换所需的虚电路号,交换机根据虚电路号转发分组。</p>
<h3 id="局域网扩展网桥生成树算法的基本概念理解">局域网扩展，网桥，生成树算法的基本概念(理解)</h3>
<p><strong>局域网扩展的基本概念</strong>：局域网（LAN）扩展是指通过不同的技术手段，将原有的局域网范围进行扩大，以覆盖更大的区域或连接更多的设备。这种扩展可以通过多种方式实现：</p>
<ol type="1">
<li><p>无线局域网扩展：如Wi-Fi</p></li>
<li><p>有线局域网扩展：使用更长的网线等传输媒介，扩大局域网范围</p></li>
<li><p>虚拟局域网(VLAN)：通过在网络交换机上配置虚拟局域网，可以将原有的物理局域网划分为多个逻辑上独立的虚拟局域网，实现不同部门或功能的隔离和管理，同时在逻辑上连接它们，形成一个扩展的网络。</p></li>
<li><p>子网划分： 将原有的单一子网划分为多个子网，每个子网可以有自己的IP地址范围和路由规则，使得网络可以更有效地支持不同的设备和服务</p></li>
<li><p>中继器和网桥： 使用中继器和网桥等设备，可以将原有的局域网连接到其他局域网，实现不同物理位置之间的网络扩展。</p></li>
<li><p>广域网连接： 通过使用广域网（WAN）连接技术，如专线、VPN（虚拟专用网络）等，将不同地理位置的局域网连接起来，形成一个更大范围的网络。</p></li>
</ol>
<p><strong>网桥的基本概念</strong>：网桥工作在数据链路层，对接收到的帧进行过滤转发，通过网桥可以连接多个局域网，以建立更大的局域网</p>
<p>网桥可分为基本网桥和学习网桥，基本网桥将收到的帧向所有端口转发，这样效率很低，不能隔离碰撞域，常用的是学习网桥，采用选择性转发的方法，维护一个转发表，根据转发表（站表）确定转发端口，不向无关端口转发（能有效隔离碰撞域，效率高）。</p>
<p><strong>生成树算法的基本概念</strong>：生成树算法是为了解决广播风暴的问题而提出的一种算法，因为根据网桥的工作原理，帧有可能在环形网络中兜圈子而产生广播风暴。生成树算法通过从网络中剪掉一些链路，构造出该网络的生成树来解决广播风暴问题</p>
<p><strong>简答：简述透明网桥的要点?其在环状拓扑结构下可能发生什么问题?</strong> 透明网桥通过逆向自主学习方式构建MAC转发表 透明网桥在环状拓扑结构下可能发生广播风暴(绕弯子)现象,生成树算法可以有效解决该问题。</p>
<p><strong>简答：什么是广播风暴</strong> 网桥工作在数据链路层。网桥根据数据帧的源地址与目的地址来决定是否接收和转发该帧。随着网络规模的扩大与用户结点数的增加,可能出现“端口-结点地址表”中没有的结点地址信息,此时网桥无从决定应该从哪个端口转发,只能在所有端口广播。这种盲目广播会使帧的数量按指数规律增长,造成网络中无用的通信量剧增,形成“广播风暴”。</p>
<p><strong>简答：虚拟局域网是不是一种新的局域网?</strong> 虚拟局域网是局域网交换机给用户提供的一种服务,并不是一种新型局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符,称为VLAN标记,用来指明发送该帧的工作站属于哪一个VLAN。局域网交换机根据VLAN标记,对于到来流量进行转发。属于同一个VLAN标记的工作站可以相互访问。</p>
<h3 id="共享式以太网与交换式以太网的区别理解">共享式以太网与交换式以太网的区别(理解)</h3>
<p><strong>简答：共享式局域网与交换式局域网有哪些区别?</strong> 共享式局域网的核心设备是集线器,在任何一个时刻只能有一个结点通过共享信道发送数据。该网络内每个结点处于同一个冲突域内,结点得到的平均带宽约等于总带宽/结点数。 交换式局域网的核心设备是交换机,可以在它的多个端口之间建立多个并发连接,从而实现了结点之间数据的并发传输。该网络内结点的通信不存在冲突,结点得到接近总带宽的带宽。</p>
<h3 id="以太网中继器集线器网桥交换机的功能与区别掌握">以太网中继器、集线器、网桥、交换机的功能与区别(掌握)</h3>
<p><strong>简答：简述中继器、集线器、网桥、交换机等设备的区别</strong> 这4 种设备都是用于互联、扩展局域网的连接设备,但它们工作的层次和实现的功能不同: (1)中继器(Repeater),工作在物理层,解决数字信号在长距离基带传输中的失真和衰减问题,通过信号再生提升信号波形和强度的质量。 (2)集线器(Hub),工作在物理层,相当于一个多端口的中继器。集线器可以将多个结点连接成为一个共享式以太网。 (3)网桥(Network Bridge),工作在数据链路层,可以互联不同的物理层、不同的 MAC 子层以及不同速率的以大网,具有过滤帧、存储转发帧的功能。 (4)交换机(Switch),,工作在数据链路层,相当于一个多端口的网桥。允许端口之间建立多个并发的连接,实现多个结点之间的并发传输。</p>
<h2 id="第五章网络互联">第五章：网络互联</h2>
<h3 id="ip尽力服务的服务模型ip数据包转发原理理解">IP尽力服务的服务模型，IP数据包转发原理(理解)</h3>
<p><strong>"IP尽力服务"</strong>是一种服务模型，也称为“Best Effort Service”，是指在计算机网络中，网络设备尽其所能地传输数据，但不保证数据包的可靠性、顺序或时延。这种服务模型主要用于互联网中的IP网络，其中数据包以最佳可能的方式进行传输，但网络不提供对数据包的任何特殊处理或保证。</p>
<p><strong>IP数据包转发原理</strong>：</p>
<ol type="1">
<li>数据包的封装</li>
<li>路由器查找</li>
<li>数据包转发</li>
<li>数据包到达目标设备</li>
</ol>
<p><strong>简答：解释Everything over IP和IP over Everything的含义</strong> Everything over IP:从协议栈来看,TCP/IP网络可以为各式各样的应用提供服务,在IP层上面可以有很多的应用程序。 IP over everything:从协议栈看,TCP/IP网络也允许IP协议在各种异构网络构成互联网上运行,在IP层以上无需关心下层的物理网络实现。</p>
<h3 id="ipv4分段与重组的概念与计算掌握">IPv4分段与重组的概念与计算(掌握)</h3>
<p>IPv4分段与重组是一种处理大数据包的机制，允许将大于网络链路允许的最大传输单元（MTU）的IPv4数据包进行分割，并在到达目的地后重新组装这些分段。这是为了适应网络链路上的不同MTU和确保数据的正确传输。</p>
<p>在了解如何计算IPv4的分段和重组之前，我们需要了解IPv4数据报的首部格式 其示意图如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-38-31.png"></p>
<p>各参数含义如下： 1. 版本：表示IP协议版本 2. 首部长度，取值以4为单位，最小值为5，20字节，最大值为15，表明首部包含20字节固定部分和最大40字节可变部分 3. 可选字段：用于排错，很少使用 4. 填充字段：确保首部长度为4的整数倍，用全0填充 5. 区分服务：很少使用 6. 总长度：表示IP数据报总长度 7. 标识：属于同一数据包的各分片应该具有相同标识 8. 标志：各比特定义为: - DF位：1/0 表示是否允许分片 - MF位：1/0 表示后面是否还有分片 - 保留位：必须为0 9. 片偏移：指出其数据载荷部分在原数据基础上偏移了多少位，以八个字节为单位</p>
<p>其计算常涉及到如何将大数据包分为更小的片段进行传输，具体操作可以通过下图来理解 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-34-47.png"></p>
<p>值得注意的是：<strong>在IP层的计算中，IP实际的数据段需要减去首部长度，但如果题目说的是TCP传输层的报文传入下层IP层传输，则不需要减去TCP传输层的首部长度，因为IP层的数据载荷就是整个TCP报文</strong></p>
<h3 id="ipv4地址以及cidr设计和规划的概念与计算方法掌握">IPv4地址以及CIDR设计和规划的概念与计算方法(掌握)</h3>
<h4 id="ipv4的分类编址">IPv4的分类编址</h4>
<p>IP地址往往进行分类编址 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-56-24.png"></p>
<p><strong>且在每个网络的主机号中，全0的最小地址作为网络地址，全1的最大地址作为广播地址不可分配</strong></p>
<p>常用的3类网络的网络数和主机数的关系如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-59-13.png"></p>
<h4 id="ipv4划分子网">IPv4划分子网</h4>
<p>对于网络中的网络，我们往往是直接在该网络中分配子网，而不是申请新的网络号，这可表述为<strong>借用主机地址作为网络地址</strong> 我们可以用IP地址与子网掩码相与得到网络地址，其计算如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-04-24.png"></p>
<p><strong>给定一个分类的IP地址和子网掩码，即可计算子网划分细节</strong>： 1. <span class="math inline">\(子网数量=2^{子网掩码1数-网络号}\)</span> 2. <span class="math inline">\(子网可分配IP地址数量=2^{子网掩码0数}-3\)</span> 3. <span class="math inline">\(子网网络地址=子网地址，子网广播地址=下一个子网地址-1\)</span> 4. <span class="math inline">\(子网最小地址=子网地址+1，子网最大地址=下一个子网地址-2\)</span></p>
<h4 id="ipv4无分类编址超网--cidr">IPv4无分类编址(超网)--CIDR</h4>
<p>CIDR使用斜线记法，在<strong>斜线后面写上网络前缀所占比特数量</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-12-35.png"></p>
<p><strong>简答：说明IP地址与硬件地址的区别</strong> IP地址是连接互联网上的主机标识符;IP地址也被称为逻辑地址,其分配可以被静态指定也可以被动态分配;IPv4是32bit的,IPv6是128bit的。 硬件地址也被称为物理地址,用于标识每个网络接口设备;IEEE系列标准规定了MAC地址的格式,由48bit构成,由网卡制造商在生产时内置。</p>
<h3 id="arp协议dhcp协议nat协议icmp协议了解">ARP协议，DHCP协议，NAT协议，ICMP协议(了解)</h3>
<p>ARP协议用于将IP地址映射到MAC地址 DHCP协议用于将域名映射到IP地址 NAT协议用于在私有网络和公共网络中映射IP地址，允许多个设备享有一个IP地址 ICMP用于IP网络上的检错</p>
<p><strong>简答：ARP协议向网络层提供了转换地址的服务,是否属于数据链路层?</strong> 这种说法是错误的。ARP 不是向网络层提供服务,它本身就是网络层的一部分,帮助向传输层提供服务。数据链路层不存在IP地址问题,数据链路层协议把比特串从线路的一端传送到另一端。</p>
<h3 id="基于距离向量和基于链路状态的路由算法的原理与计算掌握">基于距离向量和基于链路状态的路由算法的原理与计算(掌握)</h3>
<p><strong>简答：简述距离向量路由算法原理,该算法有哪些不足?</strong> 该算法定义距离向量信息为当前结点到达每一个其他结点的代价,通过邻结点之间多轮次两两交换距离向量信息,基于Bellman-ford算法逐步更新到全网其它结点的最短路径下一跳。 该算法的不足包括,构造距离向量需要知道全网结点数量规模,可能产生无穷计算问题。</p>
<p><strong>简答：“好消息传得快,坏消息传得慢”描述的是哪个路由算法,如何克服?</strong> 这是距离向量路由算法的缺点。其原因是,路由交换时依赖两两信息交换,无法得到全局准确信息,导致计算到无穷。该问题无法通过算法改进彻底解决,在该算法对应的RIP协议中,通过设定路由跳数最大值来加以克服。RIP约定值为16即表示不可达,避免计算到无穷。</p>
<p><strong>简答：对比距离向量路由算法和链路状态路由算法的差异。</strong> 距离向量路由算法:与邻结点交互全局信息,每个结点仅与直接相连的结点通信,交互的信息是到达其余所有结点的距离,路由计算采用Bellman-ford算法。 链路状态路由算法:与全局结点交互局部信息,每个结点通过洪泛方式与其他所有结点通信,交互的信息是该结点相连链路的状态,路由计算采用Dijkstra算法。</p>
<h3 id="路由器与交换机的区别掌握">路由器与交换机的区别(掌握)</h3>
<p><strong>简答：作为中间设备,转发器、网桥、路由器和网关有何区别?</strong> 将网络互相连接起来要使用一些中间设备: (1) 物理层使用的中间设备叫做转发器。 (2) 数据链路层使用的中间设备叫做网桥或桥接器。 (3) 网络层使用的中间设备叫做路由器。 (4) 在网络层以上使用的中间设备叫做网关。用网关连接两个不兼容的系统需要在高层进行协议的转换。</p>
<h3 id="自治系统的概念域内路由与域间路由的概念理解">自治系统的概念，域内路由与域间路由的概念(理解)</h3>
<h4 id="自治系统">自治系统</h4>
<p>因特网将整个互联网划分为许多较小的自治系统 AS。 一个自治系统是一个互联网，其最重要的特点就是自治系统有权自主地决定在本系统内应采用何种路由选择协议。 一个自治系统内的所有网络都属于一个行政单位(例如，一个公司，一所大学，政府的一个部门，等等)来管辖。 一个自治系统的所有路由器在本自治系统内都必须是连通的。</p>
<h4 id="域内路由与域间路由">域内路由与域间路由</h4>
<p><strong>简答：IGP和EGP这两类协议的主要区别是什么?</strong> IGP是内部网关协议,即在一个自治系统内部使用的路由选择协议,代表性的包括RIP和OSPF协议。IGP的路由选择主要采用最短路径的算法。 EGP是外部网关协议,用于自治系统之间路由选择,目前使用最多的外部网关协议是BGP协议。EGP的路由选择受多种因素影响,通常不使用最短路径。</p>
<h3 id="路径向量路由算法的原理与bgp协议实现理解">路径向量路由算法的原理与BGP协议实现(理解)</h3>
<p><strong>路径向量路由算法</strong> 想法： 对距离向量进行扩展使其能够快速检测环路 支持灵活的路由策略 避免无穷计算问题</p>
<p>核心思想 : 通告整条路径 距离向量 : 发送到每一个目的地 d 的距离向量 路径向量 : 发送到每一个目的地 d 的路径向量</p>
<p><strong>BGP协议</strong></p>
<ol type="1">
<li>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 （不能兜圈子），而并非要寻找一条最佳路由</li>
<li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 BGP 发言人</li>
<li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换BGP 报文以建立 BGP 会话 ( session)，利用 BGP 会话交换路由信息。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站 。</li>
</ol>
<p><strong>简答：RIP、OSPF、BGP的承载协议有何不同,有何考虑?</strong> RIP采用UDP协议。RIP在1980年代早期开发,其只需要与邻结点交互信息。UDP虽然无可靠性保证,但传输开销较小,可以满足RIP的需求。 OSPF采用IP协议。OSPF在1980年代末期开发,其需要在全网交互信息。当时TCP/IP架构已经形成,直接使用IP协议,易于在路由器上实现链路状态信息的洪泛。 BGP采用TCP协议。BGB协议在不同的自治系统之间交换路由信息,交换域间路由信息需要可靠传输保证,所以选择TCP。</p>
<h3 id="ipv6协议了解">IPv6协议(了解)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-23-41.png"></p>
<h2 id="第六章端到端协议">第六章：端到端协议</h2>
<h3 id="传输协议udp与tcp的实现要点和对比理解">传输协议UDP与TCP的实现要点和对比(理解)</h3>
<p>UDP协议的实现要点： 1. 无连接的 2. 支持单播、多播和广播 3. 面向应用报文 4. 向上传提供无连接不可靠传输服务(适用于IP电话，视频会议等实时应用) 5. 首部短，仅8字节</p>
<p>TCP协议实现要点： 1. 面向连接 2. 一对一可靠通信 3. 面向字节流 4. 可靠传输，使用流量控制和拥塞控制 5. 首部最小20字节，最大60字节</p>
<p>UDP与TCP的对比 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-32-56.png"></p>
<p><strong>简答：为什么说UDP是面向报文的,而TCP是面向字节流的?</strong> UDP对应用程序交下来的报文,在添加首部后就向下交付IP层。UDP待交付的报文,既不合并,也不拆分,因此UDP是面向报文的。 TCP将应用层发送的报文看成是一串字节流,并对把每一个字节都进行编号,传输保证每一个字节都正确无误地传送到对方。因此TCP是面向字节流的。</p>
<h3 id="tcp连接的三次握手与四次挥手掌握">TCP连接的三次握手与四次挥手(掌握)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-47-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-48-36.png"></p>
<p><strong>简答：为什么在TCP连接建立时要使用三报文握手?</strong> 如果不采用三报文握手,而是仅仅两报文握手。一旦滞留在网络中某处的陈旧的SYN报文段抵达接收方,就会让接收方误以为这是一个新的连接而进入连接等待状态,导致接收方资源被占用而无法释放。</p>
<p><strong>简答：为什么TCP连接释放比连接建立过程多一次交互?</strong> TCP三次握手是确保两个站点都对当前建立连接进行确认,避免两个站点过去发送的连接建立请求延后到达后导致一方进入资源等待状态而空等。 TCP四次挥手在三次握手基础上增加一次,原因是接收方需要等待上层应用将数据取走,因此接收方一次表示确认收到释放请求,一次再发起释放请求。</p>
<h3 id="tcp流量控制滑动窗口掌握">TCP流量控制(滑动窗口)(掌握)</h3>
<p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收 一般我们采用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-46-04.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-45-43.png"></p>
<p><strong>简答：TCP发送窗口的大小取决于流量控制还是拥塞控制?</strong> TCP发送窗口的上限值是Min [rwnd,cwnd],即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。当接收窗口小于拥塞窗口时,发送窗口的大小取决于流量控制,即取决于接收端的接收能力;当拥塞窗口小于接收窗口时,则发送窗口的大小取决于拥塞控制,即取决于整个网络的拥塞状况。</p>
<h2 id="第七章拥塞控制">第七章：拥塞控制</h2>
<h3 id="拥塞控制的概念以及与流量控制的区别理解">拥塞控制的概念以及与流量控制的区别(理解)</h3>
<p><strong>简答：流量控制和拥塞控制的最主要的区别是什么?</strong> 流量控制是在一条TCP连接中的接收端采用的措施,用来限制对方(发送端)发送报文段的速率,以免在接收端来不及接收。流量控制只控制一个发送端。 拥塞控制是用来控制TCP连接中发送端发送报文段的速率,以免使互联网中的某处产生过载。拥塞控制可能会同时控制许多个发送端,限制它们的发送速率。</p>
<h3 id="tcp拥塞控制的主要机制掌握">TCP拥塞控制的主要机制(掌握)</h3>
<p>常用的机制主要是慢开始和拥塞避免 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-52-05.png"></p>
<p>为了进一步改进性能，又提出了快重传和快恢复算法 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-54-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-55-01.png"></p>
<h3 id="tcp拥塞控制与流量控制的综合计算掌握">TCP拥塞控制与流量控制的综合计算(掌握)</h3>
<p>仅举一例 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-56-31.png"></p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">湖科大计算机网络微课堂</a></li>
<li>Computer Networks: A Systems Approach, 5th Edition</li>
<li>华中科技大学电子信息与通信学院计算机网络课程组提供的优秀课件和资料</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2023/05/15/mips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/15/mips/" class="post-title-link" itemprop="url">mips</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-15 16:27:25 / 修改时间：16:30:22" itemprop="dateCreated datePublished" datetime="2023-05-15T16:27:25+08:00">2023-05-15</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="华中科技大学模拟与电路系统三实验汇总">华中科技大学模拟与电路系统（三）实验汇总</h1>
<h2 id="并行io接口实验">并行IO接口实验</h2>
<h3 id="实验任务">实验任务</h3>
<p>嵌入式计算机系统将独立按键以及独立开关作为输入设备，七段数码管作为输出设备。实现以下功能：</p>
<ol type="1">
<li><p>点击BTNC 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该二进制数的低8 位对应的二进制数值0 或1 显示到8 个七段数码管上。</p></li>
<li><p>点击BTNU 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该16 进制数据各位数字对应的字符0~F 显示到低4 位七段数码管上（高4 位七段数码管不显示）。</p></li>
<li><p>点击BTND 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该数据表示的无符号十进制数各位数字对应的字符0~9 显示到低5 位七段数码管上（高3 位七段数码管不显示）。</p></li>
</ol>
<p>程序控制方式提示：程序以七段数码管动态显示控制循环为主体，在循环体内的延时函数内循环读取按键键值以及开关状态，并根据按键值做相应处理。</p>
<h3 id="实验源码">实验源码</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;xil_io.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;xgpio.h&quot;</span><br><span class="line">#include &quot;sleep.h&quot;</span><br><span class="line">#include &quot;xtmrctr.h&quot;</span><br><span class="line">#include &quot;xintc_l.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char button = 0x0;</span><br><span class="line">    char segtable[16]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e&#125;;</span><br><span class="line">    short segcode[8]=&#123;0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff&#125;;</span><br><span class="line">    short pos=0xff7f;</span><br><span class="line">    Xil_Out16(XPAR_GPIO_0_BASEADDR+XGPIO_TRI_OFFSET,0xffff);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI_OFFSET,0X0);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI2_OFFSET,0x0);</span><br><span class="line">    Xil_Out8(XPAR_GPIO_2_BASEADDR+XGPIO_TRI_OFFSET,0x1f);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        while((Xil_In8(XPAR_GPIO_2_BASEADDR+XGPIO_DATA_OFFSET)&amp;0X1f)!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            button = Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f;</span><br><span class="line">            short sw = Xil_In16(XPAR_GPIO_0_BASEADDR+XGPIO_DATA_OFFSET);</span><br><span class="line">			while((Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f)!=0);</span><br><span class="line">            switch (button)</span><br><span class="line">            &#123;</span><br><span class="line">            case 0x1:</span><br><span class="line">                for(int j=0;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;j)&amp;0x1];</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x2:</span><br><span class="line">                    for(int j=0;j&lt;4;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;(4*j))&amp;0xf];</span><br><span class="line">                    &#125;</span><br><span class="line">                    for(int j=4;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x10:</span><br><span class="line">                int a=sw;</span><br><span class="line">                for(int j=0;j&lt;5;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    switch (a%10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            case(0):segcode[7-j]=segtable[0];break;</span><br><span class="line">                            case(1):segcode[7-j]=segtable[1];break;</span><br><span class="line">                            case(2):segcode[7-j]=segtable[2];break;</span><br><span class="line">                            case(3):segcode[7-j]=segtable[3];break;</span><br><span class="line">                            case(4):segcode[7-j]=segtable[4];break;</span><br><span class="line">                            case(5):segcode[7-j]=segtable[5];break;</span><br><span class="line">                            case(6):segcode[7-j]=segtable[6];break;</span><br><span class="line">                            case(7):segcode[7-j]=segtable[7];break;</span><br><span class="line">                            case(8):segcode[7-j]=segtable[8];break;</span><br><span class="line">                            case(9):segcode[7-j]=segtable[9];break;</span><br><span class="line">                        &#125;    </span><br><span class="line">                    &#125;</span><br><span class="line">                    a/=10;</span><br><span class="line">                &#125;</span><br><span class="line">                    for(int j=5;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;                </span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;8;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA_OFFSET,pos);</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA2_OFFSET,segcode[i]);</span><br><span class="line">        for(int j=0;j&lt;10000;j++);</span><br><span class="line">        pos=pos&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    pos=0xff7f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2023/03/05/deeplearning-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/05/deeplearning-tips/" class="post-title-link" itemprop="url">深度学习训练Tips</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-05 20:09:47 / 修改时间：21:15:51" itemprop="dateCreated datePublished" datetime="2023-03-05T20:09:47+08:00">2023-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">AI笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>635</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言">前言</h1>
<p>笔者在刚接触深度学习时，曾因为找不到系统实验指南而抓耳挠腮，十分痛苦，在搜索了无数次资源加上n次痛苦的debug后终于跑起了第一个深度学习实验，为了记录下自己的debug心得和为后来者提供一些建议，所以写下此博客，不足之处，望多多指正</p>
<h1 id="初期准备">初期准备</h1>
<h2 id="系统选择">系统选择</h2>
<p>尽可能选择Linux系统，因为大部分论文实验都是在Linux系统下操作开发，可能到Windows系统上会有一些“水土不服”（别问我是怎么知道的。。。） 推荐租云服务器:便宜的服务器平台：<a target="_blank" rel="noopener" href="https://www.autodl.com/home">AutoDL</a>[应该是市面上最便宜的，学生认证有优惠] 免费的服务器平台：<a target="_blank" rel="noopener" href="https://colab.research.google.com/">Google Colab</a>[12小时会自动断开，不过免费，分配的卡也还不错！] 如果自己电脑显卡较好且内存充足，可以选择装虚拟机后显卡直通或装双系统，其中显卡直通笔者没试过，装双系统有点折磨，且不太方便（两个系统不能同时在线）</p>
<h2 id="深度学习环境配置">深度学习环境配置</h2>
<p>这里网上教程很多，这里推荐一个我当时配的参考博客： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/LXP-Never/p/15151578.html#blogTitle0">凌逆战的博客</a></p>
<h1 id="具体实操">具体实操</h1>
<p>这里我以当时我配的CVPR2020 best paper（Unsupervised Learning of Probably Symmetric Deformable 3D Objects from Images in the Wild）举例： 首先打开论文查看论文代码位置： <img src="https://s2.loli.net/2023/03/05/a7ELmUqVIp4ZPxe.png" alt="训练tips_1.png"> 点击代码位置后在GitHub中下载代码 然后根据项目处的readme文件按步骤一步步配置 Tips：请注意创建虚拟环境，详细请看<a target="_blank" rel="noopener" href="https://blog.csdn.net/SARACH_WONG/article/details/89328307">conda创建环境</a> 通过创建环境我们可以在一台主机上同时配上不同实验的实验环境并进行训练</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2022/12/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">数学建模笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 19:33:40" itemprop="dateCreated datePublished" datetime="2022-12-27T19:33:40+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-10 15:07:33" itemprop="dateModified" datetime="2023-11-10T15:07:33+08:00">2023-11-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数学建模笔记姜启源">数学建模笔记（姜启源）</h1>
<h2 id="线性规划">线性规划</h2>
<ol type="1">
<li>定义： 在一组线性条件限制下，求一线性目标函数最大或最小的问题</li>
<li>标准的matlab形式：<span class="math inline">\(min f^T x,\)</span> <span class="math inline">\(s.t. \begin{cases} A\cdot x \le b\\ Aeq \cdot x = beq \\ lb \le x \le ub \end{cases}\)</span> 其中<span class="math inline">\(f,x,b,beq,lb,u\)</span>为列向量，<span class="math inline">\(A，Aeq\)</span>为矩阵</li>
<li>matlab相关求解命令为 <span class="math inline">\([x,val]=linprog(f,A,b,Aeq,beq,lb,ub)\)</span></li>
</ol>
<h2 id="整数规划">整数规划</h2>
<ol type="1">
<li>定义： 数学规划中的变量（部分或全部）限制为整数时，称为整数规划</li>
<li>分类： 根据变量整数是部分还是全部可分为纯整数规划和混合整数规划</li>
<li>求解方法：
<ol type="1">
<li>分支定界法（纯或混）</li>
<li>割平面法（纯或混）</li>
<li>隐枚举法（01规划）
<ul>
<li>过滤隐枚举法</li>
<li>分支隐枚举法</li>
</ul></li>
<li>匈牙利法（指派问题）</li>
<li>蒙特卡洛法（各种类型）</li>
</ol></li>
</ol>
<h3 id="型整数规划">0-1型整数规划</h3>
<ol type="1">
<li>定义：整数规划的一种特殊情况，变量仅取值0或1 应用范围可分为以下几种情况</li>
</ol>
<h4 id="相互排斥的约束条件">相互排斥的约束条件</h4>
<p>也就是说题目中的某一种条件只有一个量，如果给了这个1，同类的都为0，较为典型的问题有运输问题，只用一种方式运输，用火车运了，其他的运输栏都为0，其约束条件可进一步简化为 <span class="math inline">\(y_i=\begin{cases} 1,第i个元素起约束作用\\ 0,第i个元素不起作用，i=1,2.....,m\\ \end{cases}\)</span> $a_{i1}x_1+...a_{in}x_nb_i+(1-y_i)M,i=1,2...,m,\ y_1++y_m=1 $ 由约束条件很容易看出，当<span class="math inline">\(y_i\)</span>等于1,就只有这个约束起作用，其他的都是多余的</p>
<h4 id="固定费用的问题">固定费用的问题</h4>
<p>在讨论线性规划时，有些问题要求固定费用，这种问题可以通过改变为混合整数规划来解决，数学模型可表示为 <span class="math inline">\(y_i\epsilon\le x_i\le y_i M\)</span> 其中<span class="math inline">\(\epsilon\)</span>为充分小的正常数；M为充分大的正常数，表明<span class="math inline">\(x_i&gt;0\)</span>时，<span class="math inline">\(y_i\)</span>必须为1，<span class="math inline">\(x_i=0\)</span>时<span class="math inline">\(y_i\)</span>必须为0 <span class="math inline">\(【x_i】\)</span>表示采用i方式生产时产量，<span class="math inline">\(y_i\)</span>表示是否用第i种方式生产</p>
<h4 id="指派问题">指派问题</h4>
<p>指派问题描述的是分配n个人去做n件事情，每个人做且仅做一件事情，且分配第i个人去做第j件事情，花费<span class="math inline">\(C_{ij}\)</span>单位时间，求如何分配使总时间最小，这类问题的关键就是要求出分配矩阵，数学形式可表现为 <span class="math inline">\(x_{ij}=\begin{cases} 1,第i人做第j项工作\\ 0,第i人做第j项工作\\ \end{cases}\)</span> 数学模型为：<span class="math inline">\(min \sum_{i=1}^N \sum_{j=1}^N c_{ij}x_{ij}\)</span> <span class="math inline">\(s.t. \begin{cases}  \sum_{i=1}^N x_{ij}=1,i=1,2,...,n\\  \sum_{j=1}^N x_{ij}=1,j=1,2,...,n\\  x_{ij}=0 or 1,i,j=1,...,n  \end{cases}\)</span></p>
<h3 id="蒙特卡洛法随机取样法">蒙特卡洛法（随机取样法）</h3>
<ol type="1">
<li>又被称为计算机随机模拟法，它是基于对大量数据的统计结果来实现一些确定性问题的计算</li>
<li>使用该方法必须使用计算机生成相关分布的随机数</li>
</ol>
<h3 id="整数线性规划的计算机求解">整数线性规划的计算机求解</h3>
<ol type="1">
<li>整数规划的求解用Lingo等专用软件比较方便，对于整数线性规划也可以用matlab的intlinprog函数求解，<strong>但其的缺点是必须把所有的决策变量化为一维决策变量，变量替换后，约束条件很难写出</strong>，最好用lingo</li>
<li>matlab求解混合整数线性规划的命令是 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【x,fval】=intlinprog(f,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> 对应以下数学模型 <span class="math inline">\(min_x f^Tx,\)</span> <span class="math inline">\(s.t. \begin{cases} x(intcon)为整数\\ A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb \le x \le ub \\ \end{cases}\)</span> 式中：<span class="math inline">\(f,x,intcon,b,beq,lb,ub为列向量；A，Aeq为矩阵\)</span></li>
</ol>
<h2 id="非线性规划">非线性规划</h2>
<h3 id="非线性规划模型">非线性规划模型</h3>
<ol type="1">
<li>定义：如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题</li>
<li>通过投资决策问题归纳非线性规划数学模型的一般形式 总资金A元，投资第i个项目花<span class="math inline">\(a_i\)</span>元，预计可收益<span class="math inline">\(b_i\)</span>元 选择最佳投资方案 投资决策变量 <span class="math inline">\(x_i=\begin{cases} 1,决定投资第i个项目\\ 0,决定不投资第i个项目\\ \end{cases}\)</span> 则该模型可用下列数学模型表示 <span class="math inline">\(max\, Q = \frac{\sum_{i=1}^n b_i x_i} {\sum_{i=1}^n a_i x_i} s.t. \begin{cases} 0 &lt; \sum_{i=1}^n a_i x_i \le A ,\\ x_i(1-x_i)=0,i=1,...,n\\ \end{cases}\)</span></li>
<li>根据2中例题，非线性规划问题可进一步概括为： <span class="math inline">\(min\,f(x)\\ s.t. \begin{cases} h_j(x)\le0,j=1,2,...,q\\ g_i(x)=0,i=1,2,...,p\\ \end{cases}\)</span> 其中<span class="math inline">\(x=[x_1,...,x_n]^T\)</span>为模型的决策变量，<span class="math inline">\(f\)</span>为目标函数，<span class="math inline">\(g_i和h_j\)</span>为约束函数，<span class="math inline">\(g_i(x)=0\)</span>为等式约束，<span class="math inline">\(h_j(x)\le0\)</span>为不等式约束</li>
<li>对一个实际问题，要将其规为非线性规划问题时，一般要注意以下几点
<ol type="1">
<li>确定供选方案</li>
<li>提出追求目标</li>
<li>给出价值标准</li>
<li>寻求限制条件</li>
</ol></li>
<li>线性规划与非线性规划的区别：线性规划最优解只能在可行域的边界上达到（特别是顶点），而非线性规划最优解可在可行域任一点达到</li>
<li>非线性规划的matlab表示 <span class="math inline">\(minf(x)\\ s.t. \begin{cases} A\cdot x \le b,\\ Aeq \cdot x=beq,\\ c(x)\le0\\ ceq(x)=0,\\ lb\le x \le ub \end{cases}\)</span> 式中的<span class="math inline">\(f(x)\)</span>为标量函数，<span class="math inline">\(A,b,Aeq,beq,lb,ub\)</span>为相应维数的矩阵和向量，<span class="math inline">\(c(x),ceq(x)\)</span>为非线性向量函数 matlab命令为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br><span class="line"># x返回决策变量x的取值，fval返回目标函数取值，fun是M文件自定义函数f(x),x0是x的初始值</span><br><span class="line">nonlcon是用M文件定义的c(x)ceq(x)，options定义优化参数</span><br></pre></td></tr></table></figure> ### 无约束问题的Matlab解法</li>
<li>在matlab工具箱中，用于求无约束极小值的函数有fminunc和fminsearch，用法分别为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x,fval]=fminunc(fun,x0,options)</span><br><span class="line">[x,fval]=fminsearch(fun,x0,options) #只能求初始值附近的一个极小值点</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="约束极值问题">约束极值问题</h3>
<ol type="1">
<li>定义：带有约束条件的极值问题，也叫规划问题</li>
</ol>
<h4 id="二次规划">二次规划</h4>
<ol type="1">
<li>定义：若某非线性规划的目标函数为自变量x的二次函数，约束条件又全为线性的，称这种规划为二次规划</li>
<li>Matlab中二次规划的数学模型可表述为 $min, x<sup>THx+f</sup>Tx,\ s.t.
<span class="math display">\[\begin{cases}
Ax\le b\\
Aeq \cdot x=beq,\\
lb\le x\le ub
\end{cases}\]</span>
H为实对称矩阵，\ $ matlab求解二次规划的命令为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,fval]=quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="罚函数法">罚函数法</h4>
<ol type="1">
<li>利用罚函数法可以将非线性规划问题的求解转化为求一系列无约束极值的问题，也把这种方法叫做序列无约束最小化技术</li>
<li>罚函数求解非线性规划问题的思想是利用问题中的约束函数作出适当的罚函数，由此构造出带参数的增广目标函数，把问题转换为无约束非线性规划问题，主要有两种形式，一种叫外罚函数法，另一种叫内罚函数法</li>
<li>外罚函数法： 考虑问题：<span class="math inline">\(minf(x)\\ s.t.\begin{cases} g_i(x) \le 0,i=1,...,r\\ h_j(x) \ge 0,j=1,...,s\\ k_m(x) =0,m=1,...,t \end{cases}\)</span>取一个充分大的数M&gt;0,构造函数<span class="math inline">\(P(x,M)=f(x)+M\sum_{i=1}^nmax(g_i(x),0)-M\sum_{j=1}^nmin(h_j(x),0)+M\sum_{m=1}^n |k_m(x)|\)</span>,则以增广目标函数<span class="math inline">\(P(x,M)\)</span>为目标函数的无约束极值问题<span class="math inline">\(minP(x,M)\)</span>的最优解也是原问题的最优解</li>
<li><ol type="1">
<li>如果非线性规划问题要求实时算法，可以使用罚函数算法，但计算精度较低</li>
<li>如果不要求实时算法，要求高精度,可以使用lingo或matlab的fmincon命令求解</li>
</ol></li>
</ol>
<h4 id="matlab求约束极值问题">matlab求约束极值问题</h4>
<ol type="1">
<li>在matlab工具箱中，用于求解约束最优化问题的函数有fminbnd,fmincon,quadprog,fseminf,fminimax函数</li>
<li>fminbnd函数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x,fval]=fminbnd(fun,x1,x2,options) </span><br><span class="line"># 用于求单变量非线性函数在[x1,x2]上极小值</span><br><span class="line"># 返回极小点x和函数的极小值</span><br></pre></td></tr></table></figure></li>
<li>fseminf函数 用于求下列模型 <span class="math inline">\(minf(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)\le0\\ K_i(x,w_i)\le0,1\le i\le n \end{cases}其中c(x),ceq(x)为向量函数，K_i(x,w_i)为标量函数,w_1...为附加变量\)</span> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,fval]=fseminf(fun,x0,ntheta,seminfcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> fun定义目标函数f(x),x0为x初始值，ntheta是半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>个数，函数seminfcon用于定义非线性不等式约束<span class="math inline">\(c(x)\)</span>,非线性等式约束<span class="math inline">\(ceq(x)\)</span>和半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>的函数，seminfcon有两个输入参量x,s,s是推荐的采样步长 可以不使用</li>
<li>fminimax函数 用于求下列模型 <span class="math inline">\(min_xmax_iF_i(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)=0\\ \end{cases}\)</span> matlab命令为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,fval]=fminimax(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2022/05/17/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA/" class="post-title-link" itemprop="url">稀疏矩阵的三元组表示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-17 19:41:19 / 修改时间：20:14:37" itemprop="dateCreated datePublished" datetime="2022-05-17T19:41:19+08:00">2022-05-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">数据结构学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言">前言</h1>
<p>在学习邻接矩阵时，我们会发现一个有意思的现象，有时100*100的矩阵中只储存了10个数据，我们把这种矩阵称为稀疏矩阵，其适用于一个阶数较大的矩阵中的非零元素个数相对于矩阵元素的总个数很小，如果这种稀疏矩阵用邻接矩阵来储存，这是浪费了很多空间的，那么我们应当如何在保留其矩阵信息的前提下，用一个好的结构来节省空间的开支呢？</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/17/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2022/05/11/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/11/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="post-title-link" itemprop="url">最小生成树(Prim算法，Kruskcal算法)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-11 11:19:12" itemprop="dateCreated datePublished" datetime="2022-05-11T11:19:12+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-10 15:11:57" itemprop="dateModified" datetime="2023-11-10T15:11:57+08:00">2023-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">数据结构学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言">前言</h2>
<p>最小生成树由一个经典的架电线的问题引出：在n个村庄间架电线，现在已经知道各村庄的相对距离，如果你是工程师，请问如何设计能使得总造价最小</p>
<h2 id="解决思路">解决思路</h2>
<p>首先可以分析得到这显然是一个带权值的图，即网结构，我们的目标可以抽象为用n-1条边把一个连通图连接起来，并使得权值最小，这就是我们常说的最小生成树问题，最经典的两种算法是：prim算法和kruskcal算法，下文将一一介绍 <img src="https://s2.loli.net/2022/05/12/9SoUqmLdXEpjTGz.png" alt="最小生成树.png"></p>
<h2 id="prim算法">prim算法</h2>
<h3 id="算法思路">算法思路</h3>
<p><strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，因为这里涉及到顶点与顶点的带权值边信息，所以我们考虑使用邻接矩阵作为储存结构来实现，如果不清楚邻接矩阵，请戳<a target="_blank" rel="noopener" href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> <img src="https://s2.loli.net/2022/05/12/4B8ck6RtxqHmw9u.png" alt="最小生成树-邻接矩阵.png"> 这样一来，我们已经有了一个以邻接矩阵为存储结构的网，我们下面该如何求最小生成树呢?其实很简单，我们在prim算法的开头就说过，<strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，我们就先去一个顶点来研究，默认为v0，然后把v0在邻接矩阵中所对应的那一行信息取出(用一个lowcost数组保存)，目的是研究以v0为起点，与其相连最近的顶点。然后我们遍历一遍lowcost数组，找到其数组中除了本节点(即v0-0)外的最小值，记录下它的值与下标-<em>此时的low cost数组中lowcost[0]=0,表示该位置对应节点已加入最小生成树</em>，连接该下标所对应的顶点与v0，构成第一条电线，在这里对应的是v1，在找到v1后，我们把lowcost该位置的值设为0，表示该节点已经被纳入了最小生成树，然后我们再去取出v1在邻接矩阵中对应行的信息，将其与lowcost数组的对应值相比较，若更小则修改lowcost值，<strong>该操作的目的是找到v0,v1这两行连接信息中的最小值来形成第二根电线</strong>，接下来的操作也和上面的操作类似了，直到所有节点都添加到最小生成树中，lowcost数组全部置为0，表明最小生成树生成完毕。</p>
<h3 id="实现代码">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Prim算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree_Prim(MGraph G)&#123;</span><br><span class="line">	int min, i, j, k;</span><br><span class="line">	int adjvex[MAXVEX];	//保存相关顶点下标</span><br><span class="line">	int lowcost[MAXVEX];	//保存相关顶点间边的权值</span><br><span class="line">	lowcast[0] = 0;	//初始化第一个权值为0，即v0加入生成树，lowcost的值为0，在这里就是此下标的顶点已经加入生成树</span><br><span class="line">	adjvex[0] = 0;	//初始化第一个顶点下标为0</span><br><span class="line">	for(i = 1;i&lt;G.numVertexes;i++)&#123;	//循环除下标为0外的全部顶点</span><br><span class="line">		lowcost[i] = G.arc[0][i];		//将v0顶点与之有边的权值存入数组</span><br><span class="line">		adjvex[i] = 0;	//初始化都为v0的下标</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=1;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">		min = INFINITY;	//初始化最小权值为无穷大，通常设置为很大的数字</span><br><span class="line">		j = 1;</span><br><span class="line">		k = 0;</span><br><span class="line">		while(j&lt;G.numVertexes)&#123;		//循环全部顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min)&#123;	//如果权值不为0且权值小于min</span><br><span class="line">				min = lowcost[j];		//让当前权值成为最小值</span><br><span class="line">				k = j;		//将当前最小值的下标存入k</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;(%d,%d)&quot;,adjvex[k],k);	//打印当前顶点边中权值最小边</span><br><span class="line">		lowcost[k] = 0;	//将当前顶点的权值设置为0，表示此顶点已经完成任务</span><br><span class="line">		for(j=1;j&lt;G.numVertexes;j++)&#123;	//循环所有顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;	//若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值</span><br><span class="line">				lowcost[j] = G.arc[k][j];		//将较小权值存入lowcost</span><br><span class="line">				adjvex[j] = k;	//将下标为k的顶点存入adjvex</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由算法代码中的循环嵌套可知该算法时间复杂度为O(<span class="math inline">\(n^2\)</span>)</p>
<h2 id="kruskal算法">Kruskal算法</h2>
<h3 id="算法思路-1">算法思路</h3>
<p>与prim算法不同的是，prim算法以顶点为目标构造最小生成树，而Kruskal算法直接以边的目标去构造，每次找最小权值的边来构成最小生成树，但是，<strong>因为我们在构建时是以边为目标，必须要考虑边的闭环问题,因为可能出现要铺设九个村庄的电线，但在三个村庄间就出现了闭环，导致存在环与环之间无法互联的现象，这个问题出现的原因是因为我们如果只研究边的权值大小，会忽略顶点与顶点互联的要求</strong>，因为是对边的权值大小直接进行研究，这里我们最好使用边集数组作为存储结构，不会请戳<a target="_blank" rel="noopener" href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> 这里我们需要先将边集数组按照权值从小到大进行下转换。 <img src="https://s2.loli.net/2022/05/12/n4ofahW37AziSxJ.png" alt="最小生成树-边集数组.png"> 我们对边集数组做循环遍历，每当你要添加一个边时，必须先调用一个find函数来判断该边对应的起点和终点在当前的最小生成树数组中是否会构成闭环，如果会，则舍弃接着往后，不会则添加，这个find函数借助了一个parent数组，我们将其初始化为0，每当添加一条边，就将对应起点的parent数组值修改为该边的终点，然后find函数判断连线顶点的尾部下标，如果和原来尾部对应下标经find函数处理返回值一致，说明形成了环，舍弃该边</p>
<h3 id="实现代码-1">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* kruskal算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree(MGraph G)&#123;	//生成最小生成树</span><br><span class="line">	int i, n, m;</span><br><span class="line">	Edge edges[MAXEDGE];	//定义边集数组</span><br><span class="line">	int parent[MAXVEX];	//定义一数组用来判断边与边是否形成环路</span><br><span class="line">	/* 此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码 */</span><br><span class="line">	for(i = 0;i&lt;G.numVertexes;i++)</span><br><span class="line">		parent[i] = 0;	//初始化数组值为0</span><br><span class="line">	for(i = 0;i&lt;G.numEdges;i++)&#123;	//循环每一条边</span><br><span class="line">		n = Find(parent, edges[i].begin);</span><br><span class="line">		m = Find(parent, edges[i].end);</span><br><span class="line">		if(n != m)&#123;		//假如n与m不等，说明此边没有与现有生成树形成环路</span><br><span class="line">			parent[n] = m;	//将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中</span><br><span class="line">			printf(&quot;(%d,%d) %d&quot;, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int* parent, int f)&#123;	//查找连线顶点的尾部下标</span><br><span class="line">	while(parent[f] &gt; 0)</span><br><span class="line">		f = parent[f];</span><br><span class="line">	return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为O(eloge),e为边数</p>
<h2 id="总结">总结</h2>
<p>对比两个算法来说，Kruskcal算法主要针对边来展开，边数少的时候效率会非常高，对于稀疏图有很大的优势，而Prim算法对于稠密图，边上非常多的情况会更好一些(个人认为是因为边数少是Kruskcal出现闭环的可能性小，在这种情况下，其效率会比Prim算法高很多，然后边数多了以后，出现闭环的可能性大大增加，导致其效率反而不如Prim算法了)</p>
<h2 id="参考资料">参考资料</h2>
<p>《大话数据结构》程杰</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2022/05/08/Gin%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/Gin%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Gin学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-08 17:56:34" itemprop="dateCreated datePublished" datetime="2022-05-08T17:56:34+08:00">2022-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 14:53:56" itemprop="dateModified" datetime="2022-11-17T14:53:56+08:00">2022-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO/" itemprop="url" rel="index"><span itemprop="name">GO</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="gin框架简介">00 Gin框架简介</h2>
<p>Gin是一个用Go语言编写的web框架，是一个拥有良好性能的API框架，其性能非常好，是GO世界里最流行的web框架，是一个简单易用的轻量级框架 ## 01 Gin框架安装与使用 ### 安装 下载并安装Gin： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure> ### 第一个Gin实例 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    // 创建一个默认的路由引擎</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    // GET: 请求方式；/hello: 请求的路径</span><br><span class="line">    // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span><br><span class="line">    r.GET(&quot;/hello&quot;,func(c *gin.Context)&#123;</span><br><span class="line">        // c.JSON: 返回JSON格式的数据</span><br><span class="line">        c.JSON(200,gin.H&#123;</span><br><span class="line">            &quot;message&quot;:&quot;Hello world!&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    // 启动HTTP服务，默认在0.0.0.0：8080启动服务</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 将上面的代码保存并编译执行，<strong>注意</strong>：把终端切到文件目录下再执行，然后使用浏览器打开127.0.0.1：8080/hello就能看到一串JSON字符串 ## 02 RESTful API REST代表一种软件架构风格，是Representational State Transfer的简称 简单来说，REST的含义就是客户端与web服务器之间进行交互时，使用HTTP协议中的四个请求方法代表不同的动作。 - GET用来获取资源 - POST用来新建资源 - PUT用来更新资源 - DELETE用来删除资源 只要API程序遵循了REST风格，那就可以将其称为RESTful API。目前在前后端分离的架构中，前后端基本上都是通过RESTful API来进行交互 现在我们举一个编写管理书籍系统的例子，该系统可以进行对一本书进行查询，创建，更新，删除等操作，如果我们按照RESTful API设计，就如下表所示 |请求方法 | URL | 含义 | |----------|--------|--------------| |GET | | 获取书籍信息 | |POST | | 新建书籍信息 | |PUT | | 更新书籍信息 | |DELETE | | 删除书籍信息 | ### 实例代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;GET&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;POST&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.PUT(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;PUT&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.DELETE(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;DELETE&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 03 Gin渲染 ### HTML渲染 我们首先定义一个存放模板文件的templates文件夹，然后在其内部根据业务分别定义一个posts文件夹和一个users文件夹 其中posts/index.html文件内容如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define &quot;posts/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;posts/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure> users/index.html文件的内容如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define &quot;users/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;users/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure> Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLGlob(&quot;templates/**/*&quot;)</span><br><span class="line">	//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)</span><br><span class="line">	r.GET(&quot;/posts/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;posts/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(&quot;users/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;users/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(&quot;:8080&quot;)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2022/05/04/KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/04/KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-04 11:04:06" itemprop="dateCreated datePublished" datetime="2022-05-04T11:04:06+08:00">2022-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-08 16:44:36" itemprop="dateModified" datetime="2022-05-08T16:44:36+08:00">2022-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">算法学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>127</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kmp算法">KMP算法</h1>
<h2 id="前言">前言</h2>
<p>KMP算法绝对是每一本数据结构书籍都会讲的算法，应该算是知名度最高的算法之一，可惜的是，我反反复复学了很多次都没完全学懂，一直处于一种似懂非懂的状态中，最近因为复习，下决心要弄懂KMP算法，在网上看了很多相关博客，想把它们记录下来，以便复习</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiazhi1.github.io/2022/05/03/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="夏至">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏至的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="post-title-link" itemprop="url">表达式生成树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-03 11:21:40 / 修改时间：15:36:57" itemprop="dateCreated datePublished" datetime="2022-05-03T11:21:40+08:00">2022-05-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">数据结构学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="表达式生成树">表达式生成树</h1>
<h2 id="前言">前言</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">夏至</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">夏至</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">54k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">49 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
