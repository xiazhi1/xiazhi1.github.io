<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gin学习</title>
    <url>/2022/05/08/Gin%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="gin框架简介">00 Gin框架简介</h2>
<p>Gin是一个用Go语言编写的web框架，是一个拥有良好性能的API框架，其性能非常好，是GO世界里最流行的web框架，是一个简单易用的轻量级框架</p>
<span id="more"></span>
<h2 id="gin框架安装与使用">01 Gin框架安装与使用</h2>
<h3 id="安装">安装</h3>
<p>下载并安装Gin：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>
<h3 id="第一个gin实例">第一个Gin实例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    // 创建一个默认的路由引擎</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    // GET: 请求方式；/hello: 请求的路径</span><br><span class="line">    // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span><br><span class="line">    r.GET(&quot;/hello&quot;,func(c *gin.Context)&#123;</span><br><span class="line">        // c.JSON: 返回JSON格式的数据</span><br><span class="line">        c.JSON(200,gin.H&#123;</span><br><span class="line">            &quot;message&quot;:&quot;Hello world!&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    // 启动HTTP服务，默认在0.0.0.0：8080启动服务</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码保存并编译执行，<strong>注意</strong>：把终端切到文件目录下再执行，然后使用浏览器打开127.0.0.1：8080/hello就能看到一串JSON字符串</p>
<h2 id="restful-api">02 RESTful API</h2>
<p>REST代表一种软件架构风格，是Representational State Transfer的简称 简单来说，REST的含义就是客户端与web服务器之间进行交互时，使用HTTP协议中的四个请求方法代表不同的动作。</p>
<ul>
<li>GET用来获取资源</li>
<li>POST用来新建资源</li>
<li>PUT用来更新资源</li>
<li>DELETE用来删除资源 只要API程序遵循了REST风格，那就可以将其称为RESTful API。目前在前后端分离的架构中，前后端基本上都是通过RESTful API来进行交互 现在我们举一个编写管理书籍系统的例子，该系统可以进行对一本书进行查询，创建，更新，删除等操作，如果我们按照RESTful API设计，就如下表所示| 请求方法 | URL | 含义 | | -------- | ----- | ------------ | | GET | | 获取书籍信息 | | POST | | 新建书籍信息 | | PUT | | 更新书籍信息 | | DELETE | | 删除书籍信息 |</li>
</ul>
<h3 id="实例代码">实例代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;GET&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;POST&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.PUT(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;PUT&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.DELETE(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;DELETE&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gin渲染">03 Gin渲染</h2>
<h3 id="html渲染">HTML渲染</h3>
<p>我们首先定义一个存放模板文件的templates文件夹，然后在其内部根据业务分别定义一个posts文件夹和一个users文件夹 其中posts/index.html文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;posts/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;posts/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>users/index.html文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;users/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;users/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLGlob(&quot;templates/**/*&quot;)</span><br><span class="line">	//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)</span><br><span class="line">	r.GET(&quot;/posts/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;posts/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(&quot;users/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;users/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(&quot;:8080&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>互联网技术</tag>
      </tags>
  </entry>
  <entry>
    <title>pr-learn</title>
    <url>/2022/02/01/PR/</url>
    <content><![CDATA[<h2 id="新手村">新手村</h2>
<h3 id="从pr的最简工作流讲起">01-从pr的最简工作流讲起</h3>
<ol type="1">
<li>pr的用途： pr是一款用于视频段落的组合和拼接，并提供一定特效和调色功能</li>
<li>项目窗口： 用于储存视频，音频，图片，序列等素材</li>
<li>序列窗口： 用于编辑音频，视频，可以多个轨道同时编辑</li>
<li>预览窗口： 用于实时预览时间线上的素材效果。</li>
<li>效果控件窗口 可以对素材的基本属性做出调整，也可以调整添加在素材上的效果参数</li>
<li>效果窗口： pr中需要用到的各种自带的效果</li>
<li>pr工作流程：
<ol type="1">
<li>素材窗口中导入素材</li>
<li>新建序列</li>
<li>通过剃刀工具（C）对素材进行裁剪</li>
<li>通过选择工具（V）对素材进行选择并删除</li>
<li>通过拼接完成对素材的剪辑</li>
<li>渲染输出成片</li>
</ol></li>
</ol>
<span id="more"></span>
<h3 id="剪辑多素材如何标记出入点">02-剪辑多素材如何标记出入点</h3>
<h4 id="导入素材">导入素材</h4>
<ol type="1">
<li>熟悉素材，选取合适的音乐</li>
<li>将素材和音乐导入pr素材窗口中</li>
</ol>
<h4 id="剪辑流程">剪辑流程</h4>
<ol start="3" type="1">
<li>反复感受音乐，对音乐做一个节奏和情绪上的区分</li>
<li>选取偏努力的和刻苦一些的素材，在素材窗口中，选取出入点，截取合适的段落，将素材拖到视频轨道上</li>
<li>对于前半段音乐节奏比较快的地方，选取的素材相应的要短一些，剪辑点可以密一些</li>
<li>选取成功，胜利一类的素材，放在音乐后半段</li>
<li>反复感受音乐节奏，可以在音乐有大的节拍的地方，将剪辑点对齐</li>
<li>反复预览视频，使视频剪辑点和音乐更契合</li>
<li>导出视频</li>
</ol>
<h4 id="寻找剪辑点干货">寻找剪辑点（干货）</h4>
<ol type="1">
<li><p>空格键Space播放和暂停</p></li>
<li><p>Left Right键 ：向前向后一帧 （比较细致，可以一直按，这样速度快一点）</p></li>
<li><p>shift+Left Right键：向前向后五帧（这个比较快）</p></li>
<li><p>J 左穿梭/倒放 K 停止穿梭 L 右穿梭/正放</p></li>
<li><p>Shift + L 慢速右穿梭 Shift + J 慢速左穿梭</p></li>
<li><p>穿梭键如果连按，可以加速，K和Space都可以停止播放 时间线窗口中时间帧的管理</p></li>
<li><p>End 跳转到序列-素材结束点 Home 跳转到序列-素材开始点 Shift + End 跳转到所选素材结束点 Up 跳转上一个编辑点 Down 跳转下一个编辑点</p></li>
<li><p>i o:设出入点 Shift + I 跳转入店 Shift + O 跳转出点 ‘ 提取 ， 插入 . 覆盖</p></li>
</ol>
<h3 id="如何制作抽帧卡点">03-如何制作抽帧/卡点</h3>
<h4 id="卡点操作">卡点操作：</h4>
<ol type="1">
<li>试听音乐，找出音乐中的卡顿点，即变化很大的点，然后标记他 #### 抽帧操作</li>
<li>对已经标记的卡顿点，然后将其后面一部分删掉，把再后面的往前面拖，这样就可以营造出卡点抽帧的效果来</li>
</ol>
<h3 id="如何添加字幕">04-如何添加字幕</h3>
<p>下载ARCTIMEPRO</p>
<h3 id="鬼畜视频基础制作倍速加重复">05-鬼畜视频基础制作（倍速加重复）</h3>
<p>鬼畜的最基本操作就是把某个搞笑的片段重复的，以较快的倍速播放，还可以设置倒放等操作</p>
<h3 id="常见操作键">06-常见操作键</h3>
<figure>
<img src="https://s2.loli.net/2022/02/11/2EfkAIH5lo8Uu1z.jpg" alt="v2-58c3473d36a4622235aa0eda5ca1de7c_r.jpg"><figcaption aria-hidden="true">v2-58c3473d36a4622235aa0eda5ca1de7c_r.jpg</figcaption>
</figure>
]]></content>
      <categories>
        <category>PR&#39;s area</category>
      </categories>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/03/19/Linux-%E6%89%BE%E5%9B%9Eroot%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="linux-centos7.6找回root密码">Linux-centos7.6找回root密码</h1>
<p>说来话长，笔者在某个晴朗的周六早晨进行了root密码找回的测试，本以为是一个依葫芦画瓢的操作，没想到却折磨了笔者一个上午的时间去完成，话不多说，直接上步骤</p>
<span id="more"></span>
<p>在开机出现如下界面时，快按e键(只有五秒停留时间，速度，不然就要进登录界面了)： <img src="https://s2.loli.net/2022/03/26/i6Df2velR4hAqad.png" alt="image-33.png"> 2. 在步骤一按下”e”键之后，出现如下界面，按 ↓键一直到底部找到“LANG=zh_CN.UTF-8”这句，在这句后面加上“init=/bin/sh”,然后按Ctrl+x进入单用户。 <img src="https://s2.loli.net/2022/03/26/wvr8bVFBCN9SGad.png" alt="image-35.png"> 3. 挂载文件系统为可写模式：mount –o remount,rw /(rw 后两个空格，一定要按步骤来) <img src="https://s2.loli.net/2022/03/26/blj4R9o8Pe7JMUm.png" alt="image-34.png"> 4. 执行passwd命令，修改root密码，密码要输入两次要求两次密码要一致。(你刚相信，我失败多次的原因之一在passwd后面没加root) <img src="https://s2.loli.net/2022/03/26/WhUlDFGXJ6SKIN5.png" alt="image-36.png"> 5. 如果之前系统启用了selinux，必须执行以下命令，否则将无法正常启动系统：touch /.autorelabel。然后执行命令exec /sbin/init来正常启动，或者用命令exec /sbin/reboot重启就OK了。</p>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2022/03/19/hexo-d%20%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="hexo-d-提交spawn-failed-的解决办法">hexo d 提交spawn failed 的解决办法</h1>
<h2 id="网络问题">网络问题</h2>
<p>这个问题很多都是因为网络问题引起的 我们可以</p>
<ul>
<li>重启电脑(请首先尝试)</li>
<li>科学上网问题</li>
</ul>
<h2 id="本地文件问题">本地文件问题</h2>
<h3 id="重置git的deploy文件夹">重置git的deploy文件夹</h3>
<p>删除博客文件夹的.deploy_git文件夹，然后在对这个文件git bash 后输入 git config --global core.autocrlf false</p>
<h3 id="多系统混合编写">多系统混合编写</h3>
<p>笔者就亲身经历过，可能是因为当时在同一台电脑上运行Linux和Windows，cd进.deploy_git文件夹，输入git config –-global core.autocrlf false。</p>
<h3 id="end">end</h3>
<p>最后直接hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2022/02/06/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="git学习">Git学习</h1>
<h2 id="创建版本库">创建版本库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit//创建目录</span><br><span class="line">$ cd learngit//切换目录</span><br><span class="line">$ pwd//显示当前目录</span><br><span class="line">$ ls -ah//显示目录</span><br><span class="line">$ git init//把目录变成可管理的仓库</span><br><span class="line">$ git add //把文件添加到仓库</span><br><span class="line">$ git commit -m&quot;&quot;//git commit告诉Git，把文件提交到仓库，-m用于添加对这次操作的说明</span><br><span class="line">$ cat readme.txt//查看readme.txt的内容</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>
<p>在Windows中当输入完txt内容后，按esc加：wq退出输入模式</p>
<span id="more"></span>
<h2 id="时光机穿梭">时光机穿梭</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status 命令可以让我们时刻掌握仓库当前的状态</span><br><span class="line">$ git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式</span><br><span class="line">提交修改和提交新文件步骤一样，$ git add $ git commit;不过在执行第二步之前可以运行 git status 看看当前仓库的状态</span><br></pre></td></tr></table></figure>
<h3 id="版本回退">版本回退</h3>
<p><code>git log</code>命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p>
<p>我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本</p>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<h3 id="工作区和暂存区">工作区和暂存区</h3>
<p><code>git add</code>命令实际上就是把要提交的所有修改（来自工作区的修改）放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<h3 id="管理修改">管理修改</h3>
<p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中</p>
<h3 id="撤销修改">撤销修改</h3>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p>
<h3 id="删除文件">删除文件</h3>
<p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交</p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了</p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code></p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本</p>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</file></file></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<h2 id="远程仓库">远程仓库</h2>
<p>1.创建自己的SSH Key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>
<h3 id="添加远程库">添加远程库</h3>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h3 id="从远程库克隆">从远程库克隆</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>
<h2 id="分支管理">分支管理</h2>
<h3 id="创建并合并分支">创建并合并分支</h3>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突">解决冲突</h3>
<p>冲突来源：<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="分支管理策略">分支管理策略</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并</p>
<h3 id="bug分支">Bug分支</h3>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h3 id="feature分支">Feature分支</h3>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="多人协作">多人协作</h3>
<h4 id="推送分支">推送分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<h4 id="抓取分支">抓取分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull//抓取分支</span><br></pre></td></tr></table></figure>
<h4 id="多人协作工作模式">多人协作工作模式</h4>
<ol type="1">
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>
<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>
<p>再pull：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<h4 id="小结">小结</h4>
<ul>
<li><p>查看远程库信息，使用<code>git remote -v</code>；</p></li>
<li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li>
<li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p></li>
<li><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li>
<li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li>
<li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h3 id="rebase">Rebase</h3>
<ul>
<li><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p></li>
<li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</p>
<p>指令是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br></pre></td></tr></table></figure>
<h3 id="标签管理">标签管理</h3>
<p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>。tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p>
<h4 id="创造标签">创造标签</h4>
<ul>
<li><p>标签不是按时间顺序列出，而是按字母排序的</p></li>
<li><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</p></li>
<li><p>命令<code>git tag -a &lt;tagname&gt; -m "blablabla..."</code>可以指定标签信息；</p></li>
<li><p>命令<code>git tag</code>可以查看所有标签。</p></li>
<li><p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p></li>
</ul>
<p>#### 操作标签</p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>互联网技术</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习训练Tips</title>
    <url>/2023/03/05/deeplearning-tips/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>笔者在刚接触深度学习时，曾因为找不到系统实验指南而抓耳挠腮，十分痛苦，在搜索了无数次资源加上n次痛苦的debug后终于跑起了第一个深度学习实验，为了记录下自己的debug心得和为后来者提供一些建议，所以写下此博客，不足之处，望多多指正</p>
<span id="more"></span>
<h1 id="初期准备">初期准备</h1>
<h2 id="系统选择">系统选择</h2>
<p>尽可能选择Linux系统，因为大部分论文实验都是在Linux系统下操作开发，可能到Windows系统上会有一些“水土不服”（别问我是怎么知道的。。。） 推荐租云服务器:便宜的服务器平台：<a href="https://www.autodl.com/home">AutoDL</a>[应该是市面上最便宜的，学生认证有优惠] 免费的服务器平台：<a href="https://colab.research.google.com/">Google Colab</a>[12小时会自动断开，不过免费，分配的卡也还不错！] 如果自己电脑显卡较好且内存充足，可以选择装虚拟机后显卡直通或装双系统，其中显卡直通笔者没试过，装双系统有点折磨，且不太方便（两个系统不能同时在线）</p>
<h2 id="深度学习环境配置">深度学习环境配置</h2>
<p>这里网上教程很多，这里推荐一个我当时配的参考博客： <a href="https://www.cnblogs.com/LXP-Never/p/15151578.html#blogTitle0">凌逆战的博客</a></p>
<h1 id="具体实操">具体实操</h1>
<p>这里我以当时我配的CVPR2020 best paper（Unsupervised Learning of Probably Symmetric Deformable 3D Objects from Images in the Wild）举例： 首先打开论文查看论文代码位置： <img src="https://s2.loli.net/2023/03/05/a7ELmUqVIp4ZPxe.png" alt="训练tips_1.png"> 点击代码位置后在GitHub中下载代码 然后根据项目处的readme文件按步骤一步步配置 Tips：请注意创建虚拟环境，详细请看<a href="https://blog.csdn.net/SARACH_WONG/article/details/89328307">conda创建环境</a> 通过创建环境我们可以在一台主机上同时配上不同实验的实验环境并进行训练</p>
]]></content>
      <categories>
        <category>AI笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>jittor与pytorch的区别一览</title>
    <url>/2024/01/14/jittor%E4%B8%8Epytorch%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%80%E8%A7%88/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最近在完成一个利用Jittor复现GaussianSplatting的项目，里面用到了清华大学自主开发的深度学习框架jittor，因为GaussianSplatting官方代码是基于Pytorch和CUDA，所以复现过程中遇到了许许多多的问题，这里记录一下，希望能对读者有所帮助</p>
<h2 id="jittor安装问题">jittor安装问题</h2>
<p>经过测试发现，在1.3.7.3往后的jittor版本，在Linxu系统上安装通过不了CUDA测试，里面生成的变量都有问题，无法正确计算data属性，推荐安装版本1.3.6.5, 1.3.7.3,另外jittor安装CUDA版本一般都需要你安装配套的CUDNN</p>
<h2 id="jittor梯度求法">jittor梯度求法</h2>
<p>jittor和torch生成的变量var与tensor相比，有个比较重要的区别就是jittor.var没有grad属性,grad只能通过创建优化器，然后对优化器参数求jt.opt_grad，并且jittor无法实现对非叶子节点的梯度保留</p>
<h2 id="jittor的c和cuda扩展">jittor的C++和CUDA扩展</h2>
<p>相对于Pytorch来说，jittor主要为python环境设计，没有提供类似于Pytorch的C++和CUDA扩展，这导致无法复用GaussianSplatting的CUDA光栅化器，最后采用的解决方法是利用python和jittor手写一个光栅化器</p>
<h2 id="jittor.meshgrid">jittor.meshgrid</h2>
<p>jittor.meshgrid默认的indexing是ij，而torch.meshgrid默认的indexing是xy</p>
<h2 id="jittor中的no_grad">jittor中的no_grad</h2>
<p>与pytorch不同的是 jittor中no_grad方法里的梯度无法重新设置梯度，因为jittor不存在设置require_grad的方法，所以一定要注意不要把你需要计算梯度的参量，比如优化器参量放入道no_grad函数里，jittor不支持像pytorch那样的nn.paremeter()函数来将张量设置为可优化的，有梯度的</p>
<h2 id="jittor优化器的状态参数">jittor优化器的状态参数</h2>
<p>与pytorch优化器不同的是 pytorch优化器的状态参数都存在优化器.stact属性中。jittor不存在这个属性，但jittor的param_groups属性储存了优化器参数，每个优化器参数里面又存有其对应的状态参数，如果你想修改优化器状态参数，请采用param_groups获取优化器参数，并修改其中的状态参数部分即可</p>
<h2 id="cuda占用参数空间过多">CUDA占用参数空间过多</h2>
<p>因为 jittor 通过 jt.flags.use_cuda 设置是否使用 GPU，所有的 jt.Var 根据此开关自动使用 cpu 或者 gpu 计算，不需要关心 var 所在的设备。这导致很多参数全部都是无脑的放在CUDA设备上，对显卡资源丰富的人来说，这显然不是个问题，但如果你的卡的显存有限，且模型较大，这会使你很容易就显存爆炸或参数空间溢出</p>
<p>如果你的显存空间爆炸，推荐你可以尝试在定义并使用完函数的局部变量后，及时将其del删除，然后利用jt.gc()函数回收参数空间</p>
<h2 id="jittor调试技巧">jittor调试技巧</h2>
<p>因为jittor默认是异步执行的，这可以大大加快其运算速度，但这在调试时非常难以准确定位错误发生位置，推荐关闭延迟执行，可以在环境变量中将export lazy_execution=0 或者在python代码中jt.flags.lazy_execution=0</p>
<h2 id="jittor模型的保存和加载">jittor模型的保存和加载</h2>
<p>与pytorch不同的是 jittor.save函数只支持dict方式保存参数，而且目前经过测试发现其对pth，pt格式的文件的保存读取会报错，建议使用pkl文件格式</p>
<h2 id="总结">总结</h2>
<p>以上是本人在编写jittor项目是遇到的一些比较大的Bug,也有一些比较小的问题没有一一列举，因为jittor和pytorch大部分函数和属性还是比较相似的，一些比较简单的问题，可以直接问chatGPT就可以解决，这里只记录了一些我认为比较重要或比较难发现的区别，如果你在复现jittor时，遇到了一些问题，你可以参考我的GitHub仓库里转换好的模型<a href="https://github.com/xiazhi1/JGaussian">JGaussian</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>mips</title>
    <url>/2023/05/15/mips/</url>
    <content><![CDATA[<h1 id="华中科技大学模拟与电路系统三实验汇总">华中科技大学模拟与电路系统（三）实验汇总</h1>
<h2 id="并行io接口实验">并行IO接口实验</h2>
<h3 id="实验任务">实验任务</h3>
<p>嵌入式计算机系统将独立按键以及独立开关作为输入设备，七段数码管作为输出设备。实现以下功能：</p>
<span id="more"></span>
<ol type="1">
<li><p>点击BTNC 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该二进制数的低8 位对应的二进制数值0 或1 显示到8 个七段数码管上。</p></li>
<li><p>点击BTNU 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该16 进制数据各位数字对应的字符0~F 显示到低4 位七段数码管上（高4 位七段数码管不显示）。</p></li>
<li><p>点击BTND 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该数据表示的无符号十进制数各位数字对应的字符0~9 显示到低5 位七段数码管上（高3 位七段数码管不显示）。</p></li>
</ol>
<p>程序控制方式提示：程序以七段数码管动态显示控制循环为主体，在循环体内的延时函数内循环读取按键键值以及开关状态，并根据按键值做相应处理。</p>
<h3 id="实验源码">实验源码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;xil_io.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;xgpio.h&quot;</span><br><span class="line">#include &quot;sleep.h&quot;</span><br><span class="line">#include &quot;xtmrctr.h&quot;</span><br><span class="line">#include &quot;xintc_l.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char button = 0x0;</span><br><span class="line">    char segtable[16]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e&#125;;</span><br><span class="line">    short segcode[8]=&#123;0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff&#125;;</span><br><span class="line">    short pos=0xff7f;</span><br><span class="line">    Xil_Out16(XPAR_GPIO_0_BASEADDR+XGPIO_TRI_OFFSET,0xffff);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI_OFFSET,0X0);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI2_OFFSET,0x0);</span><br><span class="line">    Xil_Out8(XPAR_GPIO_2_BASEADDR+XGPIO_TRI_OFFSET,0x1f);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        while((Xil_In8(XPAR_GPIO_2_BASEADDR+XGPIO_DATA_OFFSET)&amp;0X1f)!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            button = Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f;</span><br><span class="line">            short sw = Xil_In16(XPAR_GPIO_0_BASEADDR+XGPIO_DATA_OFFSET);</span><br><span class="line">			while((Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f)!=0);</span><br><span class="line">            switch (button)</span><br><span class="line">            &#123;</span><br><span class="line">            case 0x1:</span><br><span class="line">                for(int j=0;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;j)&amp;0x1];</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x2:</span><br><span class="line">                    for(int j=0;j&lt;4;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;(4*j))&amp;0xf];</span><br><span class="line">                    &#125;</span><br><span class="line">                    for(int j=4;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x10:</span><br><span class="line">                int a=sw;</span><br><span class="line">                for(int j=0;j&lt;5;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    switch (a%10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            case(0):segcode[7-j]=segtable[0];break;</span><br><span class="line">                            case(1):segcode[7-j]=segtable[1];break;</span><br><span class="line">                            case(2):segcode[7-j]=segtable[2];break;</span><br><span class="line">                            case(3):segcode[7-j]=segtable[3];break;</span><br><span class="line">                            case(4):segcode[7-j]=segtable[4];break;</span><br><span class="line">                            case(5):segcode[7-j]=segtable[5];break;</span><br><span class="line">                            case(6):segcode[7-j]=segtable[6];break;</span><br><span class="line">                            case(7):segcode[7-j]=segtable[7];break;</span><br><span class="line">                            case(8):segcode[7-j]=segtable[8];break;</span><br><span class="line">                            case(9):segcode[7-j]=segtable[9];break;</span><br><span class="line">                        &#125;    </span><br><span class="line">                    &#125;</span><br><span class="line">                    a/=10;</span><br><span class="line">                &#125;</span><br><span class="line">                    for(int j=5;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;                </span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;8;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA_OFFSET,pos);</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA2_OFFSET,segcode[i]);</span><br><span class="line">        for(int j=0;j&lt;10000;j++);</span><br><span class="line">        pos=pos&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    pos=0xff7f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2022/02/01/%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="分治算法">分治算法</h2>
<h3 id="简要理解">简要理解</h3>
<p>分治算法由三部分组成：</p>
<ul>
<li>分：递归解决较小的问题（基本情况除外）</li>
<li>治：从子问题的解构建原问题的解</li>
</ul>
<span id="more"></span>
<h4 id="tips"><strong>Tips</strong>：</h4>
<ol type="1">
<li>传统上，在代码中至少含有两个递归调用的例程叫做分治算法，正文中只有一个递归调用的例程不是分治算法。</li>
<li>我们一般坚持子问题不相交，基本上要不重叠。</li>
</ol>
<h4 id="分治算法解决问题的特点"><strong>分治算法解决问题的特点</strong>：</h4>
<ol type="1">
<li>原问题规模通常比较大，不易直接解决，但问题缩小到一定程度能够较容易的解决。</li>
<li>问题可以分解为若干规模较小，求解方式相同（似）的子问题，且子问题之间求解是独立的，互不影响的。</li>
<li>合并问题分解的子问题可以得到问题的解</li>
</ol>
<h4 id="分治算法与递归的关系"><strong>分治算法与递归的关系</strong></h4>
<p>分治重要的是一种思想，注重的是问题分，治，合并的过程，而递归是一种方式（工具），这种方式通过方法自己调用自己形成一个来回的过程，分治就是利用了多次这样的来回过程。</p>
<h3 id="经典示例">经典示例</h3>
<ol type="1">
<li><strong>快速排序</strong> 快速排序的本质就是对基准数的两边分别递归进行查找交换，在这里，其满足分治算法中<em>分</em>：递归解决较小的问题：把整个数组的查找交换，分成对每个基准数的左右的查找交换的小问题。<em>治</em>：从子问题的解构建原问题的解：在对每个基准数左右进行排序后，整个大问题就已经排好了，就解决了原问题。</li>
<li><strong>最近点对</strong> 在二维坐标轴上有若干个点坐标，让你求出最近的两个点的距离，我们通常采用分治的方法来处理这种问题，按照x或者y的维度进行考虑，将数据分成两个区域，先分别计算(按照同方法)左右区域内最短的点对。然后根据这个两个中较短的距离向左和向右覆盖，计算被覆盖的左右点之间的距离，找到最小那个距离与当前最短距离比较即可。然后在每个区域的内部我们在进行像上面一样的操作</li>
</ol>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/02/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划">动态规划</h2>
<h3 id="简要理解">简要理解</h3>
<p>动态规划的思想是把问题划分为多个子问题，但子问题常常并不是互相独立的，当前子问题的解可看作是前面多个阶段的完整总结，所以它需要在子问题求解过程中进行多次判断与选择，与前面的问题相比，它现阶段一定要构成一种最优的结构，它满足最优化原理， <strong>最优化原理</strong>：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。同时，这样的最优策略是针对有已作出决策的总结，对后来的决策没有直接影响，只能借用目前最优策略的状态数据。这也被称之为无后效性。 <span id="more"></span> ### 求解思路 开始先要将问题按照一定顺序划分为各个阶段，然后确定每个阶段的状态，然后重点是根据决策的方法来确定状态转移方法，也就是说根据当前的状态确定下一阶段的状态，在这个过程中，下一状态的确定往往要参考之前的状态，因此需要在每一次状态转移过程中将当前的状态遍历记录，方便之后的查找。 ### 算法特点 * 需要在给定约束条件下优化某种指标时，动态规划是很有用的 * 问题可以分解为离散子问题是，可以用动态规划来解决 * 没有通用固定的公式，需要具体问题具体分析，这也就是其难点所在</p>
<h3 id="经典示例">经典示例</h3>
<p><strong>背包问题</strong>： 如果有一个小偷背有一个容量为4kg的背包去商场偷东西，可盗窃的物品有如下三件： 音响：3000 4kg 笔记本：2000 3kg 吉他：1500 1kg 每个物品只能偷一次，请问，小偷怎么偷收益最高 <strong>解决方法</strong> 我们可以考虑用画网格的方法来解决，我们构造下面的网格，每一行代表新添加的可以拿到物品，每一列代表当前容量，数字代表当前情况下可以拿的最大收益。这个过程就是动态规划的经典应用过程，就是保存上一步的结果，在这层进行决策时，与上一层结果比较，得到最优解 示意图如下： <img src="http://assets.processon.com/chart_image/61f9465b1e08530f015afacd.png" alt="alt"></p>
<p><strong>最长公共子串问题</strong> 如果用户在字典网站中查找单词时不小心拼错了，你必须猜测她原本要输入什么单词，例如啊彬想查单词fish，但不小心输入了hish，在网站的字典中，根本就没有这样的单词，但有类似的单词，那我们如何做这个判断呢？ 同样的，我们也可以构建一个网格，上方是输入单词的每个字母，左边是待匹配单词的字母，如果匹配就是左上角数字+1，最后比较整个方格中的最大值谁大，最大的就最匹配。 示意图如下： <img src="http://assets.processon.com/chart_image/61f9d53007912906b0b8147e.png" alt="alt"></p>
<p><strong>总结</strong> 从上面的两个例子可以看出，动态规划的核心是对上一步操作进行记忆，再与现在的操作进行对比，已得到最优解，同时，我们可以发现，不同问题中的动态规划虽然思路大体一致，都是保存上一步解并在确定这一步解时做参考，但具体实现上是完全不同的，所以说动态规划题并没有通用解法</p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2022/03/04/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>单调栈实际上也是栈，但他利用了一些巧妙的逻辑，让每次新元素入栈后，栈内元素都保持 有序（单调递增或单调递减），那么，这个逻辑是什么，其实很简单，以栈底-栈顶单调递增 为例，每次新元素入栈时，让栈内元素与新元素判断，比新元素大的栈内元素出栈即可。</p>
<span id="more"></span>
<h3 id="用途">用途</h3>
<p>单调栈的用途并不广泛，只处理一种典型问题，Next Greater Element</p>
<h3 id="单调栈模板">单调栈模板</h3>
<p>下面举一个例子说明其模板，现有这样一道题：给你一个数组nums，请你返回一个等长的结 果数组，结果数组中对应索引储存着下一个更大元素，如果没有更大的元素，就存-1，例如 输入数组 nums = [2,1,2,4,3],返回数组[4,2,4,-1,-1] 解释：第一个2后面比2大的数是4，第二个2后面比2大的数是4，4后面没有比4大的数，填 -1，3后面没有比3大的数，填-1.</p>
<ul>
<li>暴力解法：对每个元素的后面进行扫描，找到第一个更大的元素就可以了，时间复杂度为 <em>O（n^2）</em></li>
<li>单调栈法：把数组元素想象成并列的数，元素大小想象成树的高度，在某个位置时，后面 可见的第一颗树就是它的 Next Greater Number.
<ul>
<li>实现代码(C++)：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">  vector&lt;int&gt; res(nums.size()); // 存放答案的数组</span><br><span class="line">  stack&lt;int&gt; s;</span><br><span class="line">  // 倒着往栈里放</span><br><span class="line">  for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">      // 判定个子高矮</span><br><span class="line">      while (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123;</span><br><span class="line">          // 矮个起开，反正也被挡着了。。。</span><br><span class="line">          s.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      // nums[i] 身后的 next great number</span><br><span class="line">      res[i] = s.empty() ? -1 : s.top();</span><br><span class="line">      s.push(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这就是单调栈解决问题的模板，倒着入栈其实就是正着出栈，while循环是排除两颗高树间 的矮树，这个算法的复杂度只有O（n），尽管它存在for循环嵌套while循环，但要分析一个 算法的时间复杂度，要从整体入手，总共有n个元素，每个元素都被push入栈一次，最多被 pop一次，没有对于操作，计算规模与元素规模还是成正比的，也就是O（n）复杂度</p>
<h3 id="单调栈模板改良处理环形数组">单调栈模板改良处理环形数组</h3>
<p>同求next Greater Number 如果要求环形数组，怎么办 比如输入一个数组[2,1,2,4,3].返回数组[4,2,4,-1,4]拥有了环形属性，最后一个元素3绕 了一圈后找到了比自己大的元素4. 这种情况一般都是通过%运算符求模(余数)，来获得环形特效 对于这个问题还是要用单调栈解题模板，对环形需求，常用套路是将数组长度翻倍，我们也 可以不构造新数组，而是用循环数组来模拟数组长度翻倍的效果 示例代码（C++）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    vector&lt;int&gt; res(n);</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    // 假装这个数组长度翻倍了</span><br><span class="line">    for (int i = 2 * n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // 索引要求模，其他的和模板一样</span><br><span class="line">        while (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res[i % n] = s.empty() ? -1 : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考博客：<a href="https://labuladong.%20gitee.io/algo/2/21/51/">labuladong的算法小抄-单调栈结构解决三道算法题</a></p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的存储结构</title>
    <url>/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="图的存储结构">图的存储结构</h1>
<h2 id="前言">前言</h2>
<p>最近笔者在准备数据结构考试，故复习了些课本知识，发下自己对与图的存储结构还有诸多遗漏，故特意整理了些图的存储结构笔记，图的存储结构相对来说比较复杂，望大家复习时不要遗漏 <span id="more"></span> ## 邻接矩阵 该储存方式是由两个数组来表示图1，一个一维数组储存图中顶点信息，一个二维数组(即为邻接矩阵)储存图中的边或弧的信息 具体实例： <strong>无向图</strong> <img src="https://s2.loli.net/2022/05/02/jKxgNmBUbHko5ZX.png" alt="邻接矩阵-无向图.png"> 可以很容易看出无向图的边数组是一个对称矩阵。 有了该矩阵后，我们可以： 1. 判定任意两顶点是否有边无边 2. 确定某个顶点的度。就是该顶点的行(列)的元素之和。 3. 求某顶点的所有邻接点就是把矩阵该行元素全部扫描一遍，为一的就是邻接点 <strong>有向图</strong> <img src="https://s2.loli.net/2022/05/02/znGTpIKuiC6NfH8.png" alt="邻接矩阵-有向图.png"> 有向图讲究的入度和出度，入度对应列，出度对应行 <strong>带权值的有向图</strong> 就把有向图中为0的地方数组改为无穷，其余地方的值为该边上的权值即可 <strong>缺点</strong> 对于边数相对顶点较少的图，这种结构对储存空间造成极大浪费 ## 邻接表 顶点用一个一维数组储存，便于读取顶点信息，其次还要储存一个指向第一个邻接点的指针，便于查找该顶点的边信息 顶点所有邻接点构成一个线性表，用单链表储存，无向图称为顶点的边表，有向图称为顶点作为弧尾的出边表 具体实例如下： <strong>无向图</strong> <img src="https://s2.loli.net/2022/05/03/uTWl1rjJwQHo3AN.png" alt="邻接表-无向图.png"> 每个节点有data，firstedge两个域表示，data储存顶点信息，firstedge指针域，指向边表的第一个节点，边表节点由adjvex和next两个域组成，adjvex储存邻接点在顶点表的下标，next指向边表下一个节点的指针</p>
<p><strong>有向图</strong> 有向图的邻接表结构是类似的，但由于它有方向，我们以顶点为弧尾储存边表，很容易可以得到每个顶点的出度，如果要得到每个顶点的入度，可构建一个逆邻接表 示意图如下 <img src="https://s2.loli.net/2022/05/03/jcmVLbKYsDCf1yk.png" alt="邻接表-有向图.png"></p>
<p><strong>带权值的有向图</strong> 只需在边表节点定义中加一个weight的数据域，储存权值信息即可 <strong>缺点</strong> 对于有向图来说，邻接表不能同时了解入度出度问题 ## 十字链表 顶点表节点包括data，firstin，firstout，分别表示数据，入边表头指针，出边表头指针 边表节点结构包括tailvex，headvex，headlink，taillink，分别代表弧起点，弧终点，入边表指针域，指向终点相同的下一条边，出边表指针域，指向起点相同的下一条边，如果是网，还可以增加一个weight域来储存权值 示意图如下： <img src="https://s2.loli.net/2022/05/03/1QYCHpEr6waGAxh.png" alt="十字链表.png"></p>
<p><strong>优缺点</strong> 好处在于容易找到顶点的入出度，但其结构复杂点，但创建时间复杂度和邻接表相同，所以在有向图的应用中，它是一个非常好的模型</p>
<h2 id="邻接多重表">邻接多重表</h2>
<p>只需要在邻接表基础上，对边表节点进行一些改造，重新定义的边表结构如下：ivex，ilink，jvex，jlink，分别为边对应的两个顶点下标，指向依附ivex的下一条边，指向依附jvex的下一条边 <img src="https://s2.loli.net/2022/05/03/Y1nJSLVyEWPbI6t.png" alt="邻接多重表.png"></p>
<p><strong>与邻接表的区别</strong> 一条边在邻接表中要用两个节点表示，而在邻接多重表中只有一个节点，这样对边的操作更方便</p>
<h2 id="边集数组">边集数组</h2>
<p>有两个一维数组构成，一个储存顶点信息，一个储存边的信息，边数组数据元素由边起点下标begin，终点下标end，权值weight组成，它不适合对顶点操作，更适合对边的操作 <img src="https://s2.loli.net/2022/05/03/yOtG873msjzWafh.png" alt="边集数组.png"></p>
<h2 id="参考资料">参考资料</h2>
<p>程杰《大话数据结构》</p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2022/03/17/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h1 id="字典树">字典树</h1>
<h2 id="简介">简介</h2>
<p>字典树，又称单词查找树、前缀树，是一种树形结构，属于哈希树的变种，在统计、排序、保存大量字符串时具有很小的时间复杂度，常用于搜索引擎系统用于文本词频的统计，其优点在于利用字符串的公共前缀来减少查询时间，最大限度减少没有意义的字符串比较，查找效率比哈希树高。 <span id="more"></span> 比如我有"a","apple","appeal","bee","beef","cat"这七个单词，就能够组成下面图示的字典树，如果我们需要获得"apple"这个单词的信息，按顺序访问对应的结点即可 <img src="https://s2.loli.net/2022/03/26/pMQFd1OTDjorUu4.png" alt="字典树.png"> ### 字典树的性质 1. 根节点不包含字符，除根节点外每个结点有且仅有有一个字符 2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 3. 每个节点的所有子节点包含字符各不相同</p>
<h3 id="字典树的应用">字典树的应用</h3>
<ol type="1">
<li>字典：字符串集合对应一定的信息</li>
<li>计算热词：统计字符串在集合中出现的元素</li>
<li>串的快速检索：给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，按最早出现的顺序写出所有不在熟词表中的生词，我们可以把熟词建成字典树，然后读入文章进行比较</li>
<li>串排序：给出N个互不相同的仅由一个单词构成的英文名，让他们按字典序从小到大输出，采用数组的方式创建字典树，这棵树的每个节点的儿子很显然按照其字母大小排序，对这棵树进行先序遍历即可</li>
<li>最长公共前缀：对所有串建立字典树，对两个串的最长公共前缀长度就是他们所在节点的公共祖先个数 ## 具体实现 ### 顺序储存结构 #### 节点结构体定义 我们先开辟一个足够大的数组，这里我们使用静态链表的思想，用游标表示节点的后继，我们在结构体中开辟一个数组来描述节点的后继，这里可以确定其长度为26，然后再定义一个bool类型，判定是否为单词的结尾 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># define MAXSIZE 26</span><br><span class="line">struct node&#123;</span><br><span class="line">    bool flag;</span><br><span class="line">    int next[MAXSIZE];</span><br><span class="line">&#125;trie[100001]</span><br></pre></td></tr></table></figure> #### 插入操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Insert(char *str,int *space)</span><br><span class="line">&#123;</span><br><span class="line">    \*space表示第一个空闲节点的下标,str为插入的字符串，idx为挖掘层数，order将字符转化为在字母表中的顺序</span><br><span class="line">    *\</span><br><span class="line">    int order;</span><br><span class="line">    int idx; //从第一层开始向下挖掘</span><br><span class="line">    for(int i=0;i&lt;strlen(str);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(trie[idx].next[order] == 0)//idx没有该字符的子节点</span><br><span class="line">        &#123;</span><br><span class="line">            trie[idx].next[order] = space++;//启用第space号节点，copy新节点的编号</span><br><span class="line">            idx = trie[idx].next[order];//idx节点对应的后继为space</span><br><span class="line">            trie[idx].flag = false;//标记新节点不是单词的结尾</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">         idx = trie[idx].next[order];//前缀存在继续挖掘</span><br><span class="line">    &#125;</span><br><span class="line">    trie[idx].flag = true;//表示单词结尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 查询操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Find(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int order;</span><br><span class="line">    int idx=1;</span><br><span class="line">    for(int i=0;i&lt;strlen(str);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(trie[idx].next[order]==0)//若字母失配，匹配结束</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = trie[idx].next[order];//存在对应字母，匹配继续</span><br><span class="line">    &#125;</span><br><span class="line">    if (trie[idx].flag == false)//若成功匹配，但不为单词结尾</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 链式储存结构 #### 节点结构体定义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    Node *next[26];</span><br><span class="line">    bool flag;</span><br><span class="line">&#125;Node, *Trie;</span><br></pre></td></tr></table></figure> #### 插入操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void buildTrie(Trie root,char *word)</span><br><span class="line">&#123;</span><br><span class="line">    Trie pre = root;</span><br><span class="line">    Trie ptr;</span><br><span class="line">    int order;</span><br><span class="line">    for(int i=0;i&lt;strlen(word);++i)//字母序对应后继不存在</span><br><span class="line">    &#123;</span><br><span class="line">        order = word[i]-&#x27;a&#x27;;</span><br><span class="line">        if(pre-&gt;next[order] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = (Node *)malloc(sizeof(Node));//初始化新节点</span><br><span class="line">            for(int j=0;j&lt;26;++j)</span><br><span class="line">                ptr-&gt;next[j]==NULL;</span><br><span class="line">            ptr-&gt;fail = NULL;</span><br><span class="line">            ptr-&gt;flag = false;</span><br><span class="line">            pre-&gt;next[order] = ptr;//插入新节点</span><br><span class="line">        &#125;</span><br><span class="line">        pre = ptr-&gt;next[order];//用新节点作为下一次循环的根节点</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;flag = true;//修改flag表示为单词结尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 查询操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Find(char * str)</span><br><span class="line">&#123;</span><br><span class="line">    int order;</span><br><span class="line">    Trie pre= root</span><br><span class="line">    Trie ptr;</span><br><span class="line">    int length = strlen(str);</span><br><span class="line">    if(!length)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(pre-&gt;next[order] == NULL &amp;&amp; pre!=root)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next[order];</span><br><span class="line">    &#125;</span><br><span class="line">    if(pre-&gt;flag==false)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 例题详解 #### leetcode 720(词典中最长的单词) 题目描述如下： <img src="https://s2.loli.net/2022/03/17/tjBVbDG73lKdsMZ.png" alt="760.png"> ##### 思路和算法</li>
</ol>
<p>由于符合要求的单词的每个前缀都是符合要求的单词，因此可以使用字典树存储所有符合要求的单词。 创建字典树，遍历数组 words,并将每个单词插入字典树。当所有的单词都插入字典树之后，将答案初始化为空字符串，再次遍历数组 words，判断每个单词是否是符合要求的单词，并更新答案。如果一个单词是符合要求的单词，则比较当前单词与答案，如果当前单词的长度大于答案的长度，或者当前单词的长度等于答案的长度且当前单词的字典序小于答案的字典序，则将答案更新为当前单词。</p>
<h5 id="代码">代码</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAX_STR_LEN 32</span><br><span class="line"></span><br><span class="line">typedef struct Trie &#123;</span><br><span class="line">    struct Trie * children[26];</span><br><span class="line">    bool isEnd;</span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void initTrie(Trie * trie) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        trie-&gt;children[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    trie-&gt;isEnd = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insertTrie(Trie * trie, const char * word) &#123;</span><br><span class="line">    Trie * node = trie;</span><br><span class="line">    int len = strlen(word);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char ch = word[i];</span><br><span class="line">        int index = ch - &#x27;a&#x27;;</span><br><span class="line">        if (node-&gt;children[index] == NULL) &#123;</span><br><span class="line">            node-&gt;children[index] = (Trie *)malloc(sizeof(Trie));</span><br><span class="line">            initTrie(node-&gt;children[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEnd = true;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool searchTrie(const Trie * trie, const char * word) &#123;</span><br><span class="line">    Trie * node = trie;</span><br><span class="line">    int len = strlen(word);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char ch = word[i];</span><br><span class="line">        int index = ch - &#x27;a&#x27;;</span><br><span class="line">        if (node-&gt;children[index] == NULL || !node-&gt;children[index]-&gt;isEnd) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    return node != NULL &amp;&amp; node-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * longestWord(char ** words, int wordsSize)&#123;</span><br><span class="line">    Trie * trie = (Trie *)malloc(sizeof(Trie));</span><br><span class="line">    initTrie(trie);</span><br><span class="line">    for (int i = 0; i &lt; wordsSize; i++) &#123;</span><br><span class="line">        insertTrie(trie, words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    char * longest = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; wordsSize; i++) &#123;</span><br><span class="line">        if (searchTrie(trie, words[i])) &#123;</span><br><span class="line">            if (strlen(words[i]) &gt; strlen(longest) || (strlen(words[i]) == strlen(longest) &amp;&amp; strcmp(words[i], longest) &lt; 0)) &#123;</span><br><span class="line">                longest = words[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考资料： <a href="https://www.cnblogs.com/linfangnan/p/12655724.html">乌漆WhiteMoon：数据结构：字典树</a> <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">leetcode 730 词典中最长的单词</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法学习笔记</title>
    <url>/2022/01/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="贪心算法">贪心算法</h2>
<h3 id="简要理解">简要理解</h3>
<p>贪心算法是分阶段工作的，在每一个阶段，他都会选择工作它认为眼下所作决定最好的，它是不考虑将来结果的，他只在乎局部最优解，算法终止时，我们希望得到的局部最优的结构就是全局最优，如果是就说明算法是正确的，否则算法得到的是一个次最优解，如果不要求绝对最佳答案，有时可以用简单的贪心算法生成近似答案，它的好处是在处理较大数据，较复杂的问题时，一般时间复杂度与空间复杂度都比产生准确答案的复杂算法要快上很多倍得到一个几乎接近正确的答案。 <span id="more"></span></p>
<h3 id="经典示例">经典示例</h3>
<ul>
<li><strong>找零钱问题</strong>：为了使用货币找零钱，求找出零钱张数最少值，我们可以重复配发最大额货币，于是为了找一百七十五元，我们肯定先选一张一百的，再拿一张五十的，再拿一张二十，五块的，这里就用到了贪心算法每一步选取局部最优解的思想，而且在这个问题中，局部最优就是整体最优.</li>
<li><strong>求最快抵达路径</strong>：在北京的某个交通高峰期间，有些主要干道可能看起来是空空荡荡的，但你最好还是不要选择这条干道，因为交通可能会在你抵达是=时突然变得车水马龙。这就是贪心算法行不通的例子</li>
</ul>
<h3 id="经典应用">经典应用</h3>
<ol type="1">
<li><p><strong>作业调度问题</strong> 对于多个作业（假设每个作业需要批改时间不同），我们有多个老师参与批阅，假设每个老师批阅速度一致，我们该如何想办法让整体完成时间最快。 这里就可以用到贪心算法的思想，我们可以给第一个老师挑时间最短的。第二个挑第二短的，在这样依次下去，保证每个老师先拿到的作业都是目前它眼中最好批改的作业。 这样做，虽然不一定能使整体批阅时间达到最低，但是他决定使较为接近最低的答案。而且它的算法执行复杂度会比准确算法要低，如果数据很大，贪心算法的优势为变得越来越明显</p></li>
<li><p><strong>哈夫曼编码</strong></p>
<ul>
<li>哈夫曼编码是从底向顶的构造哈夫曼树，我们每次挑取两个权值最小的元素连接构成某节点的左右子树，然后把两个左右子树的权值相加，赋给连接这两颗子树的节点，再接着这么操作，就可以把一个字符串按权重大小编码且不影响读取，字符根节点往左为0，往右为1，那么出现频率最高的字符的位数一定是最小的，这样一来就可以减小空间成本</li>
<li>哈夫曼编码使用贪心算法的地方在于，他没有对整体数据进行分析，也是每次运行优先挑取两个权值最小的树，也就是局部最优解，这里就反映出了贪心算法的本质。</li>
<li>流程示例 <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F2018120514551994.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTk0NTU0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1646208341&amp;t=fe7ae4698acc0bcbf76d0734ca3ebdd9" alt="alt 哈夫曼树构建流程"></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>微波技术基础第一二章知识小结</title>
    <url>/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>因为第一章绪论内容较少，所以将第一章内容与第二章合并</p>
<h2 id="绪论">绪论</h2>
<h3 id="微波的概念">微波的概念</h3>
<p>顾名思义“微波”是波长极短，频率极高的电磁波。在电磁波谱中是介于普通线电波与红外线之间的波段。因此，波长的长与短、频率的高与低都是相对的，在微波波段内部又可划分为分米波、厘米波、毫米波和亚毫米波.</p>
<span id="more"></span>
<p>不同频率的电磁波，其传播特性不同，适用场合也不同</p>
<p><img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-19-58-33.png" style="width:60.0%;height:60.0%"></p>
<p>从上图可以看出，本课程要学习的微波，频率范围在<span class="math inline">\(300MHz\sim 3000GHz\)</span>,波长范围在<span class="math inline">\(0.1mm\sim 1dm\)</span></p>
<h2 id="传输线理论概述">传输线理论概述</h2>
<h3 id="微波传输线及其分类">微波传输线及其分类</h3>
<p>定义：凡能够引导微波沿一定方向传输的导波装置称为传输线。作用：1.引导微波传输。2. 构成各种微波元器件</p>
<p>分类：根据传输线结构和电磁波的特点可分为：</p>
<ol type="1">
<li>TEM波及准TEM波传输线 例如：双导线、同轴线、带状线、微带线</li>
<li>TE波和TM波传输线 例如：矩形波导、圆波导等</li>
<li>表面波传输线 例如：介质波导、介质镜像线等</li>
</ol>
<p>传输线的性能要求和应用范围：</p>
<ul>
<li>性能要求：工作频带宽；功率容量大；工作稳定性好；损耗小；尺寸小和成本低。</li>
<li>应用范围：
<ul>
<li>米波或分米波：双导线、同轴线</li>
<li>厘米波：空心金属波导管、带状线、微带线</li>
<li>毫米波：空心金属波导管、介质波导、介质镜像线、微带线</li>
</ul></li>
</ul>
<p>传输线理论的研究问题：</p>
<ul>
<li>横向问题：研究电磁波在传输线横截面内电场、磁场的分布规律，即场结构、模、波型。通过求解电磁场的边值问题来解决</li>
<li>研究电磁波沿传输线轴向的传播特性和场的分布规律。采用的方法：场的分析方法、路的分析方法。路的分析方法简便、易懂，本章采用路的方法来研究双导线的纵向问题</li>
</ul>
<h3 id="长线与分布参数电路">长线与分布参数电路</h3>
<p>长线与短线：如果传输线的几何长度<span class="math inline">\(L\)</span>与工作波长<span class="math inline">\(\lambda\)</span>可比拟或<span class="math inline">\(L&gt;&gt;\lambda\)</span>时，传输线称为长线，否则称为短线，<span class="math inline">\(\frac{L}{\lambda}\)</span>-电长度，当电长度&lt;0.1,为短线，做集总参数处理(导线无L,R,C,G),反之则为长线，做分布参数电路处理(导线有L,R,C,G)</p>
<h3 id="分析方法">分析方法</h3>
<ul>
<li>场的方法：以E、H为研究对象，从麦克斯韦尔方程出发, 解满足边界条件的波动方程, 得出传输线上电场和磁场的解, 进而研究传输特性的横向分布及纵向传输特性。该方法严格、精确, 但数学计算复杂、繁琐，解析方程求解困难</li>
<li>路的方法：在一定的条件下，以U、I为对象，从传输线方程出发, 求出满足边界条件的电压、 电流波动方程的解, 分析电压波和电流波随时间和空间的变化规律,即用电路理论来研究纵向传输特性。本质上是化场为路。该方法有足够的精度, 数学上较为简便, 因此被广泛采用。</li>
</ul>
<p><strong>传输线（长线）理论就是研究TEM波传输线的分布参数的电路理论</strong></p>
<h2 id="长线方程及其解">长线方程及其解</h2>
<h3 id="长线方程">长线方程</h3>
<p><img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-20-24-37.png" style="width:60.0%;height:60.0%"></p>
<p>设位置z处的电压和电流的复振幅分别为<span class="math inline">\(\dot{U},\dot{I}\)</span>,而在位置<span class="math inline">\(z+dz\)</span>处的电压和电流的复振幅分别为<span class="math inline">\(\dot{U}+d\dot{U},\dot{I}+d\dot{I}\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-20-38-38.png"> 则有<span class="math display">\[\begin{cases}
    (\dot{U}+d\dot{U})-\dot{U}=(Rdz+jwLdz)(\dot{I}+d\dot{I})\\
    (\dot{I}+d\dot{I})-\dot{I}=(Gdz+jwCdz)\dot{U}
\end{cases}\]</span> 忽略第一式中的高阶微分项,并将dz除到左端，得 <span class="math display">\[\begin{cases}
    \frac{d\dot{U}}{dz}=(R+jwL)\dot{I}=Z\dot{I},\quad Z=R+jwL\\
    \frac{d\dot{I}}{dz}=(R+jwC)\dot{U}=Y\dot{U},\quad Y=G+jwC\\
\end{cases}\]</span></p>
<p><strong>这就是均匀传输线方程，也称为长线方程</strong></p>
<h3 id="长线方程的解">长线方程的解</h3>
<p>求解上一小节提到的长线方程，可得长线方程的解为 <span class="math display">\[\begin{cases}
    \dot{U}(z)=A_1e^{\gamma z}+A_2e^{-\gamma z}\\
    \dot{I}(z)=\frac{1}{Z_0}(A_1e^{\gamma z}-A_2e^{-\gamma z})\\
\end{cases}\]</span> 式中，第1项表示向负z方向传播的波，第2项表示向正z方向传播的波。A1和A2则分别表示向负z和正z方向传输的波的复振幅，它们是待定的积分常数，取决于传输线的负载端或源端的边界条件.<span class="math inline">\(Z_0=\frac{Z}{Y}\)</span>(特性阻抗),<span class="math inline">\(\gamma=\sqrt{ZY}=\alpha+j\beta\)</span>(传播常数)</p>
<p>边界条件通常有以下三种： 1. 已知负载端电压,电流<span class="math inline">\(\dot{U_L},\dot{I_L}\)</span> 2. 已知源端电压,电流<span class="math inline">\(\dot{U_g},\dot{I_g}\)</span> 3. 已知信源电动势，内阻电压,负载阻抗<span class="math inline">\(E_g,Z_g,Z_L\)</span></p>
<p>这里仅讨论第一种情况：</p>
<p><span class="math inline">\(\because \dot{U}(0)=\dot{U_L}=A_1+A_2\\\quad\dot{I}(0)=\dot{I}(L)=\frac{1}{Z_0}(A_1-A_2)\)</span> 联立即可求出<span class="math inline">\(A_1,A_2\)</span>，进而解出整个方程</p>
<p>在微波波段，若传输线所用导体为良导体，且媒质是低损耗的，则有<span class="math inline">\(R&lt;&lt;wL,G&lt;&lt;wC\)</span>,故可认为<span class="math inline">\(R=G=0\)</span>，则此传输线为均匀无耗线。<strong>均匀无耗线是本章讨论的重点</strong></p>
<p>故在长线方程求解过程中，用到的参数<span class="math inline">\(\gamma,Z_0\)</span>可化简为 <span class="math display">\[\gamma=j\beta,\beta=w\sqrt{LC}\\Z_0=\sqrt{\frac{L}{C}}\]</span></p>
<p>因此均匀无耗传输线上的电压，电流为 <span class="math display">\[\begin{cases}
    \dot{U(z)}=\dot{U_L}cos\beta z+j\dot{I_L}Z_0sin\beta z\\
    \dot{I(z)}=\dot{I_L}cos\beta z+j\frac{\dot{U_L}}{Z_0}sin\beta z
\end{cases}\]</span></p>
<h3 id="解的物理意义">解的物理意义</h3>
<p>电压和电流均可表示为入射波和反射波的叠加，且都是行波（波的传播过程中只有相位的变化，而无幅度的变化），<strong>两个行波之和不一定是行波</strong></p>
<h2 id="长线的参量">长线的参量</h2>
<h3 id="特性参量">特性参量</h3>
<p>指由长线的结构、尺寸、填充的媒质及工作频率决定的参量。（和负载无关），主要包括特性阻抗<span class="math inline">\(Z_0\)</span>,传播常数<span class="math inline">\(\gamma\)</span>,相速<span class="math inline">\(V_p\)</span>,波长<span class="math inline">\(\lambda\)</span></p>
<ol type="1">
<li>特性阻抗<span class="math inline">\(Z_0\)</span> 将传输线上行波电压与行波电流之比定义为传输线的特性阻抗,亦即入射波电压与电流复量之比或反射波电压与电流复量之比的负值，用<span class="math inline">\(Z_0\)</span>来表示, 其倒数称为特性导纳, 用<span class="math inline">\(Y_0\)</span>来表示。根据定义有<span class="math inline">\(Z_0=\frac{U^+(z)}{I^+(z)}=\sqrt{\frac{Z}{Y}}=\sqrt{\frac{R+jwL}{G+jwC}}\)</span>。可见特性阻抗<span class="math inline">\(Z_0\)</span>通常是个复数, 且与工作频率有关。 它由传输线填充的介质、线的横向尺寸和横截面内电磁场的分布状态决定而与线长度、负载及信源无关, 故称为特性阻抗。 对于无耗均匀传输线,<span class="math inline">\(Z_0=\sqrt{\frac{L}{C}}\)</span>,纯电阻，与频率无关</li>
<li>传播常数<span class="math inline">\(\gamma\)</span> 传播常数<span class="math inline">\(\gamma\)</span>是描述传输线上导行波沿导波系统传播过程中衰减和相移的参数,<span class="math inline">\(\gamma=\sqrt{ZY}=\sqrt{(R+jwL)(G+jwC)}=\alpha+j\beta\)</span>,对于均匀无耗传输线，有<span class="math inline">\(\gamma=jw\sqrt{LC}=j\beta\)</span></li>
<li>相速<span class="math inline">\(V_p\)</span>和工作波长<span class="math inline">\(\lambda\)</span> 传输线上的相速定义为行波等相位面沿传输方向的传播速度, 用<span class="math inline">\(v_p=\frac{w}{\beta}\)</span>表示，对于无耗传输线<span class="math inline">\(\beta=w\sqrt{LC},\therefore v_p=\frac{1}{\sqrt{LC}}\)</span> 传输线的工作波长定义为：同一时刻，线上行波相位相差2π的两点间的距离，用λ表示 <span class="math inline">\(\lambda=\frac{2\pi}{\beta}=\frac{2\pi}{w\sqrt{LC}}=\frac{v_p}{f}\)</span> 对于均匀无耗传输线来说, 由于β与ω成线性关系, 故导行波的相速与频率无关, 也称为无色散波。当传输线有损耗时, β不再与ω成线性关系, 使相速<span class="math inline">\(v_p\)</span>与频率<span class="math inline">\(f\)</span>有关,这就称为色散特性</li>
</ol>
<h3 id="工作参量">工作参量</h3>
<p>与长线终端负载有关的参量，主要包括输入阻抗，反射系数，驻波比</p>
<ol type="1">
<li><p>输入阻抗Z(z) 输入阻抗Z(z)定义：传输线上任意位置处的总电压与总电流复量之比，称为该处的输入阻抗<span class="math inline">\(Z_{in}\)</span>，即从该位置朝负载方向看去的等效阻抗。推导得出<span class="math inline">\(Z(z)=Z_0\frac{Z_L+jZ_0tan\beta z}{Z_0+jZ_Ltan\beta z}\)</span> 上式表明: 均匀无耗传输线上任意一点的输入阻抗与该点的<strong>位置</strong>、传输线的<strong>特性阻抗</strong>、<strong>终端负载阻抗</strong>及<strong>工作频率</strong>有关</p>
<p>输入阻抗表达式有多种变形</p>
<ol type="1">
<li><span class="math display">\[if\qquad d=n\lambda/2(n=1,2,3,\dots)\\\because\beta d=n\pi,\therefore Z(z+d)=Z(z)\]</span> 可见均匀无耗线上的阻抗具有<span class="math inline">\(\lambda/2\)</span>周期性</li>
<li><span class="math display">\[if\qquad d=(2n-1)\lambda/4(n=1,2,3,\dots)\\\because\beta d=(2n-1)\pi/2,\therefore Z(z+d)Z(z)=Z_0^2\]</span> 可见均匀无耗线上的阻抗具有<span class="math inline">\(\lambda/4\)</span>变换性 <span class="math display">\[感性\leftrightarrow容性\\大于Z_0的电阻\leftrightarrow小于Z_0的电阻\\开路\leftrightarrow短路\]</span></li>
<li>当终端负载<span class="math inline">\(Z_L=Z_0\)</span>，即终端接有匹配负载时，传输线任意位置输入阻抗等于<span class="math inline">\(Z_0\)</span>,与传输线无限长等效，只有入射波无反射波，行波状态，阻抗匹配</li>
</ol></li>
<li><p>（电压）反射系数<span class="math inline">\(\Gamma(z)\)</span></p>
<ol type="1">
<li>定义：传输线上任意一点z处的反射波电压与入射波电压之比为电压反射系数，记为<span class="math inline">\(\Gamma(z)=\frac{U^-(z)}{U^+(z)}\)</span>,若为无耗传输线，则其任一位置上的反射系数为<span class="math inline">\(\Gamma(z)=\frac{U^-(z)}{U^+(z)}=\Gamma_Le^{-j2\beta z},\Gamma_L=\frac{U_L^-}{U_L^+}=|\Gamma_L|e^{j\psi_L},0\le|\Gamma_L|\le1\qquad -\pi\le\psi_L\le\pi,\\\therefore \Gamma(z)=|\Gamma_L|e^{j\psi},0\le|\Gamma|\le1,\psi=\psi_L-2\beta z\)</span></li>
<li>无耗传输线上<span class="math inline">\(Z(z)\)</span>与<span class="math inline">\(\Gamma(z)\)</span>的关系 <span class="math display">\[Z(z)=Z_0\frac{1+\Gamma(z)}{1-\Gamma(z)}\quad or \quad\Gamma(z)=\frac{Z(z)-Z_0}{Z(z)+Z_0}\\\therefore \Gamma_L=\frac{Z_L-Z_0}{Z_L+Z_0}\]</span> 可见<span class="math inline">\(Z(z)与\Gamma(z)\)</span>具有相同的周期<span class="math inline">\(\lambda/2\)</span></li>
</ol></li>
<li><p>驻波比<span class="math inline">\(\rho\)</span>与行波比<span class="math inline">\(k\)</span></p>
<ol type="1">
<li>驻波比：传输线上最大电压（或者电流）振幅值与最小电压（或电流）振幅值之比，称为驻波比，记为<span class="math inline">\(\rho=\frac{|\dot{U}|_{max}}{|\dot{U}|_{min}}\)</span> <span class="math display">\[\because \Gamma(z)=|\Gamma_L|e^{j(\psi_L-2\beta z)}且\dot{U}=U^+(1+\Gamma)=U_L^+e^{j\beta z}(1+\Gamma(z))\\\therefore \dot{U}=U_L^+e^{j\beta z}(1+|\Gamma|e^{j(\psi_L-2\beta z)})\]</span>对上式求U的模可以看出,当<span class="math inline">\(2\beta z-\psi_L=2n\pi\)</span>时,<span class="math inline">\(n=0,1,2...\)</span>,<span class="math inline">\(|\dot{U}_{max}|=|U_L^+|(1+|\Gamma|)\)</span>,当<span class="math inline">\(2\beta z-\psi_L=(2n+1)\pi\)</span>时,<span class="math inline">\(n=0,1,2...\)</span>,<span class="math inline">\(|\dot{U}_{min}|=|U_L^+|(1-|\Gamma|)\)</span>,进一步化简有<span class="math inline">\(\rho=\frac{1+|\Gamma|}{1-|\Gamma|},1\le\rho\le\infty,|\Gamma|=\frac{\rho-1}{\rho+1}\)</span></li>
<li>行波比：<span class="math inline">\(K=\frac{|\dot{U}|_{min}}{|\dot{U}|_{max}}=\frac{1}{\rho},0\le k\le1\)</span></li>
</ol></li>
</ol>
<h2 id="均匀无耗线的工作状态的分析">均匀无耗线的工作状态的分析</h2>
<p>对于无耗传输线, 负载阻抗不同则波的反射也不同; 反射波不同则合成波不同; 合成波的不同意味着传输线有不同的工作状态。根据终端负载的情况, 无耗传输线有三种工作状态:行波状态，驻波状态，行驻波状态，下面将分别讨论</p>
<h3 id="行波状态">行波状态</h3>
<p>当传输线是无限长，或其终端接有等于传输线的特性阻抗的负载时，信号源传向负载的能量将被负载完全吸收，而无反射，此时称传输线工作于行波状态。这时候也称传输线与负载处于匹配状态，即<span class="math inline">\(Z_L=Z_0\)</span>，终端匹配，无反射。</p>
<ol type="1">
<li><p>电压及电流 <span class="math display">\[\because U^-=I^-=0\\\therefore\begin{cases}
   \dot{U}(z)=\dot{U_L^+}e^{j\beta z}\\
   \dot{I}(z)=\dot{I_L^+}e^{j\beta z}\\
\end{cases}\]</span> 可见传输线上只有入射行波,行波状态下，均匀无耗线上各点电压复振幅的值是相同的，各点电流复振幅的值也是相同的，不随z而变化，只是U及I的相位随z的减少而滞后,线上任一处的U和I同相位，即它们的瞬时值是同相的</p></li>
<li><p>工作参量 <span class="math display">\[Z(z)=Z_L=Z_0=\sqrt{\frac{L}{C}}\\\Gamma(z)=0,\rho=1,k=1\]</span></p></li>
</ol>
<h3 id="驻波状态">驻波状态</h3>
<p>当传输线终端是短路、开路，或接有纯电抗性（电感性或电容性）负载时，由于负载不吸收能量，因而，从信号源传向负载的入射波在终端产生全反射，线上的入射波与反射波相叠加，从而形成了纯驻波状态，即<span class="math inline">\(Z_L=0,\infty,\pm jX\)</span>时，负载不吸收能量，终端全反射，线上纯驻波</p>
<h4 id="终端短路">终端短路</h4>
<ol type="1">
<li>电压及电流 <span class="math display">\[\because \dot{U_L}=0,\therefore\begin{cases}
   \dot{U}(z)=j\dot{I_L}Z_0sin\beta z\\
   \dot{I}(z)=\dot{I_L}Z_0cos\beta z\\
\end{cases}\\\because \dot{U_L^+}=\frac{\dot{U_L}+\dot{I_L}Z_0}{2},\dot{U_L}=0,\therefore \dot{I_L}=2\dot{I_L^+}\\\therefore\begin{cases}
   u(z,t)=2|\dot{U_L^+}|sin\beta zcos(wt+\psi+\pi/2)\\
   i(z,t)=2|\dot{I_L^+}|cos\beta zcos(wt+\psi)
\end{cases}\]</span> 由此可知，电压电流在时间相位与空间分布上相差<span class="math inline">\(\pi/2\)</span>，z相差<span class="math inline">\(\frac{\lambda}{4}\)</span>,当<span class="math inline">\(\beta z=n\pi\)</span>时，即<span class="math inline">\(z=\frac{n\pi}{\beta}=\frac{n\lambda}{2}(n=0,1,2,...)\)</span>,为电压驻波波节点，电流驻波波腹点；当<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2}\)</span>时，即<span class="math inline">\(z=(2n+1)\frac{\pi}{2\beta}=(2n+1)\frac{\lambda}{4}(n=0,1,2,...)\)</span>,为电压驻波波腹点，电流驻波波节点</li>
<li>工作参量
<ol type="1">
<li><span class="math inline">\(Z(z)=jZ_0tan\beta z\)</span>，纯电抗</li>
<li><span class="math inline">\(\Gamma(z)=-e^{-j2\beta z},|\Gamma_L|=1,\psi_L=-\pi\)</span></li>
<li><span class="math inline">\(\rho=\infty,k=0\)</span></li>
<li>当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(1,3,5....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(1,3,5....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯感抗。当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(2,4,6....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(2,4,6....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯容抗，在<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2},z=(2n+1)\frac{\lambda}{4}\)</span>时，<span class="math inline">\(Z(z)=\infty\)</span>,为并联谐振，在<span class="math inline">\(\beta z=n\pi,z=n\frac{\lambda}{2}\)</span>时，<span class="math inline">\(Z(z)=0\)</span>,为串联谐振</li>
</ol></li>
</ol>
<h4 id="终端开路">终端开路</h4>
<ol type="1">
<li>电压及电流 <span class="math display">\[\because\dot{I_L}=0,\therefore \begin{cases}
   \dot{U}(z)=2\dot{U_L^+}Z_0cos\beta z\\
   \dot{I}(z)=j2\dot{I_L^+}Z_0sin\beta z\\
\end{cases}\]</span> <span class="math inline">\(z=\frac{n\pi}{\beta}=\frac{n\lambda}{2}(n=0,1,2,...)\)</span>,为电压波腹点，电流波节点；当<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2}\)</span>时，即<span class="math inline">\(z=(2n+1)\frac{\pi}{2\beta}=(2n+1)\frac{\lambda}{4}(n=0,1,2,...)\)</span>,为电压驻波波节点，电流驻波波腹点 实际上终端开口的传输线并不是开路传输线, 因为在开口处会有辐射，<strong>理想的终端开路线是在终端开口处接上λ/4短路线来实现的。</strong></li>
<li>工作参量
<ol type="1">
<li><span class="math inline">\(Z(z)=-jZ_0cot\beta z\)</span>，纯电抗</li>
<li><span class="math inline">\(\Gamma(z)=e^{-j2\beta z},|\Gamma_L|=1,\psi_L=0\)</span></li>
<li><span class="math inline">\(\rho=\infty,k=0\)</span></li>
<li>当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(1,3,5....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(1,3,5....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯容抗。当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(2,4,6....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(2,4,6....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯感抗，在<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2},z=(2n+1)\frac{\lambda}{4}\)</span>时，<span class="math inline">\(Z(z)=0\)</span>,为串联谐振，在<span class="math inline">\(\beta z=n\pi,z=n\frac{\lambda}{2}\)</span>时，<span class="math inline">\(Z(z)=\infty\)</span>,为并联谐振</li>
</ol></li>
</ol>
<h4 id="终端接纯电抗z_lpm-jx">终端接纯电抗(<span class="math inline">\(Z_L=\pm jX\)</span>)</h4>
<p>纯电抗性负载是指传输线终端接有纯电感性或纯电容性负载时的情况,因为一段长为<span class="math inline">\(l(0&lt;l&lt;\lambda/4)\)</span>的终端短路线或开路线的输入阻抗为<span class="math inline">\(\pm jX\)</span>,所以可用一段长为<span class="math inline">\(l\)</span>的终端短路线或开路线等效代替,该方法称为<strong>延长线段法</strong> 1. 当<span class="math inline">\(Z_L=+jX\)</span>时，延长线段为<span class="math inline">\(l_e\)</span>的短路线<span class="math inline">\(\because jZ_0tan\beta l_e=+jX,\therefore l_e=\frac{\lambda}{2\pi}tan^{-1}(\frac{X}{Z_0})(0&lt;l_e&lt;\lambda/4)\)</span> 2. 当<span class="math inline">\(Z_L=-jX\)</span>时，延长线段为<span class="math inline">\(l_c\)</span>的开路线<span class="math inline">\(\because -jZ_0cot\beta l_c=-jX,\therefore l_c=\frac{\lambda}{2\pi}cot^{-1}(\frac{X}{Z_0})(0&lt;l_c&lt;\lambda/4)\)</span> 根据上面分析，终端接有纯电抗性负载的传输线，其上的电压、电流和输入阻抗也呈纯驻波状态。终端既不是电压的节腹点，也不是电流的节腹点,且<strong>当负载为纯电感时，距负载最近的为电压波腹点，负载为纯电容时，距负载最近的为电压波节点</strong> 3. 工作参量 <span class="math inline">\(\Gamma_L=\frac{\pm jX-Z_0}{\pm jX+Z_0}=|\Gamma_L|e^{j\psi_{\Gamma_L}},|\Gamma_L|=1,\psi_{\Gamma_L}=arctan(\frac{\pm2XZ_0}{X^2-Z_0^2}),\rho=\infty,K=0\)</span>,<strong>其终端处的反射系数不再是-1或+1，而是一个带有初相角的复数</strong></p>
<h3 id="行驻波状态">行驻波状态</h3>
<p>若传输线终端接有复数阻抗<span class="math inline">\(Z_L=R\pm jX\)</span>，或实数阻抗<span class="math inline">\(Z_L=R\neq Z_0\)</span>，此时，入射波能量一部分被负载吸收，剩余的能量反射回源。故线上为驻波与行波的迭加，即为行驻波状态。</p>
<ol type="1">
<li><p>电压及电流 <span class="math display">\[|\dot{U}(z)|=|\dot{U_L^+}|\sqrt{1+|\Gamma_L|^2+2|\Gamma_L|cos(\psi_L-2\beta z)}\\|\dot{I}(z)|=|\dot{I_L^+}|\sqrt{1+|\Gamma_L|^2-2|\Gamma_L|cos(\psi_L-2\beta z)}\]</span> 当<span class="math inline">\(\psi_L-2\beta z=-2n\pi,z=\frac{\psi_L\lambda}{4\pi}+\frac{n\lambda}{2}\)</span>,<span class="math inline">\(|\dot{U}(z)|\)</span>具有最大值<span class="math inline">\(|\dot{U}_L^+|(1+|\Gamma_L|)\)</span>,<span class="math inline">\(|\dot{I}(z)|\)</span>具有最小值<span class="math inline">\(|\dot{I}_L^+|(1-|\Gamma_L|)\)</span>,当<span class="math inline">\(\psi_L-2\beta z=-(2n+1)\pi,z=\frac{\psi_L\lambda}{4\pi}+\frac{(2n+1)\lambda}{4}\)</span>,<span class="math inline">\(|\dot{U}(z)|\)</span>具有最小值<span class="math inline">\(|\dot{U}_L^+|(1-|\Gamma_L|)\)</span>,<span class="math inline">\(|\dot{I}(z)|\)</span>具有最大值<span class="math inline">\(|\dot{I}_L^+|(1+|\Gamma_L|)\)</span></p>
<p>可见：行驻波状态传输线上电压与电流节腹点的分布规律与驻波状态时一样，节点与腹点相距λ/4，而且传输线上电压的腹点即电流的节点，电压的节点即电流的腹点。但不同的是：</p>
<ol type="1">
<li><span class="math inline">\(Z_L=R\neq Z_0\)</span>时，终端为节腹点，<span class="math inline">\(Z_L=R&gt;Z_0\)</span>,则<span class="math inline">\(z=0\)</span>处是电压腹点，电流节点，<span class="math inline">\(Z_L=R&lt;Z_0\)</span>,则<span class="math inline">\(z=0\)</span>处是电压节点，电流腹点</li>
<li><span class="math inline">\(Z_L=R\pm jX\)</span>时，<span class="math inline">\(\psi_l=arctan(\frac{\pm2XZ_0}{R^2+X^2-Z_0^2})\)</span>,对应的分别为感性/容性复阻抗，离开终端第一个出现的时电压腹/节点</li>
</ol></li>
<li><p>工作参量</p>
<ol type="1">
<li><span class="math inline">\(Z(z)=Z_0\frac{Z_L+jZ_0tan\beta z}{Z_0+jZ_Ltan\beta z}=Z_0\frac{1+\Gamma(z)}{1-\Gamma(z)}\)</span></li>
<li><span class="math inline">\(\Gamma(z)=|\Gamma_L|e^{j(\psi_L-2\beta z)}=\frac{Z(z)-Z_0}{Z(z)+Z_0}\)</span></li>
<li><span class="math inline">\(\rho=\frac{1+|\Gamma_L|}{1-|\Gamma_L|},1&lt;\rho&lt;\infty\)</span></li>
<li>在电压腹点(电流节点)有<span class="math inline">\(Z=\rho Z_0=R_{max}\)</span>,在电压节点(电流腹点)有<span class="math inline">\(Z=KZ_0=R_{min}\)</span>,进一步有<span class="math inline">\(R_{min}R_{max}=Z_0^2\)</span></li>
</ol></li>
<li><p>沿线阻抗分布特点</p>
<ol type="1">
<li>沿线阻抗周期性变化。在波腹、波节点处，阻抗呈现阻性（X = 0），阻抗变化周期为λ/2。在电压腹点处，阻抗出现最大值，且为纯电阻，相当于并联谐振，在电压节点处，阻抗出现最小值，且为纯电阻，相当于串联谐振。</li>
<li>每隔λ/4，阻抗性质变换一次，即具有“λ/4阻抗变换特性”</li>
<li>每隔λ/2，阻抗性质重复一次，即具有“λ/2抗重复特性”。因此，长度为λ/2或其整数倍时，不论终端接什么样的负载，其输入阻抗都和负载阻抗相等。</li>
</ol></li>
</ol>
<h2 id="史密斯圆图">史密斯圆图</h2>
<p>史密斯圆图是一种微波工程中最常用的图形工具，把特征参数和工作参数形成一体，采用图解法解决的一种专用Chart</p>
<h3 id="阻抗圆图">阻抗圆图</h3>
<h4 id="原理">原理</h4>
<p>在传输线问题的计算中常涉及要找出输入阻抗和反射系数的关系，我们可以将二者间的关系式绘制成曲线图，用图解的方法进行运算，则可以使计算大为简化。由于这些曲线实际上是一些圆，故名圆图.</p>
<p>定义： <span class="math inline">\(\frac{Z(z)}{Z_0}=Z&#39;(z)=R&#39;(z)+jX&#39;(z),Z&#39;：归一化阻抗，R&#39;：归一化电阻，X&#39;：归一化电抗\)</span>,所以有<span class="math inline">\(Z&#39;(z)=\frac{1+\Gamma(z)}{1-\Gamma(z)}\qquad\Gamma(z)=\frac{Z&#39;(z)-1}{Z&#39;(z)+1}\)</span></p>
<p>由于均匀无耗线上任一点的归一化阻抗与该点的反射系数具有一一对应的关系，因此可以将归一化阻抗实部及虚部的等值线画在以极坐标表示的反射系数的复平面上，这样构成的图形称为阻抗圆图。</p>
<h4 id="圆图的反射系数">圆图的反射系数</h4>
<p><span class="math display">\[\Gamma(z)=\Gamma_Le^{-j2\beta z}=|\Gamma_L|e^{j(\psi_L-2\beta z)}=|\Gamma_L|e^{j\psi}\]</span> <span class="math inline">\(|\Gamma|=\)</span>常数的曲线为一系列的同心圆簇，称为等<span class="math inline">\(|\Gamma|\)</span>圆，由于<span class="math inline">\(|\Gamma|=\frac{\rho+1}{\rho-1}\)</span>，所以在圆图上不画出等<span class="math inline">\(|\Gamma|\)</span>圆，只是在图中横轴上标出对应于<span class="math inline">\(|\Gamma|\)</span>的<span class="math inline">\(\rho\)</span>值(右半横轴)和K值(左半横轴)，<span class="math inline">\(\psi=\)</span>常数的曲线为一系列的径向射线簇，称为等<span class="math inline">\(\psi\)</span>线，在圆图上也不画出，而是在单位圆上标出,上半圆<span class="math inline">\(0\le\psi\le180^{\circ}\)</span>,下半圆<span class="math inline">\(-180^{\circ}\le\psi\le0\)</span>,且<span class="math inline">\(\psi=\psi_L-2\beta z=\psi_L-4\pi(\frac{z}{\lambda})\)</span>,故<span class="math inline">\(\psi\)</span>的变化对应线上电长度的变化 <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-10-18-11.png" style="width:60.0%;height:60.0%"></p>
<h4 id="圆图上的归一化阻抗">圆图上的归一化阻抗</h4>
<p><span class="math display">\[\because Z&#39;(z)=R&#39;(z)+jX&#39;(z)=\frac{1+\Gamma}{1-\Gamma},\Gamma=\Gamma_r+j\Gamma_i\\\therefore (\Gamma_r-\frac{R&#39;}{1+R&#39;})^2+\Gamma_i^2=(\frac{1}{1+R&#39;})^2\\(\Gamma_r-1)^2+(\Gamma_i-\frac{1}{X&#39;})=(\frac{1}{X&#39;})^2\]</span> 以上两方程为<span class="math inline">\(\Gamma_r+j\Gamma_i\)</span>平面上的等<span class="math inline">\(R&#39;\)</span>圆簇，等<span class="math inline">\(X&#39;\)</span>圆簇</p>
<ol type="1">
<li>等R′圆簇为R′＝常数时在<span class="math inline">\(\Gamma\)</span>平面上的圆簇,圆心坐标为<span class="math inline">\((\Gamma_r=\frac{R&#39;}{1+R&#39;},0),\)</span>半径为<span class="math inline">\(\frac{1}{1+R&#39;}\)</span>;可发现：
<ol type="1">
<li>所有等R′圆的圆心都在横轴上；</li>
<li><span class="math inline">\(\Gamma_r\)</span>与半径之和恒为1。故所有的等R′圆都相切于点（1，0）；</li>
<li>因为R&gt;0,所以所有的等R′圆都在单位圆内。其中单位圆： R′=0; 点(1,0), R′=<span class="math inline">\(\infty\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-10-35-35.png"></li>
</ol></li>
<li>等X′圆簇为X′＝常数时在<span class="math inline">\(\Gamma\)</span>平面上的圆簇,圆心坐标为<span class="math inline">\((\Gamma_r=1,\Gamma_i=\frac{1}{X&#39;})\)</span>,半径为<span class="math inline">\(\frac{1}{X&#39;}\)</span>;可发现：
<ol type="1">
<li>所有等R′圆的圆心都在<span class="math inline">\(\Gamma_r=1\)</span>上；</li>
<li>圆心纵坐标大小恒等于半径。故所有的等X′圆都相切于点（1，0）；</li>
<li>当X'&gt;0,等X'圆在上半平面，当X'&lt;0,等X'圆在下半平面，当X'=0,等X'圆在横轴，当X'=<span class="math inline">\(\infty\)</span>,等X'圆为点(1,0) <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-10-35-52.png"></li>
</ol></li>
<li>等X′圆的X′值直接标在图上，等R'圆的R'值直接由其与横轴交点处读取，又因为右半横轴对应<span class="math inline">\(\psi=0,\Gamma=|\Gamma|,\therefore Z&#39;=\frac{1+|\Gamma|}{1-|\Gamma|}=\rho\rightarrow R&#39;=\rho\)</span>,又因为左半横轴对应<span class="math inline">\(\psi=180^{\circ},\Gamma=-|\Gamma|,\therefore Z&#39;=\frac{1-|\Gamma|}{1+|\Gamma|}=K\rightarrow R&#39;=K\)</span></li>
</ol>
<h4 id="意义">意义</h4>
<ol type="1">
<li>三个特殊点
<ol type="1">
<li>坐标原点O，<span class="math inline">\(Z&#39;=R&#39;=1,X&#39;=0,\Gamma=0,\rho=K=1\)</span>代表了线上的行波工作状态，称为匹配点</li>
<li>横轴右端点，<span class="math inline">\(R&#39;=X&#39;=\infty,Z=\infty,\Gamma=1,\psi=0^{\circ},\rho=\infty\)</span>代表线上的开路处，称为开路点</li>
<li>横轴的左端点,<span class="math inline">\(R&#39;=X&#39;=Z&#39;=0,\Gamma=-1,\psi=180^{\circ},\rho=\infty\)</span>代表线上的短路处，称为短路点</li>
</ol></li>
<li>三条特殊线
<ol type="1">
<li>右半横轴（不包括两端点）:<span class="math inline">\(1&lt;R&#39;=\rho&lt;\infty,X&#39;=0,Z&#39;=R&#39;,\Gamma=|\Gamma|,\psi=0^{\circ}\)</span>代表行驻波状态的电压腹点，电流节点。称为电压波腹线</li>
<li>左半横轴（不包括两端点）:<span class="math inline">\(0&lt;R&#39;=K&lt;1,X&#39;=0,Z&#39;=R&#39;,\Gamma=-|\Gamma|,\psi=180^{\circ}\)</span>代表行驻波状态的电压节点，电流腹点。称为电压波节线</li>
<li>单位圆:<span class="math inline">\(R&#39;=0,Z&#39;=\pm jX&#39;,|\Gamma|=1\)</span>代表线上全驻波状态时节腹点之间的线段,半圆周<span class="math inline">\(\frac{\lambda}{4}\)</span></li>
</ol></li>
<li>两个半平面
<ol type="1">
<li>上半平面， X′&gt;0，电抗是感性，为感性平面</li>
<li>下半平面， X′&lt;0，电抗是容性，为容性平面</li>
<li>代表线上为行驻波状态时，节腹点之间的各<span class="math inline">\(\lambda/4\)</span>的线段</li>
</ol></li>
<li>两个旋转方向
<ol type="1">
<li>向电源:从负载移向信号源，圆图上顺时针方向旋转,z 增加</li>
<li>向负载: 从信号源移向负载，圆图上逆时针方向旋转, z减小</li>
</ol></li>
</ol>
<h3 id="导纳圆图">导纳圆图</h3>
<p>导纳圆图为阻抗圆图旋转<span class="math inline">\(180^{\circ}\)</span>所得，一般应用时圆图时不对圆图做旋转，而是将阻抗点旋转<span class="math inline">\(180^{\circ}\)</span>得到其导纳值 <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-11-11-12.png" style="width:60.0%;height:60.0%"></p>
<h2 id="长线的阻抗匹配">长线的阻抗匹配</h2>
<h3 id="阻抗匹配的概念">阻抗匹配的概念</h3>
<p>阻抗匹配通常包含两个方面的含义：1. 如何才能使得负载从信号源得到最大的功率。2. 如何才能消除传输线上的反射波。对于均匀无耗线来说，一般有三种阻抗匹配状态，对应传输线上三种不同的状态。1. 负载阻抗匹配：<span class="math inline">\(Z_L=Z_0\)</span>：行波匹配，传输线上只有从信号源到负载的入射波而无反射波。2. 源阻抗匹配：<span class="math inline">\(Z_g=Z_0\)</span>，传输线和信号源是匹配的，这种信号源称为“匹配源”，即使负载阻抗不匹配，负载的反射波也将被匹配源所吸收，始端不再产生新的反射。3. 源共轭匹配: <span class="math inline">\(Z_{in}=Z_g^*\)</span>--信号源输出功率最大</p>
<h3 id="阻抗匹配的重要性">阻抗匹配的重要性</h3>
<ol type="1">
<li>信号源共轭匹配时，信号源可以输出最大功率</li>
<li>尽量使传输系统处于或接近行波状态是很必要的，此时匹配负载可以从匹配源输出功率中吸收最大功率，传输线中的功率损耗最小、传输效率最高，传输线功率容量最大，行波状态时信号源工作稳定</li>
</ol>
<h3 id="阻抗匹配的方法">阻抗匹配的方法</h3>
<p>阻抗匹配：<span class="math inline">\(Z_L=Z_0、Z_g=Z_0、Z_{in}=Z_g^*\)</span>:只有当三者相等且都为纯电阻时，才能同时实现匹配,但<span class="math inline">\(Z_g,Z_L\)</span>一般为复阻抗，无耗传输线<span class="math inline">\(Z_0\)</span>为纯阻抗，很难同时满足匹配，<strong>为实现匹配，一般在信号源和终端负载处加始端和终端匹配装置，本节着重讨论负载阻抗匹配的方法</strong></p>
<p>负载阻抗匹配的方法从频率上可划分为窄带匹配和宽带匹配，从实现手段上可划分为<span class="math inline">\(\lambda/4\)</span>阻抗变换器法和支节调配法(利用并联/串联电抗性元件进行匹配)</p>
<h4 id="lambda4阻抗变换器法"><span class="math inline">\(\lambda/4\)</span>阻抗变换器法</h4>
<p>原理：利用<span class="math inline">\(\lambda/4\)</span>传输线的阻抗变化作用,<span class="math inline">\(Z_{in}(l)=Z_0\frac{Z_L+jZ_0tan\beta l}{Z_0+jZ_Ltan\beta l}\overset{l=\lambda/4}{\rightarrow} Z_{in}(l=\lambda/4)=\frac{Z_0^2}{Z_L}\)</span> 1. 负载阻抗<span class="math inline">\(Z_L=R_L\neq Z_0\)</span>为纯电阻时,在终端与主传输线（特性阻抗为<span class="math inline">\(Z_0\)</span>）之间串联一段长为<span class="math inline">\(\lambda/4\)</span>,特性阻抗为<span class="math inline">\(Z_{01}\)</span>的传输线，为实现匹配，<span class="math inline">\(Z_{in}=Z_0\rightarrow Z_{01}=\sqrt{Z_0Z_L}\)</span> 2. 负载阻抗<span class="math inline">\(Z_L\)</span>＝<span class="math inline">\(R_L+jX_L\)</span>为复阻抗时,若仍利用λ/4线进行阻抗匹配，则需先变换为实阻抗。 1. 法1：将λ/4线接于主传输线中的电压波节点或波腹点处 <span class="math inline">\(\because\)</span> 电压波节点或波腹点处，<span class="math inline">\(Z_{in}=Z_0/\rho\)</span>或<span class="math inline">\(Z_{in}=\rho Z_0\)</span>为纯电阻 2. 法2：将λ/4线仍接在终端，但在终端再并联长为l的短路线等。确定长度l：使特性阻抗为<span class="math inline">\(Z_{02}\)</span>，长度为l的短路线的输入导纳等于<span class="math inline">\(-jB_L\)</span>，抵消负载中的电纳部分<span class="math inline">\(jB_L\)</span>，使终端等效负载为纯电阻性的 以上方法只能调配一个频率点，属于窄带阻抗匹配 <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-41-37.png" style="width:60.0%;height:60.0%"></p>
<h4 id="利用并联电抗性元件进行匹配的支节调配器">利用并联电抗性元件进行匹配的支节调配器</h4>
<p>支节调配器法：在主传输线上某位置并联或串联长度可调的 短路线（或开路线）进行阻抗调配的方法。它是通过附加反射来抵消传输线上原存在的反射波达到匹配的目的。常用并联电抗性元件的方法</p>
<p>支节调配器：是由距离负载的某位置上的并联或串联终端短路或开路的传输线（又称支节）构成的。支节数可以是一条、两条、三条或更多。 讨论 (1)单株线调配器、(2)双株线调配器、(3)三株线调配器</p>
<ol type="1">
<li><p>单株线调配器 在主传输线上距负载d处，并联一长度为l的短路（或开路）支节，d，l可调节 工作原理：1. 在距离负载d（d&lt;λ/2）处的线上总可以找到归一化导纳为<span class="math inline">\(y_1=1+jb_1\)</span>的点(由此可确定d)；2. 在该处并联一个归一化电纳<span class="math inline">\(y_2=-jb_1\)</span>(由此可确定l),可实现与主传输线的匹配，<span class="math inline">\(y=y_1+y_2=1\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-42-11.png" style="width:60.0%;height:60.0%"> 理论上：若d在λ/2范围内可变化，B2可在<span class="math inline">\(\pm\infty\)</span>间任意调节,则可对任何有耗负载进行调配。缺点：窄频带匹配，当工作频率变化时，d和l都需重新调节，负载不同，d和l都需要改变</p></li>
<li><p>双株线调配器 距负载两个固定的位置处各并联一个短路线（或开路线）支节，固定<span class="math inline">\(d_1,d_2\)</span>，<span class="math inline">\(d_2\)</span>一般取λ/8,λ/4或3λ/8，但不能选λ/2(否则相当于一个固定位置的单支节),调节<span class="math inline">\(l_1,l_2\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-42-37.png" style="width:60.0%;height:60.0%"> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-42-56.png" style="width:60.0%;height:60.0%"> 缺点：窄带，存在死区，某些情况得不到匹配，只适用于匹配由负载产生的驻波比较小的传输线系统</p></li>
<li><p>三株线调配器 距负载三个固定的位置处，各并联一个短路线（或开路线）支节，主要用于缓解双株线调配器的死区问题</p></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>微波技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title>微波技术基础第五六章知识小结</title>
    <url>/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>因为第六章内容较少，故将两章合并</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<ol type="1">
<li>为什么在微波波段不能使用集总参数LC谐振回路？
<ol type="1">
<li><span class="math inline">\(w_0=1/\sqrt{LC}\)</span>在微波波段，<span class="math inline">\(w_0\)</span>很高，所以L和C很小，元件制造困难</li>
<li>当电路尺寸与微波波长可以相比拟时，就会产生能量的辐射，波长越短辐射越严重，故辐射损耗大。另外，由于此时趋肤效应严重，故欧姆损耗大，而且介质损耗大。因此，在频率较高的微波波段，集总LC谐振回路储能小，损耗大，导致Q值小到不能用</li>
</ol></li>
<li>微波谐振器与LC谐振回路的相同和相异点
<ol type="1">
<li>LC回路为集总参数电路，微波谐振器时属于分布参数电路。所以LC回路能量只分布在L、C上，而微波谐振器的能量分布在整个腔体中</li>
<li>LC回路在L及C一定时，只有一个谐振频率，而微波谐振器有无限多个谐振频率，这称为微波谐振器的多谐性</li>
<li>微波谐振腔储能多，损耗小。故微波谐振器品质因数很高，比LC回路的Q值高很多。</li>
</ol></li>
<li>微波谐振器的分析方法：主要是场解法和场的叠加法，这里主要用的是后者</li>
</ol>
<h2 id="微波谐振器的主要参数">微波谐振器的主要参数</h2>
<ol type="1">
<li>谐振频率：无色散波<span class="math inline">\(\beta=\frac{2\pi}{\lambda_r}=\frac{2\pi}{v}f\)</span>,色散波<span class="math inline">\(\beta=\frac{2\pi}{\lambda_g}=\frac{2\pi}{v}\sqrt{f_r^2-f_c^2}\)</span></li>
<li>品质因数
<ol type="1">
<li>固有品质因数:表征谐振器的损耗的大小、频率选择性的强弱、工作稳定度 <span class="math display">\[Q_0=2\pi\frac{W(腔体总储能)}{W_T(腔体一个周期损耗能量)=PT(P:一周期谐振器平均损耗功率)}\\\therefore Q_0=\frac{2\pi W}{PT}=w_r\frac{W}{P}\]</span> 进一步化简可知<span class="math inline">\(Q_0\)</span>正比于<span class="math inline">\(V/S\)</span>,其与谐振器尺寸成正比，又因谐振器尺寸与工作波长成正比，所以其与工作波长成正比</li>
<li>有载品质因数：谐振器带上负载时腔体的品质因数 <span class="math display">\[Q_L=w_r\frac{W}{P_i+P_c}或\frac{1}{Q_L}=\frac{1}{Q_0}+\frac{1}{Q_c}或Q_L=\frac{Q_0}{1+k}\]</span> <span class="math inline">\(W-总储能，P_i-腔本身损耗功率，P_c-外界负载损耗功率，\\Q_c-耦合品质因数，k-耦合系数(腔体与外界负载之间的耦合程度)\)</span></li>
</ol></li>
</ol>
<h2 id="圆柱谐振腔">圆柱谐振腔</h2>
<p>圆柱谐振腔具有较高的品质因数，调谐方便，结构坚固，易于加工，制作。属于传输线型谐振腔，<strong>可以看作两端短路的一段圆波导</strong></p>
<h3 id="场分量表达式">场分量表达式</h3>
<ol type="1">
<li><span class="math inline">\(TE_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(H_z\)</span>，其形式与圆波导有一定相似性，其在<span class="math inline">\(r,\psi,z\)</span>上均呈驻波状态，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{\mu_{mn}}{R})^2+(\frac{p\pi}{l})^2},m=0,1,2,\dots,n=1,2\dots,p=1,2\dots\)</span></li>
<li><span class="math inline">\(TM_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(E_z\)</span>，其形式与圆波导有一定相似性，其在<span class="math inline">\(r,\psi,z\)</span>上均呈驻波状态，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{v_{mn}}{R})^2+(\frac{p\pi}{l})^2},m=0,1,2,\dots,n=1,2\dots,p=0,1,2\dots\)</span></li>
</ol>
<h3 id="谐振频率和波型图">谐振频率和波型图</h3>
<ol type="1">
<li>谐振频率： <span class="math inline">\(f_r=\frac{Kv}{2\pi}\Rightarrow\lambda_r=\frac{v}{f_r}=\frac{2\pi}{K},\therefore TE_{mnp}:f_r=\frac{1}{2\pi\sqrt{\mu\epsilon}}\sqrt{(\frac{\mu_{mn}}{R})^2+(\frac{p\pi}{l})^2},\lambda_r=\frac{1}{\sqrt{(\frac{\mu_{mn}}{2\pi R})^2+(\frac{p}{2l})^2}},\\\therefore TM_{mnp}:f_r=\frac{1}{2\pi\sqrt{\mu\epsilon}}\sqrt{(\frac{v_{mn}}{R})^2+(\frac{p\pi}{l})^2},\lambda_r=\frac{1}{\sqrt{(\frac{v_{mn}}{2\pi R})^2+(\frac{p}{2l})^2}}\)</span></li>
<li>波形图：如果用<span class="math inline">\(X_{mn}\)</span>来代替上式中的<span class="math inline">\(\mu_{mn}\)</span>和<span class="math inline">\(v_{mn}\)</span>，则圆柱谐振腔中的 谐振波长<span class="math inline">\(\lambda_r\)</span>可以写成一个公式<span class="math inline">\(\lambda_r=\frac{1}{\sqrt{(\frac{X_{mn}}{2\pi R})^2+(\frac{p}{2l})^2}}=\frac{D}{\sqrt{(\frac{X_{mn}}{\pi})^2+(\frac{Dp}{2l})^2}}\rightarrow(f_rD)^2=(\frac{vX_{mn}}{\pi})^2+(\frac{vp}{2})^2(\frac{D}{l})^2\)</span>,从上面关系式可知，对于给定模式，<span class="math inline">\((f_rD)^2与(\frac{D}{l})^2\)</span>在波形图上是一直线,斜率为<span class="math inline">\((\frac{vp}{2})^2\)</span>,截距为<span class="math inline">\((\frac{vX_{mn}}{\pi})^2\)</span> <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-14-42-16.png"> 工作方块：以选定工作波型的调谐曲线为对角线，最小、最大的<span class="math inline">\((f_rD)^2\)</span>值与对应的 <span class="math inline">\((D/l)^2\)</span>确定的矩形区域。利用工作方块保证单模工作，避免干扰波型：
<ul>
<li>自干扰型：相同m、n，不同p-相同截距，不同斜率，与工作波型耦合最强，务必不使其落入工作方块内</li>
<li>一般干扰型：相同p，不同m、n-不同截距，相同斜率，会导致一个以上的谐振频率。</li>
<li>交叉型：m、n、p完全不同-场结构完全不同。</li>
<li>简并型：曲线完全重合，fr完全相同，但场结构完全不同，容易抑制。</li>
</ul></li>
<li>圆柱谐振腔特点：
<ol type="1">
<li>圆柱腔存在多谐性</li>
<li>R、l一定时，谐振波长<span class="math inline">\(λ_r\)</span>最长的模为主模。当l&gt;2.1R时，<span class="math inline">\(TE_{111}\)</span>为主模,当l&lt;2.1R时，<span class="math inline">\(TM_{010}\)</span>为主模</li>
<li><span class="math inline">\(TE_{onp}\)</span>与<span class="math inline">\(TM_{1np}\)</span>模式简并，同时都存在极化简并</li>
</ol></li>
<li>圆柱腔常用的3个振荡模式
<ol type="1">
<li><span class="math inline">\(TE_{011},K_c=\frac{3.832}{R},\lambda_r=1/\sqrt{(\frac{1}{1.64R})^2+(\frac{1}{2l})^2}\)</span>为高次模，磁场分量只有<span class="math inline">\(H_r,H_\psi\)</span>,侧壁和端壁内表面只有<span class="math inline">\(\psi\)</span>方向表面电流，可用不接触式活塞进行调谐，场结构稳定、无极化简并，损耗小，Q值可高达几万以上。故可作成<strong>高精度的频率计</strong></li>
<li><span class="math inline">\(TE_{111},\lambda_r=1/\sqrt{(\frac{1}{3.41R})^2+(\frac{1}{2l})^2},l&gt;2.1R\)</span>时，为圆柱谐振腔的主模，腔体尺寸较小，Q值不高，存在极化简并</li>
<li><span class="math inline">\(TM_{010},K_c=\frac{2.405}{R},\lambda_r=2.61R,l&lt;2.1R\)</span>为主模,既无模式简并，又无极化简并.Q值不高，且<span class="math inline">\(λ_r\)</span>与l无关，故无法用短路活塞来进行调谐,常用的调谐方法从端面中心插入一圆柱体，插入深度可调</li>
</ol></li>
</ol>
<h2 id="矩形谐振腔">矩形谐振腔</h2>
<p>矩形空腔谐振器是由一段长为l、 两端短路的矩形波导组成</p>
<h3 id="场解及振荡模式">场解及振荡模式</h3>
<ol type="1">
<li><span class="math inline">\(TE_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(H_z\)</span>，其形式与矩形波导有一定相似性，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2+(\frac{p\pi}{l})^2},m,n不同时为0,p=1,2\dots\)</span></li>
<li><span class="math inline">\(TM_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(E_z\)</span>，其形式与矩形波导有一定相似性，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2+(\frac{p\pi}{l})^2},m,n\neq0,p=1,2\dots\)</span></li>
</ol>
<h3 id="特性参数">特性参数</h3>
<ol type="1">
<li>谐振频率、谐振波长 <span class="math inline">\(f_r=\frac{Kv}{2\pi}\Rightarrow\lambda_r=\frac{v}{f_r}=\frac{2\pi}{K},\therefore f_r=\frac{1}{2\sqrt{\mu\epsilon}}\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2+(\frac{p}{l})^2},\lambda_r=\frac{2}{\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2+(\frac{p}{l})^2}}\)</span></li>
<li>固有品质因数(以<span class="math inline">\(TE_{101}\)</span>为例) <span class="math display">\[Q_0=\frac{abl}{\delta}\frac{a^2+l^2}{2b(a^3+l^3)+al(a^2+l^2)}\]</span> <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-03-51.png"></li>
</ol>
<h2 id="同轴线空腔谐振器">同轴线空腔谐振器</h2>
<p>同轴腔由一段长为l的同轴线构成，其振荡模式为TEM模。优点：场结构简单、稳定，无色散，无频率下限，工作频带宽 ,缺点：固有品质因数Q值比较低，损耗大，故工作频率不能太高,适用：米波、分米波、厘米波（小功率）低精度的波长计,主要可分为<span class="math inline">\(\lambda/2\)</span>同轴腔：<span class="math inline">\(\lambda_r=\frac{2l}{p}\)</span>和<span class="math inline">\(\lambda/4\)</span>同轴腔:<span class="math inline">\(\lambda_r=\frac{4l}{2p+1}\)</span>与电容加载同轴谐振腔<span class="math inline">\(l&lt;(2p+1)\frac{\lambda_r}{4}\)</span></p>
<h2 id="微波网络基础">微波网络基础</h2>
<p>微波网络模型由一个通常称之为“黑箱”的N与外部相连接的若干端口构成。 “黑箱”表示不均匀性，端口是它与外界相联系的“窗口”，电信号由端口输入或输出，并可在端口处进行电压、电流、反射系数和衰减等量的测量。<strong>其优点在于不用关心黑盒内部长的具体实现情况，只需要通过测量的方式知道各端口信号量之间的关系，避免了对内部场分布的复杂计算</strong></p>
<h3 id="微波网络与传输矩阵">微波网络与传输矩阵</h3>
<p><img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-12-47.png"> 线性微波网络（Network），输入电压电流<span class="math inline">\(U_1、I_1\)</span>和输出电压电流<span class="math inline">\(U_2、I_2\)</span>可用传输矩阵[A]联系起来 <span class="math display">\[\begin{bmatrix}
U_1\\
I_1\\
\end{bmatrix}=\begin{bmatrix}
A_{11}&amp;A_{12}\\
A_{21}&amp;A_{22}\\
\end{bmatrix}\begin{bmatrix}
U_2\\
-I_2\\
\end{bmatrix}=A\begin{bmatrix}
U_2\\
-I_2\\
\end{bmatrix}\]</span> A称为二端口网络的传输矩阵，其元素<span class="math inline">\(A_{11}、A_{12}、A_{21}和A_{22}\)</span>称为传输参数（A参数）,A参数的定义式可以在端口开路和短路的情况下求得，A参数各参数的物理意义为： <span class="math inline">\(A_{11}\)</span>：端口②开路时，端口①到端口②电压传输系数的倒数； <span class="math inline">\(A_{21}\)</span>：端口②开路时，端口①与端口②之间的转移导纳； <span class="math inline">\(A_{21}\)</span>：端口②短路时，端口①到端口②电流传输系数的倒数； <span class="math inline">\(A_{22}\)</span>：端口②短路时，端口①与端口②之间的转移阻抗。</p>
<p>由于A参数是在网络端口开路和短路的情况下求出的，因此称为混合A参数，并具有明确的物理意义。互易网络:<span class="math inline">\(A_{11}A_{22}-A_{12}A_{21}=1\)</span>对称网络:<span class="math inline">\(A_{11}=A_{22}\)</span></p>
<h3 id="微波网络的散射参数">微波网络的散射参数</h3>
<p><img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-19-43.png"></p>
<p><span class="math display">\[\begin{bmatrix}
b_1\\
b_2\\
\end{bmatrix}=\begin{bmatrix}
S_{11}&amp;S_{12}\\
S_{21}&amp;S_{22}\\
\end{bmatrix}\begin{bmatrix}
a_1\\
a_2\\
\end{bmatrix}\]</span> 简记为b=Sa,b和a分别为由端口的归一化反射波和归一化入射波所构成的列矩阵，S是一个正方矩阵,称为二端口网络的归一化散射矩阵，其元素称为归一化的散射参数，也称为S参数</p>
<p>S参量各参数的物理意义为： <span class="math inline">\(S_{11}\)</span>：端口②接匹配负载时，端口①的反射系数； <span class="math inline">\(S_{21}\)</span>：端口②接匹配负载时，端口①到端口②波的传输系数； <span class="math inline">\(S_{22}\)</span>：端口①接匹配负载时，端口②的反射系数； <span class="math inline">\(S_{12}\)</span>：端口①接匹配负载时，端口②到端口①波的传输系数。 可见, ［S］矩阵的各参数是建立在端口接匹配负载基础上的反射系数或传输系数。 这样利用网络输入输出端口的参考面上接匹配负载即可测得散射矩阵的各个参量。 对于互易网络: <span class="math inline">\(S_{12}=S_{21}\)</span> 对于对称网络: <span class="math inline">\(S_{11}=S_{22}\)</span></p>
<h3 id="二端口网络的工作特性参量">二端口网络的工作特性参量</h3>
<p>二端口元件是微波系统中用的最多的元件,将这些二端口元件接入到传输系统后，相当于在均匀传输线中插入一个二端口网络,此时其输入端的反射系数不仅与网络参量有关，而且还与输出端所接的负载有关 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-25-42.png"></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>微波技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title>微波技术基础第三四章知识小结</title>
    <url>/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>因为第四章内容较少，且和第三章关系紧密，故将两章合并</p>
<h2 id="导波系统的一般分析方法">导波系统的一般分析方法</h2>
<h3 id="导波系统的基本概念">导波系统的基本概念</h3>
<p><strong>导波（导行波）</strong>：在微波传输线中按指定方向传播的电磁波</p>
<p><strong>导波系统（波导）</strong>：用来导行电磁波的装置</p>
<span id="more"></span>
<p><strong>规则波导</strong>：沿轴线方向，横截面的形状、尺寸，以及填充介质的分布状态和电参数均不变的无限长的直波导</p>
<p><strong>狭义的波导</strong>：只限于空心的金属矩形和圆形波导等。</p>
<h3 id="不同类型的场">不同类型的场</h3>
<p>波形可划分为三类(根据纵向分量区分):</p>
<ol type="1">
<li><span class="math inline">\(\dot{E_z}=0,\dot{H_z}=0\)</span>:横电磁波：TEM波,<span class="math inline">\(\dot{\overrightarrow{E_t}}=\eta\dot{\overrightarrow{H_t}}\times\dot{\overrightarrow{a_z}}\\\dot{\overrightarrow{H_t}}=\frac{1}{\eta}\dot{\overrightarrow{a_z}}\times\dot{\overrightarrow{E_t}}\)</span></li>
<li><span class="math inline">\(\dot{E_z}=0,\dot{H_z}\neq 0\)</span>:横电波：TE波 H波 电场只有横向分量，纵向分量为零，所以有<span class="math inline">\(\dot{\overrightarrow{E_t}}=\frac{w\mu}{\beta}\dot{\overrightarrow{H_t}}\times\dot{\overrightarrow{a_z}}\)</span></li>
<li><span class="math inline">\(\dot{E_z}\neq 0,\dot{H_z}=0\)</span>:横磁波：TM波 E波 磁场只有横向分量，纵向分量为零，所以有<span class="math inline">\(\dot{\overrightarrow{H_t}}=\frac{w\epsilon}{\beta}\dot{\overrightarrow{a_z}}\times \dot{\overrightarrow{E_t}}\)</span> TE、TM波在横截面内<span class="math inline">\(E_t\)</span>和<span class="math inline">\(H_t\)</span>相互正交，而且与单位矢量z构成一个右手螺旋系</li>
</ol>
<h2 id="波沿导波装置的传输特性">波沿导波装置的传输特性</h2>
<h3 id="传输条件">传输条件</h3>
<p>TE波和TM波在金属波导内传输需满足一定的条件：</p>
<ol type="1">
<li><span class="math inline">\(Z(z)=A^+e^{-j\beta z}\)</span>：无耗波导沿z轴正方向</li>
<li><span class="math inline">\(\beta=\sqrt{K^2-K_c^2}\)</span>：相移常数</li>
<li><span class="math inline">\(K_c=\frac{2\pi}{\lambda_c}=2\pi\sqrt{\mu\epsilon}f_c\)</span>:由横截面尺寸、性质和波型决定</li>
<li><span class="math inline">\(K=w\sqrt{\mu\epsilon}\)</span>:当波导介质一定，就由该波的频率决定</li>
<li><span class="math inline">\(\beta\rightarrow f,\lambda\)</span>,当f变化时，出现以下三种情况：
<ol type="1">
<li><span class="math inline">\(K&gt;K_c,\beta\rightarrow\)</span>实数，波导-传输状态(波向正方向和负方向传播)，此时<span class="math inline">\(\lambda&lt;\lambda_c,f&gt;f_c\)</span>(<span class="math inline">\(\lambda=2\pi/(w\sqrt{\mu\epsilon})\)</span>)-工作波长，f-工作频率，与波导无关</li>
<li><span class="math inline">\(K&lt;K_c,\beta\rightarrow\)</span>虚数，波导-截止状态(波沿指数规律衰减)，此时<span class="math inline">\(\lambda&gt;\lambda_c,f&lt;f_c\)</span></li>
<li><span class="math inline">\(K=K_c,\beta=0\)</span>,波导-临界状态,此时<span class="math inline">\(\lambda=\lambda_c,f=f_c,f_c=\frac{K_c}{2\pi\sqrt{\mu\epsilon}},\lambda_c=\frac{2\pi}{K_c}=\frac{1}{\sqrt{\mu\epsilon}f_c}=\frac{v}{f_c},v:\)</span>波在无界介质中传播速度，可见波导具有高通滤波器特性。(TEM波截止频率为零)</li>
</ol></li>
</ol>
<h3 id="传播常数">传播常数</h3>
<p>传播常数<span class="math inline">\(\gamma=\alpha+j\beta\)</span>,衰减常数<span class="math inline">\(\alpha\)</span>:波导单位长度上波幅值的衰减量 (dB/m),相移常数<span class="math inline">\(\beta\)</span>:波沿波导轴向传播时单位距离内相位的变化量(rad/m),无耗传输线:<span class="math inline">\(\alpha=0\quad\gamma=j\beta\)</span></p>
<h3 id="相速">相速</h3>
<p>相速<span class="math inline">\(v_p\)</span>: 波的等相位面沿波导轴向（z）传播的速度,<span class="math inline">\(v_p=\frac{dz}{dt}=\frac{w}{\beta}=\frac{2\pi f}{\sqrt{(\frac{2\pi}{\lambda})^2-(\frac{2\pi}{\lambda_c})^2}}=\frac{v}{\sqrt{1-(\lambda/\lambda_c)^2}}\)</span>,<strong>TEM波型的相速:<span class="math inline">\(\because \lambda_c\rightarrow\infty\quad v_p=v=\frac{1}{\sqrt{\mu\epsilon}}\)</span></strong>,TE和TM波型相速：<span class="math inline">\(\lambda&lt;\lambda_c,v_p&gt;v\)</span>,可知TEM波的相速与频率无关。具有这种特性的波型称为<strong>无色散波型</strong>，对于传输某一波型的电磁波而言，其相速随频率而变化的(例如TE和TM波型)，具有这种特性的波型称为<strong>色散波型</strong>。</p>
<h3 id="波导波长">波导波长</h3>
<p>波导波长<span class="math inline">\(\lambda_g\)</span>：波导内沿轴向传播的电磁波相邻的两个同相位点之间的距离, 也就是相位相差2π的两点间的距离。<span class="math inline">\(\lambda_g=\frac{v_p}{f}=\frac{\lambda}{\sqrt{1-(\lambda/\lambda_c)^2}},\beta=\frac{2\pi}{\lambda_g}\)</span>,TEM波:<span class="math inline">\(\lambda_g=\lambda\)</span>,TE/TM波：<span class="math inline">\(\lambda&lt;\lambda_c\quad\lambda_g&gt;\lambda\)</span></p>
<h3 id="群速">群速</h3>
<p>群速<span class="math inline">\(v_g\)</span>：多频率成分构成的“波群”的速度（波群－－一群具有相近的ω与相近的β的波），代表能量的传播速度。<span class="math inline">\(v_g=\frac{dw}{d\beta}=v\sqrt{1-(\frac{\lambda}{\lambda_c})^2}(\lambda&lt;\lambda_c),v_g\cdot v_p=v^2\)</span></p>
<h3 id="波型阻抗">波型阻抗</h3>
<p>波型阻抗<span class="math inline">\(Z_w\)</span>：电场的横向分量<span class="math inline">\(E_t\)</span>与磁场的横向分量<span class="math inline">\(H_t\)</span>的幅值之比（行波状态下）,TE波:<span class="math inline">\(Z_{TE}=\frac{w\mu}{\beta}=\sqrt{\frac{\mu}{\epsilon}}\frac{\lambda_g}{\lambda}=\eta\frac{\lambda_g}{\lambda}&gt;\eta\)</span>,TM波:<span class="math inline">\(Z_{TM}=\frac{\beta}{w\mu}=\sqrt{\frac{\mu}{\epsilon}}\frac{\lambda}{\lambda_g}=\eta\frac{\lambda}{\lambda_g}&lt;\eta\)</span>,TEM波：<span class="math inline">\(Z_{TEM}=\sqrt{\frac{\mu}{\epsilon}}=\eta\)</span>(波在无界媒质中的波阻抗)<span class="math inline">\(\approx120\pi\)</span></p>
<h2 id="矩形波导">矩形波导</h2>
<p>矩形波导：通常将由金属材料制成的（一般为铜或铝，内表面镀银或金）、矩形截面的、内充空气的规则金属波导称为矩形波导。它是微波技术中最常用的传输系统之一，其优点在于<strong>微波高频段（厘米波或毫米波）损耗小、功率容量大、频带宽</strong></p>
<h3 id="场解及波型">场解及波型</h3>
<h4 id="te波h波">TE波(H波)</h4>
<ol type="1">
<li><p>场分量表达式：TE波型：<span class="math inline">\(E_Z=0,H_z\neq 0\)</span>,由矩形波导的边界条件:理想导体表面磁场的垂直分量<span class="math inline">\((H_x,H_y)=0\)</span>，结合边界条件得到磁场纵向分量<span class="math inline">\(H_z=H_0cos(\frac{m\pi}{a}x)cos(\frac{n\pi}{b}y)e^{-j\beta z}\)</span>，再进一步推导得到矩形波导其他场分量表达式，其中，最重要的是<span class="math inline">\(K_c=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2}\)</span>,其与波导尺寸和传输波型有关</p>
<ol type="1">
<li>上式的m,n分别代表TE波沿x方向和y方向分布的半波个数,且每一对(m,n)对应一种波型，记为<span class="math inline">\(TE_{mn}(H_{mn})\)</span></li>
<li>对于TE波而言，m、n中任意一个可以为0，但是不能同时为0，故存在<span class="math inline">\(TE_{m0},TE_{0n},TE_{mn}\)</span>,矩形波导中TE波的最低次波型(截止波长最长或截止频率最低)为<span class="math inline">\(TE_{10}(a&gt;b)\)</span>，其余称为高次模</li>
<li>场沿z轴为行波，x,y轴为纯驻波分布，<strong>这意味着在行波状态下，沿矩形波导的纵向（z轴）传输的是有功功率，而在矩形波导的横向（x和y轴）只存在无功功率，即没有功率的传输。</strong></li>
</ol></li>
<li><p>场结构：为了能形象和直观的了解场的分布（场结构），可以利用电力线和磁力线来描绘它。电力线和磁力线遵循的规律：力线上某点的切线方向<span class="math inline">\(\rightarrow\)</span>该点处场的方向,力线的疏密程度<span class="math inline">\(\rightarrow\)</span>场的强弱,当给定了m和n时，根据场分量表达式，就可以绘出电力线和磁力线的图形----场结构图,下面举例<span class="math inline">\(TE_{10}模\)</span></p>
<p><span class="math inline">\(TE_{10}\)</span>波:各个场分量沿x方向有一个半驻波分布，y方向不变为均匀分布。 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-18-53-24.png" style="width:40.0%;height:40.0%"></p></li>
</ol>
<h4 id="tm波e波">TM波（E波）</h4>
<ol type="1">
<li>场分量表达式：TM波型：<span class="math inline">\(H_Z=0,E_z\neq 0\)</span>,由矩形波导的边界条件:理想导体表面切向电场为零,结合边界条件得到磁场纵向分量<span class="math inline">\(E_z=E_0sin(\frac{m\pi}{a}x)sin(\frac{n\pi}{b}y)e^{-j\beta z}\)</span>
<ol type="1">
<li>存在无穷多个波型与m、n对应，其线性组合（叠加）也是场解。每一对（m、n）对应一种波型，记为<span class="math inline">\(TM_{mn}\)</span>。同样<span class="math inline">\(K_c=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2}\)</span></li>
<li>对于TM波，m、n中任意一个不能为0，否则场全为0。(<span class="math inline">\(m,n=0\rightarrow E_z=0\)</span>)所以<span class="math inline">\(TM_{00}、TM_{0n}、TM_{m0}\)</span>不存在。最低波型为<span class="math inline">\(TM_{11}\)</span>。</li>
<li>TM波型的场沿z轴为行波，沿x、y轴为纯驻波分布（正弦、余弦的分布规律）所以行波状态下，沿波导纵向（z轴）传输有功功率、横向（x、y轴）无功功率</li>
</ol></li>
<li>场结构 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-19-02-54.png"></li>
</ol>
<h3 id="矩形波导中电磁波的传播特性">矩形波导中电磁波的传播特性</h3>
<ol type="1">
<li>截止波长和截止频率 <span class="math inline">\(\lambda_c=\frac{2\pi}{K_c}=\frac{2}{\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2}},f_c=\frac{v}{\lambda_c}=\frac{1}{2\sqrt{\mu\epsilon}}\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2}\)</span>,可见<span class="math inline">\(TE_{mn},TM_{mn}\)</span>在m、n相同时具有相同的截止波长与截止频率，但场分布不同</li>
<li>波型简并 由于矩形波导中，对于m及n均不为0的<span class="math inline">\(TE_{mn},TM_{mn}\)</span>模，具有相同的截止波长<span class="math inline">\(\lambda_c\)</span>，故这种场结构（波型）不同的模式截止波长相同的现象。<span class="math inline">\(TE_{0n},TE_{m0}\)</span>是非简并模,存在简并现象的模式称为简并模，简并模在工作频率相同时，其相速、群速、波导波长都是相同的。在工作中要想办法抑制工作模的简并模。</li>
<li>截止波长分布图 因为截止波长与m,n成反比，所以当a,b一定时，m,n越小，截止波长<span class="math inline">\(\lambda_c\)</span>越大,对应的<span class="math inline">\(\beta=\frac{2\pi}{\lambda}\sqrt{1-(\frac{\lambda}{\lambda_c})^2}\)</span>,<strong>所以当工作波长<span class="math inline">\(\lambda&lt;\)</span>某种模式的<span class="math inline">\(\lambda_c\)</span>时，<span class="math inline">\(\beta&gt;0\rightarrow\)</span>传导模，反之则为截止模</strong></li>
<li>主模，高次模,单模波导 截止波长最长的模式称为矩形波导中的主模其余为高次模。矩形波导中的主模为<span class="math inline">\(TE_{10}\)</span>，其<span class="math inline">\(\lambda_c=2a\)</span>，只能传输主模的波导为单模波导</li>
</ol>
<h3 id="矩形波导主模te_10模场分布及工作特性">矩形波导主模<span class="math inline">\(TE_{10}\)</span>模场分布及工作特性</h3>
<p>为何要单模传输？:不同模式的相速不同，他们之间将有模式色散，从而使信号发生畸变。所以微波传输系统无一例外采用单模传输，即只传输主模</p>
<p><span class="math inline">\(TE_{10}\)</span>模可以在相当宽的频带内单模工作，而在此频带内其它模式都截止。这是其得到广泛应用的主要原因</p>
<ol type="1">
<li><span class="math inline">\(TE_{10}\)</span>模的特点:
<ol type="1">
<li>只有<span class="math inline">\(E_y、H_x、H_z\)</span>三个分量</li>
<li>各分量与y无关，即沿y轴均匀分布</li>
<li>横向场量<span class="math inline">\(E_y,H_x\)</span>与纵向场量<span class="math inline">\(H_z\)</span>在x方向上和z方向上相位相差π/2</li>
</ol></li>
<li>传输特性
<ol type="1">
<li><span class="math inline">\(K_c=\frac{\pi}{a}\quad\lambda_c=\frac{2\pi}{K_c}=2a\)</span></li>
<li><span class="math inline">\(\beta=\frac{2\pi}{\lambda}\sqrt{1-(\lambda/\lambda_c)^2}=\frac{2\pi}{\lambda}\sqrt{1-(\lambda/2a)^2}{}\\\lambda_g=\frac{2\pi}{\beta}=\frac{\lambda}{\sqrt{1-(\lambda/2a)^2}}\)</span></li>
<li><span class="math inline">\(v_p=\frac{w}{\beta}=\frac{v}{\sqrt{1-(\lambda/2a)^2}}\\v_g=\frac{dw}{d\beta}=v\sqrt{1-(\lambda/2a)^2}\)</span></li>
<li><span class="math inline">\(Z_{TE_{10}}=\frac{120\pi}{\sqrt{1-(\lambda/2a)^2}}\)</span></li>
<li>传输功率：<span class="math inline">\(P=\frac{abE_0^2}{480\pi}\sqrt{1-(\lambda/2a)^2}\)</span></li>
<li>功率容量：<span class="math inline">\(P_{br}=6\times10^5\sqrt{1-(\lambda/2a)^2}(W),a,b,\lambda\)</span>单位均为cm</li>
</ol></li>
<li>波导横截面尺寸选择原则
<ol type="1">
<li>主要依据是单模传输：<span class="math inline">\(\lambda_{cTE_{20}}&lt;\lambda&lt;\lambda_cTE_{10},\lambda_{cTE_{01}}&lt;\lambda&lt;\lambda_cTE_{10}\\\therefore \frac{\lambda}{2}&lt;a&lt;\lambda,0&lt;b&lt;\frac{\lambda}{2}\)</span></li>
<li>综合考虑传输功率及损耗的要求一般对于工作于<span class="math inline">\(TE_{10}\)</span>模的矩形波导，取<span class="math inline">\(a\approx0.7\lambda,b\approx(0.3-0.35)\lambda\)</span></li>
</ol></li>
<li>管壁电流 管壁电流波在波导内传播，会在波导壁的内表面上（微米数量级）感应出的高频电流，称为管壁电流,其特点为<strong>两个侧壁的表面电流大小相等，方向相同,上下壁上的电流大小相等，方向相反</strong> <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-30-09-45-14.png"> 该图可用于判断外部器件是否切割表面电流</li>
</ol>
<h2 id="圆波导">圆波导</h2>
<p>圆波导－横截面为圆形的空心金属波导管圆波导。圆波导具有加工方便、双极化、低损耗等优点，也是常用的波导管之一，可用于天线馈线、多路通信和卫星电视，可构成微波谐振腔、旋转式移相器、衰减器、旋转关节、天线辐射器等微波器件</p>
<h3 id="场解及波型-1">场解及波型</h3>
<p>圆波导的求解过程与矩形波导的求解类似，区别在于圆波导中，场量沿r方向按贝塞尔函数规律变化，沿圆周按三角函数变化。</p>
<h4 id="tm波型">TM波型</h4>
<p>对于TM波型，<span class="math inline">\(H_z=0\)</span>,经过运算和贝塞尔函数性质可知，其通过边界条件可导出<span class="math inline">\(K_c=\frac{v_{mn}}{R},v_{mn}\)</span>为m阶贝塞尔函数的第n个根的值，则可得其截止波长为<span class="math inline">\(\lambda_c=\frac{2\pi R}{v_{mn}}\)</span>，其特点如下</p>
<ol type="1">
<li>沿圆周和半径方向均呈纯驻波分布</li>
<li><span class="math inline">\(TM_{m0}\)</span>不存在，所以最低的波型为<span class="math inline">\(TM_{01}\)</span>，它的<span class="math inline">\(λ_c\)</span>最长</li>
<li>m：角向波数，表示场量沿圆周分布的整驻波的个数。n：径向波数，表示场量沿半径分布的半驻波分布个数、或最大值个数</li>
</ol>
<h4 id="te波型">TE波型</h4>
<p>对于TE波型，<span class="math inline">\(E_z=0\)</span>,经过运算和贝塞尔函数性质可知，其通过边界条件可导出<span class="math inline">\(K_c=\frac{\mu_{mn}}{R},\mu_{mn}\)</span>为m阶贝塞尔函数导函数的第n个根的值，则可得其截止波长为<span class="math inline">\(\lambda_c=\frac{2\pi R}{\mu_{mn}}\)</span>，其特点如下</p>
<ol type="1">
<li>沿圆周和半径方向均呈纯驻波分布</li>
<li><span class="math inline">\(TE_{m0}\)</span>不存在，所以最低的波型为<span class="math inline">\(TM_{11}\)</span>，它的<span class="math inline">\(λ_c\)</span>最长</li>
<li>m：角向波数，表示场量沿圆周分布的整驻波的个数。n：径向波数，表示场量沿半径分布的半驻波分布个数、或最大值个数</li>
</ol>
<h3 id="截止波长">截止波长</h3>
<p><span class="math inline">\(\lambda_c=\frac{2\pi}{K_c}=\begin{cases}  \frac{2\pi R}{v_{mn}}(TM)\\  \frac{2\pi R}{\mu_{mn}}(TE) \end{cases}\)</span></p>
<ol type="1">
<li>主模及高次模:圆波导中的主模为<span class="math inline">\(TE_{11},λ_c=3.41R\)</span>,其它的模均为高次模</li>
<li>简并现象
<ul>
<li>模式简并：<span class="math inline">\(\because J_0&#39;(x)=-J_1(x),\therefore \mu_{0n}=v_{1n},TE_{0n},TM_{1n}\)</span>模的<span class="math inline">\(\lambda_c\)</span>相同</li>
<li>因为当<span class="math inline">\(m\neq 0\)</span>时，TM波和TE波每一个模的场有两种分布可能（cos/sin），这种同一模式但具有两种极化的场分布，且<span class="math inline">\(λ_c\)</span>相同，称为极化简并现象。</li>
</ul></li>
</ol>
<h3 id="圆波导中常用的三个模式">圆波导中常用的三个模式</h3>
<ol type="1">
<li><span class="math inline">\(TE_{11}\)</span>:
<ol type="1">
<li>是圆波导中的主模，其<span class="math inline">\(λ_c=3.41R\)</span></li>
<li>在横截面上，其场结构与矩形波导的<span class="math inline">\(TE_{10}\)</span>很相似，故常用矩形波导中TE10通过方-圆接头过渡为圆波导中的<span class="math inline">\(TE_{11}\)</span></li>
<li>有极化简并现象，即在<span class="math inline">\(\psi\)</span>方向场分布有<span class="math inline">\(cosm\psi\)</span>及<span class="math inline">\(sinm\psi\)</span>两种分布的可能,故圆波导长距离传输信号一般不用这种波型，而在旋转式移相器、衰减器、谐振腔等，常采用这种波型</li>
</ol></li>
<li><span class="math inline">\(TE_{01}\)</span>：
<ol type="1">
<li><span class="math inline">\(TE_{01}\)</span>也是圆波导中常用的波型之一，它的场分量只有<span class="math inline">\(E_φ,H_r,H_z,E_r＝E_z＝H_φ＝0\)</span></li>
<li>为圆波导中的高次模， <span class="math inline">\(λ_c=1.64R\)</span></li>
<li>m=0，场结构在横截面上是轴对称的（与<span class="math inline">\(\psi\)</span>无关），所以无极化简并。但是与<span class="math inline">\(TM_{11}\)</span>存在模式简并，又称为E－H简并。故在使用时必须设法抑制低次模及简并模。</li>
<li>该波型在波导内壁的切向磁场只有<span class="math inline">\(H_z\)</span>分量，故内壁上只有圆周方向的(<span class="math inline">\(\psi\)</span>方向)的表面电流，导体损耗小</li>
<li>当传输功率一定时，频率越高，则损耗越小。所以该模式适合作为高Q谐振腔的工作模式，以及用来长距离传输功率信号</li>
</ol></li>
<li><span class="math inline">\(TM_{01}\)</span>：
<ol type="1">
<li><span class="math inline">\(TM_{01}\)</span>场分量只有<span class="math inline">\(H_φ,E_r,E_z,H_r＝H_z＝E_φ＝0\)</span></li>
<li>是横磁模中的最低模式,<span class="math inline">\(λ_c=2.61R\)</span></li>
<li>横截面上的场结构具有轴对称性，即沿<span class="math inline">\(\psi\)</span>向无变化,故无极化简并，也无模式简并，因此常作为雷达天线与馈线的旋转关节中的工作模式。</li>
<li>该波型在内壁表面的切向磁场只有<span class="math inline">\(H_\psi\)</span>分量，只有z方向的管壁电流，因此它可以有效地和轴向流动的电子流交换能量，由此将其应用于微波电子管中的谐振腔及直线电子加速器中的工作模式</li>
</ol></li>
</ol>
<h2 id="同轴线">同轴线</h2>
<p>同轴线的优点：主波型（主模）是TEM波，是无色散波，无频率下限、频带宽，场结构稳定，比双绞线损耗小。</p>
<p>同轴线的缺点：随着频率升高，功率容量下降，导体与介质损耗增加。所以一般只能用于分米波和厘米波的低频段</p>
<h3 id="tem波的传输特性">TEM波的传输特性</h3>
<ol type="1">
<li><span class="math inline">\(K_c=0\Rightarrow\lambda_c=\infty,\beta=K=w\sqrt{\mu\epsilon},\lambda_g=\lambda\\v_p=v_g=v=\frac{1}{\sqrt{\mu\epsilon}},Z_{TEM}=\eta=\sqrt{\frac{\mu}{\epsilon}}\)</span></li>
<li>特性阻抗:<span class="math inline">\(Z_0=\frac{\eta}{2\pi}ln\frac{b}{a}=\frac{60}{\sqrt{\epsilon_r}ln\frac{b}{a}}\)</span></li>
<li>传输功率:<span class="math inline">\(P_{br}=\sqrt{\epsilon_r}\frac{a^2E_0^2}{120}ln\frac{b}{a}(w)\)</span></li>
</ol>
<h3 id="高次模及横向尺寸的选择">高次模及横向尺寸的选择</h3>
<p>当工作波长减少到与同轴线的横向尺寸可以相比拟时，同轴线中会出现高次模,一般不用高次波型传输功率，而采用主模TEM来传输功率。为了做到单模传输，就需要抑制高次模。</p>
<p>同轴线中最低的高次模为<span class="math inline">\(TE_{11}\)</span>，截止波长<span class="math inline">\(λc\approx\pi(b+a)\)</span>所以得到横向尺寸选择的依据</p>
<ol type="1">
<li>保证主模单模工作:<span class="math inline">\(\lambda_{min}&gt;\lambda_cTE_{11}=\pi(b+a),\therefore a+b&lt;\frac{\lambda_{min}}{\pi}\)</span></li>
<li>使传输功率容量最大</li>
</ol>
<h2 id="微带传输线">微带传输线</h2>
<p>上一章介绍了规则金属波导传输系统的传输原理及特性, 这类传输系统具有损耗小、结构牢固、功率容量高及电磁波限定在导管内等优点, 其缺点是比较笨重、高频下批量成本高、 频带较窄等。随着航空、航天以及通信发展的需要, 对微波设备提出了体积要小、重量要轻、 可靠性要高、性能要优越、一致性要好、 成本要低等要求, 这就促成了微波技术与半导体器件及集成电路的结合, 产生了微波集成电路。对微波集成传输元件的基本要求之一就是它必须具有平面型结构, 这样可以通过调整单一平面尺寸来控制其传输特性, 从而实现微波电路的集成化。微带线就是一种微波集成电路中应用最广泛的平面传输线。</p>
<h3 id="微带线">微带线</h3>
<p>微带传输线的基本结构有两种形式: 带状线和微带线 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-21-20-50.png"> 带状线由同轴线演化而来，其流程如下，主要传输的还是TEM波 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-21-22-26.png"> 微带线是由沉积在介质基片上的金属导体带和接地板构成的一个特殊传输系统, 它可以看成由双导体传输线演化而来 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-21-22-11.png"> 由于这种开放式不对称结构导致微带线是一种不均匀介质填充的传输线，可以证明微带中的电磁场必有纵向分量，即在微带线中不能导行TEM波，但是在工作频率较低时，由于微带线基片厚度h远小于微带波长，其纵向分量很小，可以忽略，此时的场结构与TEM模相似，<strong>此时的传输波型为准TEM模。它是微带线的主模。</strong></p>
<h4 id="微带线的特性阻抗">微带线的特性阻抗</h4>
<p>如果微带线是由<span class="math inline">\(\epsilon_r\)</span>的均匀介质包围，则<span class="math inline">\(Z_0^0=\sqrt{\frac{L}{C}}=\frac{1}{v_pC},v_p=\frac{1}{\sqrt{LC}}=\frac{v_0}{\sqrt{\epsilon_r}},\lambda=\frac{v_p}{f}=\frac{\lambda_0}{\sqrt{\epsilon_r}}\)</span></p>
<p>但是微带线实际上是介质与空气的混合介质系统,所以引入等效相对介电常数的概念: <span class="math inline">\(C_0\)</span>--单一空气介质包围的微带线的分布电容,<span class="math inline">\(C_1\)</span>--实际空气+介质填充微带线的分布电容，等效相对介电常数<span class="math inline">\(\epsilon_{re}=\frac{C_1}{C_0}\)</span></p>
<p>即把实际混合介质系统想象成单一的、均匀的相对介电常数<span class="math inline">\(ε_{re}\)</span>的介质构成的系统,所以<span class="math inline">\(Z_0=\frac{Z_0^0}{\sqrt{\epsilon_{re}}}\quad Z_0^0=\frac{1}{v_pC_0},Z_0^0\)</span>为同样形状尺寸下填充介质全部是空气的微带线的特性阻抗</p>
<p>两组实用的工程计算公式</p>
<ol type="1">
<li>假设导体带厚度为零：<span class="math inline">\(\epsilon_{re}\approx \frac{\epsilon_r+1}{2}+\frac{\epsilon_r-1}{2}(1+\frac{10h}{W})^{-1/2}=1+q(\epsilon_r-1),q=\frac{1}{2}[1+(1+\frac{10h}{W})^{-1/2}]:\)</span>填充系数，表示<span class="math inline">\(\epsilon_r&gt;1\)</span>的介质填充程度</li>
<li>导体带厚度不为零时，这时的解法一般是把边缘电容增加的影响等效为导体带的宽度增加了△ω，即此时的导带宽度为<span class="math inline">\(W_e=w+\Delta w,\Delta w\)</span>的工程近似计算公式为 <span class="math display">\[\frac{w}{h}\le\frac{1}{2\pi}:\Delta w=\frac{t}{\pi}(ln\frac{4\pi w}{t}+1)\\\frac{w}{h}\ge\frac{1}{2\pi}:\Delta w=\frac{t}{\pi}(ln\frac{2h}{t}+1)\]</span></li>
</ol>
<p>其他参量：相速度<span class="math inline">\(v_p=\frac{v_0}{\sqrt{\epsilon_{re}}}\quad\lambda_g=\frac{\lambda_0}{\sqrt{\epsilon_{re}}}\leftrightarrow\beta=k_0\sqrt{\epsilon_{re}}\)</span></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>微波技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第三章知识小结</title>
    <url>/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-21-27-51.png"></p>
<ol type="1">
<li>连续傅里叶变换(FT)：连续时间,连续频率的傅里叶变换</li>
<li>傅里叶级数(FS)：连续时间,离散频率的傅里叶变换</li>
<li>序列的傅里叶变换(DTFT):离散时间,连续频率的傅里叶变换</li>
<li>离散傅里叶变换(DFT):离散时间,离散频率的傅里叶变换</li>
</ol>
<p><strong>前三种变换总有一个域不是离散的，计算机不能直接计算；希望的变换：不仅在时间域上离散，在频率域上也离散(DFT)</strong></p>
<span id="more"></span>
<h2 id="离散时间信号级数及其性质dfs">离散时间信号级数及其性质(DFS)</h2>
<h3 id="离散傅里叶级数dfs">离散傅里叶级数(DFS)</h3>
<p>周期序列表示</p>
<p><span class="math display">\[
1.\widetilde{x}(n)=\widetilde{x}(n+kN)\\\widetilde{x}(n)=x((n))_N\\\widetilde{x}(n)=\sum_{r=-\infty}^\infty x(n-rN)
\]</span></p>
<p>其中k,r为任意整数，N-周期，其ZT不收敛</p>
<p>在《信号与线性系统》中，用傅里叶级数表示连续时间周期信号。对应地，可用离散傅里叶级数表示离散周期序列，即用周期为N的复指数序列来表示</p>
<p><span class="math display">\[
\widetilde{x}(n)=\frac{1}{N}\sum_{k=0}^{N-1}\widetilde{X}(k)e^{j\frac{2\pi}{N}kn}
\]</span></p>
<p>两边<span class="math inline">\(\times e^{-j\frac{2\pi}{N}nr}\)</span>并从0-N-1求和并交换左右求和次序得：</p>
<p><span class="math display">\[
\sum_{k=0}^{N-1}\widetilde{x}(n)e^{-j\frac{2\pi}{N}nr}=\widetilde{X}(r)
\]</span></p>
<p>用k置换r 得到</p>
<p><span class="math display">\[
\sum_{k=0}^{N-1}\widetilde{x}(n)e^{-j\frac{2\pi}{N}nk}=\widetilde{X}(k)
\]</span></p>
<p>设<span class="math inline">\(W_N=e^{-j\frac{2\pi}{N}}\)</span>(旋转因子)，可得周期序列的傅里叶级数变换对</p>
<p><span class="math display">\[
\widetilde{x}(n)=IDFS[\widetilde{X}(k)]=\frac{1}{N}\sum_{k=0}^{N-1}\widetilde{X}(k)W_N^{-kn},-\infty&lt;n&lt;\infty\\\widetilde{X}(k)=DFS[\widetilde{x}(n)]=\sum_{k=0}^{N-1}\widetilde{x}(n)W_N^{kn},-\infty&lt;k&lt;\infty
\]</span></p>
<p>注：<span class="math inline">\(\widetilde{x}(n),\widetilde{X}(K)\)</span>都是离散和周期性的,且周期为N,DFS只取k次谐波分量中N个谐波分量；n为离散时间变量，理解为nT；k是离散频率变量，理解为<span class="math inline">\(\Delta wk\)</span>,DFS和IDFS具有唯一性</p>
<h3 id="离散傅里叶级数的性质">离散傅里叶级数的性质</h3>
<ol type="1">
<li><p>线性性</p></li>
<li><p>周期序列的移位： <span class="math display">\[
设DFS[\widetilde{x}(n)]=\widetilde{X}(k),则：DFS[\widetilde{x}(n-m)]=W_N^{mk}\widetilde{X}(k)\\IDFS[\widetilde{X}(k-l)]=W_N^{-nl}\widetilde{x}(n)
\]</span></p></li>
<li><p>周期卷积：设<span class="math inline">\(\widetilde{x_1}(n),\widetilde{x_2}(n)\)</span>都为周期为N的周期序列，且 <span class="math display">\[
\widetilde{X_1}(k)=\sum_{m=0}^{N-1}\widetilde{x_1}(m)W_N^{km},\\\widetilde{X_2}(k)=\sum_{r=0}^{N-1}\widetilde{x_1}(m)W_N^{kr},\\\widetilde{Y}(k)=\widetilde{X_1}(k)\widetilde{X_2}(k),\\则\widetilde{y}(n)=IDFS[\widetilde{X_1}(k)\widetilde{X_2}(k)]=\sum_{m=0}^{N-1}\widetilde{x_1}(m)\widetilde{x_2}(n-m)
\]</span></p>
<p><strong>结论：周期卷积的操作步骤与非周期序列的线性卷积相同，不同的是周期卷积仅在一个周期内求和。周期卷积中<span class="math inline">\(\widetilde{x_1}(m),\widetilde{x_2}(n-m)\)</span>对m是周期性的，周期为N,<span class="math inline">\(\widetilde{y}(n)\)</span>周期为N,且周期卷积满足交换律</strong></p>
<p>同理可得：如果<span class="math inline">\(\widetilde{y}(n)=\widetilde{x_1}(n)\widetilde{x_2}(n)\)</span>,则有<span class="math inline">\(\widetilde{Y}(k)=DFS[\widetilde{x_1}(n)\widetilde{x_2}(n)]=\frac{1}{N}\widetilde{X_1}(k)*\widetilde{X_2}(k)\)</span></p></li>
</ol>
<h2 id="离散傅里叶变换及其性质">离散傅里叶变换及其性质</h2>
<p>有限长序列的Fourier变换称为离散Fourier变换(DFT)，定义方法：由DFS导出DFT。</p>
<ol type="1">
<li>将有限长序列<span class="math inline">\(x(n)\)</span>延拓成周期序列<span class="math inline">\(\widetilde{x}(n)\)</span></li>
<li>求周期序列<span class="math inline">\(\widetilde{x}(n)\)</span>的DFS得<span class="math inline">\(\widetilde{X}(k)\)</span></li>
<li>取出<span class="math inline">\(\widetilde{X}(k)\)</span>的一个周期作为<span class="math inline">\(x(n)\)</span>的DFT <span class="math display">\[
X(k)=\widetilde{X}(k)R_N(k)
\]</span></li>
</ol>
<p>经由上诉步骤可由DFS得出有限长序列的DFT为</p>
<p><span class="math display">\[
x(n)=IDFT[X(k)]=\frac{1}{N}\sum_{k=0}^{N-1}X(k)e^{j\frac{2\pi}{N}kn}=\begin{cases}
   \frac{1}{N}\sum_{k=0}^{N-1}X(k)W_N^{-kn},0\le n\le N-1\\
   0,others
\end{cases}\\
X(k)=DFT[x(n)]=\sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn}=\begin{cases}
   \sum_{n=0}^{N-1}x(n)W_N^{kn},0\le k\le N-1\\
   0,others
\end{cases}
\]</span></p>
<p>注：<span class="math inline">\(x(n),X(K)\)</span>都是有限长的，取值范围为<span class="math inline">\(0\sim N-1\)</span>,n为离散时间变量，理解为nT,k是离散频率变量，理解为<span class="math inline">\(\Delta wk\)</span>,DFT与DFS无本质区别，DFT是DFS的主值，且隐含周期性，具有唯一性。</p>
<h3 id="用矩阵计算n点dft">用矩阵计算N点DFT</h3>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-21-22-17-24.png" style="width:50.0%;height:50.0%"></p>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-21-22-17-54.png" style="width:50.0%;height:50.0%"></p>
<h3 id="dft的性质">DFT的性质</h3>
<p><strong>旋转因子的性质</strong></p>
<ol type="1">
<li>对称性：<span class="math inline">\((W_N^k)^*=W_N^{N-k}\)</span></li>
<li>周期性：<span class="math inline">\(W_N^{k+mN}=W_N^k\)</span></li>
<li>换底：<span class="math inline">\(W_N^k=W_{mN}^{mk}\)</span></li>
</ol>
<p><strong><span class="math inline">\(\frac{N}{2}，\frac{N}{4}\)</span>点DFT为</strong></p>
<p><span class="math display">\[
X(k)=\sum_{n=0}^{N/2-1}x(n)W_{N/2}^{kn},k=0,1,...,N/2-1\\X(k)=\sum_{n=0}^{N/4-1}x(n)W_{N/4}^{kn},k=0,1,...,N/4-1
\]</span></p>
<p><strong>DFT与ZT/FT的关系：有限长序列<span class="math inline">\(x(n)\)</span>的DFT系数<span class="math inline">\(X(k)\)</span>可看作其ZT在单位圆上等角距取样的样本值:<span class="math inline">\(X(k)=X(z)|_{z=W_N^{-k}}\)</span>,有限长序列<span class="math inline">\(x(n)\)</span>的DFT系数<span class="math inline">\(X(k)\)</span>可看作其FT在一个周期<span class="math inline">\(2\pi\)</span>中等间距取样的样本值，取样间隔<span class="math inline">\(\Delta w=\frac{2\pi}{N}:X(k)=X(e^{jw})|_{w=\frac{2\pi}{N}k}=X(e^{j\frac{2\pi}{N}k})\)</span></strong></p>
<p>离散傅立叶变换的性质:</p>
<ol type="1">
<li><p>线性</p></li>
<li><p>复共轭序列的DFT <span class="math inline">\(DFT[x^*(n)]=X^*(N-k),0\le k \le N-1\)</span> 由上式可知 <span class="math display">\[\begin{cases}
   Re[X(k)]=Re[X(N-k)]\\
   Im[X(k)]=-Im[X(N-k)]
\end{cases}\]</span> 进一步可以方便的由一个复序列的DFT求得两个实序列的DFT <span class="math display">\[w(n)=x(n)+jy(n)\\W(k)=X(k)+jY(k)=Re[X(k)]-Im[Y(k)]+j(Im[X(k)]+Re[Y(k)])\\\because x(n)=\frac{1}{2}[w(n)+w^*(n)]\qquad y(n)=\frac{1}{2j}[w(n)-w^*(n)]\\\therefore X(k)=\frac{1}{2}[W(k)+W^*(N-k)]\qquad Y(k)=\frac{1}{2j}[W(k)-W^*(N-k)]\]</span></p></li>
<li><p>对称性</p>
<ul>
<li>有限长共轭对称序列<span class="math inline">\(x_{ep}(n)=x_{ep}^*(N-n)\)</span>,也可称为圆周共轭对称序列。</li>
<li>有限长共轭反对称序列<span class="math inline">\(x_{op}(n)=-x_{op}^*(N-n)\)</span></li>
<li>变换区间：<span class="math inline">\(0\le n \le N-1\)</span>，以n=N/2为对称点</li>
<li>频域定义：共轭对称序列：<span class="math inline">\(X_{ep}(k)=X_{ep}^*(N-k)\)</span>，共轭反对称序列：<span class="math inline">\(X_{op}(k)=-X_{op}^*(N-k)\)</span></li>
<li>序列分解：
<ul>
<li><span class="math inline">\(x_{ep}(n)=\frac{1}{2}[x(n)+x^*(N-n)],x_{op}(n)=\frac{1}{2}[x(n)-x^*(N-n)]\)</span></li>
<li><span class="math inline">\(DFT[jx_i(n)]=X_{op}(k) \quad DFT[x_r(n)]=X_{ep}(k)\\DFT[x_{ep}(n)]=X_R(k) \quad DFT[x_{op}(n)]=jX_I(k)\)</span> <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-14-50-38.png" style="width:50.0%;height:50.0%"></li>
</ul></li>
</ul></li>
<li><p>序列的循环移位:一个序列的循环移位定义为:<span class="math inline">\(y(n)=x((n+m)_N)\cdot R_N(n)\)</span>,序列循环移位后DFT为:<span class="math inline">\(Y(k)=DFT[x((n+m)_N)R_N(n)]=W_N^{-km}X(k)\)</span>,由时域频域的对偶关系，<span class="math inline">\(X(k)\)</span>循环移位时，设<span class="math inline">\(Y(k)=X((k+l))_N\cdot R_N(k)\)</span>,则<span class="math inline">\(y(n)=IDFT[X((k+l))_NR_N(k)]=W_N^{nl}x(n)\)</span> <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-14-54-56.png" style="width:40.0%;height:40.0%"></p></li>
<li><p>循环卷积:对于两个长度均为N的序列<span class="math inline">\(x_1(n),x_2(n)\)</span>,其循环卷积定义为<span class="math inline">\(y(n)=\sum_{m=0}^{N-1}x_1(m)x_2((n-m))_NR_N(n)=\)</span><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-15-01-41.png" style="width:20.0%;height:10.0%"> <strong>特点</strong>：</p>
<ul>
<li>循环卷积的过程与周期卷积一样，只取周期卷积的主值</li>
<li>循环卷积隐含周期性</li>
<li>循环卷积在主值区间内进行，参与卷积的两个序列的长度和结果序列的长度均相等</li>
<li>线性卷积与循环卷积计算步骤比较：
<ul>
<li>线性卷积：反折、平移、相乘、积分(或相加)</li>
<li>循环卷积：反折、周期化、平移、相乘、相加 <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-21-22-19-51.png"></li>
</ul></li>
</ul></li>
</ol>
<h2 id="利用循环卷积计算线性卷积">利用循环卷积计算线性卷积</h2>
<p>循环卷积与线性卷积的对比图 <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-15-05-34.png"></p>
<p>由循环卷积求线性卷积</p>
<ol type="1">
<li>当<span class="math inline">\(L&lt;N+M-1\)</span>其循环卷积的结果与线性卷积不相等，但满足一定关系</li>
<li>当<span class="math inline">\(L\ge N+M-1\)</span>两个长度为M，N的序列的线性卷积可用长度均为L的循环卷积来代替</li>
</ol>
<h2 id="频率取样">频率取样</h2>
<h3 id="序列的几种变换之间的关系">序列的几种变换之间的关系</h3>
<ol type="1">
<li>ZT与FT：<span class="math inline">\(X(z)|_{z=e^{jw}}=X(e^{jw})\)</span> 单位圆上的ZT等于序列的FT</li>
<li>LT与ZT：<span class="math inline">\(X(z)|_{z=e^{sT}}=\hat{X}_a(s)\)</span> S平面-&gt;Z平面：S平面上的宽度为<span class="math inline">\(\frac{2\pi}{T}\)</span>的水平带映射为整个平面，左半带映射到单位圆内，右半带映射成单位圆外，虚轴映射为单位圆</li>
<li>DFT与ZT：<span class="math inline">\(X(k)=X(z)|_{z=W_N^{-k}}\)</span> DFT是ZT在单位圆上等角距<span class="math inline">\(\frac{2\pi}{N}\)</span>取样的样本值</li>
<li>DFT与FT：<span class="math inline">\(X(k)=X(e^{jw})|_{w=\frac{2\pi}{N}k}=X(e^{j\frac{2\pi}{N}k})\)</span>,DFT是FT在一个周期等间距取样值，取样间隔<span class="math inline">\(\Delta w=\frac{2\pi}{N}\)</span></li>
</ol>
<h3 id="从n个取样值恢复xn">从N个取样值恢复<span class="math inline">\(x(n)\)</span></h3>
<p><strong>频域取样是指对时域已是离散，频域仍是连续信号。现在频域上进行抽样处理，使其频域也离散化。</strong></p>
<p>在Z平面的单位圆上对序列的ZT进行等角距取样，将导致时间序列的周期延拓 取样后序列主值序列为<span class="math inline">\(x_N(n)=x_p(n)R_N(n)=[\sum_{r=-\infty}^{\infty}x(n+rM)]R_N(n)\)</span></p>
<p><strong>对于长度为N的有限长序列，ZT取样即频率取样不失真的条件是取样点数M应等于或大于原序列的长度N</strong></p>
<h3 id="从n个取样值恢复xzxejw">从N个取样值恢复<span class="math inline">\(X(z),X(e^{jw})\)</span></h3>
<p>长度为N的序列<span class="math inline">\(x(n)\)</span>的FT<span class="math inline">\(x(e^{jw})\)</span>可通过Z平面单位圆上的N个取样值<span class="math inline">\(x(k)\)</span>，即N个频域取样值来恢复,其中用到了和第二章类似的思路通过内插函数<span class="math inline">\(\phi(z)\)</span>与<span class="math inline">\(x(k)\)</span>相乘恢复</p>
<h2 id="快速傅里叶变换">快速傅里叶变换</h2>
<p>直接计算DFT对于计算机来说运算时间和资源占用非常大，因此本节将介绍两种常用的快速傅里叶变换算法(FFT)来用于DFT计算</p>
<h3 id="时间抽取fft算法">时间抽取FFT算法</h3>
<p>基本出发点：利用<span class="math inline">\(W_N^k\)</span>的周期性和对称性，将DFT的计算分解成一些逐次减小的DFT计算；</p>
<p>分解规则：：（1）对时间进行偶奇分（2）对频率进行前后分。</p>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-16-36-54.png" style="width:60.0%;height:60.0%"></p>
<p>上面时间抽选FFT流图具有三个特点： ① 基本计算单元为一碟形； ② 输入为“混序”排列；输出为正序排列； ③ 具有“同址计算”特性。</p>
<ol type="1">
<li>蝶形计算： 对于任意<span class="math inline">\(N=2^M\)</span>，总可以通过M级分解成2点DFT计算，每次由<span class="math inline">\(\frac{N}{2}\)</span>蝶形计算组成，如下图所示 <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-17-09-25.png" style="width:50.0%;height:50.0%"> 计算方程为 <span class="math display">\[\begin{cases}
   X_{m+1}(p)=X_m(p)+W_N^kX_m(q)\\
   X_{m+1}(q)=X_m(p)-W_N^kX_m(q)
\end{cases}\]</span> 完成一次蝶形运算需要2次复加法和1次复乘法，因为完成<span class="math inline">\(N=2^M\)</span>点的DFT计算需要<span class="math inline">\(log_2N\)</span>级迭代计算，每级<span class="math inline">\(\frac{N}{2}\)</span>个蝶形，蝶形数<span class="math inline">\(\frac{N}{2}log_2N\)</span>，完成N点的时间抽选FFT总计算量为:复乘法次数<span class="math inline">\(\alpha_F=\frac{N}{2}log_2N\)</span>,复加法次数<span class="math inline">\(\beta_F=Nlog_2N\)</span>，直接计算DFT需复乘法次数<span class="math inline">\(\alpha_D=N^2\)</span>,则<span class="math inline">\(\frac{\alpha_F}{\alpha_D}=\frac{log_2N}{2N}\)</span></li>
<li>同址计算： 蝶形计算的好处在于其是一个蝶形计算，输入的运算结果直接送到下一蝶形计算输入保存，中间不需要其他存储器，<strong>节省存储单元，N越大好处越明显</strong></li>
<li>变址计算 从FFT流图可知，输入是混序排列，输出是正序排列，在实际计算中，输入的混序是通过输入正序排列按码位倒置的变址处理得到的，即 <span class="math display">\[x(1)\rightarrow x(001)\Rightarrow x(100)\rightarrow x(4)\]</span> 这样即可实现FFT的同址计算</li>
</ol>
<h3 id="频率抽取fft算法">频率抽取FFT算法</h3>
<p>分解原则：(1)对时间前后分；(2)对频率偶奇分</p>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-16-37-26.png" style="width:60.0%;height:60.0%"></p>
<h3 id="n为合数的fft算法">N为合数的FFT算法</h3>
<p>在前面两小节的讨论中，我们只涉及序列长度<span class="math inline">\(N=2^M\)</span>的FFT算法，本节则将着重讨论如果序列长度<span class="math inline">\(N\neq2^M\)</span>时的处理办法。通常有以下两种处理方法</p>
<ol type="1">
<li>用补零的办法将<span class="math inline">\(x(n)\)</span>延长为<span class="math inline">\(2^M\)</span>，再使用基2FFT算法。由于有限长序列补零以后，只是频谱的取样点有所增加。</li>
<li>采用以任意数为基数的FFT算法。设N等于两个整数p和q的乘积，即<span class="math inline">\(N=p\cdot q\)</span>，则可将N点DFT分解成p个q点DFT或q个p点DFT来计算。</li>
</ol>
<h2 id="fft应用">FFT应用</h2>
<h3 id="利用fft对信号进行谱分析">利用FFT对信号进行谱分析</h3>
<p>所谓谱分析就是计算信号的频谱，包括振幅谱、相位谱和功率谱。设离散时间信号<span class="math inline">\(x(n)\)</span>是从连续时间信号<span class="math inline">\(x_a(t)\)</span>取样得到的，定义参数如下:</p>
<ol type="1">
<li>T-取样周期(s)</li>
<li><span class="math inline">\(f_s\)</span>-取样频率(Hz),<span class="math inline">\(f_s=\frac{1}{T}\)</span></li>
<li><span class="math inline">\(f_0\)</span>-连续时间信号的最高频率(Hz)</li>
<li>F-频率分辨率：指频域取样中两相邻点间的频率间隔(Hz)</li>
<li><span class="math inline">\(t_p\)</span>-信号的最小记录长度(s),<span class="math inline">\(t_p=\frac{1}{F}\)</span></li>
<li>N-一个记录长度中的取样数,<span class="math inline">\(t_p=NT\)</span></li>
</ol>
<p>根据取样定理，为了避免混叠失真，要求</p>
<p><span class="math display">\[
f_s\ge2f_0\quad or \quad T\le \frac{1}{2f_0}
\]</span></p>
<p>最小记录长度为：<span class="math inline">\(t_p=NT=\frac{1}{F}\)</span>，则取样点数N须满足条件<span class="math inline">\(N\ge\frac{2f_0}{F}\)</span></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第五章知识小结</title>
    <url>/2023/11/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%94-%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>由于课程对第五章和第七章要求不高，讲述的知识点不多，所以将其整理到一起。（第七章基本没讲，故直接略过）<strong>注意：第五章前四节的知识点和随机过程讲述的知识点高度重合，故不在此赘述</strong></p>
<span id="more"></span>
<h2 id="相关序列和协方差序列的性质">5.5 相关序列和协方差序列的性质</h2>
<p>设<span class="math inline">\(x_n,y_n\)</span>是两个实平稳随机过程，它们的自相关序列，自协方差序列，互相关序列，互协方差序列为:<span class="math display">\[R_{xx}(m)=E[x_nx_{n+m}]\qquad C_{xx}=E[(x_n-m_x)(x_{n+m}-m_x)]\\R_{xy}(m)=E[x_ny_{n+m}]\qquad C_{xx}=E[(x_n-m_x)(y_{n+m}-m_y)]\]</span></p>
<p>性质1：</p>
<p><span class="math inline">\(C_{xx}(m)=R_{xx}(m)-m_x^2\qquad C_{xy}(m)=R_{xy}(m)-m_xm_y\\when \quad m_x=0\quad m_y=0:C_{xx}(m)=R_{xx}(m)\quad C_{xy}(m)=R_{xy}(m)\)</span></p>
<p>性质2：</p>
<p><span class="math inline">\(C_{xx}(0)=\sigma_x^2\qquad R_{xx}(0)=E[x_n^2]\)</span></p>
<p>性质3：</p>
<p><span class="math inline">\(R_{xx}(m)=R_{xx}(-m)\qquad C_{xx}(m)=C_{xx}(-m)\\R_{xy}(m)=R_{yx}(-m)\qquad C_{xy}(m)=C_{yx}(m)\)</span></p>
<p>性质4：</p>
<p><span class="math inline">\(|R_{xy}(m)|\le (R_{xx}(0)R_{yy}(0))^{1/2}\qquad |C_{xy}(m)|\le (C_{xx}(0)C_{yy}(0))^{1/2}\\特例：|R_{xx}(m)|\le R_{xx}(0)\qquad |C_{xx}(m)|\le C_{xx}(0)\)</span></p>
<p>性质5：若<span class="math inline">\(y_n=x_{n-n_0}\)</span>,则有:<span class="math inline">\(R_{yy}(m)=R_{xx}(m)\qquad C_{yy}(m)=C_{xx}(m)\)</span></p>
<p>性质6：在随机过程中，两随机过程中时间间隔越大，它们的相关性越小<span class="math display">\[\lim_{m \to \infty}C_{xx}(m)=0 \qquad \lim_{m \to \infty}C_{xy}(m)=0 \\ \lim_{m \to \infty}R_{xx}(m)=m_x^2 \qquad \lim_{m \to \infty}R_{xy}(m)=m_xm_y\]</span> <img src="/2023/11/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%94-%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-16-07-13.png"></p>
<h2 id="功率谱">5.6 功率谱</h2>
<h3 id="平稳随机过程的功率谱">平稳随机过程的功率谱</h3>
<p>协方差序列的Z变换称为平稳随机过程的功率谱<span class="math inline">\(S_{xx}(z)\overset{\underset{\mathrm{\Delta}}{}}{=}\sum_{m=-\infty}^\infty C_{xx}(m)z^{-m}\)</span>。在本课程的讨论中，功率谱总是针对于零均值随机信号，则有：<span class="math inline">\(S_{xx}(z)=\sum_{m=-\infty}^\infty R_{xx}(m)z^{-m}\)</span>，功率谱也可以表述为<span class="math inline">\(S_{xx}(e^{jw})=\sum_{m=-\infty}^\infty R_{xx}(m)e^{-jwm}\)</span>。<strong>这两种表述都是等价的</strong>。对于一个实平稳随机过程，<span class="math inline">\(R_{xx}(m)\)</span>的Fourier变换总是存在的,推导可得<span class="math inline">\(E[x_n^2]=\frac{1}{2\pi}\int_{-\pi}^{\pi} S_{xx}(e^{jw})\, {\rm d}w\)</span>。<strong>功率谱在一个周期内的平均值就是随机过程的平均功率</strong>,功率谱的反变换可表述为<span class="math inline">\(R_{xx}(m)=\frac{1}{2\pi j}\oint_{C} S_{xx}(z)z^{m-1}\, \mathrm{d}z=\frac{1}{2\pi}\int_{-\pi}^{\pi} S_{xx}(e^{jw})e^{jmw}\, {\rm d}w\)</span></p>
<h3 id="功率谱的性质">功率谱的性质</h3>
<ol type="1">
<li>实平稳随机过程的功率谱是非负的</li>
<li>实平稳随机过程的功率谱是实函数</li>
<li>实平稳随机过程的功率谱是<span class="math inline">\(w\)</span>的偶函数</li>
</ol>
<h3 id="平稳随机过程的互功率谱">平稳随机过程的互功率谱</h3>
<p>两个平稳随机过程<span class="math inline">\({x_n}\)</span>和<span class="math inline">\({y_n}\)</span>的互功率谱定义为<span class="math display">\[S_{xy}(z)=\sum_{m=-\infty}^\infty R_{xy}(m)z^{-m}\quad S_{xy}(e^{jw})=\sum_{m=-\infty}^\infty R_{xy}(m)e^{-jwm} \]</span>,由上式可得<span class="math inline">\(S_{xy}(e^{jw})=S_{yx}^*(e^{-jw})\)</span></p>
<h2 id="离散随机信号通过线性非移变系统">5.7 离散随机信号通过线性非移变系统</h2>
<p>整个过程可表述为： <span class="math inline">\(y(n)=\sum_{k=-\infty}^\infty h(k)x(n-k)=\sum_{k=-\infty}^\infty h(n-k)x(k)\)</span></p>
<p>其输出的均值可表述为<span class="math inline">\(m_y=m_x \sum_{k=-\infty}^\infty h(k)=m_x H(e^{j0})\)</span></p>
<p>其输出的自相关序列<span class="math inline">\(R_{yy}(m)=\sum_{k=-\infty}^\infty h(k)\sum_{r=-\infty}^\infty h(r)R_{xx}(m-r+k)\)</span>，进一步化简得<span class="math inline">\(R_{yy}(m)=R_{xx}(m)*R_{hh}(m)=R_{xx}(m)*h(m)*h(-m)\)</span>,其中：<span class="math inline">\(R_{hh}(l)=\sum_{k=-\infty}^\infty h(k)h(l+k)=h(l)*h(-l)\)</span>为系统单位冲激响应的自相关序列</p>
<p>其输出的功率谱<span class="math inline">\(S_{yy}(z)=S_{xx}(z)S_{hh}(z)\)</span>,若<span class="math inline">\(h(n)\)</span>为实序列,则<span class="math inline">\(S_{hh}(z)=H(z)H(z^{-1})\)</span>。若<span class="math inline">\(h(n)\)</span>为复序列,则<span class="math inline">\(S_{hh}(z)=H(z)H^*(1/z^*)\)</span></p>
<p>输入输出随机过程的互相关序列<span class="math inline">\(R_{xy}(m)=R_{xx}(m)*h(m)\)</span>,进而可以得到<span class="math inline">\(R_{yy}(m)=R_{xy}(m)*h(-m)\)</span></p>
<p><strong>如果输入是一个零均值的平稳白噪声随机过程，其方差为<span class="math inline">\(\sigma_x^2\)</span>,自相关序列为<span class="math inline">\(R_{xx}(m)=\sigma_x^2\delta(m)\)</span>,功率谱为<span class="math inline">\(S_{xx}(z)=\sigma_x^2\)</span>,根据<span class="math inline">\(R_{yy}(m)=R_{xy}(m)*h(-m)\)</span>有<span class="math inline">\(R_{xy}(m)=\sigma_x^2h(m)\)</span>,对其进行z变换得<span class="math inline">\(S_{xy}(z)=\sigma_x^2H(z)\)</span></strong></p>
<p>输出随机过程的方差:<span class="math inline">\(E[y^2(n)]=R_{yy}(0)=R_{xx}(m)=\\\frac{1}{2\pi j}\oint_{C} S_{yy}(z)z^{-1}\, \mathrm{d}z=\frac{1}{2\pi j}\oint_{C} S_{xx}(z)H(z)H(z^{-1})z^{-1}\, \mathrm{d}z\)</span> 式中的积分围线可选择为单位圆</p>
<p>白噪声<span class="math inline">\(w(n):m_w=0,R_{ww}=\sigma_w^2\delta(m),S_{ww}(z)=\sigma_w^2\qquad S(e^{jw})=\sigma_w^2\)</span></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第二章知识小结</title>
    <url>/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p><strong>本章与信号与系统知识有较多重复，仅记录部分重要的概念</strong></p>
<ol type="1">
<li><p>信号分类</p>
<table>
<thead>
<tr class="header">
<th>时间-幅度</th>
<th>连续</th>
<th>离散</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>连续</td>
<td>模拟</td>
<td>抽样</td>
</tr>
<tr class="even">
<td>离散</td>
<td>量化</td>
<td>数字</td>
</tr>
</tbody>
</table></li>
</ol>
<span id="more"></span>
<h2 id="离散时间信号-序列">离散时间信号-序列</h2>
<h3 id="常见序列">常见序列</h3>
<ol type="1">
<li><p>单位取样序列<span class="math display">\[\delta(n)=\begin{cases}
 1,n=0\\
 0,n\ne0
\end{cases},\delta(n-n_0)=\begin{cases}
 1,n=n_0\\
 0,n\ne n_0
\end{cases}\\
x(n)\delta(n)=x(0)\qquad x(n)\delta(n-n_0)=x(n_0)\\x(n)*\delta(n-n_0)=x(n-n_0)\qquad x(t)\delta(t)=x(0)\delta(t)\]</span></p></li>
<li><p>单位阶跃序列<span class="math display">\[u(n)=\begin{cases}
 1,n\ge0\\
 0,n&lt;0
\end{cases},\delta(n)=u(n)-u(n-1)\\
u(n)=\sum_{k=\infty}^n\delta(k)\quad u(n)=\sum_{k=0}^\infty\delta(n-k)\]</span></p></li>
<li><p>矩形序列<span class="math display">\[R_N(n)=\begin{cases}
 1,0\le n \le N-1\\
 0,others
\end{cases},R_N(n)=u(n)-u(n-N)\]</span></p></li>
<li><p>复指数序列和正弦序列<span class="math display">\[x(n)=e^{(\sigma+jw)n}=e^{\sigma n}cos(wn)+je^{\sigma n}sin(wn),w-数字域频率\\
比较：x_a(t)=Asin(\Omega t+\phi)=Asin(2\pi ft+\phi)\]</span>其中:<span class="math inline">\(\Omega=2\pi f\)</span>模拟域频率，<strong><span class="math inline">\(w=\Omega T(采样周期)\)</span></strong></p></li>
</ol>
<p>当<span class="math inline">\(w=0\)</span>时，<span class="math inline">\(cos(wn)\)</span>变化最慢，当<span class="math inline">\(w=\pi\)</span>时，<span class="math inline">\(cos(wn)\)</span>变化最快，在主值空间<span class="math inline">\([-\pi,\pi]or[0,2\pi]\)</span>上，把<span class="math inline">\(w=0\)</span>附近称为数字低频，<span class="math inline">\(w=\pi\)</span>称为数字高频。<strong>这一特点与模拟正弦信号完全不同，后者<span class="math inline">\(\Omega\)</span>越大，变化越快，因为其连续取值</strong></p>
<h2 id="离散时间系统">离散时间系统</h2>
<h3 id="fir系统和iir系统">FIR系统和IIR系统</h3>
<p>FIR：有限冲激响应，IIR：无限冲激响应 <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-14-21-13-31.png"></p>
<h3 id="离散时间系统的性质">离散时间系统的性质</h3>
<p>在判断离散时间系统性质时，一般用到的都是和信号与系统中已经学到的性质，如线性性，稳定性，因果性这些，主要用到的是因果性，稳定性。因果性和稳定性的判断一般可借助系统函数进行判断，系统函数收敛域包含单位圆即稳定，收敛域到无穷即为因果，在一般判断中，用二者即可，在有些习题中可能不给出时域信号是否是右边信号，只给出<span class="math inline">\(H(z)\)</span>，其判断思路可以参考下面这道例题</p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-09-48-20.png" style="width:70.0%;height:70.0%"></p>
<p>在这道例题中，没给出时域信号是否为右边信号，但根据其在无穷远处仍存在，且极点在单位圆外，可判断其为因果不稳定</p>
<h2 id="离散时间信号和系统的频域表示">离散时间信号和系统的频域表示</h2>
<h3 id="连续信号的ft">连续信号的FT</h3>
<p>重要性质1：当<span class="math inline">\(x(n)\)</span>为实序列时，<span class="math inline">\(X(e^{jw})\)</span>的幅值<span class="math inline">\(|X(e^{jw})|\)</span>在区间<span class="math inline">\(0\le w\le2\pi\)</span>内是偶对称函数，相位 <span class="math inline">\(arg[X(e^{jw})]\)</span> 是奇对称函数</p>
<h3 id="离散时间信号的ft的性质">离散时间信号的FT的性质</h3>
<ol type="1">
<li><p>序列的FT的对称性</p>
<p><span class="math inline">\(x_e(n)=x_e^*(-n)\)</span> 共轭对称序列</p>
<p><span class="math inline">\(x_o(n)=-x_o^*(-n)\)</span> 共轭反对称序列</p>
<p><span class="math inline">\(x_e(e^{jw})=x_e^*(e^{-jw})\)</span> 共轭对称函数</p>
<p><span class="math inline">\(x_o(e^{jw})=-x_o^*(e^{-jw})\)</span> 共轭反对称函数</p>
<p>这表明<span class="math inline">\(x_e(n)\)</span>的实部和<span class="math inline">\(x_o(n)\)</span>的虚部为偶序列，<span class="math inline">\(x_e(n)\)</span>的虚部和<span class="math inline">\(x_o(n)\)</span>的实部为奇序列，进一步推导可以得到以下序列分解公式<span class="math display">\[x_e(n)=\frac{1}{2}[x(n)+x^*(-n)] \qquad x_o(n)=\frac{1}{2}[x(n)-x^*(-n)]\\X_e(e^{jw})=\frac{1}{2}[X(e^{jw})+X^*(e^{-jw})] \qquad X_o(e^{jw})=\frac{1}{2}[X(e^{jw})-X^*(e^{-jw})]\]</span></p>
<p>以及FT的共轭对称性<span class="math display">\[FT[x_r(n)]=X_e(e^{jw}),FT[jx_i(n)]=X_o(e^{jw})\\FT[x_e(n)]=X_R(e^{jw}),FT[x_o(n)]=jX_I(e^{jw})\]</span></p>
<p>当<span class="math inline">\(x(n)\)</span>为实序列时<span class="math display">\[若x(n)为实偶序列，则X(e^{jw})为实偶函数\\若x(n)为实奇序列，则X(e^{jw})为纯虚奇函数\]</span></p></li>
</ol>
<h3 id="离散时间系统的频率响应">离散时间系统的频率响应</h3>
<p>与模拟信号处理中正弦信号和复指数信号具有很重要的作用一样，在数字信号处理中，正弦序列和复指数序列也起着很重要的作用。<strong>这是因为线性非移变系统对正弦序列的稳态响应仍然是正弦序列，频率与输入信号频率相同，而幅度和相位取决于系统特性，具体可表述如下</strong></p>
<p>设<span class="math inline">\(x(n)=e^{jw_0n}\)</span>,则<span class="math inline">\(y(n)=e^{jw_0n}H(e^{jw_0})\)</span>,其中<span class="math inline">\(H(e^{jw_0})\)</span>是系统在<span class="math inline">\(w_0\)</span>处的频率响应</p>
<p>设<span class="math inline">\(x(n)=Acos(w_0n+\phi)\)</span>且<span class="math inline">\(h(n)\)</span>为实序列，则<span class="math inline">\(y(n)=A|H(e^{jw_0})|cos(w_0n+\phi+\theta)\)</span>,其中<span class="math inline">\(H(e^{jw_0})\)</span>是系统在<span class="math inline">\(w_0\)</span>处的频率响应,<span class="math inline">\(\theta=arg[H(e^{jw_0})]\)</span>是系统在<span class="math inline">\(w_0\)</span>处的相位响应</p>
<h2 id="连续时间信号的取样">连续时间信号的取样</h2>
<h3 id="取样信号的时域频域表示">取样信号的时域频域表示</h3>
<p>取样信号为<span class="math inline">\(\hat{x_a}(t)=x_a(t)p(t)=\sum_{n=-\infty}^\infty x_a(t)\delta(t-nT),p(t)=\sum_{n=-\infty}^\infty \delta(t-nT)\)</span>,其频谱则为<span class="math inline">\(\\\hat{X_a}(j\Omega)=FT[x_a(t)p(t)]=\frac{1}{2\pi}X_a(j\Omega)*P(j\Omega)=\frac{1}{T}\sum_{r=-\infty}^\infty X_a(j\Omega-jr\Omega_s)\\P(j\Omega)=\frac{2\pi}{T}\sum_{n=-\infty}^\infty\delta(j\Omega-jr\Omega_s)\)</span></p>
<p><strong>这表明取样信号的频谱就是模拟信号频谱的周期延拓，延拓周期的取样角频率为<span class="math inline">\(\Omega_s\)</span></strong></p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-14-21-56-22.png"></p>
<p><strong>若要不产生混叠，则要求<span class="math inline">\(\Omega_s\ge2\Omega_0,\Omega_s：奈奎斯特频率,\Omega_s/2\)</span>：折叠频率</strong></p>
<h3 id="频率归一化">频率归一化</h3>
<p>频率归一化讨论的是离散时间信号<span class="math inline">\(x(n)\)</span>的频谱<span class="math inline">\(X(e^{jw})\)</span>和取样信号<span class="math inline">\(\hat{x_a}(t)\)</span>的频谱<span class="math inline">\(\hat{X_a}(j\Omega)\)</span>之间的关系</p>
<p>取样信号的频谱为：<span class="math display">\[\hat{X_a}(j\Omega)=FT[\hat{x_a}(t)]=FT[x_a(t)p(t)]=FT[\sum_{n=-\infty}^\infty x_a(t)\delta(t-nT)]\\=\sum_{n=-\infty}^\infty x_a(nT)\cdot FT[\delta(t-nT)]=\sum_{n=-\infty}^\infty x_a(nT)e^{-j\Omega nT}\]</span></p>
<p>而离散时间信号的FT变换为： <span class="math display">\[X(e^{jw})=\sum_{n=-\infty}^\infty x(n)e^{-jwn},when \quad w=\Omega T,X(e^{jw})|_{w=\Omega T}=\sum_{n=-\infty}^\infty x(n)e^{-j\Omega Tn}=\hat{X_a}(j\Omega)\]</span></p>
<p>比较可得出<span class="math display">\[X(e^{jw})|_{w=\Omega T}=\hat{X_a}(j\Omega)=\frac{1}{T}\sum_{r=-\infty}^\infty X_a(j\Omega-jr\Omega_s)\\=\frac{1}{T}\sum_{r=-\infty}^\infty X_a(j\frac{w}{T}-jr\frac{2\pi}{T})\]</span></p>
<p><strong>即在<span class="math inline">\(w=\Omega T\)</span>的条件下，离散时间信号的频谱与取样信号的相等，由于<span class="math inline">\(w=\Omega T=\frac{2\pi f}{f_s}(f_s为取样频率)\)</span>是<span class="math inline">\(f\)</span>对<span class="math inline">\(f_s\)</span>归一化的结果，因此可认为离散时间信号频谱是模拟信号频谱的周期延拓且在频率轴上进行归一化的结果</strong></p>
<h3 id="信号重建">信号重建</h3>
<p>如果取样信号频谱不存在混叠，让取样信号通过一理性低通滤波器，其特性为<span class="math inline">\(H(j\Omega)=\begin{cases}  T,|\Omega|\le\Omega_s/2\\  0,|\Omega|&gt;\Omega_s/2 \end{cases}\)</span>,其频谱特性为<span class="math inline">\(H(j\Omega)\hat{X_a}(j\Omega)=X_a(j\Omega),|\Omega|\le\Omega_s/2\)</span>,输出信号则为<span class="math display">\[x_a(t)=\frac{1}{2\pi}\int_{-\frac{\Omega_s}{2}}^{\frac{\Omega_s}{2}} X_a(j\Omega)e^{j\Omega t}\, {\rm d}\Omega=\sum_{n=-\infty}^\infty x(nT)\cdot S_a(t-nT)\\Sa(t-nT)=\frac{sin[\frac{\pi}{T}(t-NT)]}{\frac{\pi}{T}(t-nT)}为内插函数\]</span><strong>此处积分的详细步骤略过，结论：取样信号经过理想LPF后，完全可以把信号还原，而不损失任何信息，由于插值的唯一性，还原的信号也是唯一的</strong></p>
<h3 id="离散时间信号的取样">离散时间信号的取样</h3>
<p>其思路与连续时间信号取样类似</p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-12-53.png"></p>
<p>其可以看为一个信号调制的过程：<span class="math inline">\(x_p(n)=\sum_{n=-\infty}^\infty x(Nk)\delta(n-kN)\)</span>,频域表示为<span class="math inline">\(X_p(w)=\frac{1}{N}\sum_{n=0}^{N-1}X(w-kw_s),w_s\)</span>为取样频率，且<span class="math inline">\(w_s=\frac{2\pi}{N}\)</span> <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-16-29.png"></p>
<p><strong>为了不发生混叠，取样频率同样需满足<span class="math inline">\(w_s\ge2w_M\)</span></strong></p>
<p>若要恢复序列<span class="math inline">\(x(n)\)</span>，同样可以采用低通滤波器滤波恢复，其频率特性为<span class="math inline">\(H(w)=\begin{cases}  N,|w|\le w_s/2\\  0,|w|&gt; w_s/2 \end{cases}\)</span>,恢复的序列<span class="math inline">\(x_r(n)=\sum_{k=-\infty}^\infty x(kN)\frac{N}{\pi(n-kN)}sin[\frac{w_s}{2}(n-kN)]\)</span></p>
<h3 id="离散时间信号的取样和内插">离散时间信号的取样和内插</h3>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-25-46.png"> <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-26-29.png"></p>
<p>离散时间信号的抽取/减取样：</p>
<p><span class="math inline">\(x_d(n)=x(nN)=x_p(nN)\\FT(x_d(n))=X_d(w)=\sum_{n=-\infty}^\infty x_p(n)e^{-jwn/N}\\=X_p(w/N)=\sum_{n=-\infty}^\infty x_p(nN)e^{-jwn}\)</span></p>
<p><strong>取样序列和抽取序列的频谱只是频率尺度不同，注意，只有对原连续时间信号取样率高于奈奎斯特频率，即进行"过采样"，才允许进一步降低采样率，即进行“减采样”</strong></p>
<p>离散时间信号的内插/增采样：是抽取的逆过程，现在每相邻两个序列之间插入N-1个零值，再用低通滤波器得到内插后序列 <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-28-20.png"></p>
<h2 id="全通系统和最小相位系统">全通系统和最小相位系统</h2>
<ol type="1">
<li>全通系统：全通系统是幅度响应<span class="math inline">\(|H(e^{jw})|\equiv C\)</span>（C为常数）的系统，系统函数:<span class="math inline">\(H_{ap}(z)=\frac{z^{-1}-a^*}{1-az^{-1}}\)</span>（一阶系统）,对于单位取样为实数的多阶系统，有<span class="math inline">\(H_{ap}(z)=A\prod^M_c\frac{z^{-1}-d_k}{1-d_kz^{-1}}\prod^M_r\frac{(z^{-1}-e_k^*)(z^{-1}-e_k)}{(1-e_kz^{-1})(1-e_k^*z^{-1})},|d_k|,|e_k|&lt;1\)</span>,<strong>全通系统的特点是每个极点<span class="math inline">\(z_p\)</span>都有一个与之配对的共轭倒数零点<span class="math inline">\(z_o=\frac{1}{z_p^*}\)</span>,且一阶全通滤波器的相位响应单调递减</strong></li>
<li>最小/大相位系统：系统函数<span class="math inline">\(H_{min}(z)\)</span>所有零极点都在单位圆内/外的系统，对于最小相位系统，存在一个稳定的因果逆系统<span class="math inline">\(H_{min}^{-1}(z)\)</span>,使得<span class="math inline">\(H_{min}(z)H_{min}^{-1}(z)=1\)</span></li>
<li>全通系统与最小相位系统级联：任何系统可表述为一个最小相位系统和一个全通系统级联,<span class="math inline">\(H(z)=H_{min}(z)H_{ap}(z)\)</span></li>
<li>相位延迟与群延迟：数字滤波器的相位延迟：<span class="math inline">\(T_p(w)=-\frac{\phi(w)}{w}\)</span>表示输入是频率为<span class="math inline">\(w\)</span>的单一正弦波的延迟时间，群延迟则定义为<span class="math inline">\(T_g(w)=-\frac{d\phi(w)}{dw}\)</span>表示某一频率<span class="math inline">\(w\)</span>邻域内的延迟性质</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2022/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>首先堆又被称为完全二叉堆，因为它是一种逻辑上基于完全二叉树，物理上基于线性数据结构(如数组，链表等)的数据结构，堆根据其有序性可以被分为两种：大根堆(最大堆)-大根堆在逻辑上二叉树结构中满足根节点&gt;子节点，小根堆(最小堆)-小根堆在逻辑上二叉树结构满足根节点&lt;子节点</p>
<span id="more"></span>
<h1 id="常见应用">常见应用</h1>
<ol type="1">
<li>利用堆的性质找出一个序列中最大最小的元素</li>
<li>堆排序</li>
<li>建立优先级队列，快速获取队列中优先级最高</li>
<li>在n个元素中排出前k大元素的问题，可以建立一个小根堆，依次读入n个元素并调整，当堆的规模达到k+1时，剔除第一个元素，剩下k个较大元素，保持堆的规模不超过k，然后一直循环</li>
</ol>
<h1 id="具体操作">具体操作</h1>
<p>下面介绍的操作以大根堆为例</p>
<h2 id="堆的插入">堆的插入</h2>
<p>每次插入都先将新数据放在数组最后，由于从这个新数据的父节点到根节点必然为一个有序的序列，在插入后，我们需要从下而上依次比较使堆整体有序，比如我们有这样一个堆数组[10,7,2,5,1]，下面我们往这个堆插入16，具体流程图如下 <img src="https://s2.loli.net/2022/04/10/p2vDjPuXJs3iS6M.png" alt="堆示意图.png"></p>
<h2 id="堆的删除">堆的删除</h2>
<p>堆中删除需要把最后一个数据的值赋给根节点，然后再从根节点开始开始从上而下的调整，再从根节点开始进行一次从上向下调整，不断将根节点与其子节点比较调整直到堆恢复有序，下面，我们还是以堆数组[10,7,2,5,1]为例，下面我们删除10，具体流程图如下 <img src="https://s2.loli.net/2022/04/10/AkqT9yxutWCc2LM.png" alt="堆示意图2.png"></p>
<h1 id="堆的实现代码">堆的实现代码</h1>
<p>由于最近在学python，所以使用python代码实现，其他版本请百度,同时，因为最大堆和最小堆实现方式类似，下面我们只给出最大堆代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Array(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Achieve an Array by Python list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, size = 32):</span><br><span class="line">        self._size = size</span><br><span class="line">        self._items = [None] * size</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get items</span><br><span class="line">        :param index: get a value by index</span><br><span class="line">        :return: value</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._items[index]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, index, value):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        set item</span><br><span class="line">        :param index: giving a index you want to teset</span><br><span class="line">        :param value: the value you want to set</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._items[index] = value</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :return: the length of array</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._size</span><br><span class="line"></span><br><span class="line">    def clear(self, value=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        clear the Array</span><br><span class="line">        :param value: set all value to None</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for i in range(self._size):</span><br><span class="line">            self._items[i] = value</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        for item in self._items:</span><br><span class="line">            yield item</span><br><span class="line">          </span><br><span class="line">class MaxHeap(object):</span><br><span class="line">    def __init__(self, maxsize=None):</span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self._elements = Array(maxsize)</span><br><span class="line">        self._count = 0</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return self._count</span><br><span class="line"></span><br><span class="line">    def add(self, value):</span><br><span class="line">        if self._count &gt;= self.maxsize:</span><br><span class="line">            raise Exception(&#x27;full&#x27;)</span><br><span class="line">        self._elements[self._count] = value</span><br><span class="line">        self._count += 1</span><br><span class="line">        self._siftup(self._count-1)  # 维持堆的特性</span><br><span class="line"></span><br><span class="line">    def _siftup(self, ndx):</span><br><span class="line">        if ndx &gt; 0:</span><br><span class="line">            parent = int((ndx-1)/2)</span><br><span class="line">            if self._elements[ndx] &gt; self._elements[parent]:    # 如果插入的值大于 parent，一直交换</span><br><span class="line">                self._elements[ndx], self._elements[parent] = self._elements[parent], self._elements[ndx]</span><br><span class="line">                self._siftup(parent)    # 递归</span><br><span class="line"></span><br><span class="line">    def extract(self):</span><br><span class="line">        if self._count &lt;= 0:</span><br><span class="line">            raise Exception(&#x27;empty&#x27;)</span><br><span class="line">        value = self._elements[0]    # 保存 root 值</span><br><span class="line">        self._count -= 1</span><br><span class="line">        self._elements[0] = self._elements[self._count]    # 最右下的节点放到root后siftDown</span><br><span class="line">        self._siftdown(0)    # 维持堆特性</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def _siftdown(self, ndx):</span><br><span class="line">        left = 2 * ndx + 1</span><br><span class="line">        right = 2 * ndx + 2</span><br><span class="line">        # determine which node contains the larger value</span><br><span class="line">        largest = ndx</span><br><span class="line">        if (left &lt; self._count and     # 有左孩子</span><br><span class="line">                self._elements[left] &gt;= self._elements[largest] and</span><br><span class="line">                self._elements[left] &gt;= self._elements[right]):  # 原书这个地方没写实际上找的未必是largest</span><br><span class="line">            largest = left</span><br><span class="line">        elif right &lt; self._count and self._elements[right] &gt;= self._elements[largest]:</span><br><span class="line">            largest = right</span><br><span class="line">        if largest != ndx:</span><br><span class="line">            self._elements[ndx], self._elements[largest] = self._elements[largest], self._elements[ndx]</span><br><span class="line">            self._siftdown(largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_maxheap():</span><br><span class="line">    import random</span><br><span class="line">    n = 5</span><br><span class="line">    h = MaxHeap(n)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        h.add(i)</span><br><span class="line">    for i in reversed(range(n)):</span><br><span class="line">        assert i == h.extract()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="python中heapq模板">Python中heapq模板</h1>
<p>Python中创建一个堆可以直接使用list的创建方式H = [], 或者使用heapify()函数将一个存在的列表转为堆。</p>
<p>这个模块提供了下面几种堆的操作： heapq.heappush(heap, item) 往堆中插入一个值，同时要保持为最小堆。</p>
<p>heapq.heappop(heap) 返回堆中的最小值，并把它从堆中删除，同时保持为最小堆；如果堆为空，发生 IndexError。直接通过heap[0]可以获取最小值并不从堆中把它删除。</p>
<p>heapq.heappushpop(heap, item) 向堆中插入值后再弹出堆中的最小值，这个函数的速度比直接使用heappush() 和heappop()的效率更加高。</p>
<p>heapq.heapreplace(heap, item) 弹出和返回堆中的最小值再插入一个新的值。堆的大小没有改变。如果堆为空，产生 IndexError。 这一个操作也比直接使用heappush() 和heappop()的效率更加高，尤其适合使用在固定堆大小不变的情况。 与上一个函数相比，这个函数返回的值可能要比将要插入到堆的值大。</p>
<p>heapq.heapify(x) 将一个list转为最小堆，线性时间复杂度，O(n).</p>
<h1 id="重要应用-堆排序">重要应用-堆排序</h1>
<h2 id="简述-1">简述</h2>
<p>堆排序主要分为两个步骤</p>
<ol type="1">
<li>建堆
<ul>
<li>升序：建大堆</li>
<li>降序：建小堆</li>
</ul></li>
<li>利用堆删除的思想来排序，建堆和堆删除中都用到了向下调整，所以关键是要掌握向下调整 下面以升序为例简述下堆排序的流程：</li>
</ol>
<ul>
<li>首先应该建一个大堆，不能直接使用堆来实现，可以将需要排序的数组看作是一个堆，但需要把数组结构变为堆</li>
<li>从堆倒数第二行最右边开始依次往下调整直到调整到堆顶，这样就可以把数组调整成一个堆</li>
<li>然后按照堆删的思想将堆顶域堆底的数据交换，不同的是这里不删除最后一个元素</li>
<li>这样一来最大元素就在最后一个位置，然后从堆顶向下调整到倒数第二个元素，这样次大元素在堆顶，重复到只剩堆顶为止 流程图如下： <img src="https://s2.loli.net/2022/05/18/EewJOgZ5jr32a7p.gif" alt="堆排序示例.gif"></li>
</ul>
<h2 id="实现代码">实现代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 堆排序</span><br><span class="line">void AdjustDown(int* a, int n, int root)//向下调整</span><br><span class="line">&#123;</span><br><span class="line">	assert(a);</span><br><span class="line">	int parent = root;</span><br><span class="line">	int child = parent * 2 + 1;</span><br><span class="line">	while (child &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child])</span><br><span class="line">		&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[child] &gt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			Swap(&amp;a[child], &amp;a[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * 2 + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void HeapSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	assert(a);</span><br><span class="line"> </span><br><span class="line">    //建堆</span><br><span class="line">	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		AdjustDown(a, n, i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //交换</span><br><span class="line">	for (int i = n - 1; i &gt; 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		Swap(&amp;a[i], &amp;a[0]);</span><br><span class="line">		AdjustDown(a, i, 0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体应用">具体应用</h2>
<p>给定数组{33,44,21,8,19,123,46,78,11}如何求解其第一趟堆排序后的结果？ <img src="https://s2.loli.net/2022/05/18/Fad4QHSLjnrvOUE.png" alt="堆排序.png"></p>
<h2 id="总结">总结</h2>
<p>从上面的例子，我们可以看出，其实堆排序就是在树形结构下对父子节点不断进行交换，选出最大的放在堆顶，然后将对堆顶元素与堆底倒数第x个元素交换(x为当前循环趟数)，这样就起到了一趟选出一个剩余数组中最大值并放于剩余数组末尾的目的。它的特点是，一趟排序就能确定一个元素的最终位置，因为用了二叉树结构进行辅助排序，其时间复杂度显然为O(logn)</p>
<h1 id="leetcode例题">leetcode例题</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-product-after-k-increments/">6039-K次增加后的最大乘积</a></p>
<p>参考资料： <a href="https://blog.csdn.net/xiaomucgwlmx/article/details/103522410">OH,CGWLMXUP的博客</a> <a href="https://blog.csdn.net/qq_23869697/article/details/82735088">西檬饭的博客</a> <a href="https://blog.csdn.net/Edward_Asia/article/details/121419975">风继续吹TT的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模笔记</title>
    <url>/2022/12/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数学建模笔记姜启源">数学建模笔记（姜启源）</h1>
<h2 id="线性规划">线性规划</h2>
<ol type="1">
<li>定义： 在一组线性条件限制下，求一线性目标函数最大或最小的问题</li>
<li>标准的matlab形式：<span class="math inline">\(min f^T x,\)</span> <span class="math inline">\(s.t. \begin{cases} A\cdot x \le b\\ Aeq \cdot x = beq \\ lb \le x \le ub \end{cases}\)</span> 其中<span class="math inline">\(f,x,b,beq,lb,u\)</span>为列向量，<span class="math inline">\(A，Aeq\)</span>为矩阵</li>
<li>matlab相关求解命令为 <span class="math inline">\([x,val]=linprog(f,A,b,Aeq,beq,lb,ub)\)</span></li>
</ol>
<span id="more"></span>
<h2 id="整数规划">整数规划</h2>
<ol type="1">
<li>定义： 数学规划中的变量（部分或全部）限制为整数时，称为整数规划</li>
<li>分类： 根据变量整数是部分还是全部可分为纯整数规划和混合整数规划</li>
<li>求解方法：
<ol type="1">
<li>分支定界法（纯或混）</li>
<li>割平面法（纯或混）</li>
<li>隐枚举法（01规划）
<ul>
<li>过滤隐枚举法</li>
<li>分支隐枚举法</li>
</ul></li>
<li>匈牙利法（指派问题）</li>
<li>蒙特卡洛法（各种类型）</li>
</ol></li>
</ol>
<h3 id="型整数规划">0-1型整数规划</h3>
<ol type="1">
<li>定义：整数规划的一种特殊情况，变量仅取值0或1 应用范围可分为以下几种情况</li>
</ol>
<h4 id="相互排斥的约束条件">相互排斥的约束条件</h4>
<p>也就是说题目中的某一种条件只有一个量，如果给了这个1，同类的都为0，较为典型的问题有运输问题，只用一种方式运输，用火车运了，其他的运输栏都为0，其约束条件可进一步简化为 <span class="math inline">\(y_i=\begin{cases} 1,第i个元素起约束作用\\ 0,第i个元素不起作用，i=1,2.....,m\\ \end{cases}\)</span> $a_{i1}x_1+...a_{in}x_nb_i+(1-y_i)M,i=1,2...,m,\ y_1++y_m=1 $ 由约束条件很容易看出，当<span class="math inline">\(y_i\)</span>等于1,就只有这个约束起作用，其他的都是多余的</p>
<h4 id="固定费用的问题">固定费用的问题</h4>
<p>在讨论线性规划时，有些问题要求固定费用，这种问题可以通过改变为混合整数规划来解决，数学模型可表示为 <span class="math inline">\(y_i\epsilon\le x_i\le y_i M\)</span> 其中<span class="math inline">\(\epsilon\)</span>为充分小的正常数；M为充分大的正常数，表明<span class="math inline">\(x_i&gt;0\)</span>时，<span class="math inline">\(y_i\)</span>必须为1，<span class="math inline">\(x_i=0\)</span>时<span class="math inline">\(y_i\)</span>必须为0 <span class="math inline">\(【x_i】\)</span>表示采用i方式生产时产量，<span class="math inline">\(y_i\)</span>表示是否用第i种方式生产</p>
<h4 id="指派问题">指派问题</h4>
<p>指派问题描述的是分配n个人去做n件事情，每个人做且仅做一件事情，且分配第i个人去做第j件事情，花费<span class="math inline">\(C_{ij}\)</span>单位时间，求如何分配使总时间最小，这类问题的关键就是要求出分配矩阵，数学形式可表现为 <span class="math inline">\(x_{ij}=\begin{cases} 1,第i人做第j项工作\\ 0,第i人做第j项工作\\ \end{cases}\)</span> 数学模型为：<span class="math inline">\(min \sum_{i=1}^N \sum_{j=1}^N c_{ij}x_{ij}\)</span> <span class="math inline">\(s.t. \begin{cases}  \sum_{i=1}^N x_{ij}=1,i=1,2,...,n\\  \sum_{j=1}^N x_{ij}=1,j=1,2,...,n\\  x_{ij}=0 or 1,i,j=1,...,n  \end{cases}\)</span></p>
<h3 id="蒙特卡洛法随机取样法">蒙特卡洛法（随机取样法）</h3>
<ol type="1">
<li>又被称为计算机随机模拟法，它是基于对大量数据的统计结果来实现一些确定性问题的计算</li>
<li>使用该方法必须使用计算机生成相关分布的随机数</li>
</ol>
<h3 id="整数线性规划的计算机求解">整数线性规划的计算机求解</h3>
<ol type="1">
<li>整数规划的求解用Lingo等专用软件比较方便，对于整数线性规划也可以用matlab的intlinprog函数求解，<strong>但其的缺点是必须把所有的决策变量化为一维决策变量，变量替换后，约束条件很难写出</strong>，最好用lingo</li>
<li>matlab求解混合整数线性规划的命令是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【x,fval】=intlinprog(f,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> 对应以下数学模型 <span class="math inline">\(min_x f^Tx,\)</span> <span class="math inline">\(s.t. \begin{cases} x(intcon)为整数\\ A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb \le x \le ub \\ \end{cases}\)</span> 式中：<span class="math inline">\(f,x,intcon,b,beq,lb,ub为列向量；A，Aeq为矩阵\)</span></li>
</ol>
<h2 id="非线性规划">非线性规划</h2>
<h3 id="非线性规划模型">非线性规划模型</h3>
<ol type="1">
<li>定义：如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题</li>
<li>通过投资决策问题归纳非线性规划数学模型的一般形式 总资金A元，投资第i个项目花<span class="math inline">\(a_i\)</span>元，预计可收益<span class="math inline">\(b_i\)</span>元 选择最佳投资方案 投资决策变量 <span class="math inline">\(x_i=\begin{cases} 1,决定投资第i个项目\\ 0,决定不投资第i个项目\\ \end{cases}\)</span> 则该模型可用下列数学模型表示 <span class="math inline">\(max\, Q = \frac{\sum_{i=1}^n b_i x_i} {\sum_{i=1}^n a_i x_i} s.t. \begin{cases} 0 &lt; \sum_{i=1}^n a_i x_i \le A ,\\ x_i(1-x_i)=0,i=1,...,n\\ \end{cases}\)</span></li>
<li>根据2中例题，非线性规划问题可进一步概括为： <span class="math inline">\(min\,f(x)\\ s.t. \begin{cases} h_j(x)\le0,j=1,2,...,q\\ g_i(x)=0,i=1,2,...,p\\ \end{cases}\)</span> 其中<span class="math inline">\(x=[x_1,...,x_n]^T\)</span>为模型的决策变量，<span class="math inline">\(f\)</span>为目标函数，<span class="math inline">\(g_i和h_j\)</span>为约束函数，<span class="math inline">\(g_i(x)=0\)</span>为等式约束，<span class="math inline">\(h_j(x)\le0\)</span>为不等式约束</li>
<li>对一个实际问题，要将其规为非线性规划问题时，一般要注意以下几点
<ol type="1">
<li>确定供选方案</li>
<li>提出追求目标</li>
<li>给出价值标准</li>
<li>寻求限制条件</li>
</ol></li>
<li>线性规划与非线性规划的区别：线性规划最优解只能在可行域的边界上达到（特别是顶点），而非线性规划最优解可在可行域任一点达到</li>
<li>非线性规划的matlab表示 <span class="math inline">\(minf(x)\\ s.t. \begin{cases} A\cdot x \le b,\\ Aeq \cdot x=beq,\\ c(x)\le0\\ ceq(x)=0,\\ lb\le x \le ub \end{cases}\)</span> 式中的<span class="math inline">\(f(x)\)</span>为标量函数，<span class="math inline">\(A,b,Aeq,beq,lb,ub\)</span>为相应维数的矩阵和向量，<span class="math inline">\(c(x),ceq(x)\)</span>为非线性向量函数 matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br><span class="line"># x返回决策变量x的取值，fval返回目标函数取值，fun是M文件自定义函数f(x),x0是x的初始值</span><br><span class="line">nonlcon是用M文件定义的c(x)ceq(x)，options定义优化参数</span><br></pre></td></tr></table></figure> ### 无约束问题的Matlab解法</li>
<li>在matlab工具箱中，用于求无约束极小值的函数有fminunc和fminsearch，用法分别为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminunc(fun,x0,options)</span><br><span class="line">[x,fval]=fminsearch(fun,x0,options) #只能求初始值附近的一个极小值点</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="约束极值问题">约束极值问题</h3>
<ol type="1">
<li>定义：带有约束条件的极值问题，也叫规划问题</li>
</ol>
<h4 id="二次规划">二次规划</h4>
<ol type="1">
<li>定义：若某非线性规划的目标函数为自变量x的二次函数，约束条件又全为线性的，称这种规划为二次规划</li>
<li>Matlab中二次规划的数学模型可表述为 $min, x<sup>THx+f</sup>Tx,\ s.t.
<span class="math display">\[\begin{cases}
Ax\le b\\
Aeq \cdot x=beq,\\
lb\le x\le ub
\end{cases}\]</span>
H为实对称矩阵，\ $ matlab求解二次规划的命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="罚函数法">罚函数法</h4>
<ol type="1">
<li>利用罚函数法可以将非线性规划问题的求解转化为求一系列无约束极值的问题，也把这种方法叫做序列无约束最小化技术</li>
<li>罚函数求解非线性规划问题的思想是利用问题中的约束函数作出适当的罚函数，由此构造出带参数的增广目标函数，把问题转换为无约束非线性规划问题，主要有两种形式，一种叫外罚函数法，另一种叫内罚函数法</li>
<li>外罚函数法： 考虑问题：<span class="math inline">\(minf(x)\\ s.t.\begin{cases} g_i(x) \le 0,i=1,...,r\\ h_j(x) \ge 0,j=1,...,s\\ k_m(x) =0,m=1,...,t \end{cases}\)</span>取一个充分大的数M&gt;0,构造函数<span class="math inline">\(P(x,M)=f(x)+M\sum_{i=1}^nmax(g_i(x),0)-M\sum_{j=1}^nmin(h_j(x),0)+M\sum_{m=1}^n |k_m(x)|\)</span>,则以增广目标函数<span class="math inline">\(P(x,M)\)</span>为目标函数的无约束极值问题<span class="math inline">\(minP(x,M)\)</span>的最优解也是原问题的最优解</li>
<li><ol type="1">
<li>如果非线性规划问题要求实时算法，可以使用罚函数算法，但计算精度较低</li>
<li>如果不要求实时算法，要求高精度,可以使用lingo或matlab的fmincon命令求解</li>
</ol></li>
</ol>
<h4 id="matlab求约束极值问题">matlab求约束极值问题</h4>
<ol type="1">
<li>在matlab工具箱中，用于求解约束最优化问题的函数有fminbnd,fmincon,quadprog,fseminf,fminimax函数</li>
<li>fminbnd函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminbnd(fun,x1,x2,options) </span><br><span class="line"># 用于求单变量非线性函数在[x1,x2]上极小值</span><br><span class="line"># 返回极小点x和函数的极小值</span><br></pre></td></tr></table></figure></li>
<li>fseminf函数 用于求下列模型 <span class="math inline">\(minf(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)\le0\\ K_i(x,w_i)\le0,1\le i\le n \end{cases}其中c(x),ceq(x)为向量函数，K_i(x,w_i)为标量函数,w_1...为附加变量\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fseminf(fun,x0,ntheta,seminfcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> fun定义目标函数f(x),x0为x初始值，ntheta是半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>个数，函数seminfcon用于定义非线性不等式约束<span class="math inline">\(c(x)\)</span>,非线性等式约束<span class="math inline">\(ceq(x)\)</span>和半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>的函数，seminfcon有两个输入参量x,s,s是推荐的采样步长 可以不使用</li>
<li>fminimax函数 用于求下列模型 <span class="math inline">\(min_xmax_iF_i(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)=0\\ \end{cases}\)</span> matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminimax(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第四章知识小结</title>
    <url>/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<h3 id="滤波器的分类">滤波器的分类</h3>
<p>经典滤波器从功能上可分为：低通(LP),高通(HP),带通(BP),带阻(BS),且均有AF和DF之分,AF和DF的四种滤波器的理想幅频响应如下图所示： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-50-28.png"> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-50-45.png"></p>
<span id="more"></span>
<h3 id="数字滤波器的技术要求">数字滤波器的技术要求</h3>
<p>数字滤波器的传输函数:<span class="math inline">\(H(e^{jw})=|H(e^{jw})|e^{j\phi(w)}\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-51-38.png"></p>
<p><span class="math inline">\(w_p\)</span>:通带截止频率, <span class="math inline">\(\alpha_p\)</span>:通带允许的最大衰减</p>
<p><span class="math inline">\(w_s\)</span>:阻带截止频率, <span class="math inline">\(\alpha_s\)</span>:阻带允许的最小衰减</p>
<p><span class="math inline">\(w_c\)</span>:3dB通带截止频率，<span class="math inline">\(\delta_1,\delta_2\)</span>：通带、阻带的容限(允许误差)</p>
<p><span class="math inline">\(\alpha_p,\alpha_s\)</span>分别定义为：</p>
<p><span class="math display">\[
\alpha_p=20lg\frac{|H(e^{j0})|}{|H(e^{jw_p})|}\\\alpha_s=20lg\frac{|H(e^{j0})|}{|H(e^{jw_s})|}
\]</span></p>
<h3 id="模拟滤波器的技术要求">模拟滤波器的技术要求</h3>
<p><img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-59-33.png"></p>
<p><span class="math inline">\(\Omega_p\)</span>:通带截止频率, <span class="math inline">\(\alpha_p\)</span>:通带中的最大衰减系数</p>
<p><span class="math inline">\(\Omega_s\)</span>:阻带截止频率, <span class="math inline">\(\alpha_s\)</span>:阻带的最小衰减系数</p>
<p><span class="math inline">\(\Omega_c\)</span>:3dB通带截止频率</p>
<p><span class="math inline">\(\alpha_p,\alpha_s\)</span>分别定义为：</p>
<p><span class="math display">\[
\alpha_p=20lg\frac{|H_a(j0)|}{|H_a(j\Omega_p)|}\\\alpha_s=20lg\frac{|H_a(j0)|}{|H_a(j\Omega_s)|}
\]</span></p>
<p>数字滤波器的三种基本运算的框图表示和流程图表示 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-03-39.png"></p>
<h2 id="iir数字滤波器的基本网络结构">IIR数字滤波器的基本网络结构</h2>
<h3 id="直接i型">直接I型</h3>
<p>系统函数：<span class="math inline">\(H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^M b_k\cdot z^{-k}}{1-\sum_{k=1}^N a_k\cdot z^{-k}}=H_1(z)\cdot H_2(z)\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-08-50.png"> 其中<span class="math inline">\(H_1(z)=\sum_{k=0}^M b_k\cdot z^{-k},H_2(z)=1/[1-\sum_{k=1}^N a_k\cdot z^{-k}]\)</span></p>
<p><strong>直接I型,先实现<span class="math inline">\(H_1(z)\)</span>,再实现<span class="math inline">\(H_2(z)\)</span>,特点：先实现系统函数的零点，再实现极点，需要2N个延迟器和2N个乘法器。</strong></p>
<h3 id="直接ii型">直接II型</h3>
<p><strong>直接II型,先实现<span class="math inline">\(H_2(z)\)</span>,再实现<span class="math inline">\(H_1(z)\)</span>,特点：先实现系统函数的极点，再实现零点，需要N个延迟器和2N个乘法器。</strong> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-12-23.png"></p>
<h3 id="级联型">级联型</h3>
<p>系统函数：<span class="math inline">\(H(z)=A\prod_{k=1}^L \frac{\beta_{0k}+\beta_{1k}\cdot z^{-1}+\beta_{2k}\cdot z^{-2}}{1-\alpha_{1k}\cdot z^{-1}-\alpha_{2k}\cdot z^{-2}}=A\prod_{k=1}^L H_k(z)\)</span>,<span class="math inline">\(H_k(z)\)</span>称为滤波器的二阶基本节。 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-22-55.png"> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-22-36.png"></p>
<p><strong>基本结构：二阶基本节，“田字型”结构。特点：1、二阶基本节搭配灵活，可调换次序；2、可直接控制零极点；3、存储器最少；4、误差较大。</strong></p>
<h3 id="并联型">并联型</h3>
<p>系统函数:<span class="math inline">\(H(z)=c_0+\sum_{k=1}^P \frac{A_k}{1-c_k\cdot z^{-1}}+\sum_{k=1}^Q \frac{\gamma_{0k}+\gamma_{1k}\cdot z^{-1}}{1-\alpha_{1k}\cdot z^{-1}-\alpha_{2k}\cdot z^{-2}}\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-27-07.png"> <strong>基本结构：一阶基本节和二阶基本节。特点：1、可单独调整极点，不能直接控制零点；2、误差小，各基本节的误差不相互影响；3、速度快。</strong></p>
<h2 id="fir数字滤波器的基本网络结构">FIR数字滤波器的基本网络结构</h2>
<p>FIR数字滤波器是一种非递归结构，其冲激响应<span class="math inline">\(h(n)\)</span>是有限长序列</p>
<p><span class="math display">\[
H(z)=\sum_{n=0}^{N-1} h(n)z^{-n}
\]</span></p>
<p>FIR系统仅在<span class="math inline">\(z=0\)</span>处有N-1阶极点，在其它地方没有极点，有(N-1)个零点分布在有限Z平面内的任何位置上。</p>
<h3 id="直接型">直接型</h3>
<p>系统函数:<span class="math inline">\(H(z)=\sum_{n=0}^{N-1}h(n)z^{-n}=h(0)+h(1)z^{-1}+\dots+h(N-1)z^{-(N-1)}\)</span></p>
<p><img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-20-15-13.png"></p>
<p><strong>特点：只含前向通路</strong></p>
<h3 id="级联型-1">级联型</h3>
<p>系统函数:<span class="math inline">\(H(z)=\sum_{k=0}^{N-1}h(n)z^{-k}=\prod_{k=1}^M(\beta_{0k}+\beta_{1k}\cdot z^{-1}+\beta_{2k}\cdot z^{-2}),h(n)\)</span>为实系数 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-20-20-09.png"></p>
<p>特点：1、每一个基本节控制一对零点；2、乘法器较多；3、遇到高阶时<span class="math inline">\(H(z)\)</span>难分解。</p>
<h3 id="快速卷积型">快速卷积型</h3>
<p>已知两个长度为N的序列的线性卷积，可用2N-1点的循环卷积来代替。 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-20-22-02.png"> 特点：能对信号进行高速处理。需要实时处理时采用此结构。</p>
<h3 id="线性相位型">线性相位型</h3>
<ol type="1">
<li>线性相位FIR DF的条件： 单位取样响应<span class="math inline">\(h(n)=\pm h(N-1-n),\)</span>,当N为奇数时，系统的幅度响应和相位响应为<span class="math inline">\(\begin{cases} H(w)=\sum_{n=1}^{N/2}a(n)cos[w(n-\frac{1}{2})]\\ \phi(w)=-w(N-1)/2 \end{cases}\)</span>。<strong>幅度函数<span class="math inline">\(H(w)\)</span>是一个标量函数，可以包括正值和负值;<span class="math inline">\(H(w)\)</span>对<span class="math inline">\(\pi\)</span>呈奇对称。相位特性是严格线性的</strong>。当N为偶数时，系统的幅度响应和相位响应<span class="math inline">\(\begin{cases} H(w)=\sum_{n=1}^{(N-1)/2}b(n)cos[w(n)]\\ \phi(w)=-w(N-1)/2 \end{cases}\)</span>。<strong><span class="math inline">\(H(w)\)</span>对<span class="math inline">\(0,\pi,2\pi\)</span>呈偶对称,相位特性是严格线性的。</strong></li>
<li>线性相位FIR DF系统函数的零点分布 零点分布：两组共轭对<span class="math inline">\(z,\frac{1}{z},z^*,\frac{1}{z^*}\)</span>--要求<span class="math inline">\(h(n)\)</span>为实序列，如果不为实序列，只能确定零点分布为<span class="math inline">\(z,\frac{1}{z}\)</span></li>
<li>线性相位FIR DF系统函数的系数特点 冲激响应为偶对称的线性相位系统函数多项式的系数是镜像对称的,如一个四阶系统<span class="math inline">\(H(z)\)</span>的的形式<span class="math inline">\(a+bz^{-1}+cz^{-2}+bz^{-3}+az^{-4}\)</span></li>
<li>线性相位FIR DF的网络结构 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/当$h(n)=h(N-1-n)$且N为偶数时.png"></li>
</ol>
<h3 id="频率取样型">频率取样型</h3>
<p>上章已证明：长度为N的有限长序列的z变换可用围绕单位圆上的N个等间隔的取样值来表示。即 <span class="math display">\[X(z)=\frac{1-z^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{X(k)}{1-W_N^{-k}\cdot z^{-1}}\]</span> 对FIR系统，其冲激相应<span class="math inline">\(h(n)\)</span>是有限长的（长度为N），根据上述的插值公式，FIR系统的系统函数可表示为： <span class="math display">\[H(z)=\frac{1-z^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{H(k)}{1-W_N^{-k}\cdot z^{-1}}\]</span> 其中<span class="math inline">\(H(k)\)</span>是<span class="math inline">\(h(n)\)</span>的z变换在各点上的取样值，即 <span class="math display">\[H(k)=H(z)|_{z=W_N^{-k}}\]</span> 上式为实现FIR滤波器提供了另一种结构，由两个串联网络组成，即： <span class="math display">\[H(z)=\frac{1}{N}H_1(z)\cdot H_2(z)=\frac{1-z^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{H(k)}{1-W_N^{-k}\cdot z^{-1}}=\frac{1}{N}H_1(z)\cdot \sum_{k=0}^{N-1} H_k(z)\]</span> 其串联网络如下图所示： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-18-57-47.png"> 第一节网络<span class="math inline">\(H_1(z)\)</span>是由N节延迟线组成的梳状滤波器。</p>
<p>相应的差分方程为<span class="math inline">\(y_1(n)=x(n)-x(n-N),H_1(z)\)</span>在单位圆上有N个等分零点，即：<span class="math inline">\(z_k=e^{j\frac{2\pi}{N}k},k=0,1,\dots,N-1\)</span> 其频率响应为：<span class="math inline">\(H_1(e^{jw})=1-e^{-jwN}\)</span>,其流图和幅频特性表示如图： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-19-02-01.png"> 第二个网络<span class="math inline">\(H_2(z)=\sum_{k=0}^{N-1} H_k(z)\)</span>是并联的一阶网络,每个一阶网络<span class="math inline">\(H_k(z)=\frac{H(k)}{1-W_N^{-k}\cdot z^{-1}}\)</span>是一个谐振器,每个一阶网络在单位圆上有一个极点：<span class="math inline">\(z_k=W_N^{-k}\)</span></p>
<p>结论： 1. 由N个谐振器并联的网络有N个极点； 2. 网络对<span class="math inline">\(w=\frac{2\pi}{N},k＝0，1，2，……（N－1）\)</span>的响应为无穷大； 3. 并联谐振器的极点正好各自与梳状滤波器的零点相抵消，从而使这个频率上的响应等于H(k) <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-19-05-35.png"> FIR系统频率取样结构的主要特点是：并联谐振器的系数<span class="math inline">\(H(k)\)</span>就是滤波器在<span class="math inline">\(w=\frac{2\pi}{N}k\)</span>处的响应，因此控制其响应是很直接的。</p>
<p>缺点： 1. 所有的相乘系数都是复数，复数乘法比较麻烦； 2. 所有谐振器的极点均在单位圆上，如果滤波器的系数稍有误差，极点就可能移到单位圆外，系统不容易稳定。</p>
<p>改进： 1. 将谐振器的极点从单位圆向内收缩，使极点处在半径为<span class="math inline">\(r&lt;1\)</span>的圆上，<span class="math inline">\(H(z)=\frac{1-r^Nz^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{H_r(k)}{1-r\cdot W_N^{-k}\cdot z^{-1}}\)</span> 2. 将复数的复乘法运算变成实数相乘，即复一阶网络用实系数的二阶网络来实现</p>
<h2 id="iir数字滤波器的设计方法">IIR数字滤波器的设计方法</h2>
<p>设计步骤：</p>
<ol type="1">
<li>根据实际需要给定滤波器的技术指标。</li>
<li>由技术指标计算滤波器的系统函数<span class="math inline">\(H(z)\)</span>或单位取样响应<span class="math inline">\(h(n)\)</span>，即用一个稳定的因果系统逼近这些指标；</li>
<li>用有限精度的运算实现<span class="math inline">\(H(z)\)</span>或<span class="math inline">\(h(n)\)</span>，包括选择运算结构、进行误差分析和选择存储单元的字长。</li>
</ol>
<p>IIR常用的设计方法：</p>
<ol type="1">
<li>将IIR模拟滤波器映射成数字滤波器 <span class="math inline">\(H(z)=H_a(s)|_{s=m(z)}\)</span>映射函数<span class="math inline">\(s=m(z)\)</span>应具有下列性质：
<ul>
<li>将<span class="math inline">\(s\)</span>平面的虚轴<span class="math inline">\(j\Omega\)</span>映射成z平面上的单位圆周<span class="math inline">\(|z|=1\)</span>,以保持模拟滤波器的幅度响应在映射后不发生失真。</li>
<li>将s平面左半平面映射成z平面单位圆内的内部，以保证稳定的模拟滤波器能够映射成稳定的数字滤波器</li>
<li><span class="math inline">\(m(z)\)</span>是有理函数，将有理函数<span class="math inline">\(H_a(s)\)</span>映射成有理函数<span class="math inline">\(H(z)\)</span></li>
</ul></li>
<li>计算机辅助设计方法</li>
</ol>
<h3 id="冲激响应不变法">冲激响应不变法</h3>
<ol type="1">
<li>使用冲激响应不变法设计数字滤波器的准则 使数字滤波器的单位取样响应与所参照的模拟滤波器的冲激响应的取样值一样，即<span class="math inline">\(h(n)=h_a(nT)\)</span>，复频域:<span class="math inline">\(H(z)|_{z=e^{sT}}=\frac{1}{T}\sum_{r=-\infty}^{\infty}H_a(s-j\frac{2\pi}{T}r)\)</span>。DF与AF的频率特性<span class="math inline">\(H(e^{jw})|_{w=T\Omega}=\frac{1}{T}\sum_{r=-\infty}^{\infty} H_a(j\frac{w}{T}-j\frac{2\pi}{T}r)\)</span> 数字滤波器的频率响应是模拟滤波器频率响应的周期延拓。在冲激响应不变法中，数字滤波器的频率响应产生混迭失真；数字域频率和模拟域频率之间是线性关系,即<span class="math inline">\(w=T\Omega\)</span>频率之间不产生失真,且T在设计中是一个无关紧要的参量，常为了方便取1.<strong>冲激响应不变法最适合可以用部分分式表示的传递函数</strong></li>
<li>冲激响应不变法设计数字滤波器的设计步骤 <span class="math inline">\(H_a(s)-&gt;h_a(t)-&gt;h(n)=h_a(nT)-&gt;H(z)\)</span>
<ol type="1">
<li>假设模拟滤波器的传递函数<span class="math inline">\(H_a(s)\)</span>具有单阶极点，且分母的阶数高于分子的阶数,将<span class="math inline">\(H_a(s)\)</span>展开为部分分式得<span class="math inline">\(H_a(s)=\sum_{k=1}^N \frac{A_k}{s-s_k}\)</span>,<span class="math inline">\(s_k\)</span>为极点，对<span class="math inline">\(H_a(s)\)</span>求laplace变换得：<span class="math inline">\(h_a(t)=\sum_{k=1}^N A_ke^{s_kt}\cdot u(t)\)</span></li>
<li>使用冲激不变法求数字滤波器的冲激响应<span class="math inline">\(h(n)\)</span> 令<span class="math inline">\(t=nT\)</span>,代入上式得<span class="math inline">\(h(n)=h_a(nT)=h_a(t)=\sum_{k=1}^N A_ke^{s_knT}\cdot u(nT)\)</span></li>
<li>求<span class="math inline">\(h(n)\)</span>的z变换得<span class="math inline">\(H(z)=Z[h(n)]=\sum_{n=0}^\infty[\sum_{k=1}^N A_ke^{s_knT}\cdot ]z^{-n}=\sum_{k=1}^N \frac{A_k}{1-e^{s_kT}z^{-1}}\)</span></li>
</ol></li>
<li>冲激响应不变法的应用范围:能够设计的滤波器：LP、BP；</li>
</ol>
<h3 id="双线性变换法">双线性变换法</h3>
<ol type="1">
<li>双线性变换法设计数字滤波器 双线性变换法是一种s平面到z平面的映射过程，定义为<span class="math inline">\(s=\frac{2}{T}\cdot\frac{1-z^{-1}}{1+z^{-1}}\)</span>,故有<span class="math inline">\(H(z)=H_a(s)|_{s=\frac{2}{T}\cdot\frac{1-z^{-1}}{1+z^{-1}}}=H_a(\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}})\)</span> 将<span class="math inline">\(z=e^{jw}\)</span>和<span class="math inline">\(s=j\Omega\)</span>带入得<span class="math inline">\(s=\frac{2}{T}\cdot \frac{1-z^{-1}}{1+z^{-1}}:j\Omega=\frac{2}{T}\cdot\frac{1-e^{-jw}}{1+e^{jw}}=\frac{2}{T}\cdot jtan(w/2)\)</span>,即<span class="math inline">\(w=2arctan(\frac{T\Omega}{2})\)</span>
<ol type="1">
<li>数字域频率和模拟域频率之间是非线性关系,当<span class="math inline">\(\Omega\)</span>从<span class="math inline">\(0-&gt;+\infty,w:0-&gt;\pi\)</span>。即：AF的全部频率特性，被压缩成等效于DF在频率<span class="math inline">\(0&lt;w&lt;\pi\)</span>之间的特性。</li>
<li>幅度上无混迭失真。双线性变换的频率标度的非线性失真可以通过预畸变的方法来补偿。设所求的数字滤波器的通带和阻带的截止频率分别为<span class="math inline">\(w_p\)</span>和<span class="math inline">\(w_s\)</span>,则</li>
</ol>
<span class="math display">\[
\begin{cases}
   \Omega_p=\frac{2}{T}tg(\frac{w_p}{2})\\
   \Omega_s=\frac{2}{T}tg(\frac{w_s}{2})
\end{cases}\]</span>模拟滤波器就按这两个预畸变了的频率<span class="math inline">\(\Omega_s\)</span>和<span class="math inline">\(\Omega_s\)</span>来设计。双线性变换是一种稳定的变换。令<span class="math inline">\(s=\sigma+j\Omega\)</span>,得<span class="math inline">\(|z|=\sqrt{\frac{(1+\frac{\sigma T}{2})^2+(\frac{\Omega T}{2})^2}{(1-\frac{\sigma T}{2})^2+(\frac{\Omega T}{2})^2}}\)</span>
<ol type="1">
<li>双线性变换是简单映射；</li>
<li>双线性变换是稳定的变换；即模拟滤波器在s平面左半平面的所有极点经映射后均在z平面的单位圆内。</li>
</ol></li>
<li>双线性变换法设计数字滤波器的设计步骤 模拟低通滤波器-&gt;双线性变换映射成数字低通滤波器-&gt;数字低通滤波器的频率响应。</li>
<li>双线性变换法的应用范围：能够设计的滤波器－LP、HP、BP、BS。</li>
<li>冲激响应不变法和双线性变换法比较：
<ul>
<li>相同点：首先设计AF，再将AF转换为DF。</li>
<li>不同点：冲激响应不变法幅频响应有失真 频率之间呈线性 双线性变换法幅频响应无混迭 频率之间非线性</li>
</ul></li>
</ol>
<h3 id="数字butterworth滤波器">数字Butterworth滤波器</h3>
<ol type="1">
<li><p>模拟Butterworth滤波器的幅度平方函数 模拟Butterworth滤波器的幅度平方函数:<span class="math inline">\(|H_a(j\Omega)|^2=\frac{1}{1+(\Omega/\Omega_c)^{2N}}\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-10-08-54.png"> 特点：通带内幅度响应最平坦；通带和阻带内幅度特性单调下降；N增大，通带和阻带的近似性越好，过渡带越窄；存在极点，零点在<span class="math inline">\(\infty\)</span> 。</p>
<p>Butterworth滤波器极点分布特点:</p>
<p>令<span class="math inline">\(s=j\Omega\)</span>,则幅度平方函数为<span class="math inline">\(H_a(s)H_a(-s)=\frac{1}{1+(s/{j\Omega_c})^{2N}}\)</span>,令分母为0，则<span class="math inline">\(s_k=\Omega_ce^{j(\frac{\pi}{2N}+\frac{\pi}{2}+\frac{k\pi}{N})},k=0,1,\dots,(2N-1)\)</span></p>
<p>在s平面上共有2N个极点等角距地分布在半径为<span class="math inline">\(\Omega_c\)</span>的圆上；极点对称于虚轴，虚轴上无极点；N为奇数，实轴上两个极点；N为偶数，实轴上无极点；各极点间的角度为<span class="math inline">\(\frac{\pi}{N}\)</span></p></li>
<li><p>根据滤波器的指标求模拟滤波器的系统函数</p>
<p>N为偶数时：模拟Butterworth滤波器的传递函数为 <span class="math display">\[H_a(s)=\frac{\Omega_c^N}{\prod_{k=1}^{N/2}(s-s_k)(s-s_k^*)}\]</span> <span class="math inline">\(s_k\)</span>为左半平面极点，<span class="math inline">\(s_k^*\)</span>为<span class="math inline">\(s_k\)</span>的共轭极点，<span class="math inline">\(s_p\)</span>为实轴上的极点 N为奇数时：<span class="math display">\[H_a(s)=\frac{\Omega_c^N}{(s-s_p)\prod_{k=1}^{N/2-1}(s-s_k)(s-s_k^*)}\]</span></p></li>
<li><p>设计数字Butterworth滤波器的步骤</p>
<ol type="1">
<li>根据实际需要规定滤波器在数字临界频率<span class="math inline">\(w_p\)</span>和<span class="math inline">\(w_T\)</span>处的衰减 (单位为分贝)</li>
<li>确定模拟Butterworth滤波器的阶数N和截止频率<span class="math inline">\(\Omega_c\)</span></li>
<li>求模拟Butterworth滤波器的极点，并由s平面左半平面的极点构成传递函数<span class="math inline">\(H_a(s)\)</span></li>
<li>使用冲激不变法或双线性变换法将<span class="math inline">\(H_a(s)\)</span>转换成数字滤波器的系统函数<span class="math inline">\(H(z)\)</span></li>
</ol></li>
</ol>
<h2 id="iir数字滤波器的频率变换">IIR数字滤波器的频率变换</h2>
<ol type="1">
<li>设<span class="math inline">\(H(v)\)</span>是数字原型低通滤波器的系统函数，<span class="math inline">\(H_d(z)\)</span>是所要求的滤波器（LP、HP、BP、BS）的系统函数。为了将稳定、因果的<span class="math inline">\(H(v)\)</span>变换成稳定、因果的<span class="math inline">\(H_d(z)\)</span>，要求：
<ol type="1">
<li>v平面到z平面的映射<span class="math inline">\(v^{-1}=F(z^{-1})\)</span>是<span class="math inline">\(z^{-1}\)</span>的有理函数；</li>
<li>v平面的单位圆内部映射成z平面的单位圆内部。</li>
</ol></li>
<li>频率变换的设计公式
<ul>
<li>LP-&gt;LP:<span class="math inline">\(w_p\)</span>要求的截止频率 <span class="math display">\[v^{-1}=\frac{z^{-1}-\alpha}{1-\alpha z^{-1}}\qquad\alpha=\frac{sin(\frac{\theta_p-w_p}{2})}{sin(\frac{\theta_p+w_p}{2})}\]</span></li>
<li>LP-&gt;HP:<span class="math inline">\(w_p\)</span>要求的截止频率 <span class="math display">\[v^{-1}=-\frac{z^{-1}+\alpha}{1+\alpha z^{-1}}\qquad\alpha=\frac{cos(\frac{\theta_p+w_p}{2})}{cos(\frac{\theta_p-w_p}{2})}\]</span></li>
<li>LP-&gt;BP：<span class="math inline">\(w_1,w_2\)</span>要求的上、下截止频率 <span class="math display">\[v^{-1}=-\frac{z^{-2}-\frac{2\alpha k}{k+1}z^{-1}+\frac{k-1}{k+1}}{\frac{k-1}{k+1}z^{-2}-\frac{2\alpha k}{k+1}z^{-1}+1}\qquad\alpha=\frac{cos(\frac{w_1+w_2}{2})}{cos(\frac{w_1-w_2}{2})}\qquad k=ctg(\frac{w_2-w_1}{2})tg(\frac{\theta_p}{2})\]</span></li>
<li>LP-&gt;BS：<span class="math inline">\(w_1,w_2\)</span>要求的上、下截止频率 <span class="math display">\[v^{-1}=\frac{z^{-2}-\frac{2\alpha}{k+1}z^{-1}+\frac{1-k}{k+1}}{\frac{1-k}{k+1}z^{-2}-\frac{2\alpha}{k+1}z^{-1}+1}\qquad\alpha=\frac{cos(\frac{w_1+w_2}{2})}{cos(\frac{w_1-w_2}{2})}\qquad k=tg(\frac{w_2-w_1}{2})tg(\frac{\theta_p}{2})\]</span></li>
</ul></li>
</ol>
<h2 id="fir数字滤波器的设计方法">FIR数字滤波器的设计方法</h2>
<p>基本特性: 1. FIR滤波器永远是稳定的（极点均位于原点）； 2. FIR滤波器的冲激响应<span class="math inline">\(h(n)\)</span>是有限长序列； 3. FIR滤波器的系统函数<span class="math inline">\(H(z)\)</span>为多项式； 4. FIR滤波器具有线性相位。 设计的基本方法： 窗函数法，频率抽样法和等波纹逼近法等。</p>
<h3 id="窗函数法">窗函数法</h3>
<ol type="1">
<li><p>窗函数法原理 将理想低通滤波器（LPF）无限长单位取样响应序列<span class="math inline">\(h_d(n)\)</span>截断。（等效于加矩形窗），用得到的有限长序列逼近理想低通滤波器。 特点：理想低通滤波器的冲激响应序列<span class="math inline">\(h_d(n)\)</span>无限长，非因果，不绝对可和。理想LPF是不稳定的，也是不可实现的。可以对理想LPF进行逼近：截断无限长时间冲激响应序列得到一个有限长序列。即：用有限长的冲激响应序列<span class="math inline">\(h(n)\)</span>来逼近无限长的冲激响应序列<span class="math inline">\(h_d(n)\)</span>,<span class="math inline">\(h(n)\)</span>应满足FIR滤波器的基本条件。应为偶对称或奇对称以满足线性相位的条件。应为因果序列。 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-11-14-17.png"> 其中<span class="math inline">\(w_R(n)=\begin{cases}  1,0\le n\le N-1\\  0,else \end{cases}\)</span>--窗函数（矩形窗），其频谱为<span class="math inline">\(H(e^{jw})=\frac{1}{2\pi}H_d(e^{jw})*W(e^{jw})\)</span> 结论：</p>
<ol type="1">
<li>FIR数字滤波器的频谱是理想LPF的频谱与窗函数频谱的卷积；</li>
<li>采用不同的窗函数， <span class="math inline">\(H(e^{jw})\)</span>就有不同的形状 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-11-18-21.png"> 由理想LPF的时间函数加窗后得到的FIR滤波器的幅度函数是理想LPF的幅度函数与窗函数幅度函数的周期卷积,其具体过程如下： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-11-19-15.png"></li>
</ol></li>
<li><p>加窗的影响 理想LPF加窗后：使滤波器的频率响应在不连续点出现了过渡带，它主要是由窗函数频谱的主瓣引起的，其宽度取决于主瓣的宽度。而主瓣的宽度<span class="math inline">\(\Delta w=\frac{4\pi}{N}\)</span>。与滤波器的阶数N成反比。使滤波器在通带和阻带产生了一些起伏振荡的波纹—吉布斯现象，主要由旁瓣造成。</p>
<p>在一般情况下，对窗函数的要求是：(1)尽量减少窗函数频谱的旁瓣高度，使能量集中在主瓣，减少通带/阻带中的波纹。(2)主瓣的宽度尽量窄，获得较陡的过渡带。以上两条标准相矛盾，为了达到上述要求，采取的措施为：采用不同的窗函数。采用窗函数法设计出来的FIR数字低通滤波器的频率响应，它对理想低通滤波器的频率响应的逼近程度，取决于窗函数的频谱的主瓣宽度和旁瓣衰减的大小。</p></li>
<li><p>几种常用的窗函数 Bartlett窗。Hanning窗。Blackman窗。Hamming窗。Kaiser窗</p></li>
<li><p>窗函数的一般性质 窗函数的宽度N越大，窗函数的频谱的主瓣越窄，因而过渡带也越窄。窗函数的频谱的最大旁瓣高度和阻带最小衰减只取决于窗函数的种类，与窗函数的宽度N无关。</p></li>
<li><p>对窗函数的要求 为减小通带和阻带中的波纹幅度，应选择最大旁瓣高度尽可能小的窗函数，这将使更多的能量集中于主瓣内。为获得尽可能窄的过渡带，应选择主瓣宽度尽量窄的窗函数。</p></li>
<li><p>用窗函数法设计FIR数字滤波器的步骤</p>
<ol type="1">
<li>给出希望设计的滤波器的频率响应函数<span class="math inline">\(H_d(e^{jw})\)</span></li>
<li>根据允许的过渡带宽度和阻带衰减，选择窗函数和它的宽度N</li>
<li>计算希望设计的滤波器的单位取样响应<span class="math inline">\(h_d(n)\)</span></li>
<li>计算FIR数字滤波器的单位取样响应<span class="math inline">\(h(n)=h_d(n)w(n)\)</span></li>
<li>计算FIR数字滤波器的频率响应，验证是否达到所要求的指标</li>
<li>计算幅度响应和相位响应</li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树(Prim算法，Kruskcal算法)</title>
    <url>/2022/05/11/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最小生成树由一个经典的架电线的问题引出：在n个村庄间架电线，现在已经知道各村庄的相对距离，如果你是工程师，请问如何设计能使得总造价最小</p>
<h2 id="解决思路">解决思路</h2>
<p>首先可以分析得到这显然是一个带权值的图，即网结构，我们的目标可以抽象为用n-1条边把一个连通图连接起来，并使得权值最小，这就是我们常说的最小生成树问题，最经典的两种算法是：prim算法和kruskcal算法，下文将一一介绍 <img src="https://s2.loli.net/2022/05/12/9SoUqmLdXEpjTGz.png" alt="最小生成树.png"></p>
<span id="more"></span>
<h2 id="prim算法">prim算法</h2>
<h3 id="算法思路">算法思路</h3>
<p><strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，因为这里涉及到顶点与顶点的带权值边信息，所以我们考虑使用邻接矩阵作为储存结构来实现，如果不清楚邻接矩阵，请戳<a href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> <img src="https://s2.loli.net/2022/05/12/4B8ck6RtxqHmw9u.png" alt="最小生成树-邻接矩阵.png"> 这样一来，我们已经有了一个以邻接矩阵为存储结构的网，我们下面该如何求最小生成树呢?其实很简单，我们在prim算法的开头就说过，<strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，我们就先去一个顶点来研究，默认为v0，然后把v0在邻接矩阵中所对应的那一行信息取出(用一个lowcost数组保存)，目的是研究以v0为起点，与其相连最近的顶点。然后我们遍历一遍lowcost数组，找到其数组中除了本节点(即v0-0)外的最小值，记录下它的值与下标-<em>此时的low cost数组中lowcost[0]=0,表示该位置对应节点已加入最小生成树</em>，连接该下标所对应的顶点与v0，构成第一条电线，在这里对应的是v1，在找到v1后，我们把lowcost该位置的值设为0，表示该节点已经被纳入了最小生成树，然后我们再去取出v1在邻接矩阵中对应行的信息，将其与lowcost数组的对应值相比较，若更小则修改lowcost值，<strong>该操作的目的是找到v0,v1这两行连接信息中的最小值来形成第二根电线</strong>，接下来的操作也和上面的操作类似了，直到所有节点都添加到最小生成树中，lowcost数组全部置为0，表明最小生成树生成完毕。</p>
<h3 id="实现代码">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Prim算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree_Prim(MGraph G)&#123;</span><br><span class="line">	int min, i, j, k;</span><br><span class="line">	int adjvex[MAXVEX];	//保存相关顶点下标</span><br><span class="line">	int lowcost[MAXVEX];	//保存相关顶点间边的权值</span><br><span class="line">	lowcast[0] = 0;	//初始化第一个权值为0，即v0加入生成树，lowcost的值为0，在这里就是此下标的顶点已经加入生成树</span><br><span class="line">	adjvex[0] = 0;	//初始化第一个顶点下标为0</span><br><span class="line">	for(i = 1;i&lt;G.numVertexes;i++)&#123;	//循环除下标为0外的全部顶点</span><br><span class="line">		lowcost[i] = G.arc[0][i];		//将v0顶点与之有边的权值存入数组</span><br><span class="line">		adjvex[i] = 0;	//初始化都为v0的下标</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=1;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">		min = INFINITY;	//初始化最小权值为无穷大，通常设置为很大的数字</span><br><span class="line">		j = 1;</span><br><span class="line">		k = 0;</span><br><span class="line">		while(j&lt;G.numVertexes)&#123;		//循环全部顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min)&#123;	//如果权值不为0且权值小于min</span><br><span class="line">				min = lowcost[j];		//让当前权值成为最小值</span><br><span class="line">				k = j;		//将当前最小值的下标存入k</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;(%d,%d)&quot;,adjvex[k],k);	//打印当前顶点边中权值最小边</span><br><span class="line">		lowcost[k] = 0;	//将当前顶点的权值设置为0，表示此顶点已经完成任务</span><br><span class="line">		for(j=1;j&lt;G.numVertexes;j++)&#123;	//循环所有顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;	//若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值</span><br><span class="line">				lowcost[j] = G.arc[k][j];		//将较小权值存入lowcost</span><br><span class="line">				adjvex[j] = k;	//将下标为k的顶点存入adjvex</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由算法代码中的循环嵌套可知该算法时间复杂度为O(<span class="math inline">\(n^2\)</span>)</p>
<h2 id="kruskal算法">Kruskal算法</h2>
<h3 id="算法思路-1">算法思路</h3>
<p>与prim算法不同的是，prim算法以顶点为目标构造最小生成树，而Kruskal算法直接以边的目标去构造，每次找最小权值的边来构成最小生成树，但是，<strong>因为我们在构建时是以边为目标，必须要考虑边的闭环问题,因为可能出现要铺设九个村庄的电线，但在三个村庄间就出现了闭环，导致存在环与环之间无法互联的现象，这个问题出现的原因是因为我们如果只研究边的权值大小，会忽略顶点与顶点互联的要求</strong>，因为是对边的权值大小直接进行研究，这里我们最好使用边集数组作为存储结构，不会请戳<a href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> 这里我们需要先将边集数组按照权值从小到大进行下转换。 <img src="https://s2.loli.net/2022/05/12/n4ofahW37AziSxJ.png" alt="最小生成树-边集数组.png"> 我们对边集数组做循环遍历，每当你要添加一个边时，必须先调用一个find函数来判断该边对应的起点和终点在当前的最小生成树数组中是否会构成闭环，如果会，则舍弃接着往后，不会则添加，这个find函数借助了一个parent数组，我们将其初始化为0，每当添加一条边，就将对应起点的parent数组值修改为该边的终点，然后find函数判断连线顶点的尾部下标，如果和原来尾部对应下标经find函数处理返回值一致，说明形成了环，舍弃该边</p>
<h3 id="实现代码-1">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* kruskal算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree(MGraph G)&#123;	//生成最小生成树</span><br><span class="line">	int i, n, m;</span><br><span class="line">	Edge edges[MAXEDGE];	//定义边集数组</span><br><span class="line">	int parent[MAXVEX];	//定义一数组用来判断边与边是否形成环路</span><br><span class="line">	/* 此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码 */</span><br><span class="line">	for(i = 0;i&lt;G.numVertexes;i++)</span><br><span class="line">		parent[i] = 0;	//初始化数组值为0</span><br><span class="line">	for(i = 0;i&lt;G.numEdges;i++)&#123;	//循环每一条边</span><br><span class="line">		n = Find(parent, edges[i].begin);</span><br><span class="line">		m = Find(parent, edges[i].end);</span><br><span class="line">		if(n != m)&#123;		//假如n与m不等，说明此边没有与现有生成树形成环路</span><br><span class="line">			parent[n] = m;	//将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中</span><br><span class="line">			printf(&quot;(%d,%d) %d&quot;, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int* parent, int f)&#123;	//查找连线顶点的尾部下标</span><br><span class="line">	while(parent[f] &gt; 0)</span><br><span class="line">		f = parent[f];</span><br><span class="line">	return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为O(eloge),e为边数</p>
<h2 id="总结">总结</h2>
<p>对比两个算法来说，Kruskcal算法主要针对边来展开，边数少的时候效率会非常高，对于稀疏图有很大的优势，而Prim算法对于稠密图，边上非常多的情况会更好一些(个人认为是因为边数少是Kruskcal出现闭环的可能性小，在这种情况下，其效率会比Prim算法高很多，然后边数多了以后，出现闭环的可能性大大增加，导致其效率反而不如Prim算法了)</p>
<h2 id="参考资料">参考资料</h2>
<p>《大话数据结构》程杰</p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>次优查找树</title>
    <url>/2022/05/03/%E6%AC%A1%E4%BC%98%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="次优查找树">次优查找树</h1>
<h2 id="前言">前言</h2>
<p>关于静态查找表中对特定关键字进行顺序查找，折半查找或者分块查找，都是在查找表中各关键词被查找概率相同的前提下进行的，然而在查找表中各关键字查找概率不同的情况下，折半查找的效果其实是不好的。在查找成功的情况下，描述查找过程的判定树其带权路径长度之和（用PH表示）最小时，查找性能最优，称该二叉树为静态最优查找树 其中: PH = 所有节点所在的层次数*每个节点对应的概率值 由于构造最优查找树花费的时间代价较高，而且有一种构造方式创建的判定树的查找性能同最优查找树只差1%-2%，称这种极度接近于最优查找树的二叉树为次优查找树</p>
<span id="more"></span>
<h2 id="创建方法">创建方法</h2>
<p>首先取出标准每个关键字及其对应的权值，采用如下公式计算出每个关键字对应的一个值： <span class="math inline">\(\triangle P_i= \left|\sum\limits_{j=i+1}^hw_j-\sum\limits_{j=1}^{i-1}w_j\right|\)</span> 其中 wj 表示每个关键字的权值（被查找到的概率），h 表示关键字的个数。 表中有多少关键字，就会有多少个 △Pi ，取其中最小的做为次优查找树的根结点，然后将表中关键字从第 i 个关键字的位置分成两部分，分别作为该根结点的左子树和右子树。同理，左子树和右子树也这么处理，直到最后构成次优查找树完成。 ## 代码实现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int KeyType;　　// 定义关键字类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;　　// 定义元素类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">// 定义变量</span><br><span class="line">int i;</span><br><span class="line">int min;</span><br><span class="line">int dw;</span><br><span class="line"></span><br><span class="line">//创建次优查找树，R数组为查找表，sw数组为存储的各关键字的概率（权值），low和high表示的sw数组中的权值的范围</span><br><span class="line">void SecondOptimal(BiTree T, ElemType R[], float sw[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    // 由有序表R[low...high]及其累计权值表sw（其中sw[0]==0）递归构造次优查找树</span><br><span class="line">    i = low;</span><br><span class="line">    min = abs(sw[high] - sw[low]);</span><br><span class="line">    dw = sw[high] + sw[low - 1];</span><br><span class="line">    // 选择最小的△Pi值</span><br><span class="line">    for (int j = low+1; j &lt;=high; j++)</span><br><span class="line">　　&#123;</span><br><span class="line">        if (abs(dw - sw[j] - sw[j-1]) &lt; min)</span><br><span class="line">　　　　 &#123;</span><br><span class="line">            i = j;</span><br><span class="line">            min = abs(dw - sw[j] - sw[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    T = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">    T-&gt;data = R[i];　　// 生成结点（第一次生成根）</span><br><span class="line">    if (i == low) </span><br><span class="line">　　 　　T-&gt;lchild = NULL;　　// 左子树空</span><br><span class="line">    else SecondOptimal(T-&gt;lchild, R, sw, low, i - 1);　　// 构造左子树</span><br><span class="line">    if (i == high) </span><br><span class="line">　　 　　T-&gt;rchild = NULL;　　//右子树空</span><br><span class="line">    else </span><br><span class="line">　　　　SecondOptimal(T-&gt;rchild, R, sw, i + 1, high);　　//构造右子树   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 具体实例 <img src="https://s2.loli.net/2022/05/03/PduZa8y5MegBIEp.png" alt="次优生成树.png"> <strong>注意</strong> 在建立次优查找树时，由于只根据各关键字的P的值进行构建，没有考虑单个关键字的相应权值大小，有时会出现根节点权值比孩子节点权值还小，这时需要适当调整二者位置</p>
<h2 id="总结">总结</h2>
<p>由于使用次优查找树和最优查找树的性能差距很小，构造次优查找树的算法的时间复杂度为 O(nlogn)，因此可以使用次优查找树表示概率不等的查找表对应的静态查找表（又称为静态树表）。 ## 参考资料 <a href="https://www.cnblogs.com/lishanlei/p/10707664.html">如是说的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵的三元组表示</title>
    <url>/2022/05/17/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>在学习邻接矩阵时，我们会发现一个有意思的现象，有时100*100的矩阵中只储存了10个数据，我们把这种矩阵称为稀疏矩阵，其适用于一个阶数较大的矩阵中的非零元素个数相对于矩阵元素的总个数很小，如果这种稀疏矩阵用邻接矩阵来储存，这是浪费了很多空间的，那么我们应当如何在保留其矩阵信息的前提下，用一个好的结构来节省空间的开支呢？ <span id="more"></span> # 三元组 ## 定义 三元组是一种稀疏矩阵的压缩储存方式，其储存策略是只储存非零元素，它的储存方案是： 1. 储存非零元素 2. 同时储存该非零元素所对应的行下标和列下标 3. 稀疏矩阵中的每一个非零元素由一个三元组元素唯一确定，稀疏矩阵的所有非零元素构成三元组线性表，三元组的i为行下标，j为列下标，data域是对应的元素值 <img src="https://s2.loli.net/2022/05/17/iWxeFrpmwKM6jOB.png" alt="三元组.png"> ## 储存结构 下面直接上代码，注释写的比较清楚 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 100</span><br><span class="line"></span><br><span class="line">//定义三元组线性表中的数据元素存储结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int row;        //行号</span><br><span class="line">    int col;        //列号</span><br><span class="line">    ElemType d;     //元素值，ElemType为数据元素类型</span><br><span class="line"></span><br><span class="line">&#125; TupNode; //三元组定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义三元组线性表存储结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int rows;                   //行数值</span><br><span class="line">    int cols;                   //列数值</span><br><span class="line">    int nums;                   //非零元素个数</span><br><span class="line">    TupNode data[MaxSize];      //data数据域</span><br><span class="line"></span><br><span class="line">&#125; TSMatrix; //三元组顺序表定义</span><br></pre></td></tr></table></figure> ## 基本运算 ### 扫描二维矩阵，创建三元组 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以行序方式扫描二维矩阵A，将其非零的元素加入到三元组t</span><br><span class="line">//以3行4列的稀疏矩阵为例</span><br><span class="line">void CreatMat(TSMatrix *t, int arr[3][4])</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j;</span><br><span class="line">    t-&gt;rows = 3;</span><br><span class="line">    t-&gt;cols = 4;</span><br><span class="line">    t-&gt;nums = 0;</span><br><span class="line"></span><br><span class="line">    //扫描矩阵中的非零元素</span><br><span class="line">    for(i = 0; i &lt; 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; 4; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            //只存非零值，以三元组方式</span><br><span class="line">            if(arr[i][j] != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;data[t-&gt;nums].row = i;</span><br><span class="line">                t-&gt;data[t-&gt;nums].col = j;</span><br><span class="line">                t-&gt;data[t-&gt;nums].d = arr[i][j];</span><br><span class="line">                t-&gt;nums++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 将三元组指定位置元素值赋给对象 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将三元组线性表中指定位置的元素值赋值给变量x</span><br><span class="line">void arr_Assign(TSMatrix t , int *data , int i , int j)</span><br><span class="line">&#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    //i和j是否合法</span><br><span class="line">    if(i &gt;= t.rows || j &gt;= t.cols)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找到指定元素的行下标</span><br><span class="line">    while(k &lt; t.nums &amp;&amp; i &gt; t.data[k].row)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当找到指定元素的行下标后，再找到指定元素的列下标</span><br><span class="line">    while (k &lt; t.nums &amp;&amp; i == t.data[k].row &amp;&amp; j &gt; t.data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果指定元素的行和列都相等，说明找到了</span><br><span class="line">    if(t.data[k].row == i &amp;&amp; t.data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        *data = t.data[k].d;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //说明没找到</span><br><span class="line">        *data = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 对三元组元素赋值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//修改三元组元素中的值：执行A[i][j]=x</span><br><span class="line">void arr_Value(TSMatrix *t , int data , int i , int j)</span><br><span class="line">&#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    int k1;</span><br><span class="line">    //指定的行和列是否合法</span><br><span class="line">    if(i &gt;= t-&gt;rows || j &gt;= t-&gt;cols)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //先查找行</span><br><span class="line">    while(k &lt; t-&gt;nums &amp;&amp; i &gt; t-&gt;data[k].row)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找列</span><br><span class="line">    while(k &lt; t-&gt;nums &amp;&amp; i == t-&gt;data[k].row &amp;&amp; j &gt; t-&gt;data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当找到指定位置时直接修改</span><br><span class="line">    if(i == t-&gt;data[k].row &amp;&amp; j == t-&gt;data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        t-&gt;data[k].d = data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //如果指定位置不存在，则说明该元素值为0，此时插入</span><br><span class="line">        for(k1 = t-&gt;nums; k1 &gt;= k; k1--)</span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;data[k1+1].col = t-&gt;data[k1].col;</span><br><span class="line">            t-&gt;data[k1+1].row = t-&gt;data[k1].row;</span><br><span class="line">            t-&gt;data[k1+1].d = t-&gt;data[k1].d;</span><br><span class="line">        &#125;</span><br><span class="line">        //插入数据</span><br><span class="line">        t-&gt;data[k].row = i;</span><br><span class="line">        t-&gt;data[k].col = j;</span><br><span class="line">        t-&gt;data[k].d = data;</span><br><span class="line">        t-&gt;nums++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 参考资料 <a href="https://blog.csdn.net/qq_35733751/article/details/80843589">songly_的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络考前拾遗</title>
    <url>/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文只针对华中科技大学电子信息与通信学院计算机网络考试要求进行知识点归纳总结与提炼，内容不保证能满足各位读者的需求。</p>
<h2 id="第一章绪论">第一章：绪论</h2>
<h3 id="计算机网络的定义和发展历史了解">计算机网络的定义和发展历史(了解)</h3>
<p>网络:网络由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成</p>
<p>互联网：多个网络通过路由器互连起来，构成一个覆盖范围更大的网络，即互联网,互联网是网络的网络</p>
<p>因特网：因特网是世界上最大的互连网络</p>
<p>发展历史：计算机网络最早的起源来自美国军方搭建的APANET</p>
<span id="more"></span>
<p><strong>简答：列表对比说明互联网(Internet)和互连网(internet)两个概念的异同。</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-35-18.png"></p>
<h3 id="理解设计计算机网络的技术需求理解">理解设计计算机网络的技术需求(理解)</h3>
<ol type="1">
<li>可扩展的连通性</li>
<li>高性价比的资源共享</li>
<li>支持通用服务</li>
<li>可管理性</li>
</ol>
<h3 id="电路交换与分组交换掌握">电路交换与分组交换(掌握)</h3>
<p><strong>简答：简要说明电路交换的要点</strong></p>
<p>电路交换的要点包括:通信时需要经历三个阶段:建立连接、传送数据、释放连接;通信的双方之间需要建立一个专用的链路;通信过程中,沿着建立链路传输的数据无需路由;通信结束后,连接断开,链路资源被释放</p>
<p><strong>简答：简要说明分组交换的要点</strong></p>
<p>分组交换的要点包括:将完整的报文分割成为较小的数据段,在每个数据段前面加上必要的控制信息组成首部,就构成了分组;通信过程中,沿途交换机采用“存储-转发”方式,根据分组首部中的目的地信息进行转发;通信过程中,各数据分组被独立路由和转发。</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-45-41.png"></p>
<h2 id="第二章网络体系结构">第二章：网络体系结构</h2>
<h3 id="层次化体系结构的原理掌握">层次化体系结构的原理(掌握)</h3>
<p><strong>简答：简述网络体系结构采用分层设计的好处</strong></p>
<p>采用分层的网络体系结构的优势包括但不限于:</p>
<ol type="1">
<li>各层之间可以独立设计,便于分工协作,实现产业标准化;</li>
<li>层次化设计的灵活性好,一层发生变化不影响上下层;</li>
<li>层次化设计的扩展性好,各层可选用不同的技术来适应不同的应用需求。</li>
</ol>
<h3 id="网络体系结构的相关概念理解">网络体系结构的相关概念(理解)</h3>
<ol type="1">
<li>实体：任何可发送或接收数据的硬件或软件进程</li>
<li>对等实体：收发双方相同层次中的实体</li>
<li>协议：控制两个对等实体进行逻辑通信的规则的集合</li>
<li>协议的三要素：
<ol type="1">
<li>语法,即数据与控制信息的结构或格式。</li>
<li>语义,即需要发出何种控制信息、完成何种动作以及做出何种响应。</li>
<li>同步,即事件实现顺序的详细说明。</li>
</ol></li>
</ol>
<p><strong>简答：层次化网络体系结构中的服务与协议有何区别?</strong></p>
<p>层次化网络体系结构中,服务是垂直的,定义了该层能够代表它的用户完成的操作。上层是服务用户,下层是服务提供者。协议是水平的,定义的是对等实体间交换数据的格式、内容、时序,协议的实现保证了能够向上层提供服务。</p>
<h3 id="三种体系架构的模型与差异掌握">三种体系架构的模型与差异(掌握)</h3>
<figure>
<img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-00-22.png" alt="三种体系架构"><figcaption aria-hidden="true">三种体系架构</figcaption>
</figure>
<p><strong>简答：简述ISO/OSI参考模型各层功能与协议数据单元</strong></p>
<p>ISO/OSI参考模型各层功能自底向上分别为:</p>
<ol type="1">
<li>物理层:实现数据bitt在物理链路上的传输;数据单元：数据位(Bit)</li>
<li>数据链路层:处理相邻网络结点之间数据帧的传输;数据单元：数据帧</li>
<li>网络层:处理互联网络中主机之间的分组传输;数据单元：数据分组</li>
<li>传输层:实现终端主机进程之间的通信;数据单元：数据段</li>
<li>会话层:实现通信的会话管理等功能;数据单元：数据</li>
<li>表示层:实现不同表达形式数据之间的转换;数据单元：数据</li>
<li>应用层:实现应用特定操作,向用户提供相应的服务.数据单元：数据</li>
</ol>
<p><strong>简答：自上而下简述计算机网络体系结构的五层参考模型</strong></p>
<p>网络体系结构的五层模型,自上向下依次为应用层、传输层、网络层、数据链路层、物理层。</p>
<p>应用层:为用户的应用进程提供服务</p>
<p>传输层:为两个主机中进程之间的通信提供端到端服务</p>
<p>网络层:为分组交换网上的不同主机提供通信服务</p>
<p>数据链路层:在相邻结点间的链路上透明传送数据</p>
<p>物理层:在传输媒质上实现透明的比特流传送</p>
<h3 id="计算机网络的性能指标的计算方法掌握">计算机网络的性能指标的计算方法(掌握)</h3>
<p><strong>首先要区分比特和字节的概念</strong></p>
<p>1Byte(字节)=8bit(比特)</p>
<ol type="1">
<li>速率：连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率，基本单位：bit/s（bps），常用单位:kbps/Mbps <strong>这里的换算需要与计算机存储里面换算做区分，计算速率时:1k=1000,计算内存时：1k=1024</strong></li>
<li>带宽：表示网络的通信线路传送数据的能力，表示单位时间内从网络中某一点到另一点所能通过的<strong>最高数据率</strong>,单位与速率单位相同</li>
<li>吞吐量：表示单位时间内通过某个网络(或信道、接口)的数据量；用于测量实际上到底由多少数据量能通过网络，其受<strong>网络带宽或额定速率的限制</strong>,在部分习题中提出了<strong>计算网络最大吞吐率</strong>的要求：其计算公式可表述如下：<span class="math inline">\(最大吞吐量=\frac{发送窗口大小}{往返时延}\)</span></li>
<li>时延：
<ul>
<li>发送时延：<span class="math inline">\(\frac{分组长度}{发送速率}\)</span></li>
<li>传播时延：<span class="math inline">\(\frac{信道长度}{电磁波传播速率}\)</span></li>
<li>处理时延：一般不便于计算</li>
<li>排队时延：一般不考虑</li>
<li>总时延=发送时延+传播时延+处理时延+排队时延</li>
</ul></li>
<li>时延带宽积：其值等于传播时延*带宽，时延带宽积可视为以比特为单位的链路长度,等效于第一个比特到达接收方时发送方可以发送的比特数(链路满载)。</li>
<li>往返时延(RTT):链路双向交互一次的时间</li>
<li><span class="math inline">\(信道利用率=\frac{发送数据量}{信道总带宽\times往返时延}=\frac{有效传输时间}{往返传输时延（\ne RTT）}\)</span></li>
</ol>
<h2 id="第三章直连网络">第三章：直连网络</h2>
<h3 id="直连网络的概念了解">直连网络的概念(了解)</h3>
<p>直连网络：所有的主机通过某种物理媒质直接连接，是最简单的网络形式</p>
<p><strong>物理层的四个特性</strong>：</p>
<p>机械特性：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p>
<p>电气特性：指明在接口电缆的各条线上出现的电压的范围。</p>
<p>功能特性：指明某条线上出现的某一电平的电压表示何意。</p>
<p>规程特性：指明对于不同功能的各种可能事件的出现顺序。</p>
<h3 id="不同组帧方法了解">不同组帧方法(了解)</h3>
<p>组帧方法主要分为以下两种：</p>
<ol type="1">
<li>面向字节的协议：把每一帧看作一个字节集合，两种方法：字符计数法，起止标记法。</li>
<li>面向比特的协议：把数据帧看作比特的集合</li>
</ol>
<h3 id="差错控制的概念理解">差错控制的概念(理解)</h3>
<p>为什么进行差错检测？ 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错，这称为比特差错，使用差错检测码来检测是否产生比特差错，是数据链路层的重要问题之一。</p>
<p>常用的差错检测方法：</p>
<ol type="1">
<li>奇偶校验：添加一位奇偶校验位，能检测奇数个比特差错</li>
<li>循环冗余校验(CRC)：检测出一定数量的差错，其主要步骤如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-23-16.png"></li>
</ol>
<h3 id="可靠传输的概念和基本实现机制掌握">可靠传输的概念和基本实现机制(掌握)</h3>
<p>可靠传输：上文提到的比特差错只是传输差错的一种，传输差错还包括分组丢失，分组失序，分组重复</p>
<p>可靠传输的协议实现主要有以下几种：</p>
<ol type="1">
<li>停止等待协议（ARQ协议）</li>
<li>连续ARQ协议：包含两种策略：GO-BACK-N 和 选择性重传</li>
<li>滑动窗口协议</li>
</ol>
<p>停止等待协议示意图 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-40-13.png" alt="停止等待协议示意图"></p>
<p>连续ARQ协议两种策略的优缺点分析： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-44-52.png"></p>
<p><strong>注意，Go-Back-N协议如果帧序号为n个bit，其每次最多连续能传的帧数=<span class="math inline">\(2^{n}-1\)</span>，因为如果传<span class="math inline">\(2^n\)</span>个帧，如果接收方确认帧丢失，则会导致接收方无法辨别发送方发送的帧的新旧，GO-BACK-N也可以看为滑动窗口策略的一种特殊情况，即接收窗口为1</strong></p>
<p>滑动窗口协议的示意图： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-15.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-40.png"></p>
<p>三种协议的对比 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-11-11-19-01.png"></p>
<p><strong>简答：简述数据链路层实现可靠传输的基本方法。</strong></p>
<p>数据链路层实现可靠传输的基本设计方法包括:</p>
<ol type="1">
<li>确认机制:接收方给发送方发送ACK,反馈已正确接收的数据帧;</li>
<li>超时机制:发送方启动计时器,一旦出现超时则自动重传未确认的数据帧;</li>
<li>帧序号:标记数据帧,以便识别重复的数据帧</li>
</ol>
<h3 id="滑动窗口参数的计算方法掌握">滑动窗口参数的计算方法(掌握)</h3>
<p>选择重传策略的滑动窗口参数的要求如下图所示 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-48-38.png"></p>
<p><strong>广义来说：滑动窗口对于窗口的大小的限制可表述为：<span class="math inline">\(发送窗口+接收窗口\le2^{帧序号bit数}\)</span></strong></p>
<p><strong>具体细分到Go-Back-N协议和选择重传协议有：<span class="math display">\[Go-Back-N 发送窗口大小\le 2^{帧序号比特数}-1,\\
选择重传发送窗口大小\le 2^{帧序号比特数-1} \]</span></strong></p>
<h3 id="传统共享介质mac协议的设计要点理解">传统共享介质MAC协议的设计要点(理解)</h3>
<p><strong>简答：为什么在传统以太网的协议设计中,数据帧存在最短帧长的限制?</strong></p>
<p>传统以太网的MAC层协议为CSMA/CD,其中CD称为冲突检测,主要解决信号传播时延导致的媒质接入问题。在争用信道过程中,结点边发送数据边监听信道,如果在一个争用周期范围内未检测到冲突发生,则成功占用信道。IEEE 802.3规定当某个结点完成一帧数据接收后,首先要判断接收的帧长度,如果接收帧长度小于规定的帧最小长度,则表明冲突发生。</p>
<h3 id="csmacd协议的原理掌握">CSMA/CD协议的原理(掌握)</h3>
<p><strong>简答：简述传统以太网的CSMA/CD算法要点</strong></p>
<p>CSMA/CD全称为带有冲突检测的载波侦听多路接入(Carrier Sense Multiple Access with Collision Detect)。其基本思想是载波监听,多点接入,碰撞检测。每个站点发送数据之前必须侦听信道的忙、闲状态;如果信道空闲,立即发送数据,同时进行冲突检测;如果信道忙,站点继续侦听总线,直到信道变成空闲。如果在数据发送过程中检测到冲突,将立即停止发送数据并等待一段随机长的时间,然后重复上述过程。</p>
<h3 id="无线局域网mac协议设计要点理解">无线局域网MAC协议设计要点(理解)</h3>
<p><strong>简答：CSMA/CD算法为何不能应用于无线局域网</strong></p>
<p>CSMA/CD算法需要硬件一边发送数据一边监听共享链路的占用情况,在冲突窗口时间内没有检测出冲突就确定为发送成功。这些设计在无线链路上难以满足。首先,在无线网卡实现信号的同时发送和接收的难度和代价较高;其次,无线通信环境中信号传输路径复杂,存在绕射、折射、反射等多径,难以估算传输延时和判断是否存在冲突。</p>
<h3 id="csmaca协议的原理理解">CSMA/CA协议的原理(理解)</h3>
<p><strong>简答：无线局域网CSMA/CA如何实现冲突避免?</strong></p>
<p>冲突避免 Collision Avoidance,又称为虚拟载波侦听 (Virtual Carrier Sense),通过信令协商达到实际载波侦听的效果。协议约定在发送数据帧之前交换控制信息,发送方询问“Request to Send” (RTS),接收方收到 RTS后响应 “Clear to Send” (CTS),发送方收到 CTS, 则开始发送数据。在此过程中,如果其他结点收到 RTS或者 CTS,则停止发送,避免冲突。</p>
<h2 id="第四章分组交换网络">第四章：分组交换网络</h2>
<h3 id="数据报交换虚电路交换的原理理解">数据报交换、虚电路交换的原理(理解)</h3>
<p><strong>虚电路交换方法的健壮性不如数据报交换方法</strong></p>
<p><strong>简答：对比虚电路和数据报两种分组交换技术</strong></p>
<p>数据报交换的思想是网络不负责提供可靠传输保证,分组中包括源/目的地址,沿途交换机根据该地址独立处理和转发分组。 虚电路交换的思想是网络提供可靠传输保证,传输过程包括连接建立、数据传输、连接释放等阶段。在连接建立过程中,交换机协商分配局部的虚电路号并预留资源;数据传输过程中,分组首部内包含有本地交换所需的虚电路号,交换机根据虚电路号转发分组。</p>
<h3 id="局域网扩展网桥生成树算法的基本概念理解">局域网扩展，网桥，生成树算法的基本概念(理解)</h3>
<p><strong>局域网扩展的基本概念</strong>：局域网（LAN）扩展是指通过不同的技术手段，将原有的局域网范围进行扩大，以覆盖更大的区域或连接更多的设备。这种扩展可以通过多种方式实现：</p>
<ol type="1">
<li>无线局域网扩展：如Wi-Fi</li>
<li>有线局域网扩展：使用更长的网线等传输媒介，扩大局域网范围</li>
<li>虚拟局域网(VLAN)：通过在网络交换机上配置虚拟局域网，可以将原有的物理局域网划分为多个逻辑上独立的虚拟局域网，实现不同部门或功能的隔离和管理，同时在逻辑上连接它们，形成一个扩展的网络。</li>
<li>子网划分： 将原有的单一子网划分为多个子网，每个子网可以有自己的IP地址范围和路由规则，使得网络可以更有效地支持不同的设备和服务</li>
<li>中继器和网桥： 使用中继器和网桥等设备，可以将原有的局域网连接到其他局域网，实现不同物理位置之间的网络扩展。</li>
<li>广域网连接： 通过使用广域网（WAN）连接技术，如专线、VPN（虚拟专用网络）等，将不同地理位置的局域网连接起来，形成一个更大范围的网络。</li>
</ol>
<p><strong>网桥的基本概念</strong>：网桥工作在数据链路层，对接收到的帧进行过滤转发，通过网桥可以连接多个局域网，以建立更大的局域网</p>
<p>网桥可分为基本网桥和学习网桥，基本网桥将收到的帧向所有端口转发，这样效率很低，不能隔离碰撞域，常用的是学习网桥，采用选择性转发的方法，维护一个转发表，根据转发表（站表）确定转发端口，不向无关端口转发（能有效隔离碰撞域，效率高）。</p>
<p><strong>生成树算法的基本概念</strong>：生成树算法是为了解决广播风暴的问题而提出的一种算法，因为根据网桥的工作原理，帧有可能在环形网络中兜圈子而产生广播风暴。生成树算法通过从网络中剪掉一些链路，构造出该网络的生成树来解决广播风暴问题</p>
<p><strong>简答：简述透明网桥的要点?其在环状拓扑结构下可能发生什么问题?</strong></p>
<p>透明网桥通过逆向自主学习方式构建MAC转发表 透明网桥在环状拓扑结构下可能发生广播风暴(绕弯子)现象,生成树算法可以有效解决该问题。</p>
<p><strong>简答：什么是广播风暴</strong></p>
<p>网桥工作在数据链路层。网桥根据数据帧的源地址与目的地址来决定是否接收和转发该帧。随着网络规模的扩大与用户结点数的增加,可能出现“端口-结点地址表”中没有的结点地址信息,此时网桥无从决定应该从哪个端口转发,只能在所有端口广播。这种盲目广播会使帧的数量按指数规律增长,造成网络中无用的通信量剧增,形成“广播风暴”。</p>
<p><strong>简答：虚拟局域网是不是一种新的局域网?</strong></p>
<p>虚拟局域网是局域网交换机给用户提供的一种服务,并不是一种新型局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符,称为VLAN标记,用来指明发送该帧的工作站属于哪一个VLAN。局域网交换机根据VLAN标记,对于到来流量进行转发。属于同一个VLAN标记的工作站可以相互访问。</p>
<p><strong>数据帧转发过程中IP地址和MAC地址的变化情况</strong></p>
<ol type="1">
<li>当帧经过交换机时不会更改其源MAC地址和目标MAC地址</li>
<li>当帧通过路由器时，进行路由转发，IP地址是不会变的，MAC地址一定会变</li>
<li>当帧在同一个子网的主机之间进行转发，IP和MAC地址都不会改变</li>
<li>当帧在不同子网的主机进行转发时(使用NAT技术将内网IP转为外网公用IP)时，IP地址和MAC地址会发生改变</li>
</ol>
<h3 id="共享式以太网与交换式以太网的区别理解">共享式以太网与交换式以太网的区别(理解)</h3>
<p><strong>简答：共享式局域网与交换式局域网有哪些区别?</strong></p>
<p>共享式局域网的核心设备是集线器,在任何一个时刻只能有一个结点通过共享信道发送数据。该网络内每个结点处于同一个冲突域内,结点得到的平均带宽约等于总带宽/结点数。 交换式局域网的核心设备是交换机,可以在它的多个端口之间建立多个并发连接,从而实现了结点之间数据的并发传输。该网络内结点的通信不存在冲突,结点得到接近总带宽的带宽。</p>
<h3 id="以太网中继器集线器网桥交换机的功能与区别掌握">以太网中继器、集线器、网桥、交换机的功能与区别(掌握)</h3>
<p><strong>简答：简述中继器、集线器、网桥、交换机等设备的区别</strong></p>
<p>这4 种设备都是用于互联、扩展局域网的连接设备,但它们工作的层次和实现的功能不同:</p>
<ol type="1">
<li>中继器(Repeater),工作在物理层,解决数字信号在长距离基带传输中的失真和衰减问题,通过信号再生提升信号波形和强度的质量。</li>
<li>集线器(Hub),工作在物理层,相当于一个多端口的中继器。集线器可以将多个结点连接成为一个共享式以太网。</li>
<li>网桥(Network Bridge),工作在数据链路层,可以互联不同的物理层、不同的 MAC 子层以及不同速率的以大网,具有过滤帧、存储转发帧的功能。</li>
<li>交换机(Switch),,工作在数据链路层,相当于一个多端口的网桥。允许端口之间建立多个并发的连接,实现多个结点之间的并发传输。</li>
</ol>
<h2 id="第五章网络互联">第五章：网络互联</h2>
<h3 id="ip尽力服务的服务模型ip数据包转发原理理解">IP尽力服务的服务模型，IP数据包转发原理(理解)</h3>
<p><strong>IP尽力服务</strong>是一种服务模型，也称为“Best Effort Service”，是指在计算机网络中，网络设备尽其所能地传输数据，但不保证数据包的可靠性、顺序或时延。这种服务模型主要用于互联网中的IP网络，其中数据包以最佳可能的方式进行传输，但网络不提供对数据包的任何特殊处理或保证。</p>
<p><strong>IP数据包转发原理</strong>：</p>
<ol type="1">
<li>数据包的封装</li>
<li>路由器查找</li>
<li>数据包转发</li>
<li>数据包到达目标设备</li>
</ol>
<p><strong>简答：解释Everything over IP和IP over Everything的含义</strong></p>
<p>Everything over IP:从协议栈来看,TCP/IP网络可以为各式各样的应用提供服务,在IP层上面可以有很多的应用程序。 IP over everything:从协议栈看,TCP/IP网络也允许IP协议在各种异构网络构成互联网上运行,在IP层以上无需关心下层的物理网络实现。</p>
<h3 id="ipv4分段与重组的概念与计算掌握">IPv4分段与重组的概念与计算(掌握)</h3>
<p>IPv4分段与重组是一种处理大数据包的机制，允许将大于网络链路允许的最大传输单元（MTU）的IPv4数据包进行分割，并在到达目的地后重新组装这些分段。这是为了适应网络链路上的不同MTU和确保数据的正确传输。</p>
<p>在了解如何计算IPv4的分段和重组之前，我们需要了解IPv4数据报的首部格式 其示意图如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-38-31.png"></p>
<p>各参数含义如下：</p>
<ol type="1">
<li>版本：表示IP协议版本</li>
<li>首部长度，取值以4为单位，最小值为5，20字节，最大值为15，表明首部包含20字节固定部分和最大40字节可变部分</li>
<li>可选字段：用于排错，很少使用</li>
<li>填充字段：确保首部长度为4的整数倍，用全0填充</li>
<li>区分服务：很少使用</li>
<li>总长度：表示IP数据报总长度</li>
<li>标识：属于同一数据包的各分片应该具有相同标识</li>
<li>标志：各比特定义为:
<ul>
<li>DF位：1/0 表示是否允许分片</li>
<li>MF位：1/0 表示后面是否还有分片</li>
<li>保留位：必须为0</li>
</ul></li>
<li>片偏移：指出其数据载荷部分在原数据基础上偏移了多少位，以八个字节为单位</li>
</ol>
<p>其计算常涉及到如何将大数据包分为更小的片段进行传输，具体操作可以通过下图来理解 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-34-47.png"></p>
<p>值得注意的是：<strong>在IP层的计算中，IP实际的数据段需要减去首部长度，但如果题目说的是TCP传输层的报文传入下层IP层传输，则不需要减去TCP传输层的首部长度，因为IP层的数据载荷就是整个TCP报文</strong></p>
<h3 id="ipv4地址以及cidr设计和规划的概念与计算方法掌握">IPv4地址以及CIDR设计和规划的概念与计算方法(掌握)</h3>
<h4 id="ipv4的分类编址">IPv4的分类编址</h4>
<p>IP地址往往进行分类编址 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-56-24.png"></p>
<p><strong>且在每个网络的主机号中，全0的最小地址作为网络地址，全1的最大地址作为广播地址不可分配</strong></p>
<p>常用的3类网络的网络数和主机数的关系如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-59-13.png"></p>
<h4 id="ipv4划分子网">IPv4划分子网</h4>
<p>对于网络中的网络，我们往往是直接在该网络中分配子网，而不是申请新的网络号，这可表述为<strong>借用主机地址作为网络地址</strong></p>
<p>我们可以用IP地址与子网掩码相与得到网络地址，其计算如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-04-24.png"></p>
<p><strong>给定一个分类的IP地址和子网掩码，即可计算子网划分细节</strong>：</p>
<ol type="1">
<li><span class="math inline">\(子网数量=2^{子网掩码1数-网络号}\)</span></li>
<li><span class="math inline">\(子网可分配给主机的IP地址数量=2^{子网掩码0数}-2\)</span></li>
<li><span class="math inline">\(子网网络地址=子网地址，子网广播地址=下一个子网地址-1\)</span></li>
<li><span class="math inline">\(子网分配给主机的最小地址=子网地址+1，子网分配给主机的最大地址=下一个子网地址-2\)</span></li>
</ol>
<h4 id="ipv4无分类编址超网--cidr">IPv4无分类编址(超网)--CIDR</h4>
<p>CIDR使用斜线记法，在<strong>斜线后面写上网络前缀所占比特数量</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-12-35.png"></p>
<p><strong>CIDR的最长前缀匹配原则</strong></p>
<p>在路由器间进行转发时，我们采用最长前缀匹配原则将到来的IP分组进行转发，如果一个IP分组与两个网络的网络号都匹配，选择两个网络号中，长度最长的那个网络作为IP地址的下一跳路由器</p>
<p><strong>简答：说明IP地址与硬件地址的区别</strong></p>
<p>IP地址是连接互联网上的主机标识符;IP地址也被称为逻辑地址,其分配可以被静态指定也可以被动态分配;IPv4是32bit的,IPv6是128bit的。 硬件地址也被称为物理地址,用于标识每个网络接口设备;IEEE系列标准规定了MAC地址的格式,由48bit构成,由网卡制造商在生产时内置。</p>
<h3 id="arp协议dhcp协议nat协议icmp协议了解">ARP协议，DHCP协议，NAT协议，ICMP协议(了解)</h3>
<ol type="1">
<li>ARP协议用于将IP地址映射到MAC地址</li>
<li>DHCP协议用于将域名映射到IP地址(<strong>域名与IP地址不是一一对应的关系</strong>)</li>
<li>NAT协议用于在私有网络和公共网络中映射IP地址，允许多个设备享有一个IP地址</li>
<li>ICMP用于IP网络上的检错</li>
</ol>
<p><strong>简答：ARP协议向网络层提供了转换地址的服务,是否属于数据链路层?</strong></p>
<p>这种说法是错误的。ARP 不是向网络层提供服务,它本身就是网络层的一部分,帮助向传输层提供服务。数据链路层不存在IP地址问题,数据链路层协议把比特串从线路的一端传送到另一端。</p>
<h3 id="基于距离向量和基于链路状态的路由算法的原理与计算掌握">基于距离向量和基于链路状态的路由算法的原理与计算(掌握)</h3>
<p><strong>简答：简述距离向量路由算法原理,该算法有哪些不足?</strong></p>
<p>该算法定义距离向量信息为当前结点到达每一个其他结点的代价,通过邻结点之间多轮次两两交换距离向量信息,基于Bellman-ford算法逐步更新到全网其它结点的最短路径下一跳。 该算法的不足包括,构造距离向量需要知道全网结点数量规模,可能产生无穷计算问题。</p>
<p><strong>简答：“好消息传得快,坏消息传得慢”描述的是哪个路由算法,如何克服?</strong></p>
<p>这是距离向量路由算法的缺点。其原因是,路由交换时依赖两两信息交换,无法得到全局准确信息,导致计算到无穷。该问题无法通过算法改进彻底解决,在该算法对应的RIP协议中,通过设定路由跳数最大值来加以克服。RIP约定值为16即表示不可达,避免计算到无穷。</p>
<p><strong>简答：对比距离向量路由算法和链路状态路由算法的差异。</strong></p>
<p>距离向量路由算法:与邻结点交互全局信息,每个结点仅与直接相连的结点通信,交互的信息是到达其余所有结点的距离,路由计算采用Bellman-ford算法。 链路状态路由算法:与全局结点交互局部信息,每个结点通过洪泛方式与其他所有结点通信,交互的信息是该结点相连链路的状态,路由计算采用Dijkstra算法。</p>
<h3 id="路由器与交换机的区别掌握">路由器与交换机的区别(掌握)</h3>
<p><strong>简答：作为中间设备,转发器、网桥、路由器和网关有何区别?</strong></p>
<p>将网络互相连接起来要使用一些中间设备:</p>
<ol type="1">
<li>物理层使用的中间设备叫做转发器。</li>
<li>数据链路层使用的中间设备叫做网桥或桥接器。</li>
<li>网络层使用的中间设备叫做路由器。</li>
<li>在网络层以上使用的中间设备叫做网关。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li>
</ol>
<h3 id="自治系统的概念域内路由与域间路由的概念理解">自治系统的概念，域内路由与域间路由的概念(理解)</h3>
<h4 id="自治系统">自治系统</h4>
<p>因特网将整个互联网划分为许多较小的自治系统 AS。</p>
<p>一个自治系统是一个互联网，其最重要的特点就是自治系统有权自主地决定在本系统内应采用何种路由选择协议。</p>
<p>一个自治系统内的所有网络都属于一个行政单位(例如，一个公司，一所大学，政府的一个部门，等等)来管辖。</p>
<p>一个自治系统的所有路由器在本自治系统内都必须是连通的。</p>
<h4 id="域内路由与域间路由">域内路由与域间路由</h4>
<p><strong>简答：IGP和EGP这两类协议的主要区别是什么?</strong></p>
<p>IGP是内部网关协议,即在一个自治系统内部使用的路由选择协议,代表性的包括RIP和OSPF协议。IGP的路由选择主要采用最短路径的算法。 EGP是外部网关协议,用于自治系统之间路由选择,目前使用最多的外部网关协议是BGP协议。EGP的路由选择受多种因素影响,通常不使用最短路径。</p>
<h3 id="路径向量路由算法的原理与bgp协议实现理解">路径向量路由算法的原理与BGP协议实现(理解)</h3>
<p><strong>路径向量路由算法</strong></p>
<p>想法：</p>
<ul>
<li>对距离向量进行扩展使其能够快速检测环路</li>
<li>支持灵活的路由策略</li>
<li>避免无穷计算问题</li>
</ul>
<p>核心思想 : 通告整条路径</p>
<p>距离向量 : 发送到每一个目的地 d 的距离向量</p>
<p>路径向量 : 发送到每一个目的地 d 的路径向量</p>
<p><strong>BGP协议</strong></p>
<ol type="1">
<li>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 （不能兜圈子），而并非要寻找一条最佳路由</li>
<li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 BGP 发言人</li>
<li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换BGP 报文以建立 BGP 会话 ( session)，利用 BGP 会话交换路由信息。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站 。</li>
</ol>
<p><strong>简答：RIP、OSPF、BGP的承载协议有何不同,有何考虑?</strong></p>
<ol type="1">
<li>RIP采用UDP协议。RIP在1980年代早期开发,其只需要与邻结点交互信息。UDP虽然无可靠性保证,但传输开销较小,可以满足RIP的需求。</li>
<li>OSPF采用IP协议。OSPF在1980年代末期开发,其需要在全网交互信息。当时TCP/IP架构已经形成,直接使用IP协议,易于在路由器上实现链路状态信息的洪泛。</li>
<li>BGP采用TCP协议。BGP协议在不同的自治系统之间交换路由信息,交换域间路由信息需要可靠传输保证,所以选择TCP。</li>
</ol>
<h3 id="ipv6协议了解">IPv6协议(了解)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-23-41.png"></p>
<h2 id="第六章端到端协议">第六章：端到端协议</h2>
<h3 id="传输协议udp与tcp的实现要点和对比理解">传输协议UDP与TCP的实现要点和对比(理解)</h3>
<p>UDP协议的实现要点：</p>
<ol type="1">
<li>无连接的</li>
<li>支持单播、多播和广播</li>
<li>面向应用报文</li>
<li>向上传提供无连接不可靠传输服务(适用于IP电话，视频会议等实时应用)</li>
<li>首部短，仅8字节</li>
</ol>
<p>TCP协议实现要点：</p>
<ol type="1">
<li>面向连接</li>
<li>一对一可靠通信</li>
<li>面向字节流</li>
<li>可靠传输，使用流量控制和拥塞控制</li>
<li>首部最小20字节，最大60字节</li>
</ol>
<p>UDP与TCP的对比 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-32-56.png"></p>
<p><strong>简答：为什么说UDP是面向报文的,而TCP是面向字节流的?</strong></p>
<p>UDP对应用程序交下来的报文,在添加首部后就向下交付IP层。UDP待交付的报文,既不合并,也不拆分,因此UDP是面向报文的。</p>
<p>TCP将应用层发送的报文看成是一串字节流,并对把每一个字节都进行编号,传输保证每一个字节都正确无误地传送到对方。因此TCP是面向字节流的。</p>
<h3 id="tcp连接的三次握手与四次挥手掌握">TCP连接的三次握手与四次挥手(掌握)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-47-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-48-36.png"></p>
<p><strong>简答：为什么在TCP连接建立时要使用三报文握手?</strong></p>
<p>如果不采用三报文握手,而是仅仅两报文握手。一旦滞留在网络中某处的陈旧的SYN报文段抵达接收方,就会让接收方误以为这是一个新的连接而进入连接等待状态,导致接收方资源被占用而无法释放。</p>
<p><strong>简答：为什么TCP连接释放比连接建立过程多一次交互?</strong></p>
<p>TCP三次握手是确保两个站点都对当前建立连接进行确认,避免两个站点过去发送的连接建立请求延后到达后导致一方进入资源等待状态而空等。 TCP四次挥手在三次握手基础上增加一次,原因是接收方需要等待上层应用将数据取走,因此接收方一次表示确认收到释放请求,一次再发起释放请求。</p>
<h3 id="tcp流量控制滑动窗口掌握">TCP流量控制(滑动窗口)(掌握)</h3>
<p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收 一般我们采用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-46-04.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-45-43.png"></p>
<p><strong>简答：TCP发送窗口的大小取决于流量控制还是拥塞控制?</strong></p>
<p>TCP发送窗口的上限值是Min [rwnd,cwnd],即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。当接收窗口小于拥塞窗口时,发送窗口的大小取决于流量控制,即取决于接收端的接收能力;当拥塞窗口小于接收窗口时,则发送窗口的大小取决于拥塞控制,即取决于整个网络的拥塞状况。</p>
<h2 id="第七章拥塞控制">第七章：拥塞控制</h2>
<h3 id="拥塞控制的概念以及与流量控制的区别理解">拥塞控制的概念以及与流量控制的区别(理解)</h3>
<p><strong>简答：流量控制和拥塞控制的最主要的区别是什么?</strong></p>
<p>流量控制是在一条TCP连接中的接收端采用的措施,用来限制对方(发送端)发送报文段的速率,以免在接收端来不及接收。流量控制只控制一个发送端。 拥塞控制是用来控制TCP连接中发送端发送报文段的速率,以免使互联网中的某处产生过载。拥塞控制可能会同时控制许多个发送端,限制它们的发送速率。</p>
<h3 id="tcp拥塞控制的主要机制掌握">TCP拥塞控制的主要机制(掌握)</h3>
<p>常用的机制主要是慢开始和拥塞避免 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-52-05.png"></p>
<p>为了进一步改进性能，又提出了快重传和快恢复算法 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-54-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-55-01.png"></p>
<h3 id="tcp拥塞控制与流量控制的综合计算掌握">TCP拥塞控制与流量控制的综合计算(掌握)</h3>
<p>仅举一例 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-56-31.png"></p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">湖科大计算机网络微课堂</a></li>
<li>Computer Networks: A Systems Approach, 5th Edition</li>
<li>华中科技大学电子信息与通信学院计算机网络课程组提供的优秀课件和资料</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法</title>
    <url>/2022/02/01/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="递归算法">递归算法</h2>
<h2 id="什么是递归">什么是递归？</h2>
<p>递归，在计算机科学中是指一种通过重复把问题分解为同类的子问题而解决问题的方法，通俗来讲，递归表现为函数调用函数本身。在知乎上有一个比喻递归非常形象的例子。 “递归最恰当的比喻，就是查词典。我们使用的词典，本身就是递归，为了解释一个词，需要使用更多的词。当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。”. <span id="more"></span> ### 递归的特点 事实上，递归有两个显著的特征，终止条件和自身调用： * <strong>自身调用</strong>：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，都是调用自身的同一个函数 * <strong>终止条件</strong>：递归必须有一个终止的条件，即不能无线循环的调用自己</p>
<h3 id="递归与栈的关系">递归与栈的关系</h3>
<p>递归的过程也可以理解为出入栈的过程 比如说我们利用递归计算3的阶乘，因为3&gt;1,所以进入下一个递归，2&gt;1，再进入下一个递归，1=1，开始计算，依序返回，在这里，我们可以发现先进去的3反而是最后执行的，这就类似于栈的性质</p>
<h3 id="递归的经典应用场景">递归的经典应用场景</h3>
<ul>
<li>阶乘问题</li>
<li>二叉树深度</li>
<li>汉诺塔问题</li>
<li>斐波那契数列</li>
<li>快速排序，归并排序（分治算法中体现递归）</li>
<li>遍历文件，解析xml文件</li>
</ul>
<h3 id="递归解题思路">递归解题思路</h3>
<ol type="1">
<li>定义函数功能</li>
<li>寻找递归终止条件</li>
<li>递推函数的等价关系式</li>
</ol>
<h3 id="递归存在的问题">递归存在的问题</h3>
<ol type="1">
<li>递归调用层级太多，导致栈溢出问题</li>
<li>递归重复计算，导致效率低下</li>
</ol>
<h4 id="栈溢出问题">栈溢出问题：</h4>
<ul>
<li>每一次函数调用在内存栈中分配空间，然而每个进程的栈容量是有限的</li>
<li>当递归调用的层级太多时就会，就会超出栈的容量，从而导致调用栈溢出</li>
<li>其实，我们在前面小节也讨论了。递归过程类似于出栈入栈，如果递归次数过多，栈的深度就需要越深，最后栈容量就不够了</li>
</ul>
<h4 id="重复计算导致效率低下">重复计算导致效率低下</h4>
<p>递归处理时，有些问题如果不加以处理，会造成多次重复计算，降低程序的运行效率</p>
<p>参考：https://mp.weixin.qq.com/s/tqGKHZzSyDBgEp-oWsOztQ</p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>通信原理第一四章知识小结</title>
    <url>/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第一，四章内容较少，故将两章合并。本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="第一章绪论">第一章：绪论</h2>
<h3 id="信息及其度量">1.4 信息及其度量</h3>
<p>在通信原理中对信息的度量与先修课程信息论的度量方式一致，信息量<span class="math inline">\(I=-log_aP(x)\)</span>,平均信息量(熵)<span class="math inline">\(H=\sum_{i=1}^M p(x_i)log_2\frac{1}{p(x_i)}\)</span></p>
<h3 id="通信系统主要性能指标">1.5 通信系统主要性能指标</h3>
<p>通信系统的性能指标一般从两方面考虑：有效性与可靠性，其中有效性是指传输一定信息量时所占用的信道资源--“传输速度”，可靠性是指接收信息的准确程度--“传输质量”</p>
<h4 id="数字通信系统的有效性指标">1.5.1 数字通信系统的有效性指标</h4>
<ol type="1">
<li>码元传输速率<span class="math inline">\(R_B\)</span>
<ul>
<li>定义：每秒传输的码元个数</li>
<li>单位：波特(Baud)</li>
<li>计算：如一个码元的时间长度为<span class="math inline">\(T_s\)</span>秒，则<span class="math inline">\(R_B=\frac{1}{T_s}\)</span></li>
</ul></li>
<li>信息传输速率<span class="math inline">\(R_b\)</span>
<ul>
<li>定义：每秒传递的比特数(信息量)</li>
<li>单位：比特/秒(bit/s)简记为b/s,bps</li>
<li><span class="math inline">\(R_b与R_B\)</span>的关系：<span class="math inline">\(R_b=R_B\cdot log_2 M\)</span>(信息等概)，非等概时有<span class="math inline">\(R_b=R_B\cdot H\)</span></li>
</ul></li>
<li>频带利用率
<ul>
<li>定义：单位带宽内的传输速率</li>
<li><span class="math inline">\(\eta=\frac{R_B}{B}\)</span></li>
<li><span class="math inline">\(\eta_b=\frac{R_b}{B}\)</span></li>
<li><span class="math inline">\(\eta_b=\eta\cdot log_2M\)</span></li>
</ul></li>
</ol>
<h4 id="数字通信系统的可靠性指标">1.5.2 数字通信系统的可靠性指标</h4>
<ol type="1">
<li>误码率<span class="math inline">\(P_e=\frac{错误码元数}{传输总码元数}=\frac{N_e}{N}\)</span></li>
<li>误信率<span class="math inline">\(P_b=\frac{错误比特数}{传输总比特数}=\frac{I_e}{I_b}\)</span></li>
<li>在二进制中有<span class="math inline">\(P_b=P_e\)</span>,M进制有<span class="math inline">\(P_b&lt;P_e\)</span></li>
</ol>
<h2 id="第四章信道">第四章：信道</h2>
<p>信道可以分为物理信道和逻辑信道，本章主要讨论的是物理信道，物理信道可以从物理形态分类为有线信道和无线信道，按信道特性可以分为恒参信道和变参信道,其中恒参信道的特性不随时间变化，而随参信道的特性随时间随机变化。<strong>各种有线信道以及无线信道中的无线电中继和卫星通信等视线传播的信道属于恒参信道，其他各种无线信道都属于随参信道 </strong></p>
<h3 id="无有线信道信道的数学模型">4.1~3 无/有线信道&amp;信道的数学模型</h3>
<p>无线信道的的电磁波传播方式可分为地波，天波，视线传播，主要划分依据是频率的大小，其中为了增大视线传播距离，采用微波中继，卫星中继，平流层通信等手段。</p>
<p>若讨论自由空间中电磁波在发射天线和接受天线间的传播损耗<span class="math inline">\(L_{fr}\)</span>，可以不加证明的给出如下公式 <span class="math display">\[L_{fr}=\frac{P_T}{P_R}=\frac{16\pi^2d^2}{\lambda^2G_TG_R},\lambda:波长,P_{T/R}:发射机输出/入功率,d:距离\]</span></p>
<p>有线信道主要包括明线/对称电缆/同轴电缆/光纤</p>
<p>信道进一步可分为侠义信道和广义信道，前面提到的无线/有限信道均属于狭义信道，而广义信道则可分为调制信道与编码信道，分别研究调制/解调问题与编码/译码问题。 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-28-21-38-03.png"></p>
<p>信道的数学模型也可进一步分为以下几类：</p>
<ol type="1">
<li>调制信道模型：叠加有噪声的线性时变/时不变网络</li>
<li>编码信道模型：可用转移概率来描述</li>
</ol>
<h3 id="信道特性对信号传输的影响">4.4 信道特性对信号传输的影响</h3>
<p>对于恒参信道而言，其可认为为一个线性时不变系统，传输特性可表述为<span class="math inline">\(H(w)=|H(w)e^{j\psi(w)}|\)</span>,若想实现无失真传输，则幅频特性<span class="math inline">\(|H(w)|=K\)</span>,相频特性<span class="math inline">\(\psi(w)=wt_d\)</span>,当系统不满足上面的条件时，会对应的产生幅频失真和相频失真(也叫色散)</p>
<p>当信道的振幅-频率特性不理想，则信号发生的失真称为频率失真，信号的频率失真会使信号的波形发生畸变，这种畸变会引起相邻码元间发生部分重叠，造成码间串扰</p>
<p>对于随参信道(传输特性随时间随机快变)而言，主要会产生多径效应，具体来说是多径传播会使信号产生瑞利型衰落，并引起频率弥散，多径传播对一个复杂信号来说会导致信道对信号不同的频率成分有不同的衰减--频率选择性衰落，对于宽带信号来说，若信号带宽大于<span class="math inline">\(1/\tau,\tau\)</span>:信道最大相关带宽，则必然出现强烈的衰落，为了使信号基本不受多径传播的影响，要求信号的带宽小于多径信道的相关带宽，减小衰落的措施一般是使信号带宽<span class="math inline">\(B_s=(1/3\sim 1/5)\Delta f\)</span>(工程上公式)</p>
<h3 id="信道噪声">4.5 信道噪声</h3>
<p>噪声类型按噪声来源可分为人为噪声，自然噪声，内部噪声；按噪声性质可分为脉冲噪声，窄带/单频噪声，起伏噪声</p>
<h3 id="信道容量">4.6 信道容量</h3>
<p>离散信道容量不做要求，主要讲述连续信道容量，有信息论知识可知，白噪声背景下的连续信道容量为<span class="math inline">\(C=Blog_2(1+\frac{S}{N})(b/s)==Blog_2(1+\frac{S}{n_0B})(b/s),when \quad B\rightarrow \infty, C\approx1.44\frac{S}{n_0}\)</span>,S:信号平均功率(W),带宽B(Hz),<span class="math inline">\(n_0\)</span>:噪声单边功率谱密度,<span class="math inline">\(N=n_0B\)</span>:噪声功率(W)</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第七章知识小结</title>
    <url>/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<p>数字调制是指用数字基带信号控制载波某个参数的过程，数字带通传输系统是指包括调制/解调过程的数字传输系统</p>
<h2 id="二进制数字调制原理">7.1 二进制数字调制原理</h2>
<h3 id="二进制振幅键控2ask">7.1.1 二进制振幅键控(2ASK)</h3>
<p>原理<span class="math inline">\(s(t)\rightarrow\)</span>载波幅度，表达式<span class="math display">\[e_{2ASK}(t)=s(t)cosw_ct,s(t)=\sum_na_ng(t-nT_s)\\a_n=\begin{cases}
    +1,P\\0,(1-P)
\end{cases}\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-32-10.png"></p>
<p>2ASK的产生主要是采用模拟调制法和键控法，其解调可以采用包络检波法和相干解调法，包络检波法的各点波形如下： <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-33-45.png"></p>
<h3 id="二进制频移键控2fsk">7.1.2 二进制频移键控(2FSK)</h3>
<p>原理<span class="math inline">\(s(t)\rightarrow\)</span>载波频率，表达式<span class="math display">\[e_{2FSK}=s_1(t)cosw_1t+s_2(t)cosw_2t\\s_1(t)=\sum_na_ng(t-nT_s),s_2(t)=\sum_n\overline{a_n}g(t-nT_s)\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-36-08.png"></p>
<p>2FSK的产生主要也是采用模拟调频法和键控法，其解调也采用包络检波法和相干解调法 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-37-30.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-38-02.png"></p>
<h3 id="二进制相移键控2psk">7.1.3 二进制相移键控(2PSK)</h3>
<p>原理<span class="math inline">\(s(t)\rightarrow\)</span>载波相位，表达式<span class="math display">\[e_{2PSK}(t)=Acos(w_ct+\psi_n),\psi_n=\begin{cases}
    0,发0时,P\\
    \pi,发1时,1-P
\end{cases}\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-41-02.png"> 2PSK产生主要采用模拟调制法和键控法，解调采用相干解调 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-44-46.png"></p>
<h3 id="二进制差分相移键控">7.1.4 二进制差分相移键控</h3>
<p>原理：利用前后相邻码元的载波相对相位表示信息，<span class="math display">\[\delta \psi=\psi_n-\psi_{n-1}=\begin{cases}
    0\rightarrow0\\
    \pi\rightarrow1
\end{cases}\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-48-04.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-48-28.png"> 2DPSK的解调有以下两种方法 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-14-54-32.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-14-54-52.png"></p>
<h3 id="二进制数字已调信号的功率谱psd">7.1.5 二进制数字已调信号的功率谱(PSD)</h3>
<ol type="1">
<li>2ASK信号的功率谱密度：<span class="math inline">\(P_{2ASK}(f)=\frac{1}{4}[P_s(f+f_c)+P_s(f-f_c)]\)</span>，可见<span class="math inline">\(P_{2ASK}(f)\)</span>是<span class="math inline">\(P_s(f)\)</span>的线性搬移(属于线性调制)，且其带宽是基带信号带宽的两倍<span class="math inline">\(B_{2ASK}=2f_B=2R_B\)</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-14-58-38.png"></li>
<li>2PSK信号的功率谱密度与2ASK一致，频谱的区别仅在于当P=0.5时，谱中无离散谱(载波分量)，且其带宽也是基带信号带宽的两倍 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-01-51.png"></li>
<li>2FSK信号的功率谱密度：<span class="math inline">\(P_{2FSK}(f)=\frac{1}{4}[P_{s_1}(f-f_1)+P_{s_1}(f+f_1)+P_{s_2}(f-f_2)+P_{s_2}(f+f_2)]\)</span>,谱零点带宽<span class="math inline">\(B_{2FSK}\approx|f_2-f_1|+2f_B\)</span></li>
</ol>
<h2 id="二进制数字调制系统的抗噪声性能">7.2 二进制数字调制系统的抗噪声性能</h2>
<p>性能指标:系统的误码率<span class="math inline">\(P_e\)</span>,分析方法借用数字基带系统方法与结论，分析条件时恒参信道，信道噪声是加性高斯白噪声，分析过程与基带信号类似，在7.3中直接给出结论</p>
<h2 id="二进制数字调制系统的性能比较">7.3 二进制数字调制系统的性能比较</h2>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-07-54.png"></p>
<ol type="1">
<li>在r一定时，相同解调方式下，抗高斯白噪声性能优劣顺序为2PSK,2DPSK,2FSK,2ASK</li>
<li><span class="math inline">\(P_e\)</span>一定时，所需的信噪比:<span class="math inline">\(r_{2ASK}=2r_{2FSK}=4r_{2PSK}\)</span></li>
<li>r一定时,相同调制方式下：<span class="math inline">\(P_{e相干}&lt;P_{e非相关}\)</span>，大信噪比时(r&gt;&gt;1)，二者性能 相差不大</li>
</ol>
<p><strong>频带带宽--有效性</strong>：设基带信号的谱零点带宽<span class="math inline">\(R_B=1/T_s\)</span>，则有<span class="math display">\[B_{2ASK}=B_{2PSK}=B_{2DPSK}=2R_B=\frac{2}{T_s},B_{2FSK}=|f_2-f_1|+\frac{2}{T_s}\]</span>只有2FSK的带宽不仅与基带信号带宽有关，还与两个载频之差有关，在<span class="math inline">\(R_B\)</span>一定时，2FSK的频带利用率最低，有效性最差</p>
<p><strong>对信道特性变化的敏感性</strong>：2ASK易受信道参数变化的影响，不适于在变参信道中传输，2PSK不易受信道参数变化的影响，2FSK不需要认为设置判决门限，对信道变化不敏感，适用于变参信道传输场合</p>
<p><strong>设备复杂度</strong>：非相干方式一般比相干方式简单</p>
<h2 id="多进制数字调制原理">7.4 多进制数字调制原理</h2>
<p>因为在<span class="math inline">\(R_b\)</span>一定时，增加进制数M，可以降低<span class="math inline">\(R_B\)</span>，从而减小信号带宽，节约信道频率资源，<span class="math inline">\(R_B\)</span>一定时，增加进制数M，可以增大<span class="math inline">\(R_b\)</span>,从而在相同带宽内传输更多比特的信息，<strong>本质上使用多进制数字调制的原因是为了提高信道的频带利用率</strong>，代价是会导致误码率增大，系统变复杂，种类有MASK,MFSK,MDPSK,MQAM</p>
<h3 id="多进制振幅键控mask">7.4.1 多进制振幅键控(MASK)</h3>
<p>MASK可看为二进制振幅键控(2ASK)的推广，其可表示为<span class="math display">\[e_{MASK}(t)=\sum_{n=1}^Ma_ng(t-nT_s)cosw_ct,a_n=\begin{cases}
    0,以频率P_1\\
    1,以频率P_2\\
    \vdots\\
    M_1,以频率P_M
\end{cases},\sum_{i=1}^MP_i=1\]</span> MASK调制：与2ASK产生方法相似，区别在于发送端输入的二进制基带信号需要先经过电平变换器转换为M电平的基带脉冲，然后再去调制，MASK解调与2ASK解调也相似，功率谱与2ASK形式相似，谱零点带宽<span class="math inline">\(B=2R_B=\frac{2R_b}{log_2 M},B=\frac{2}{T_B}=\frac{2}{T_b\cdot log_2M}\)</span>,在<span class="math inline">\(R_b\)</span>相同时，MASK信号带宽是2ASK的<span class="math inline">\(1/log_2M\)</span>倍，但其抗噪能力差，常用多进制正交振幅调制(MQAM)代替</p>
<h3 id="多进制频移键控mfsk">7.4.2 多进制频移键控(MFSK)</h3>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-35-17.png"> MFSK可视为2FSK方式的推广，要求载频之间距离足够大，以便用滤波器分离不同频率的谱，其占用较宽的频带，但其信道频带利用率不高，<span class="math inline">\(B=|f_M-f_1|+\frac{2}{T_B}\)</span>,一般被用于调制速率不高的衰落信道传输</p>
<h3 id="多进制相移键控mpsk">7.4.3 多进制相移键控(MPSK)</h3>
<p>利用载波的M种不同相位表示数字信息，也可用信号矢量图(星座图)来表示 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-39-13.png"> M增大，多相制信号可在相同的带宽中传输更多比特的信息，从而提高频带利用率，且相邻信号点的距离会逐渐减小，导致抗噪性能下降，设备复杂</p>
<p>4PSK也叫正交相移键控(QPSK),利用载波四种不同相位表示数字信息，可视为两个互为正交的2PSK信号合成，其调制可用正交调相法和相位选择法，解调的原理则是分解为两路PSK信号的相干解调，但存在90°的相位模糊，解决方法采用四相相对相位调制QDPSK <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-43-28.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-44-01.png"> 缺点是最大相位跳变180°，使得包络起伏很大，出现包络零点，频谱扩展大，旁瓣对邻道干扰大，改进思路是改为OQPSK(不要求)</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第五章知识小结</title>
    <url>/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="幅度调制线性调制原理">5.1 幅度调制(线性调制)原理</h2>
<p>线性调制原理与通信电子线路课程中大致类似，可参见<a href="https://xiazhi1.github.io/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/">通信电子线路第六章知识小结</a></p>
<h3 id="单边带调制ssb">5.1.3 单边带调制(SSB)</h3>
<p>通信原理课程中详细讲述了SSB信号的产生，而通信电子线路课程对此要求不高，故进行补充</p>
<p>SSB信号的产生主要可以分为滤波法和相移法</p>
<ol type="1">
<li>滤波法 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-24-10-17-57.png"> 原理是需要先形成DSB信号，边带滤波即可得上或下边带信号，这要求滤波器<span class="math inline">\(H_{SSB}(w)\)</span>在载频处具有陡峭的截止特性，这也是滤波法的技术难点之一</li>
<li>相移法 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-24-10-20-11.png"> 要求掌握推导流程，设<span class="math inline">\(m(t)=A_mcosw_mt\)</span>,载波<span class="math inline">\(c(t)=cosw_ct\)</span>,则<span class="math inline">\(S_{DSB}(t)=A_mcosw_mt\cdot cosw_ct=\frac{1}{2}A_mcos(w_c-w_m)t+\frac{1}{2}A_mcos(w_c+w_m)t\\S_{USB(LSB)}(t)=\frac{1}{2}A_mcos(w_c\pm w_m)t=\frac{1}{2}m(t)cosw_ct\mp \frac{1}{2}\widehat{m(t)}sinw_ct\)</span>,<span class="math inline">\(\widehat{m(t)}\)</span>是<span class="math inline">\(m(t)\)</span>的希尔伯特变换--幅度不变，相移<span class="math inline">\(\pi/2\)</span> <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-24-10-30-46.png"> 相移法的技术难点是<span class="math inline">\(H_h(w)\)</span>难以对<span class="math inline">\(m(t)\)</span>的所有频率分量精确相移$/2 $</li>
</ol>
<p>其中DSB/SSB/VSB均是抑制载波的已调信号，不能采用简单的包络检波解调，AM信号可以采用，以上所有提到的线性调制方式都可以用相干解调方式解调</p>
<h2 id="线性调制系统的抗噪声性能">5.2 线性调制系统的抗噪声性能</h2>
<h3 id="模型与指标">5.2.1 模型与指标</h3>
<p>分析模型 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-18-21-44-04.png"></p>
<p>性能指标：</p>
<p>输出信噪比：<span class="math inline">\(\frac{S_o}{N_o}=\frac{\overline{s_i^2(t)}}{\overline{n_i^2(t)}}\)</span> 制度增益：<span class="math inline">\(G=\frac{S_o/N_o}{S_i/N_i}\)</span>,G越大，该调制系统的抗噪性能越好</p>
<h3 id="dsb-相干解调系统的抗噪性能">5.2.2 DSB-相干解调系统的抗噪性能</h3>
<p>推导过程不要求，故略过，直接给出结论，注意下面所有的<span class="math inline">\(n_0\)</span>都表示白噪声的单边功率谱密度，若题目给出的是双边功率谱密度，则需要乘2得到单边功率谱密度</p>
<p><span class="math inline">\(S_i=\frac{1}{2}\overline{m^2(t)},N_i=n_0B,S_o=\frac{1}{4}\overline{m^2(t)},N_o=\frac{1}{4}N_i\Rightarrow G_{DSB}=2\)</span></p>
<h3 id="ssb-相干解调系统的抗噪性能">5.2.3 SSB-相干解调系统的抗噪性能</h3>
<p>推导过程不要求，故略过，直接给出结论</p>
<p><span class="math inline">\(S_i=\frac{1}{4}\overline{m^2(t)},N_i=n_0B,S_o=\frac{1}{16}\overline{m^2(t)},N_o=\frac{1}{4}N_i\Rightarrow G_{SSB}=1\)</span></p>
<p>但是不能说DSB系统的抗噪声性能优于SSB系统，因为DSB的带宽是SSB带宽的两倍，换算到相同的<span class="math inline">\(S_i,n_0,f_H\)</span>条件下，DSB与SSB的抗噪声性能相同</p>
<h3 id="am包络检波系统的抗噪声性能">5.2.4 AM包络检波系统的抗噪声性能</h3>
<ol type="1">
<li><p>大信噪比时有<span class="math inline">\(G_{AM}=\frac{2\overline{m^2(t)}}{A_0^2+\overline{m^2(t)}}\)</span>,因为<span class="math inline">\(|m(t)|_{max}\le A_0\rightarrow G_{AM}&lt;1\)</span>,当100%调制时，且<span class="math inline">\(m(t)\)</span>为单频正弦时，<span class="math inline">\(G_{AM}=\frac{2}{3}\)</span></p></li>
<li><p>小信噪比时，信号被扰乱成噪声，导致输出信噪比急剧恶化--门限效应，其是由包络检波器的非线性解调作用引起的</p></li>
</ol>
<h2 id="非线性调制角度调制原理">5.3 非线性调制(角度调制)原理</h2>
<p>其基本原理与通信电子线路课程要求一致，可参见<a href="https://xiazhi1.github.io/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/">通信电子线路第七章知识小结</a></p>
<p>其中主要补充一下窄带调频和宽带调频，窄带调频是指当调频信号的瞬时相偏满足<span class="math inline">\(|\psi(t)|_{max}=|K_F\int m(t)\, {\rm d}t|_{max}\le\frac{\pi}{6}\)</span>,反之则为宽带调频</p>
<h2 id="调频系统的抗噪声性能">5.4 调频系统的抗噪声性能</h2>
<p>大信噪比时，经过推导可得<span class="math inline">\(G_{FM}=3m_f^2(m_f+1)\)</span>，又因为B与<span class="math inline">\(m_f\)</span>成正比,所以可用通过增加传输带宽来改善FM系统的抗噪声性能，但是这种做法并不是无止境的</p>
<p>小信噪比时也会产生门限效应，在门限值以上时，<span class="math inline">\((S_o/N_o)_{FM},(S_i/N_i)_{FM}\)</span>呈线性关系，且<span class="math inline">\(m_f\)</span>越大，输出信噪比改善越明显，在门限值以下，二者不再是线性关系，而是随<span class="math inline">\((S_i/N_i)_{FM}\)</span>的下降而急剧下降</p>
<p>为了提高高频信号的信噪比，往往在FM系统两端应用预加重和去加重技术</p>
<h2 id="各种模拟调制系统的比较">5.5 各种模拟调制系统的比较</h2>
<p>所有系统在“同等条件”下进行比较：解调器输入功率均为<span class="math inline">\(S_i\)</span>,信道噪声均值为0,单边功率谱密度为<span class="math inline">\(n_0\)</span>,基带信号带宽为<span class="math inline">\(f_m\)</span>,其中AM调幅度为100%,正弦型调制信号</p>
<p><img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-09-58-55.png"> <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-09-59-15.png"> <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-09-59-27.png"></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第八九章知识小结</title>
    <url>/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第八章知识点较少，将其与第九章合并，本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="第八章新型数字带通调制技术">第八章：新型数字带通调制技术</h2>
<h3 id="正交振幅调制">8.1 正交振幅调制</h3>
<p>正交振幅调制(QAM)是一种振幅与相位联合键控的数字调制技术，宽带通信采用高阶调制的原因是因为在有限带宽下增大M能提升频带利用率，所以要想在有限带宽下实现高速率通信，必须采用高阶调制，高阶调制采用QAM的原因是因为如果简单的采用MPSK，在信号幅度相等即概率相等的条件下，进制数M增加，星座图相邻信号点的距离减小，意味着在相同噪声条件下，系统误码率增大，而QAM的设计就是通过重新安排信号点的位置，增大相邻信号点的距离 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-28-42.png"></p>
<p><span class="math display">\[d_1=\frac{\sqrt{2}A_M}{3}=0.47A_M,d_2=2A_Msin(\frac{\pi}{16})=0.39A_M\]</span> 从上式看出<span class="math inline">\(d_1&gt;d_2\)</span>,表明16QAM比16PSK的噪声容限大，抗噪能力强 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-31-31.png"></p>
<p>在QAM中，其码元可表示为 <span class="math display">\[e_k(t)=A_kcos(w_ct+\theta_k),kT_B&lt;t\le(k+1)T_B\\\rightarrow e_k(t)=X_kcosw_ct+Y_ksinw_ct,X_k=A_kcos\theta_k,Y_k=-A_ksin\theta_k\]</span> 这表明MQAM信号可由两路载波正交<span class="math inline">\(\sqrt{M}\)</span>的ASK信号叠加而成 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-36-52.png"> 由上图可知16QAM编码与星座坐标的关系，如果将四位编码记为<span class="math inline">\({a_1a_2b_1b_2}\)</span>,可知任意相邻两点编码的码距达到最小值；横坐标相同的点，<span class="math inline">\(a_1a_2\)</span>编码相同;纵坐标相同的点，其<span class="math inline">\(b_1b_2\)</span>编码相同</p>
<p>16QAM信号调制的原理框图如下图所示 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-40-28.png"></p>
<p>其产生可大致划分为两种方法</p>
<ol type="1">
<li>正交调幅法：用两路正交的4ASK信号叠加，即可形成16QAM信号</li>
<li>复合相移法：用两路独立的QPSK信号叠加，即可形成16QAM信号</li>
</ol>
<p>16QAM信号的解调往往采用正交相干解调</p>
<p>MQAM信号的谱零点带宽:<span class="math inline">\(B_{MQAM}=2R_B=\frac{2R_b}{log_2M}\)</span>,频带利用率<span class="math inline">\(\eta_{MQAM}=\frac{R_b}{B}=\frac{1}{2}log_2M(bps/Hz)\)</span></p>
<p>在实际中，往往需要对转换后的信号进行脉冲成形滤波，以抑制已调信号的带外辐射，滤波器通常采用滚降系数为<span class="math inline">\(\alpha\)</span>的升余弦滤波器，此时MQAM的带宽可表述为<span class="math inline">\(B=(1+\alpha)R_B=\frac{(1+\alpha)R_b}{log_2M}\)</span>,频带利用率<span class="math inline">\(\eta_b=\frac{log_2M}{(1+\alpha)}\)</span></p>
<h3 id="最小频移键控">8.2 最小频移键控</h3>
<p>最小频移键控MSK是2FSK的改进型，是一种包络恒定，相位连续，带宽最小且严格正交的2FSK信号，使频差最小的目的是为了减小带宽，提高频带利用率，使相位连续的目的是为了实现恒定包络，从而加速带外功率谱密度下降速度</p>
<h4 id="正交2fsk信号的最小频率间隔">8.3.1 正交2FSK信号的最小频率间隔</h4>
<p>有前面的学习，我们知道<span class="math inline">\(B_{2FSK}=|f_2-f_1|+2f_b\)</span>,可见在码元速率不变的时候,<span class="math inline">\(|f_2-f_1|\)</span>越小越好，单不能无限小，因为在接收端要能区分<span class="math inline">\(f_1,f_2\)</span>才能正确解调，通常区分的方法有两种，滤波器法和正交法</p>
<p>经过推导可知非相干接收方法下，满足正交条件的最小频率间隔为<span class="math inline">\((f_1-f_0)_{min}=1/T_B\)</span>，而对于相干接受方法，保证正交的2FSK信号的最小频率间隔为<span class="math inline">\((f_1-f_0)_{min}=1/2T_B\)</span></p>
<h3 id="正交频分复用">8.3 正交频分复用</h3>
<h4 id="概述">8.3.1 概述</h4>
<p>由于单载波调制存在高速数据信号的码元持续时间<span class="math inline">\(T_B\)</span>短，但占用带宽B大，容易产生码间串扰和频率选择性衰落，而多载波调制能通过将信道划分为N个子信道，高速的在N路低速子数据流上串并传输，并分别调制到各子载波上并行传输</p>
<p>OFDM(正交频分复用)就是一种多载波并行调制体制，设计思路是将高速数据流分散到多个子载波上并行传输，从而使各子载波的信号速率大为降低，且因为子信道带宽小于信道相关带宽，意味着每个子信道可以看出平坦性衰落，从而可以消除ISI，提高抗多径和抗衰落能力，缺点是对信道频率偏移和相位噪声非常敏感，信号峰值频率与平均功率比值较大，将会降低射频功率放大器效率，对同步要求严格</p>
<h4 id="ofdm的基本原理">8.3.2 OFDM的基本原理</h4>
<ol type="1">
<li>表示式：<span class="math inline">\(e(t)=\sum_{k=0}^{N-1}B_ke^{j(2\pi f_kt+\psi_k)},B_k\)</span>为复数，第k路子信道复输入数据</li>
<li>正交条件：只要满足最小子载频间隔为<span class="math inline">\(\Delta f_{min}=1/T_B\)</span></li>
<li>频域特性：频谱相互重叠，但在一个码元持续时间内正交，即减小子载波间相互干扰又提高了频谱利用率，可按照各个子载波所处频段的信道特性采用不同的调制制度，有很大的灵活性</li>
<li>频带利用率：设OFDM系统有N路子载波，子信道码元间隔为<span class="math inline">\(T_B\)</span>，均采用M进制调制，则其占用的频带宽度为<span class="math inline">\(B_{OFDM}=\frac{N+1}{T_B}\)</span>,频带利用率为<span class="math inline">\(\eta_{OFDM}=\frac{R_b}{B_{OFDM}}=\frac{N}{N+1}log_2M(bps/Hz)\)</span>,当N很大，<span class="math inline">\(\eta_{OFDM}\approx log_2M(bps/Hz)\)</span>,若是单载波，频带利用率为<span class="math inline">\(\eta_b=\frac{1}{2}log_2M\)</span>，这表明并行OFDM比串行单载波频带利用率大约提高一倍</li>
</ol>
<h2 id="第九章数字信号的最佳接收">第九章：数字信号的最佳接收</h2>
<p>信道特性不理想与信道噪声等会直接影响接收系统的性能，一个通信系统质量的优劣在很大程度上取决于接收系统的性能</p>
<p>本章节的研究目的就是在噪声的干扰下，如何最佳地接收有用信号，使接受性能达到最优</p>
<h3 id="确知数字信号的最佳接收机">9.3 确知数字信号的最佳接收机</h3>
<p>本节主要是关注构建二进制最佳接收机的原理方框图 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-12-35-04.png"> <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-12-35-29.png"></p>
<h3 id="确知数字信号最佳接收的误码率">9.4 确知数字信号最佳接收的误码率</h3>
<p>推导过程不要求，只研究其误码率公式以及推出的结论 总误码率可表示为<span class="math display">\[P_e=P(1)\frac{1}{\sqrt{2\pi}\sigma_\xi}\int_{-\infty}^a e^{-\frac{x^2}{2\sigma^2_\xi}}dx+P(0)\frac{1}{\sqrt{2\pi}\sigma_\xi}\int_{-\infty}^b e^{-\frac{x^2}{2\sigma^2_\xi}}dx\]</span> 当先验概率P(0),P(1)有一个为1，一个为0时，总误码率都为0，当先验概率相等为0.5时，a=b,则上式可简化为 <span class="math display">\[P_e=\frac{1}{\sqrt{2\pi}\sigma_\xi}\int_{-\infty}^c e^{-\frac{x^2}{2\sigma^2_\xi}}dx,c=-\frac{1}{2}\int_0^{T_B}[s_0(t)-s_1(t)]^2dt\]</span> 可见：误码率仅和两种码元的波形之差的能量有关，而与波形本身无关，差别越大，c值越小，误码率<span class="math inline">\(P_e\)</span>也越小</p>
<p>进一步推导有如下表格 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-13-01-54.png"></p>
<p>对于多进制通信系统而言，其误码率的计算与二进制类似，每个比特的能量<span class="math inline">\(E_b=E/log_2M\)</span>,每个比特的信噪比<span class="math inline">\(\frac{E_b}{n_0}=\frac{E}{n_0k}\)</span></p>
<h3 id="实际接收机与最佳接收机的性能比较">9.7 实际接收机与最佳接收机的性能比较</h3>
<p><img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-13-03-45.png"></p>
<p>实际接收机:<span class="math inline">\(r=\frac{S}{N}=\frac{S}{n_0B}\)</span>,最佳接收机:<span class="math inline">\(\frac{E_b}{n_0}=\frac{ST}{n_0}=\frac{S}{n\frac{1}{T_B}}\)</span></p>
<p>在S和<span class="math inline">\(n_0\)</span>相同的条件下，<span class="math inline">\(r\sim \frac{E_b}{n_0}\rightarrow B\sim \frac{1}{T_B}\)</span></p>
<p>极限时，<span class="math inline">\(B=\frac{1}{T_B}\)</span>,最佳接收机与实际接收机性能相同，实际上不可能实现，<span class="math inline">\(B&gt;\frac{1}{T_B}\)</span>，这意味着最佳接收机优于实际接收机的性能</p>
<h3 id="数字信号的匹配滤波接收法">9.8 数字信号的匹配滤波接收法</h3>
<h4 id="匹配滤波器的传输特性">9.8.1 匹配滤波器的传输特性</h4>
<p>匹配滤波器是一种能在抽样时刻上获得最大输出信噪比的线性滤波器，其设计目标是通过设计<span class="math inline">\(H(w)\)</span>使其输出信噪比<span class="math inline">\(r_o\)</span>在抽样时刻<span class="math inline">\(t_0\)</span>有最大值</p>
<p>经过一系列复杂的推导，得出的结论是当且仅当<span class="math inline">\(H(f)=kS^*(f)e^{-j2\pi ft_0}\)</span>获得最大信噪比<span class="math inline">\(r_{omax}=\frac{2E}{n_o}\)</span>,此时的H(f)即为最佳接收滤波器的传输特性，等于输入信号码元频谱S(f)的复共轭，故称此滤波器为匹配滤波器，此时的<span class="math inline">\(h(t)=ks(t_0-t)\)</span>,这表明h(t)就是输入信号s(t)的镜像s(-t)在时间轴上平移(右移<span class="math inline">\(t_0\)</span>)--通常取<span class="math inline">\(t_0=T_B\rightarrow h(t)=s(T_B-t)\)</span></p>
<h4 id="匹配滤波器的输出信号">9.8.2 匹配滤波器的输出信号</h4>
<p><span class="math inline">\(s_o(t)=kR(t-t_0),k=1\rightarrow R(t-t_0)\)</span>,当<span class="math inline">\(t=t_0\)</span>时，<span class="math inline">\(max[s_o(t)]=s_o(t_0)=R(0)=E\)</span>,这意味着匹配滤波器可看成是一个计算输入信号自相关函数的相关器，在上面的讨论中并没有涉及信号的波形，这意味着最大信噪比与信号波形无关，所以匹配滤波接收法对基带数字信号和已调数字信号都适用</p>
<h4 id="匹配滤波形式的最佳接收机">9.8.3 匹配滤波形式的最佳接收机</h4>
<p><img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-14-04-53.png"></p>
<h3 id="最佳基带传输系统">9.9 最佳基带传输系统</h3>
<h4 id="理想信道下的最佳基带系统">9.9.1 理想信道下的最佳基带系统</h4>
<p>设理想信道<span class="math inline">\(C(w)=1\)</span>,则系统传输总特性<span class="math inline">\(H(w)=G_T(w)C(w)G_R(w)=G_T(w)G_R(w)\)</span>,最佳化的两个条件，H(w)满足无码间串扰的频域条件，<span class="math inline">\(\sum_i H(w+\frac{2\pi i}{T_B})=C(常数),|w|\le\frac{\pi}{T_B}\)</span>;使系统输出差错概率最小，联立两个条件，可解出<span class="math inline">\(G_R(w)=H^{1/2}(w),G_T(w)=H^(1/2)(w)\)</span> <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-14-10-02.png"></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第六章知识小结</title>
    <url>/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="数字基带信号及其频谱特性">6.1 数字基带信号及其频谱特性</h2>
<h3 id="数字基带信号">6.1.1 数字基带信号</h3>
<p>数字基带信号是指未经调制的数字信号，所占据的频谱从零频或很低频率开始的，数字基带传输系统是指不经载波调制而直接传输数字基带信号的系统，而下一章将讲述的数字带通传输系统则是包括调制和解调过程的传输系统 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-15-30-49.png"></p>
<p>在基带传输中的主要技术问题有以下几个：</p>
<ol type="1">
<li>基带传输系统通常存在隔直流电容或传输变压器，基带信号中的直流分量不能通过隔直流电容和变压器，克服措施--研究基带码的码型，寻求基本无直流分量的基带码</li>
<li>码元同步</li>
<li>码间串扰:前一码元波形拖尾干扰到后面若干个码元，克服措施--寻求合适的码元波形，使码间串扰不会引起接收判决错误；采用均衡技术，改善码元波形，减小码间串扰</li>
</ol>
<p>具体来说，数字基带信号又可分为单/双极性波形，单/双归零码，差分波形</p>
<h3 id="数字基带信号的频谱特性">6.1.2 数字基带信号的频谱特性</h3>
<p>数字基带信号可表示为<span class="math inline">\(s(t)=u(t)+v(t)\)</span>，其功率密度可表示为 <span class="math display">\[双边谱：P_s(f)=P_u(f)+P_v(f)=f_BP(1-P)|G_1(f)-G_2(f)|^2+\\\sum_{m=-\infty}^\infty|f_B[PG_1(mf_B)+(1-P)G_2(mf_B)]|^2\delta(f-mf_B)\]</span> <span class="math display">\[单边谱：P_s(f)=2f_BP(1-P)|G_1(f)-G_2(f)|^2+f_B^2|PG_1(0)+(1-P)G_2(0)|^2\delta(f)+\\2f_B^2\sum_{m=1}^\infty|[PG_1(mf_B)+(1-P)G_2(mf_B)]|^2\delta(f-mf_B)\]</span> 由此可以得出以下结论：1. 二进制随机脉冲序列的功率谱包含连续谱和离散谱(可能包含)；连续谱总是存在的，谱的形状取决于<span class="math inline">\(g_1(t),g_2(t)\)</span>频谱和出现概率P；离散谱是否存在也主要取决于以上三者</p>
<p>对于单极性NRZ和RZ矩形脉冲序列的功率谱，不加证明的给出结论(以下均默认P=0.5)</p>
<ol type="1">
<li>单极性NRZ频谱函数为<span class="math inline">\(P_s(f)=\frac{T_s}{4}Sa^2(\pi fT_s)+\frac{1}{4}\delta(f)\)</span></li>
<li>单极性RZ频谱函数为<span class="math inline">\(P_s(f)=\frac{T_s}{16}Sa^2(\frac{\pi fT_s}{2})+\frac{1}{16}\sum_{m=-\infty}^\infty Sa^2(\frac{m\pi}{2})\delta(f-mf_s)\)</span></li>
<li>双极性NRZ频谱函数为<span class="math inline">\(P_s(f)=T_BSa^2(\pi fT_B)\)</span></li>
<li>双极性RZ频谱函数为<span class="math inline">\(P_s(f)=\frac{T_B}{4}Sa^2(\frac{\pi}{2}fT_B)\)</span></li>
</ol>
<h2 id="基带传输的常用码型">6.2 基带传输的常用码型</h2>
<p>选码原则：无直流分量，且低频分量小；定时信息丰富；高频分量小；不受信源统计特性的影响；有自检能力；编译码简单</p>
<p>常用的传输波形有AMI码,<span class="math inline">\(HDB_3\)</span>码，双相码，CMI码，nBmB码，nBmT码</p>
<h2 id="数字基带信号传输与码间串扰">6.3 数字基带信号传输与码间串扰</h2>
<h3 id="系统组成与传输模型">6.3.1 系统组成与传输模型</h3>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-19-24-49.png"></p>
<h3 id="定量分析">6.3.2 定量分析</h3>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-19-25-41.png"> 基带传输总特性:<span class="math inline">\(H(w)=G_T(w)C(w)G_R(w)\)</span>,基带信号<span class="math inline">\(d(t)=\sum_{n=-\infty}^\infty a_n\delta(t-nT_B)\)</span>,接受滤波器输出信号为<span class="math inline">\(y(t)=d(t)*h(t)+n_R(t)=\sum_{n=-\infty}^\infty a_nh(t-nT_B)+n_R(t)\)</span>,设抽样时刻为<span class="math inline">\(t=kT_B+t_0\rightarrow a_kh(t_0)+\sum_{n\neq k}a_nh[(k-n)T_B+t_0]+n_R(kT_B+t_0)\)</span>,后两项为ISI值和噪声</p>
<h2 id="无码间串扰的基带传输特性">6.4 无码间串扰的基带传输特性</h2>
<h3 id="五码间串扰的条件">6.4.2 五码间串扰的条件</h3>
<p>消除码间串扰的基本思想是使得其他码元在当前码元的抽样判决点处值为0，由奈奎斯特准则知接收波形满足抽样值无失真传输的充要条件是码元仅在本码元的抽样时刻上有最大值，而其他所有码元在该时刻的串扰值均为0，其对应的时域条件为<span class="math display">\[h(kT_B)=\begin{cases}
    1,k=0\\
    0,else
\end{cases}\]</span> 频域条件<span class="math display">\[\sum_iH(w+\frac{2\pi i}{T_B})=T_B,|w|\le\frac{\pi}{T_B}\]</span></p>
<h3 id="hw的设计">6.4.3 H(w)的设计</h3>
<ol type="1">
<li><p>理想低通特性 <span class="math display">\[H(w)=\begin{cases}
 T_B,|w|\le\frac{\pi}{T_B}\\
 0,|w|&gt;\frac{\pi}{T_B}
\end{cases},h(t)=Sa(\frac{\pi}{T_B}t),B=\frac{1}{2T_B}=f_N,R_B=\frac{1}{T_B}=2f_N\]</span>其中B又被称为奈奎斯特带宽：无失真传输码元周期为<span class="math inline">\(T_B\)</span>的序列是所需的最小频带宽度，<span class="math inline">\(R_B\)</span>又被称为奈奎斯特速率：在带宽为<span class="math inline">\(f_N\)</span>的信道中无码间串扰的最高波特率,由此易得，无ISI基带系统的最高频带利用率<span class="math inline">\(\eta=R_B/B=2,\eta_b=R_b/B=2log_2M\)</span>,由上述公式可得以下重要结论：<strong>在无ISI的要求下，WHz宽的基带信道每秒最多只能传输2W个符号，无码间串扰要求<span class="math inline">\(\eta\le2 \quad or\quad\eta_b\le 2log_2M\)</span></strong>,理想低通传输特性主要存在的问题是特性陡峭不易实现，工程上广泛使用的是余弦滚降特性</p></li>
<li><p>余弦滚降特性 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-19-57-21.png"> 引入滚降系数来描述滚降程度<span class="math inline">\(\alpha=\frac{f_\Delta}{f_N}(0\sim1)\)</span>,进而可推出<span class="math display">\[B=f_N+f_\Delta=(1+\alpha)f_N,\eta=\frac{R_B}{B}=\frac{2}{1+\alpha},\eta_b=\frac{R_b}{B}=\frac{2log_2M}{1+\alpha}\]</span> <span class="math inline">\(\alpha\)</span>越大，<span class="math inline">\(h(t)\)</span>的拖尾衰减越快,<span class="math inline">\(\alpha=0\)</span>：理想低通特性，<span class="math inline">\(\alpha=1\)</span>，升余弦频谱特性，其特点为特性易实现，代价是带宽增加，频率利用率降低</p></li>
</ol>
<h2 id="基带系统的抗噪声性能">6.5 基带系统的抗噪声性能</h2>
<p>本节主要讨论：在无码间串扰的条件下， 噪声对基带信号传输的影响， 即计算噪声引起的误码率，公式考试使会给出，主要掌握其结论 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-20-03-24.png"> 上图表面，当比值<span class="math inline">\(A/\sigma_n\)</span>一定时，双极性基带系统的误码率比单极性的低，抗噪声性能好；在等概条件下，双极性的最佳判决门限电平为0，与信号幅度无关，因而不随信道特性变化而变，故能保持最佳状态。而单极性的最佳判决门限电平为A/2，它易受信道特性变化的影响，从而导致误码率增大；双极性基带系统比单极性基带系统应用更为广泛</p>
<h2 id="时域均衡">6.7 时域均衡</h2>
<p>均衡是指对信号在传输过程的非线性失真进行校正，均衡器设计的两个基本途径分别是频域均衡和时域均衡，分别处理频域与时域，使系统无码间串扰，目的都是消除或减小码间串扰</p>
<p>具体来说，时域均衡的目标使调整各增益加权系数<span class="math inline">\(C_i\)</span>,使得除<span class="math inline">\(k=0\)</span>外，y(t)在奈氏各取样点上的值均为0，消除了码间干扰,<span class="math display">\[y_k=\sum_{i=-N}^Nc_ix_{k-i}=\begin{cases}
    1,k=0\\
    0,k\neq0
\end{cases}\]</span> 均衡效果的评价一般采用峰值失真和均方失真<span class="math display">\[D=\frac{1}{y_0}\sum_{k=-\infty,k\neq0}^\infty|y_k|,e^2=\frac{1}{y_0^2}\sum_{k=-\infty,k\neq0}^\infty y_k^2\]</span>,实际应用中常用迫零调整法 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-20-13-57.png"></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第十十三章知识小结</title>
    <url>/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第十三章知识点较少，将其与第十章合并，本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="第十章信源编码">第十章：信源编码</h2>
<h3 id="引言">10.1 引言</h3>
<p>信源编码的作用十进行压缩编码和模数转换，进行数字化编码的技术主要有波形编码和参量编码，我们主要讨论的是波形编码，波形编码的三个步骤包括：抽样，量化和编码，不常用的方法是PCM,DPCM,<span class="math inline">\(\Delta M\)</span> <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-20-23-43.png"></p>
<h3 id="模拟信号的抽样">10.2 模拟信号的抽样</h3>
<h4 id="低通模拟信号的抽样定理">10.2.1 低通模拟信号的抽样定理</h4>
<p>最高频率小于<span class="math inline">\(f_H\)</span>的模拟信号m(t)可由其等间隔的抽样值唯一确定，抽样间隔<span class="math inline">\(T_S\)</span>或抽样速率<span class="math inline">\(f_S\)</span>应满足:<span class="math inline">\(T_S\le\frac{1}{2f_H},f_s\ge 2f_H\)</span>其中<span class="math inline">\(T_s,f_s\)</span>分别被称为奈奎斯特间隔与奈奎斯特速率</p>
<h4 id="带通模拟信号的抽样定理">10.2.2 带通模拟信号的抽样定理</h4>
<p>设带通型模拟信号m(t)的频率范围限制在<span class="math inline">\(f_L\le f\le f_H,且f_L&gt;B\)</span>,则最小抽样速率为<span class="math inline">\(f_s=2B(1+\frac{k}{n})\)</span>,其中<span class="math inline">\(B=f_H-f_L\)</span>,n为商<span class="math inline">\(f_H/B\)</span>的整数部分，k为商<span class="math inline">\(f_H/B\)</span>的小数部分</p>
<p>当<span class="math inline">\(f_L=0\)</span>时，<span class="math inline">\(f_s=2B=2f_H\)</span>--低通抽样情况，<span class="math inline">\(f_L\)</span>很大时，<span class="math inline">\(f_s\approx 2B\)</span></p>
<h3 id="模拟脉冲调制">10.3 模拟脉冲调制</h3>
<p>模拟脉冲调制主要可以分为PAM,PDM,PPM,分别变化脉冲高度，宽度，位置，本章主要讨论的是PAM,PAM可分为两种实际抽样，自然抽样的PAM和平顶抽样的PAM,自然抽样的特点是样值脉冲的幅度随原信号m(t)的幅度而变，平顶抽样的特点是每个样值脉冲的顶部是平坦的</p>
<h3 id="模拟信号的量化">10.4 模拟信号的量化</h3>
<h4 id="量化原理">10.4.1 量化原理</h4>
<p>量化原理可表述为用有限个量化电平表示无限个抽样值 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-20-44-10.png"></p>
<h4 id="均匀量化">10.4.2 均匀量化</h4>
<p>均匀量化意味着等间隔的划分输入信号的取值域 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-20-45-29.png"></p>
<p>量化器的性能指标中，信号量噪比<span class="math inline">\(S/N_q\)</span>是重要的一个设计指标</p>
<p>量化噪声概率<span class="math inline">\(N_q=E[(m_k-m_q)^2]=\int_a^b(x-m_q)^2f(x)dx\)</span></p>
<p>信号<span class="math inline">\(m_k\)</span>的平均功率<span class="math inline">\(S=E[(m_k)^2]=\int_a^bx^2f(x)dx\)</span></p>
<p>信号量噪比--信号功率与量化噪声功率之比<span class="math inline">\(\frac{S}{N_q}=\frac{E[m_k^2]}{E[(m_k-m_q)^2]}\)</span></p>
<p>输入信号均匀分布的最佳量化器是均匀量化器，其特点是<span class="math inline">\(N_q\)</span>与信号统计特性无关，仅取决于<span class="math inline">\(\Delta\)</span>,其缺点体现在当信号小时，信号量噪比也小，往往达不到要求，相当于限制了输入信号的动态范围，在电话传输中需要信号量噪比较高，这意味着需要的编码位数多，导致编码信号的带宽增大，且编码设备复杂，为了解决这些问题，引入了下一节的非均匀量化</p>
<h4 id="非均匀量化">10.4.3 非均匀量化</h4>
<p>设计思想：信号样值小，<span class="math inline">\(\Delta V\)</span>也小，信号样值大，<span class="math inline">\(\Delta V\)</span>也大；实现方法是对信号先压缩再进行均匀量化然后进行扩张，压缩的目的是提高小信号的量噪比</p>
<p>其实现均采用对数量化，实现方法是先压缩原始抽样值(非线性变换)，再均匀量化，国际上用的两种对数压缩特性标准，<span class="math inline">\(\mu\)</span>率和A率，本章主要讨论A率，二者间的区别是A压缩率采用的是13折线近似法，而<span class="math inline">\(\mu\)</span>率采用的是15折线近似法</p>
<p>A压缩率的表达式为 <span class="math display">\[y=\begin{cases}
    \frac{Ax}{1+lnA},0\le x\le \frac{1}{A}\\
    \frac{1+lnAx}{1+lnA},\frac{1}{A}\le x \le 1
\end{cases}\]</span> A用于决定压缩程度，A=1时无压缩效果，实用中A=87.6，用87.6的原因时使压缩曲线在原点附近斜率凑成16，使13折线逼近时，x的八个段落量化分界点近似于按2的幂次递减分割，有利于数字化 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-26-30.png"></p>
<h3 id="脉冲编码调制">10.5 脉冲编码调制</h3>
<h4 id="pcm的基本原理">10.5.1 PCM的基本原理</h4>
<p>PCM系统原理框图如下 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-29-02.png"> 模拟信号数字化过程包括抽样、量化和编码</p>
<h4 id="常用二进制码">10.5.2 常用二进制码</h4>
<ol type="1">
<li>自然二进码：一般的十进制正整数的二进制表示，特点是编码简单，译码可以逐比特独立进行</li>
<li>格雷二进码：相邻码字的距离恒为1</li>
<li>折叠二进码：由极性码(最高位)和幅度码组成，幅度码从零电平-大电平按自然码规则编码，当正负绝对值相同时，幅度吗相对于零电平呈现映像关系，或称折叠关系</li>
</ol>
<p>码位的选择与安排关乎通信质量和设备复杂度，在A率13折线PCM编码中，共计<span class="math inline">\(2^8=256\)</span>个量化极，需要将每个样值脉冲<span class="math inline">\(I_s\)</span>编成8位二进制码，其编码规则如下，<span class="math inline">\(C_1-极性码，C_2C_3C_4-段落码，C_5C_6C_7C_8-段内码\)</span>,其中极性码表示样值的极性，正编"1",负编"0",段落码表示样值的幅度所处的段落，段内码表示16种可能状态对应代表各段内的16个量化级</p>
<p>起始电平和量化间隔用于确定样值所在的段落和量化级 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-45-16.png"> <span class="math inline">\(\Delta = \frac{1}{2048}\)</span> 段内码对应的权值关系如下 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-46-28.png"></p>
<h4 id="电话信号的编译码器">10.5.3 电话信号的编译码器</h4>
<p>非线性码对应非均匀量化，只需要7位非线性编码，称为非线性/对数PCM编码，线性码对应均匀量化，需要11位线性编码，称为线性PCM编码</p>
<p>PCM信号的比特率和带宽：设模拟信号的最高频率为<span class="math inline">\(f_H\)</span>,抽样速率为<span class="math inline">\(f_S=2f_H\)</span>,二进制编码位数为N，则PCM信号的比特率<span class="math inline">\(R_b=f_s\cdot N=2f_H\cdot N\)</span>，传输带宽：若采用非归零矩形脉冲传输，谱零点带宽<span class="math inline">\(B=R_B=R_b=f_s\cdot N\)</span></p>
<h4 id="pcm系统中噪声的影响">10.5.4 PCM系统中噪声的影响</h4>
<p>PCM系统中的噪声来源于两方面，一方面是量化噪声<span class="math inline">\(N_q\)</span>，一方面是加性噪声<span class="math inline">\(N_a\)</span>，两者产生机理不同，所以相互独立，性能指标方面，抗加性噪声性能可表述为 <span class="math display">\[\frac{S_o}{N_a}=\frac{E[m^2(t)]}{E[n_a^2(t)]}=\frac{1}{4P_e}\]</span> 抗量化噪声性能 <span class="math display">\[\frac{S_o}{N_q}=\frac{E[m^2(t)]}{E[n_q^2(t)]}=M^2=2^{2N}=2^{2B/f_H}\]</span> 总输出信噪比 <span class="math display">\[\frac{S_o}{N_o}=\frac{E[m^2(t)]}{E[n_q^2(t)]+E[n_a^2(t)]}=\frac{2^{2N}}{1+4P_e2^{2N}}\\若N_a&lt;&lt;N_q,则\frac{S_o}{N_o}\approx 2^{2N},若N_a&gt;&gt;N_q,则\frac{S_o}{N_o}\approx\frac{1}{4P_e}\]</span></p>
<h3 id="时分复用tdm">10.8 时分复用(TDM)</h3>
<p>对于时分复用数字电话通信系统，ITU制定了两种准同步数字题型的建议，E体系和T体系，主要讨论E体系</p>
<p><img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-11-22-53.png"></p>
<h2 id="第十三章同步原理">第十三章：同步原理</h2>
<h3 id="概述">13.1 概述</h3>
<p>同步是数字通信系统中不可或缺的关键技术，是保证信息可靠、有序传输的前提和必要，同步性能的好坏直接影响着通信系统的质量</p>
<p>同步的类型可分为载波同步，码元同步，帧/群同步，网同步，其中载波同步负责在相干解调时，提供同频同相的本地载波(相干载波)，码元同步负责在抽样判决，差分/编译码，PCM编译码时，提供时钟同步脉冲序列，帧/群同步负责在发端插入每帧起止标记，并从收信端检测并获取这一标记，以便对接受的数字序列正确分组</p>
<p>同步获取方法可分为外同步法(插入导频法)与自同步法(直接法)，二者的区别可以直接通过是否发送导频来辨别</p>
<h3 id="载波同步">13.2 载波同步</h3>
<p>作用：提供本地载波用于相干解调，要求：本地载波应与接受信号载波同频同相，方法有插入导频法和直接法</p>
<h4 id="有辅助导频的载波提取">13.2.1 有辅助导频的载波提取</h4>
<p>一般采用一个锁相环(PLL)来提取载波 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-12-55-35.png"></p>
<h4 id="无辅助导频的载波提取">13.2.2 无辅助导频的载波提取</h4>
<p>一般解决思路是通过非线性变换，产生载波的谐波分量，然后提取分频得到载波同步信号</p>
<p>常用的解决方法可分为平方变换法和平方环法，同向正交环(costas环),再调制器 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-12-57-44.png"></p>
<h4 id="载波同步的性能">13.2.3 载波同步的性能</h4>
<p>追求效率高，精度高，同步建立时间快，保持时间长</p>
<h3 id="码元同步">13.3 码元同步</h3>
<p>作用是在数字图像的抽样判决，差分编译码，PCM编译码器中，提供所需的同步时钟序列，要求抽样判决时，接收端需提供码元同步(位定时)序列，应满足重复频率与接收码元速率相同，相位与最佳抽判时刻一致，方法也分为外同步法和自同步法</p>
<h4 id="外同步法">13.3.1 外同步法</h4>
<p>就是在发送信号的频域进行插入同步信号，优点是设备较简单，缺点是需要占用一定的频带宽度和发送速率</p>
<h4 id="自同步法">13.3.2 自同步法</h4>
<ol type="1">
<li>开环码元同步法：将解调后的基带接受码元先进行某种非线性变换，窄带滤波，从而移除码元速率的频率分量，采用的方案一般为延迟相乘法和微分整流法</li>
<li>闭环码元同步法：将接受信号与本地产生的码元定时信号相比较，使本地产生的定时信号和接收码元波形的转变点保存同步，方案是超前/滞后门同步器</li>
</ol>
<h3 id="群同步">13.4 群同步</h3>
<p>作用是在码元同步的基础上，识别每个数字信息群的起止时刻</p>
<p>一般采用的方法有集中插入法与分散插入法</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第一二章知识小结</title>
    <url>/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第一章内容较少，故将一二章合并。本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="通信系统导论">通信系统导论</h2>
<p>通信系统组成框图如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-34-42.png"> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-36-08.png"></p>
<p><strong>超外差接收机框图</strong>： <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-08-22-07-22.png"></p>
<h2 id="通信电子线路分析基础">通信电子线路分析基础</h2>
<h3 id="选频网络">选频网络</h3>
<p><strong>选频网络的作用是选出我们需要的频率分量并滤除不需要的频率分量。选频网络可分 为谐振回路和滤波器两大类</strong></p>
<p>谐振回路 由电感和电容元件组成的振荡回路，振荡回路包含单振荡回路和耦合振荡回路，而单振荡回路又包含串联谐振回路和并联谐振回路。 滤波器滤波器包含LC集中滤波器 、石英晶体滤波器 、陶瓷滤波器和声表面波滤波器 等 。 滤波器的优点是稳定性好，电性能好，品质因数高，利于微型化，便于大量生产</p>
<h4 id="串联谐振回路">串联谐振回路</h4>
<p>电感电容信号源三者串联称为串联回路，其在谐振频率或谐振频率附近工作时，称为串联谐振回路，下面将归纳串联谐振回路的参量进行分析 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-42-33.png"></p>
<ol type="1">
<li><p>回路阻抗 设z为回路阻抗，则回路阻抗可表述为<span class="math inline">\(z=R+j(wL-\frac{1}{wC})\)</span>,进一步化简即可的其阻抗模与阻抗幅角为<span class="math inline">\(|z|=\sqrt{R^2+(wL-\frac{1}{wC})^2},\psi_z=arctan\frac{wL-\frac{1}{wC}}{R}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-47-38.png"> 又上图可知，当<span class="math inline">\(w&gt;w_0\)</span>时，回路成感性，电流滞后电压，反之则成容性，电流超前电压，<span class="math inline">\(w=w_0，|z|=R\)</span>，回路串联谐振，当回路谐振时的感抗或容抗,称为特性阻抗，用<span class="math inline">\(\rho\)</span>表示，<span class="math inline">\(\rho=w_0L=\frac{1}{w_0C}=\sqrt{\frac{L}{C}}\)</span></p></li>
<li><p>谐振频率<span class="math inline">\(f_0\)</span> 由上一小节的推导知，串联谐振回路的谐振频率就是当<span class="math inline">\(wL-\frac{1}{wC}=0\)</span>的信号频率<span class="math inline">\(w_0=\frac{1}{\sqrt{LC}},f_0=\frac{1}{2\pi\sqrt{LC}}\)</span></p></li>
<li><p>品质因数Q 谐振时回路感抗值(或容抗值)与回路电阻R 的比值称为回路的品质因数，以Q表示,表示回路损耗大小 <span class="math display">\[Q=\frac{w_0L}{R}=\frac{1}{w_0CR}=\frac{\rho}{R}=\frac{1}{R}\cdot\sqrt{\frac{L}{C}}\]</span> 且在串联谐振时，电感L和电容C上的电压达到最大值且为输入信号电压的Q倍,故串联谐振也称为电压谐振。因此，必须预先注意回路元件的耐压问题</p></li>
<li><p>广义失谐系数<span class="math inline">\(\xi\)</span> 广义失谐是表示回路失谐大小的量，谐振时为0 <span class="math display">\[\xi=\frac{失谐时电抗}{谐振时电阻}=\frac{X}{R}=Q_0(\frac{w}{w_0}-\frac{w_0}{w}),when\quad w\approx w_0,\xi\approx Q_0\cdot\frac{2\Delta f}{f_0}\]</span></p></li>
<li><p>谐振曲线 串联谐振回路中电流幅值与外加电动势频率之间的关系曲线称为谐振曲线,可用<span class="math inline">\(N(f)\)</span>表示谐振曲线函数, <span class="math display">\[N(f)=\frac{失谐处电流}{谐振点电流}=\frac{1}{1+j\xi}\]</span> Q 值不同即损耗R 不同时，对曲线有很大的影响,Q值大，曲线尖锐，选择性好 ;Q小 ，曲线钝,通带宽<img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-03-37.png"></p></li>
<li><p>通频带 当回路外加电压的幅值不变时，改变频率，回路电流下降到<span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>时所对应的频率范围称为谐振回路的通频带，用B表示 <span class="math display">\[B=2\Delta f_{0.7}=\frac{f_0}{Q}\]</span> 所以B与Q成反比,Q增大,B减小,B的推导用到了广义失谐函数辅助推导，在这里省略</p></li>
<li><p>相频特性曲线 其用于表示回路电流相角<span class="math inline">\(\psi_i\)</span>随频率w变化的曲线,<span class="math inline">\(\psi_i=-arctan\frac{x}{R}=-arctan\xi\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-10-59.png"></p></li>
<li><p>信号源内阻及负载对串联谐振回路的影响 若考虑信号内阻<span class="math inline">\(R_s\)</span>与负载<span class="math inline">\(R_L\)</span>，则有载Q值可表述为<span class="math inline">\(Q_L=\frac{w_0L}{R+R_s+R_L}\)</span>,可以看出串联谐振回路适合<span class="math inline">\(R_s\)</span>很小和<span class="math inline">\(R_L\)</span>不大的电路，这样<span class="math inline">\(Q_L\)</span>不会太低，有较好的选择性</p></li>
</ol>
<h4 id="并联谐振回路">并联谐振回路</h4>
<p>由电感、电容、信号源三者并联组成的回路称为并联谐振回路，其中<span class="math inline">\(R_p=\frac{L}{RC}\)</span>，是把电感的R转换到独立支路上得到的等效电阻 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-14-03.png"></p>
<ol type="1">
<li>回路阻抗 对于并联回路来说，一般采用导纳分析比较方便，其导纳 <span class="math display">\[Y=\frac{1}{z}=\frac{CR}{L}+j(wc-\frac{1}{wL})=G+jB\]</span></li>
<li>谐振频率 与串联谐振回路一致为：<span class="math inline">\(w_p=\frac{1}{\sqrt{LC}},f_p=\frac{1}{2\pi\sqrt{LC}}\)</span>，其阻抗特性如下，<span class="math inline">\(w&gt;w_p\)</span>,回路呈容性，反之为感性 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-18-28.png"></li>
<li>品质因数 与串联谐振回路类似为 <span class="math display">\[Q_p=\frac{w_pL}{R}=\frac{R_p}{w_pL}=\frac{R_p}{\rho}=R_p\cdot\sqrt{\frac{C}{L}}\]</span> 式中,R为串联在电感支路的损耗电阻;<span class="math inline">\(R_P\)</span>为并联谐振回路的谐振电阻,且在并联谐振时，电感L和电容C上的电流达到最大值且为输入信号电流的Q倍,故串联谐振也称为电流谐振。</li>
<li>广义失谐系数<span class="math inline">\(\xi\)</span> 广义失谐是表示回路失谐大小的量，谐振时为0 <span class="math display">\[\xi=\frac{失谐时电纳}{谐振时电导}=\frac{B}{G}=\frac{w_pC}{G}(\frac{w}{w_p}-\frac{w_p}{w}),when\quad w\approx w_p,\xi\approx Q_p\cdot\frac{2\Delta f}{f_p}\]</span></li>
<li>谐振曲线 并联谐振回路中电压幅值与外加电动势频率之间的关系曲线称为谐振曲线,可用<span class="math inline">\(N(f)\)</span>表示谐振曲线函数, <span class="math display">\[N(f)=\frac{失谐处电压}{谐振点电压}=\frac{1}{1+j\xi}\]</span> Q 值不同时，对曲线有很大的影响,Q值大，曲线尖锐，选择性好 ;Q值小，曲线钝,通带宽<img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-25-22.png"></li>
<li>通频带 当回路外加电流的幅值不变时，改变频率，回路电压下降到<span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>时所对应的频率范围称为谐振回路的通频带，用B表示 <span class="math display">\[B=2\Delta f_{0.7}=\frac{f_p}{Q_p}\]</span> 所以B与Q成反比,Q增大,B减小,B的推导用到了广义失谐函数辅助推导，在这里省略</li>
<li>相频特性曲线 其用于表示回路电压相角<span class="math inline">\(\psi_v\)</span>随频率w变化的曲线,<span class="math inline">\(\psi_v\approx-arctan\xi\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-29-05.png"></li>
<li>信号源内阻及负载对串联谐振回路的影响 若考虑信号内阻<span class="math inline">\(R_s\)</span>与负载<span class="math inline">\(R_L\)</span>，则有载Q值可表述为<span class="math inline">\(Q_L=\frac{Q_p}{1+\frac{R_p}{R_s}+\frac{R_p}{R_L}}\)</span>,可以看出并联谐振回路适合<span class="math inline">\(R_s\)</span>很大和<span class="math inline">\(R_L\)</span>很大的电路，这样<span class="math inline">\(Q_L\)</span>不会太低，有较好的选择性，适用于恒流源。</li>
</ol>
<h4 id="串并联阻抗等效互换与回路抽头阻抗互换">串并联阻抗等效互换与回路抽头阻抗互换</h4>
<h5 id="串并阻抗的等效互换">串并阻抗的等效互换</h5>
<p><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-31-23.png"> 在实际电路中有时为了分析电路方便需进行串、并联电路的等效互换，若<span class="math inline">\(Z_{AB}=Z_{A&#39;B&#39;}\)</span>,则经过推导可得 <span class="math display">\[R_2=(1+Q_L^2)(R_1+R_x),x_2=x_1(1+\frac{1}{Q_{L}^2})\\when\quad Q_L&gt;&gt;1,R_2\approx(R_1+R_2)Q_L^2,x_2\approx x_1\]</span></p>
<h5 id="回路抽头时阻抗的变化折合关系">回路抽头时阻抗的变化（折合）关系</h5>
<p>从前面分析可知,<span class="math inline">\(R_s,R_L\)</span>对回路Q值有影响，实际应用中为了减小信号源内阻和负载对回路的影响。采用抽头接入方式如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-36-21.png"> 其接入系数P定义为抽头点电压与端电压之比，利用能量等效原则有如下关系 <span class="math display">\[P=\frac{L_1}{L_1+L_2}=\frac{N_1}{N_1+N_2}\]</span> 若为电容抽头，则有 <span class="math display">\[P=\frac{C}{C_2}=\frac{C_1}{C_1+C_2}\]</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-39-25.png"> 根据以上分析得出结论: 1. 抽头改变时，接入系数p改变 2. 由低抽头折合到回路高端，等效导纳降低为原来的<span class="math inline">\(P^2\)</span>,等效电阻提升<span class="math inline">\(\frac{1}{P^2}\)</span>,Q提升很多 3. 对电流源来说与阻抗导纳的区别是低抽头向高抽头转换，电流源减小为原来的P，电压源减小为原来的<span class="math inline">\(\frac{1}{P}\)</span> 4. 负载电容的折合则是等于原来的<span class="math inline">\(P^2\)</span>，折合后电容减小，阻抗加大</p>
<p><strong>插入损耗</strong>：<span class="math inline">\(K=\frac{无损输出功率P_1}{有损输出功率P_1&#39;}=(\frac{1}{1-\frac{Q_L}{Q_0}})^2\)</span></p>
<h4 id="耦合回路">耦合回路</h4>
<h5 id="耦合回路的形式">耦合回路的形式</h5>
<p>耦合回路是由相互间有影响的两个回路组成的，其中接入信号源的回路称为初级回路,与它相互耦合的第二个回路连接负载，称 为次级回路。如果初、次级回路都是谐振回路，则称为耦合振荡回路。耦合振荡回路可以改善谐振曲线,使其选频特性更接近理想的矩形曲线 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-43-37.png"> 为了说明回路间耦合程度的强弱，引入耦合系数的概念并以k表示，对于电感耦合回路有<span class="math inline">\(k=\frac{C_M}{\sqrt{C_1+C_M}\sqrt{C_2+C_M}}\)</span>,对于电感耦合回路<span class="math inline">\(k=\frac{M}{\sqrt{L_1L_2}}\)</span></p>
<h5 id="反射阻抗与耦合回路的等效阻抗">反射阻抗与耦合回路的等效阻抗</h5>
<p>一般来说我们更关心的是反射阻抗与耦合回路的等效阻抗，其中反射阻抗用来说明一个回路对另一回路电流的影响，对初次级回路的相互影响，可以用一个反射阻抗来表示 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-14-37-04.png"> 根据上图进行推导，可以求出次级回路对初级回路的反射阻抗<span class="math inline">\(Z_{f1}=\frac{(wM)^2}{Z_{22}}\)</span>,初级回路对次级回路的反射阻抗<span class="math inline">\(Z_{f2}=\frac{(wM)^2}{Z_{11}}\)</span>,经过上述分析可得到等效电路如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-14-39-26.png"> 将自阻抗分解为电阻分量和电抗分量后可得 <span class="math display">\[Z_{f1}=\frac{(wM)^2}{R_{22}^2+X_{22}^2}R_{22}+-j\frac{(wM)^2}{R_{22}^2+X_{22}^2}X_{22}\\Z_{f2}=\frac{(wM)^2}{R_{11}^2+X_{11}^2}R_{22}+-j\frac{(wM)^2}{R_{11}^2+X_{11}^2}X_{11}\]</span> 由上式可知：反射电阻永远是正值。这是因为，无论是初级回路反射到次级回路，还是从次级回路反射到初级回路，反射电阻总是代表一定能量的损耗；反射电抗的性质与原回路总电抗的性质总是相反的；反射电阻和反射电抗的值与耦合阻抗的平方值<span class="math inline">\((wM)^2\)</span>成正比</p>
<h5 id="耦合回路的调谐">耦合回路的调谐</h5>
<p>对于耦合谐振回路，凡是达到了初级等效电路的电抗为零，或次级等效电路的电抗为零或初、次级回路的电抗同时为零，都称为回路达到了谐振，根据调谐参数不同，可分为部分谐振、复谐振和全谐振三种情况</p>
<ol type="1">
<li>部分谐振：如果固定次级回路参数与耦合量不变，调节初级回路的电抗使初级回路达到电抗和为0，称初级回路达到部分谐振，也可调节次级回路电抗使初级回路达到部分谐振</li>
<li>复谐振：在部分谐振的条件下，再改变互感量使得反射电阻等于回路本身电阻，即满足最大功率传输条件，使次级回路电流达到最大值，称为复谐振，<strong>此时单独对两个回路来看都失谐，但是他们的等效回路都对信号源频率谐振</strong></li>
<li>全谐振：调节初级回路的电抗及次级回路的电抗,使两个回路都单独地达到与信号源频率谐振(电抗为0)，即耦合回路达到全谐振，如果进一步改变M使得<span class="math inline">\(R_{11}=R_{f1},R_{22}=R_{f2}\)</span>,则称为最近全谐振，此时有<span class="math inline">\(M_c=\frac{\sqrt{R_{11}R_{22}}}{w},k_c\approx\frac{1}{\sqrt{Q_1Q_2}}\)</span>:临界耦合系数，且注意耦合回路的通频带<span class="math inline">\(B=\sqrt{2}\frac{f_0}{Q}\)</span></li>
</ol>
<h4 id="石英谐振器">石英谐振器</h4>
<p>石英晶体的特点如下：等效电感特别大，等效电容特别小，所以Q值很大；外电路影响很小。</p>
<p>电路有两个谐振角频率，串联谐振角频率和并联谐振角频率，其中，串联谐振频率<span class="math inline">\(w_q=\frac{1}{L_qC_q}\)</span>,并联谐振频率<span class="math inline">\(w_p=\frac{1}{\sqrt{L_q\frac{C_0C_q}{C_0+C_q}}}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-07-08-27-52.png"> 由石英谐振器设计出来的石英晶体滤波器的电抗曲线如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-07-08-28-46.png"></p>
<h3 id="非线性电路分析基础">非线性电路分析基础</h3>
<p>非线性元件的参数与通过它的电流或施加于其上的电压有关，非线性元件构成的电路就是非线性电路</p>
<p>非线性电路中至少包含一个非线性元件，其输出输入关系用非线性函数或微分方程表达，不具备叠加型和均匀性，是其与线性电路的主要区别</p>
<p>非线性电路的输入输出关系是非线性函数关系，当信号通过非线性电路后，在输出 信号中将会产生输入信号所没有的频率成分,也可能不再出现输入信号中的某些频率成分。 这是非线性电路的重要特性</p>
<p>非线性电路的分析方法主要有以下三种：</p>
<ol type="1">
<li>幂函数分析法</li>
<li>折线分析法</li>
<li>线性时变参量电路分析法</li>
</ol>
<p>非线性电路主要可以应用在：</p>
<ol type="1">
<li>实现信号频谱的线性变换(频谱搬移)</li>
<li>实现信号频谱的非线性变换</li>
<li>实现变参量电路</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第七章知识小结</title>
    <url>/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="本章知识小结">本章知识小结</h2>
<h3 id="概述">概述</h3>
<p>角度调制是用调制信号去控制载波信号角度(频率或相位)变化的一种信号变换方式。如果受控的是载波信号的频率，则称频率调制，简称调频，以FM表示；若受控的是载波信号的相位，则称为相位调制，简称调相，以PM表示。无论是FM还是PM，载频信号的幅度都不受调制信号的影响。调频波的解调称为鉴频或频率检波，调相波的解调称鉴相或相位检波。与调幅波的检波一样，鉴频和鉴相也是从已调信号中还原出原调制信号 <span id="more"></span> <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-13-43-54.png" style="width:50.0%;height:50.0%"> <strong>角度调制与解调和振幅调制与解调最大的区别在频率变换前后频谱结构的变化不同。</strong></p>
<ol type="1">
<li>角度调制:频率变换前后频谱结构发生了变化，属于非线性频率变换。</li>
<li>角度调制的主要优点: 抗干扰性强.FM广泛应用于广播、电视、通信以及遥测方面，PM主要应用于数字通信。</li>
<li>角度调制的主要缺点: 占据频带宽，频带利用不经济。</li>
</ol>
<h3 id="调角波的性质">调角波的性质</h3>
<h4 id="调频波和调相波的波形和数学表达式">调频波和调相波的波形和数学表达式</h4>
<p>FM波和PM波的相关性质在这里省略推导，不加证明的附上二者的对比图 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-13-52-23.png"> 由上表知，此时调频波的调制指数为<span class="math inline">\(m_f=\frac{K_fV_\Omega}{\Omega}\)</span>,调相波的调制指数为<span class="math inline">\(m_p=K_pV_\Omega\)</span>,进而得到调频波最大频移为<span class="math inline">\(\Delta w_f=K_fV_\Omega\)</span>，调相波最大频移为<span class="math inline">\(\Delta w_p=K_pV_\Omega\Omega\)</span>,下面分析当调制信号<span class="math inline">\(V_\Omega(t)=V_\Omega cos\Omega t\)</span>时，调频波的数学表达式为<span class="math inline">\(a_f(t)=V_mcos(w_0t+m_fsin\Omega t)\)</span>,调相波的数学表达式为<span class="math inline">\(a_p(t)=V_mcos(w_0t+m_pcos\Omega t)\)</span></p>
<p>从上面的表达式和对比表格可以看出的是，调频波的频偏与调制频率<span class="math inline">\(\Omega\)</span>无关，调频指数<span class="math inline">\(m_f\)</span>则与<span class="math inline">\(\Omega\)</span>成反比，调相波的频偏<span class="math inline">\(\Delta w_p\)</span>与<span class="math inline">\(\Omega\)</span>成正比，调相指数则与<span class="math inline">\(\Omega\)</span>无关 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-14-49-00.png"> 对比上图中的表达式可以看出，无论调频还是调相，最大频移(频偏)与调制指数之间的关系都是相同的，若频偏都用<span class="math inline">\(\Delta w_m\)</span>表示，调制指数都用m表示，则<span class="math inline">\(\Delta w_m\)</span>与m之间满足以下关系 <span class="math display">\[\Delta w_m=m\Omega\qquad \Delta f_m=mF\\\Delta f =\frac{\Delta w}{2\pi}\qquad F=\frac{\Omega}{2\pi}\]</span> <strong>在幅度调制中，调幅度<span class="math inline">\(m_a\le1\)</span>,否则会产生过调制失真，在角度调制中，无论调频还是调相，调制指数均可大于1</strong></p>
<h4 id="调角信号的频谱与有效频带宽度">调角信号的频谱与有效频带宽度</h4>
<p>由于调频波和调相波的方程式相似,因此要分析其中一种频谱,则另一种也完全适用</p>
<p>调频波的表达式<span class="math inline">\(a_f(t)=V_mcos(w_0t+m_fsin\Omega t)\)</span>利用三角函数关系改写并求解，发现其解只能用贝塞尔函数求解，展开后发现，在单频调制情况下，调频波和调相波可分解为载频和无穷多对上下边频分量之和，各频率分量之间的距离均等于调制频率，且奇数次的上下边频相位相反，包括载频分量在内的各频率分量的振幅均由贝塞尔函数值决定。 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-14-57-47.png"> 由图可知，无论<span class="math inline">\(m_f\)</span>为何值，随着阶数n的增大，边频分量的增幅总的趋势是减小的，<span class="math inline">\(m_f\)</span>越大，具有较大振幅的边频分量就越多</p>
<p>调频波和调相波的平均功率与调幅波一样，也为载频功率和各边频功率之和。单频调制时，调频波和调相波的平均功率利用第一类贝塞尔函数性质求和得到<span class="math inline">\(P_{av}=\frac{1}{2}\frac{V_o^2}{R_L}\)</span>,这表明调频波和调相波的平均功率与调制前的等幅载波功率相等。<strong>说明，调制的作用仅是将原来的载频功率重新分配到各个边频上，而总的功率不变。这一点与调幅波完全不同。</strong></p>
<p>通常将振幅小于载波振幅10%的边频分量忽略不计，有效的上下边频分量总数则为2(m+1)个，即调频波和调相波的有效频带宽度定为<span class="math inline">\(BW=2(m+1)F=2(\Delta f+F)\)</span></p>
<p>根据FM与PM的表达式，我们发现调频波可以看出调制信号为<span class="math inline">\(\int_{0}^{t} v_\Omega(t)\, {\rm d}t\)</span>,而调相波可以看出调制信号为<span class="math inline">\(\frac{dv_\Omega(t)}{dt}\)</span>,<strong>这为间接调频方法奠定了理论基础</strong></p>
<p>当调制信号频率F发生变化时，调频波的调制指数<span class="math inline">\(m_f\)</span>与F成反比变化，其频宽宽度基本不变，故称恒带调制</p>
<p>当调制信号频率F变化时，调相波的调制指数<span class="math inline">\(m_p\)</span>与F无关，其频带宽度随调制频率F变化 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-04-41.png"></p>
<h3 id="调频方法和电路">调频方法和电路</h3>
<h4 id="实现调频的方法和基本原理">实现调频的方法和基本原理</h4>
<p>频率调制是对调制信号频谱进行非线性频率变换，而不是线性搬移，因而不能简单地用乘法器和滤波器来实现。<strong>实现调频的方法分为两大类：直接调频法和间接调频法</strong>。</p>
<ol type="1">
<li>直接调频法
<ol type="1">
<li>用调制信号直接控制振荡器的瞬时频率变化的方法称为直接调频法</li>
<li>优点：原理简单，频偏较大</li>
<li>缺点：中心频率不易稳定</li>
</ol></li>
<li>间接调频法
<ol type="1">
<li>先将调制信号进行积分处理，然后用它控制载波的瞬时相位变化，从而实现间接控制载波的瞬时频率变化的方法，称为间接调频法</li>
<li>优点：实现调相的电路独立于高频载波振荡器以外，所以这种调频波突出的优点是载波中心频率的稳定性可以做得较高。</li>
<li>缺点：可能得到的最大频偏较小</li>
</ol></li>
<li>无论是直接调频还是间接调频，主要技术要求是：
<ol type="1">
<li>频偏尽量大，并且与调制信号保持良好的线性关系(频偏增大与调制线性度之间是矛盾的)</li>
<li>中心频率的稳定性尽量高</li>
<li>寄生调幅尽量小</li>
<li>调制灵敏度尽量高</li>
</ol></li>
</ol>
<h4 id="直接调频电路">直接调频电路</h4>
<ol type="1">
<li>变容二极管：优点：电路简单，工作频率较高，容易获得较大的频偏，在频偏不需很大的情况下，非线性失真可以做得很小。缺点：变容管的一致性较差，大量生产时会给调试带来某些麻烦；另外偏置电压的漂移、温度的变化会引起中心频率漂移，因此调频波的载波频率稳定度不高</li>
<li>晶体管直接调频：用于稳定调频波的中心频率</li>
</ol>
<h4 id="间接调频方法">间接调频方法</h4>
<p>间接调频法的频稳度高，广泛用于广播发射机和电视伴音发射机，关键在于如何实现调相，常用的调相方法有移相法，可变时延调相，矢量合成调相</p>
<ol type="1">
<li>移相法调相 将载频信号<span class="math inline">\(Vcosw_0t\)</span>通过一个相移受调制信号<span class="math inline">\(V_\Omega\)</span>线性控制的移相网络，即可实现调相 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-33-38.png" style="width:60.0%;height:60.0%"> 常用移相网络：如RC移相网络、LC调谐回路移相网络 但是单极LC回路线性相位变化范围小，一般在<span class="math inline">\(30°\)</span>以下，为了增大调相系数，可以用多级单调谐回路构成的变容管调相电路</li>
<li>可变时延法调相 周期信号在经过一个网络后，如果在时间轴上有所移动，则此信号的相角必然发生变化，时延法调相就是利用调制信号控制时延大小而实现调相的一种方法 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-36-11.png" style="width:60.0%;height:60.0%"> 最大优点：调制线性好，相位偏移大</li>
<li>矢量合成调相法</li>
</ol>
<h3 id="调角信号解调">调角信号解调</h3>
<p>调频波的解调简称鉴频；调相波的解调简称鉴相。本节讨论的重点在鉴频。对调频波而言，调制信息包含在已调信号瞬时频率的变化中，所以<strong>解调的任务就是把已调信号瞬时频率的变化不失真地转变成电压变化，即实现“频率—电压”转换。</strong></p>
<h4 id="鉴频方法">鉴频方法</h4>
<ol type="1">
<li><p>实现鉴频的方法 实现鉴频的方法很多，但常用的方法有以下几种：</p>
<ol type="1">
<li>利用波形变换进行鉴频</li>
<li>相移乘法鉴频</li>
<li>脉冲计数式鉴频</li>
<li>利用锁相环路鉴频</li>
</ol></li>
<li><p>利用波形变换进行鉴频 将调频信号先通过一个线性变换网络，<strong>使调频波变换成调频调幅波</strong>，其幅度正比于瞬时频率的变化，经变换网络输出的调频调幅信号再作振幅检波即可恢复出原调制信号</p></li>
<li><p>相移乘法鉴频 将<strong>调频波经过移相电路变成调频调相波</strong>，其相位的变化正好与调频波瞬时频率的变化成线性关系；将此调频调相波与未相移调频波(为参考信号)进行相位比较，即可得到鉴频电路的解调输出。由于相位比较器一般都选用乘法电路，故此类鉴频电路称为相移乘法电路。 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-54-57.png" style="width:60.0%;height:60.0%"></p></li>
<li><p>脉冲计数式鉴频器 <strong>利用调频波单位时间内过零信息的不同来实现解调,优点是线性良好</strong> <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-56-16.png" style="width:60.0%;height:60.0%"></p></li>
<li><p>鉴频器的主要技术指标 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-58-19.png" style="width:30.0%;height:30.0%"> 鉴频特性：鉴频器输出电压和输入调频波频率之间的关系</p>
<ol type="1">
<li>鉴频跨导S：中心频率附近，单位频偏引起的输出电压的变化量S，<span class="math inline">\(S=\frac{\Delta v_o}{\Delta f}|_{f-f_o}\)</span>,S越大，意味着鉴频特性曲线越陡峭，鉴频能力越强</li>
<li>线性范围：指鉴频特性曲线近似于直线段的频率范围，用<span class="math inline">\(2\Delta f_{max}\)</span>表示，表明鉴频器不失真解调时所允许的频率变化范围<span class="math inline">\(\rightarrow\)</span>要求<span class="math inline">\(2\Delta f_{max}\)</span>应大于调频波最大频偏的两倍，又被称为鉴频器的带宽</li>
<li>鉴频灵敏度：主要是指为使鉴频器正常工作所需的输入调频波的幅度，其值越小，鉴频器灵敏度越高。</li>
</ol></li>
</ol>
<h4 id="相位鉴频">相位鉴频</h4>
<p>相位鉴频器:利用波形变换来鉴频。原理：利用回路的相位频率特性，将调频波变为调幅—调频波，然后用振幅检波恢复调制信号，常有两种，电感/电容耦合相位鉴频器,本届主要介绍电感耦合相位鉴频器 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-03-22.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>电路说明：输入电路的初级回路C1、L1和次级回路C2、L2均调谐于调频波的中心频率<span class="math inline">\(f_0\)</span>,z负责完成波形变换，等幅调频波<span class="math inline">\(\rightarrow\)</span>调幅-调频波</li>
<li>工作原理：初级回路电流经过互感耦合，在次级回路两端感应产生次级回路电压。加在两个振幅检波器的输入信号分别为 <span class="math display">\[\dot{V_{D1}}=\dot{V_{ac}}+\dot{V_{12}}=\frac{1}{2}\dot{V_{ab}}+\dot{V_{12}}\\\dot{V_{D2}}=\dot{V_{bc}}+\dot{V_{12}}=-\frac{1}{2}\dot{V_{ab}}+\dot{V_{12}}\]</span> 只要加在二极管上的电压为FM-AM波，后面就是振幅检波。这里关键是弄清<span class="math inline">\(\dot{V_{12}}\)</span>与<span class="math inline">\(\dot{V_{ab}}\)</span>间的相位关系，二者的相位关系需要利用到耦合电路化简，这里略过，最后可以得到的结论是 <span class="math display">\[\dot{V_{ab}}=j\frac{M}{L_1}\frac{X_{C2}}{R_2+jX_2}\dot{V_{12}}\]</span> <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-12-05.png" style="width:60.0%;height:60.0%"> 由上图可以看出：
<ol type="1">
<li>当信号频率等于中心频率时，<span class="math inline">\(X_2=0\)</span>,次级电路电压<span class="math inline">\(\dot{V_{ab}}\)</span>比初级电路电压<span class="math inline">\(\dot{V_{12}}\)</span>超前<span class="math inline">\(\frac{\pi}{2}\)</span></li>
<li>当信号频率高于中心频率时，<span class="math inline">\(X_2&gt;0\)</span>,次级电路电压<span class="math inline">\(\dot{V_{ab}}\)</span>比初级电路电压<span class="math inline">\(\dot{V_{12}}\)</span>超前<span class="math inline">\(\frac{\pi}{2}-\theta\)</span></li>
<li>当信号频率高于中心频率时，<span class="math inline">\(X_2&gt;0\)</span>,次级电路电压<span class="math inline">\(\dot{V_{ab}}\)</span>比初级电路电压<span class="math inline">\(\dot{V_{12}}\)</span>超前<span class="math inline">\(\frac{\pi}{2}+\theta\)</span></li>
</ol></li>
<li>由于鉴频器的输出电压等于两个检波器输出电压之差，而每个检波器的输出电压(峰值或平均值)正比于其输入电压的振幅,所以鉴频器输出电压为<span class="math inline">\(V_o=k_d(V_{D1}-V_{D2}),k_d\)</span>为检波器的电压传输系数，结合上面矢量图，有如下结论 <span class="math display">\[f_{in}=f_0,V_{a&#39;b&#39;}=0\\f_{in}&gt;f_0,V_{a&#39;b&#39;}&gt;0\\f_{in}&lt;f_0,V_{a&#39;b&#39;}&lt;0\]</span> 因此，输出电压<span class="math inline">\(V_{a&#39;b&#39;}\)</span>反映了输入信号瞬时频率的偏移<span class="math inline">\(\Delta f\)</span>。而<span class="math inline">\(\Delta f\)</span>与原调制信号<span class="math inline">\(V_\Omega(t)\)</span>成正比，即<span class="math inline">\(V_{a&#39;b&#39;}\)</span>与<span class="math inline">\(V_\Omega(t)\)</span>成正比。亦即实现了调频波的解调,若将二者关系画成曲线，则得到下图 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-21-31.png" style="width:60.0%;height:60.0%"></li>
</ol>
<h4 id="比例鉴频器">比例鉴频器</h4>
<p>前面介绍的相位鉴频器，当输入调频信号的振幅发生变化时，输出电压也会发生变化，因此由各种噪声和干扰引起的输入信号寄生调幅，都将在其输出端反映出来。为了抑制噪声及干扰，在鉴频器前必须增设限幅器，比例鉴频器具有自限幅功能，因而可省去外加限幅器 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-22-51.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>原理电路 其波形变换部分与相位鉴频器基本相同，电路上差别主要有以下几点：
<ol type="1">
<li>R1，R2连接点N接地，负载RL接在MN之间，输出电压由M，N引出</li>
<li>R1和R2两端并接大电容C6，使得在检波过程中<span class="math inline">\(a&#39;b&#39;\)</span>间的端电压基本保持不变</li>
<li>D1和D2按环路顺接，以保持直流通路，因此C3和C4上的电压极性一致,<span class="math inline">\(V_{a&#39;b&#39;}=V_{c3}+V_{c4}\)</span>,输出电压为<span class="math inline">\(v_o=\frac{1}{2}(V_{a&#39;b&#39;}-\frac{2V_{a&#39;b&#39;}}{1+\frac{V_{D1}}{V_{D2}}})\)</span></li>
</ol></li>
<li>自限幅特性分析 比例鉴频器不需要前置限幅器，它本身就具有抑制寄生调幅所产生的干扰的能力，在比例鉴频器中，由于C6的电容量很大，因此电压<span class="math inline">\(V_{a&#39;b&#39;}\)</span>基本稳定不变，它只决定于调频波的载波振幅，而与其频偏及寄生调幅都无关. 当输入信号振幅由于干扰突然变大时，由于电压<span class="math inline">\(V_{a&#39;b&#39;}\)</span>基本恒定，就使得检波管的电流明显加大，加重了对输入回路的负载，即回路Q值下降,可迫使信号振幅减小。反之亦然。因而很好地起到了稳幅的作用</li>
</ol>
<h2 id="自问自答">自问自答</h2>
<ol type="1">
<li><p>采用角度调制与解调和振幅调制与解调的区别在哪里？ 角度调制与解调和振幅调制与解调最大的区别在频率变换前后频谱结构的变化不同。角度调制是频率变换前后频谱结构发生了变化，属于非线性频率变换。角度调制的主要优点是抗干扰性强，FM广泛应用于广播、电视、通信以及遥测方面，PM主要应用于数字通信。但是角度调制的主要缺点是占据频带宽，频带利用不经济。</p></li>
<li><p>实现鉴频电路的方法主要有哪些？</p>
<ol type="1">
<li>利用波形变换进行鉴频</li>
<li>相移乘法鉴频</li>
<li>脉冲计数式鉴频器</li>
<li>利用锁相环路实现鉴频</li>
</ol></li>
<li><p>从表面看，增加带宽将使更多的噪声信号进入接收机，但是，为什么宽带的调频信号反而可以提高信噪比呢？ 这是因为调频信号的频谱是有规律地扩展的，各旁频分量是相关的，经解调后宽带信号可以凝聚为窄带的原始调制信号频谱。噪声各频率是彼此独立的，不能凝聚，解调后仍分布在宽带内，大部分 将被滤波器滤除，这就使输出信噪比得以提高。</p></li>
</ol>
<h2 id="未解答的疑惑">未解答的疑惑</h2>
<ol type="1">
<li>在调相电路尤其是阿姆斯特朗法（矢量合成调相法）中如何将电路分析与矢量建立联系？</li>
<li>如何能够进一步不把FM和PM弄混？</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第三章知识小结</title>
    <url>/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>中心频率在几百千赫兹至几百兆赫兹，信号频谱宽度在几千赫兹至几十兆赫兹,放大微弱 信号的放大器称为<strong>高频小信号放大器</strong>。高频小信号放大器工作在电子器件的线性区域，放大器输入与输出信号的频谱完全相同，因此可采用前面的有源线性四端网络来分析</p>
<p>高频小信号放大器的分类：高频小信号放大器按器件分可分为晶体管放大器，场效应管放大器，集成电路放大器，按通带分可分为窄带放大器和宽带放大器，按负载分可分为谐振放大器和非谐振放大器</p>
<p>高频小信号放大器的质量指标：</p>
<ol type="1">
<li>增益(放大系数)：放大器输出电压与输入电压之比，称为放大器的增益或放大倍数，电压增益<span class="math inline">\(A_V=\frac{V_o}{V_i}\)</span>,功率增益<span class="math inline">\(A_p=\frac{P_o}{P_i}\)</span>,分贝表示<span class="math inline">\(A_V=20lg\frac{V_o}{V_i}\)</span>,分贝表示<span class="math inline">\(A_p=10lg\frac{P_o}{P_i}\)</span></li>
<li>通频带：放大器电压增益下降到最大值的<span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>时，对应的频率范围称为放大器的通频带，用<span class="math inline">\(B=2\Delta f_{0.7}\)</span>表示，也被称为3dB带宽</li>
<li>选择性：从各种不同频率信号的总和（有用的和有害的）中选出有用信号，抑制干扰信号的能力称为放大器的选择性,选择性常采用矩形系数和抑制比来表示
<ul>
<li>矩形系数：按理想情况，谐振曲线应为一个矩形。即在通带内放大量均匀，在通带外 不需要的信号得到完全衰减，但实际上不可能。为了表示实际曲线接近理想曲线的程度，引入矩形系数，它表示对邻道干扰的抑制能力：<span class="math display">\[K_{r0.1}=\frac{2\Delta f_{0.1}}{2\Delta f_{0.7}},K_{r0.01}=\frac{2\Delta f_{0.01}}{2\Delta f_{0.7}}\]</span> <span class="math inline">\(K_r\)</span>越接近1越好</li>
<li>抑制比：表示对某个干扰信号<span class="math inline">\(f_n\)</span>的抑制能力，用<span class="math inline">\(d_n\)</span>表示：<span class="math inline">\(d_n=\frac{A_{V0}}{A_n}\)</span>,<span class="math inline">\(A_n\)</span>干扰信号放大倍数，<span class="math inline">\(A_{V0}\)</span>谐振点<span class="math inline">\(f_0\)</span>放大倍数 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-31-23.png"></li>
</ul></li>
<li>工作稳定性：指在电源电压变化或器件参数变化时,以上三个参数的稳定程度。一般的不稳定现象是增益变化，中心频率偏移，通频带变窄，不稳定状态的极端是放大器自激，导致放大器完全不能工作</li>
<li>噪声系数：放大器的噪声性能可用噪声系数表示<span class="math display">\[N_F=\frac{P_{si}/P_{ni}(输入信号噪声比)}{P_{so}/P_{no}(输出信号噪声比)},N_F\]</span>越接近1越好</li>
</ol>
<h2 id="晶体管高频小信号等效电路和参数">晶体管高频小信号等效电路和参数</h2>
<p>晶体管在高频运用时，它的等效电路不仅包含着一些和频率基本没有关系的电阻，而且 还包含着一些与频率有关的电容,这些电容在频率较高时的作用是不能忽略的。</p>
<p>在电路分析中 ，等效电路是一种很有用的方法,晶体管在高频运用时，它的等效电路主要有两种表示方法，形式等效电路(Y参数等效电路)和物理模拟等效电路(混合<span class="math inline">\(\pi\)</span>型等效电路)-不是考试要求，不介绍</p>
<h3 id="形式等效电路y参数等效电路">形式等效电路(Y参数等效电路)</h3>
<p>形式等效电路将晶体管看出有源四端网络，高频等效电路主要采用y参数分析，即<span class="math inline">\(V_1,V_2\)</span>为自变量，<span class="math inline">\(I_1,I_2\)</span>为参变量 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-37-33.png"> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-38-39.png"> 根据右图等效电路可写出电路方程 <span class="math display">\[\begin{cases}
    \dot{I_1}=y_{ie}\dot{V_1}+y_{re}\dot{V_2}\\
    \dot{I_2}=y_{fe}\dot{V_1}+y_{oe}\dot{V_2}
\end{cases}\]</span>其中<span class="math inline">\(y_{ie}=\frac{\dot{I_1}}{\dot{V_1}}|_{\dot{V_2}=0}\)</span>为输出短路的输入导纳，<span class="math inline">\(y_{re}=\frac{\dot{I_1}}{\dot{V_2}}|_{\dot{V_1}=0}\)</span>为输入短路的反向传输导纳，<span class="math inline">\(y_{fe}=\frac{\dot{I_2}}{\dot{V_1}}|_{\dot{V_2}=0}\)</span>为输出短路的正向传输导纳，<span class="math inline">\(y_{oe}=\frac{\dot{I_2}}{\dot{V_2}}|_{\dot{V_1}=0}\)</span>为输入短路的输出导纳，</p>
<h2 id="晶体管谐振放大器">晶体管谐振放大器</h2>
<h3 id="单级单调谐回路谐振放大器">单级单调谐回路谐振放大器</h3>
<p><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-47-52.png"> 上图是一个典型的单级单调谐放大器，<span class="math inline">\(R_1,R_2,R_3\)</span>为偏置电阻，<span class="math inline">\(L_F,C_F\)</span>为滤波电路，该电路采用负压供电，C,L组成LC谐振回路，<span class="math inline">\(R_4\)</span>加宽回路频带，<span class="math inline">\(y_{ie2}\)</span>是下一组输入导纳</p>
<ol type="1">
<li>等效电路分析： 因为讨论的是小信号，略去直流参数元件即可用Y参数等效电路模拟 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-50-53.png"> 由上图可知 <span class="math display">\[\begin{cases}
 \dot{I_b}=y_{ie}\dot{V_i}+y_{re}\dot{V_c}\\
 \dot{I_c}=y_{fe}\dot{V_i}+y_{oe}\dot{V_c}\\
 \dot{I_c}=-\dot{V_C}Y_L&#39;
\end{cases}\\ \]</span> <span class="math inline">\(Y_L&#39;\)</span>代表从集电极c向右看去的回路导纳<span class="math inline">\(Y_L&#39;=\frac{1}{P_1^2}(g_p+jwC+\frac{1}{jwL}+P_2^2y_{ie2})\)</span>，代入化简得放大器的输入导纳可表示为 <span class="math display">\[Y_i=\frac{\dot{I_b}}{\dot{V_i}}=y_{ie}-\frac{y_{re}y_{fe}}{y_{oe}+Y_L&#39;}\]</span></li>
<li>分析质量指标
<ol type="1">
<li>电压增益：按找第一节提到指标并集合电路分析得到电压增益可表示为 <span class="math display">\[\dot{A_V}=\frac{-P_1P_2y_{fe}}{g_\Sigma[1+j\frac{2Q_L\Delta f}{f_0}]},Q_L=\frac{w_0C_\Sigma}{g_\Sigma},f_0=\frac{1}{2\pi\sqrt{LC_\Sigma}}\Delta f=f-f_0\\g_\Sigma=P_1^2g_{oe}+g_p+P_2^2g_{ie2},C_\Sigma=C+P_1^2C_{oe}+P_2^2C_{ie2}\]</span> 注意当谐振回路并联R时，<span class="math inline">\(g_\Sigma\)</span>中要加入一个<span class="math inline">\(g_R\)</span>,当谐振时，<span class="math inline">\(\Delta f=0\)</span>,此时小信号单级单调谐放大器谐振电压增益为 <span class="math display">\[\dot{A_{V0}}=-\frac{P_1P_2y_{fe}}{g_\Sigma}=-\frac{P_1P_2y_{fe}}{P_1^2g_{oe}+g_p+P_2^2g_{ie2}}\]</span> 由上式可知，输出电压与输入电压相差180度，但由于<span class="math inline">\(y_{fe}\)</span>本身是复数也有相角，实际相位差为180°+<span class="math inline">\(\psi_{fe}\)</span>,当工作频率较低时，其相角约等于0，此时才相差180°；要求电压增益增大时，应选择正向传输导纳较大的管子；当谐振时，电压增益达到最大；有载<span class="math inline">\(Q_L=\frac{w_0C_\Sigma}{g_\Sigma}\)</span>，所以<span class="math inline">\(Q_L\)</span>不能太低，否则增益<span class="math inline">\(A_V\)</span>较低</li>
<li>功率增益：<span class="math inline">\(A_{P_0}=\frac{负载获得功率P_0}{信号源传输功率P_i}\)</span>，谐振时可以把等效电路图进一步简化为 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-17-59-02.png"> 推导得出功率增益表达式为<span class="math display">\[A_{po}=\frac{P_1^2P_2^2g_{ie2}|y_{fe}|^2}{g_{ie1}g_\Sigma^2}=(A_{Vo}^2\frac{g_{ie2}}{g_{ie1}})\]</span> 若<span class="math inline">\(g_{ie1}=g_{ie2}\)</span>，则<span class="math inline">\(A_{Po}=A_{Vo}^2\)</span>，当<span class="math inline">\(P_1^2g_{oe}=P_2^2g_{ie2}\)</span>时达到功率匹配，若不考虑<span class="math inline">\(g_p\)</span>，则最大功率增益为<span class="math inline">\((A_{Po})_{max}=\frac{|y_{fe}|^2}{4g_{ie}g_{oe}}\)</span></li>
<li>放大器的通频带：结合第二章知识和前面分析可将带宽表示为 <span class="math display">\[B=\frac{f_0}{Q_L}=\frac{g_\Sigma}{2\pi C_\Sigma}=f_0g_\Sigma w_0L(求不出C时用)\\A_{Vo}=-\frac{P_1P_2y_{fe}}{4\pi\Delta f_{0.7}\cdot C_\Sigma}\]</span> 可知带宽与增益的乘积取决于<span class="math inline">\(C_\Sigma,|y_{fe}|\)</span>且为一固定值</li>
<li>选择性：有第一节中提到的矩形系数表达式推出<span class="math inline">\(K_{r0.1}=\frac{2\Delta f_{0.1}}{2\Delta f_{0.7}}\)</span>,化简得<span class="math inline">\(K_{r0.1}=\sqrt{10^2-1}\)</span>,所以单调谐放大器矩形系数比1大得多，选择性比较差</li>
</ol></li>
</ol>
<h3 id="多级单调谐回路谐振放大器">多级单调谐回路谐振放大器</h3>
<p>若单级放大器的增益不能满足要求，就可以采用多级级联放大器，多级放大器的电压增益可表述为各级增益乘积，若多级放大器是由完全相同的单级放大器组成则有<span class="math inline">\(A_m=A_{v1}^m\)</span>,谐振曲线可表述为<span class="math inline">\(\frac{A_m}{A_{m0}}=\frac{1}{[1+(\frac{Q_L2\Delta f}{f_0})]^{\frac{m}{2}}}\)</span>,等于各单级谐振曲线乘积，级数越多，谐振曲线越尖锐，多级放大器的通频带则可表示为<span class="math inline">\((2\Delta f_{0.7})_m=\sqrt{2^{\frac{1}{m}}-1}\cdot2\Delta f_{0.7}=\sqrt{2^{\frac{1}{m}}-1}\frac{f_0}{Q_L}\)</span>,矩形系数可表示为<span class="math inline">\(K_{r0.1}=\frac{\sqrt{100^{\frac{1}{m}}-1}}{\sqrt{2^{\frac{1}{m}}-1}}\)</span></p>
<p>单调谐回路放大器的优点是电路简单，调试容易，缺点是选择性差，增益与通频带矛盾比较突出</p>
<h2 id="谐振放大器的稳定性">谐振放大器的稳定性</h2>
<p>放大器的工作稳定性是重要的质量指标之一，实际上前面讨论<span class="math inline">\(A_{V0}\)</span>时忽略了内部反馈<span class="math inline">\(y_{re}\)</span>,实际上由于<span class="math inline">\(y_{re}\)</span>存在，放大器可能产生自激,<strong>自激产生的原因主要是由于晶体管内部存在反向传输导纳<span class="math inline">\(y_{re}\)</span>,使晶体管成为双向器件，在一定频率下使得回路总电导为0，此时产生自激振荡</strong>。一般采用稳定系数S表示放大器稳定工作的条件，当S=1，放大器自激，S&lt;1,放大器更自激，S&gt;&gt;1时内部反馈最小，放大器才工作稳定，一般工程中取S=5-10，且电压增益与S满足如下关系<span class="math inline">\(A_{Vo}=\sqrt{\frac{2|y_{fe}|}{Sw_0C_{re}}}\)</span></p>
<p>为了克服自激，一般采用以下两种方法： 1. 中和法：在晶体管的输出端和输入端之间插入一个外加的反馈电路，使它的作用恰好和晶体管的内反馈互相抵消。 2. 失配法：基本思想是信号源内阻不与晶体管输入阻抗匹配，晶体管输出端负载阻抗不与本级晶体管的输出阻抗匹配 3. 优缺点比较：中和法的优点是电路简单，增益不受影响;其缺点是只能在一个频率上完全中和，不适合宽带，因为晶体管离散性大,实际调整麻烦，不适于批量生产。采用中和法对放大器由于温度等原因引起各种参数变化没有改善效果。失配法的优点是性能稳定,能改善各种参数变化的影响;频带宽,适合宽带放大，适于波段工作;生产过程中无须调整,适于大量生产。失配法的缺点是增益较低</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第五章知识小结</title>
    <url>/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="本章知识小结">本章知识小结</h2>
<h3 id="概述">概述</h3>
<p>本章主要讨论自激式振荡器，它是在无须加激励信号的情况下，能将直流电能转换为具有一定波形、频率、幅度的交变能量电路。振荡器又可根据波形不同分为正弦波振荡器和非正弦波振荡器。正弦波振荡器根据工作方式不同又可分为反馈型振荡器和负阻型振荡器。<strong>反馈型振荡器主要由决定振荡频率的选频网络和维持振荡的正反馈放大器组成</strong>，本章主要讨论反馈型正弦波振荡器</p>
<h3 id="反馈式振荡器的基本工作原理">反馈式振荡器的基本工作原理</h3>
<p>反馈式振荡器由反馈放大器演变而来，根据下图可以分析器起振的物理过程和基本组成，简单来说，当开关拨向1，电路未调谐放大器，若在电路稳定后，迅速将开关拨向2点。这是调谐放大器就变为自激振荡器 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-10-41-34.png"></p>
<p>由自激振荡建立的过程可知，反馈型自激振荡器的电路构成必须由以下三部分组成：</p>
<ol type="1">
<li>包含两个(或以上)储能元件的振荡回路，这两个元件中，一个释放能量时，另一个就接收能量。释放和接收能量可以往返进行，其频率取决于元件数值。</li>
<li>可以补充由振荡回路电阻产生损耗的能量来源，在晶体管振荡器中，能源就是直流电源<span class="math inline">\(V_{CC}\)</span></li>
<li>使能量在正确的时间内补充道电路中的控制设备，由有源器件和正反馈电路完成。</li>
</ol>
<p>在上述分析中，反馈式振荡器至少包含一个基本放大器和把能量一部分反馈到放大器输入端的反馈网络F。由模电知识可知，反馈环闭环增益表示为:<span class="math display">\[\dot{A_f}=\frac{\dot{A_o}}{1-\dot{A_o}\cdot \dot{F}}\]</span> <span class="math inline">\(\dot{A_o}=\frac{\dot{V_o}}{\dot{V_i}}|_{\dot{V_f}=0}\)</span>为基本放大器小信号开环增益，<span class="math inline">\(\dot{F}=\frac{\dot{V_f}}{\dot{V_i}}\)</span>为反馈网络小信号电压反馈系数 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-10-51-49.png"> 反馈型正弦波的起振条件为<span class="math display">\[\dot{A_o}\dot{F}&gt;1({A_o}F&gt;1.\phi_A+\phi_F=2n\pi,n=0,\pm1,\dots)\]</span>上式为振幅起振条件和相位起振条件，放大器增益A和输出电压幅度<span class="math inline">\(V_o\)</span>的关系称为振荡特性,<span class="math inline">\(\frac{1}{F}\)</span>与<span class="math inline">\(V_o\)</span>之间的关系称为反馈特性，起振的幅度条件如下图所示 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-04-47.png"> 但在实际设计中，由于静态工作点太低，振荡器电路无法自行起振，必须给一个较大幅度的初始激励，使动态点越过不稳定平衡点B才能起振，这称为硬激励起振，设计电路时要尽量避免 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-06-34.png"> 起振后，为了确保维持自激振荡，必须满足平衡条件，平衡条件可表述为：<span class="math display">\[A\cdot F=1,\phi_A+\phi_F=2n\pi,n=0,1,2\dots\]</span></p>
<p>若用电路参数表示振幅平衡条件和相位平衡条件则有 <span class="math display">\[|\overline{y_{fe}}|\cdot|Z_{p1}|\cdot F=1\\\phi_Y+\phi_Z+\phi_F=2n\pi,n=0,1,2...\]</span></p>
<p>振荡器平衡状态的稳定条件是指在外因作用下平衡条件被破坏后，振荡器能自动恢复到原来平衡状态的能力，稳定条件也分为振幅稳定和相位稳定两种： 1. 振幅稳定:<strong>在平衡点附近，放大倍数随振幅的变化特性具有负的斜率</strong><span class="math display">\[\frac{\partial A}{\partial V_{om}}|_{V_{om}=V_{omQ}}&lt;0\]</span> 2. 相位稳定：<strong>振荡器相位稳定条件要求谐振回路的相频特性曲线<span class="math inline">\(\phi_z=f(w)\)</span>在工作频率附近具有负的斜率</strong><span class="math display">\[\frac{\partial \phi}{\partial w}\approx\frac{\partial \phi_Z}{\partial w}&lt;0\]</span></p>
<h3 id="反馈型lc振荡器线路">反馈型LC振荡器线路</h3>
<p>采用LC谐振回路作为选频网络的反馈振荡器统称为LC振荡器。LC振荡器按其反馈网络的不同，可分为互感耦合振荡器、电感反馈式振荡器和电容反馈式振荡器三种类型，其中后两种通常统称为三端式振荡器</p>
<h3 id="互感耦合振荡器">互感耦合振荡器</h3>
<p>互感耦合振荡器是依靠线圈之间的互感耦合实现正反馈的，因此，耦合线圈同名端的正确位置至关重要。同时,耦合量M要选择合适,使其满足振幅起振条件。</p>
<p>互感耦合振荡器有三种形式:调集电路、调基电路和调发电路，具体根据振荡回路是在集电极电路、基极电路和发射极电路来区分的 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-29-41.png"></p>
<p>由于基极和发射极之间的输入阻抗比较低，为了避免过多地影响回路的Q 值，故在调基和调发这两个电路中，晶体管与振荡回路进行部分耦合。调集电路在高频输出方面比其他两种电路稳定,而且幅度较大,谐波成分较小。调基电路振荡频率在较宽的范围改变时，振幅比较平稳。</p>
<p><strong>互感耦合振荡器在调整反馈（改变M）时，基本上不影响振荡频率。但由于分布电容的存在,在频率较高时，难于做出稳定性高的变压器。因此，它们的工作频率不宜过高，一般应用于中、短波波段</strong></p>
<p>根据h 参数等效电路分析可知互感耦合振荡器的振荡频率 <span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\]</span></p>
<h3 id="三端式振荡器">三端式振荡器</h3>
<p>1 .电感反馈三端式振荡器（哈特莱电路） <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-44-13.png"></p>
<ul>
<li>线路特点：它的反馈电压<span class="math inline">\(\dot{v_f}\)</span>是由电感<span class="math inline">\(L_2\)</span>上获得的，晶体管的三个电极分别与回路电感的三个端点相连接，<strong>故称为电感反馈三端式振荡器</strong>。电路中集电极馈电采取串联馈电方式，基极则采取并联馈电方式, <span class="math inline">\(C_b\)</span>为隔直流电容，防止<span class="math inline">\(V_{CC}\)</span>通过电感， 加到基极，以免高压击穿管子。</li>
<li>振荡频率与反馈系数：<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\\L=L_1+L_2+2M，F=\frac{L_2+M}{L_1+M}\]</span></li>
<li>电路的优缺点：<strong>优点</strong>：<span class="math inline">\(L_1,L_2\)</span>之间有互感，反馈较强，容易起振;振荡频率调节方便,只要调整电容C的大小即可，而且C的改变基本上不影响电路的反馈系数。<strong>缺点</strong>:振荡波形不好，因为反馈电压是在电感上获得的，而电感对高次谐波呈高阻抗，因此对高次谐波的反馈较强，使波形失真大;另外，电感反馈三端电路的振荡频率不能做得太高，这是因为频率太高, L太小,不宜制造且分布参数的影响太大。电感三端式振荡器的工作频率一般在几十兆赫兹以下。</li>
</ul>
<ol start="2" type="1">
<li>电容反馈三端式振荡器(考比次电路) <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-40-21.png"></li>
</ol>
<ul>
<li>线路特点：它的反馈电压<span class="math inline">\(\dot{v_f}\)</span>是由电容<span class="math inline">\(C_2\)</span>上获得的，晶体管的三个电极分别与回路电容的三个端点相连接，故称为电容反馈三端式振荡器。电路中集电极和基极均采取并联馈电方式。<span class="math inline">\(C_b,C_c\)</span>均为隔直电容。</li>
<li>振荡频率与反馈系数：<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\\C=\frac{C_1C_2}{C_1+C_2},F=\frac{C_1}{C_2}\]</span></li>
<li>电路的优缺点：<strong>优点</strong>：振荡波形好，因为它的反馈电压<span class="math inline">\(\dot{v_f}\)</span>是靠电容获得的，而电容元件对信号的高次谐波呈低阻抗，因此，对高次谐波反馈较弱,使振荡波形更接近正弦波;另外,这种电路的频率稳定度较高，由于电路中的不稳定电容均与回路电容<span class="math inline">\(C_1,C_2\)</span>相并联,因此，适当加大回路的电容量，就可以减小不稳定因素对振荡频率的影响。电容三端电路的工作频率可以做得较高，因为它可直接利用振荡管的输出、输入电容作为回路的振荡电容。它的工作频率可做到几十兆赫兹到几百兆赫兹的甚高频波段范围。<strong>缺点</strong>:调<span class="math inline">\(C_1\)</span> 或<span class="math inline">\(C_2\)</span> 来改变振荡频率时,反馈系数也将改变。但只要在L两端并上一个可变电容器，并令<span class="math inline">\(C_1\)</span>与<span class="math inline">\(C_2\)</span>为固定电容，则在调整频率时,基本上不会影响反馈系数。</li>
</ul>
<ol start="3" type="1">
<li><p>三端式LC振荡器组成法则（相位平衡条件的判断准则） <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-47-42.png"> 电路要振荡必须满足条件：<span class="math display">\[x_{be}+x_{ce}+x_{cb}=0\]</span></p>
<p>且由电路分析可以得到，为了满足正反馈条件，<span class="math inline">\(x_{eb},x_{ce}\)</span>必须性质相同，为同名电抗，<span class="math inline">\(x_{cb}\)</span>则为异名电抗，<strong>以此准则可以迅速判断振荡电路组成是否合理，能否起振</strong></p></li>
<li><p>串联型改进电容三端式振荡器(克拉泼电路) <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-52-39.png"> 与电容三端式电路比较，克拉泼电路的特点是在回路中增加了一个与L串联的电容<span class="math inline">\(C_3\)</span>。各电容取值必须满足：<span class="math inline">\(C_3&lt;&lt;C_1,C_3&lt;&lt;C_2,C_3\)</span>为可变电容。这样可使电路的振荡频率近似只与<span class="math inline">\(C_3,L\)</span>有关。该电路的振荡频率为<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC_3}}\]</span>可见，该电路的振荡频率几乎与<span class="math inline">\(C_1,C_2\)</span>无关，<strong>所以克拉泼电路的频率稳定性比电容三端式要好</strong>，其缺点为<strong>不适于用作波段振荡器</strong>。所以克拉泼电路只适于用作固定频率振荡器或波段覆盖系数较小的可变频率振荡器</p></li>
<li><p>并联型改进电容三端式振荡器(西勒电路) <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-58-59.png"> 西勒电路是在克拉泼电路基础上,在电感L两端并联了一个小电容<span class="math inline">\(C_4\)</span>,且满足<span class="math inline">\(C_1,C_2\)</span>远大于<span class="math inline">\(C_3\)</span> ，所以其回路等效电容<span class="math display">\[C=\frac{C_1C_2C_3}{C_1C_2+C_2C_3+C_1C_3}+C_4\approx C_3+C_4\]</span> 振荡频率为:<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\\C=C_3+C_4\]</span></p>
<p>在西勒电路中，由于<span class="math inline">\(C_4\)</span>与L并联，所以<span class="math inline">\(C_4\)</span>大小不影响回路接入系数，在振荡频率变化时基本保持不变，从而使输出振幅稳定，因此其可用作波段振荡器</p></li>
</ol>
<h3 id="振荡器的频率稳定问题">振荡器的频率稳定问题</h3>
<p>振荡器的频率稳定度是振荡器的一个关键指标。频率稳定，就是在各种外界条件发生变化的情况下，要求振荡器的实际工作频率与标称频率间的偏差及偏差的变化最小。<strong>评价振荡器频率的主要指标有两个,即准确度与稳定度。</strong></p>
<p><strong>振荡器的实际工作频率f与标称频率<span class="math inline">\(f_0\)</span>之间的偏差，称为振荡频率的准确度</strong>。它通常分为绝对频率准确度与相对频率准确度两种，其表达式如下。 <span class="math display">\[绝对准确度：\Delta f=|f-f_0|\\相对准确度：\frac{\Delta f}{f_0}=\frac{|f-f_0|}{f_0}\]</span></p>
<p><strong>振荡器的频率稳定度则是指在一定时间间隔内，由于各种因素变化，引起的振荡频率相对于标称频率变化的程度</strong><span class="math display">\[频率稳定度：\delta=\frac{\Delta f_{max}}{f_0}|_{t=\Delta t}\]</span></p>
<h3 id="石英振荡器">石英振荡器</h3>
<p><img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-15-15-03.png"> 上图是石英晶振的符号和等效电路，石英晶振的Q值和特性阻抗<span class="math inline">\(\rho\)</span>都非常高。这是因为其<span class="math inline">\(L_q\)</span>较大，<span class="math inline">\(C_q\)</span>与<span class="math inline">\(r_q\)</span>很小的缘故。</p>
<p>由上图(b)可知，石英晶振可等效为一个串联谐振回路和一个并联谐振回路，若忽略<span class="math inline">\(r_q\)</span>,则晶振两端呈现纯电抗，其电抗频率特性曲线如下图实线所示 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-15-15-22.png"> 其串联谐振频率为<span class="math inline">\(f_q=\frac{1}{2\pi\sqrt{L_qC_q}}\)</span>,并联谐振频率为<span class="math inline">\(f_p=\frac{1}{2\pi\sqrt{L_q\frac{C_0C_q}{C_0+C_q}}}\\=\frac{f_0}{\sqrt{\frac{C_0}{C_0+C_q}}}=f_q\sqrt{1+\frac{C_q}{C_0}}\)</span></p>
<p>由于<span class="math inline">\(C_q/C_0\)</span>很小，所以<span class="math inline">\(f_p,f_q\)</span>间隔很小，因而在<span class="math inline">\(f_p-f_q\)</span>感性区间, 石英晶振具有陡峭的电抗频率特性，曲线斜率大，利于稳频。若外部因素使谐振频率增大，则根据晶振电抗特性,必然使等效电感L增大，但由于振荡频率与L的平方根成反比,所以又促使谐振频率下降,趋近于原来的值。</p>
<h4 id="晶体谐振器电路">晶体谐振器电路</h4>
<p>将石英晶振作为高Q 值谐振回路元件接入正反馈电路中，就组成了晶体振荡器。根据石英晶振在振荡器中的作用原理，晶体振荡器可分成两类:<strong>一类是将其作为等效电感元件用在三端式电路中，工作在感性区间，称为并联型晶体振荡器;另一类是将其作为一个短路元件串接于正反馈支路上,工作在它的串联谐振频率上，称为串联型晶体振荡器</strong></p>
<h2 id="自问自答">自问自答</h2>
<ol type="1">
<li><p>如何化简正弦波振荡器电路？ 在正弦波振荡电路中我们考虑的往往是正反馈产生振荡的电路，因此在简化电路的过程中只需要聚焦正反馈部分即可。不妨对振荡电路中的R、L、C分别讨论。 对于R，在电路化简过程中我们认为其开路，因为R在电路中起到的作用与正反馈无关。 对于L，在高频电路中L的阻抗<span class="math inline">\(jwL\)</span>很高，尤其是L充当高频扼流圈时往往认为L开路。 对于C，在高频电路中C的阻抗<span class="math inline">\(\frac{1}{jwL}\)</span>很低，尤其是C充当旁路电容、耦合电容、电源滤波电容时往往认为C短路。</p></li>
<li><p>为什么要对电容反馈三端式振荡电路进行改进呢？ 当我们利用电容反馈三端式电路，调<span class="math inline">\(C_1\)</span>或<span class="math inline">\(C_2\)</span>来改变振荡频率时，由于反馈系数为<span class="math inline">\(\frac{C_1}{C_2}\)</span>，易知反馈系数将改变。但是如果给电路串联一个小电容<span class="math inline">\(C_3\)</span>，因为C3远远小于C1和C2，所以三电容串联后的等效电容可以约等于<span class="math inline">\(C_3\)</span>。此时振荡角频率和反馈系数独立，可以有效调整并控制电路。<span class="math display">\[w_0\approx\frac{1}{LC_3},F=\frac{C_1}{C_2}\]</span></p></li>
<li><p>电感反馈三端式振荡器与电容反馈三端式振荡器各有何优缺点？ <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-05-15-00-09.png"></p></li>
</ol>
<h2 id="未解答的疑惑">未解答的疑惑</h2>
<ol type="1">
<li>对泛音晶体振荡电路的原理不太理解。</li>
<li>石英振荡器的作用和设计思路不理解</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第六章知识小结</title>
    <url>/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="本章知识小结">本章知识小结</h2>
<h3 id="频谱搬移电路的特性">频谱搬移电路的特性</h3>
<p>非线性电路具有频率变换的功能（乘法器）<br>
线性频率变换：频率变换前后，信号的频谱结构不变. 频谱搬移电路: 信号频谱无失真的在频率轴上搬移 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-37-29.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>它们的实现框图几乎是相同的，都是利用非线性器件对输入信号频谱实行变换以产生新的有用频率成分后，滤除无用频率分量。</li>
<li>从频谱结构看，上述频率变换电路都只是对输入信号频谱实行横向搬移而不改变原来的谱结构，因而都属于所谓的线性频率变换。</li>
<li>频谱的横向平移从时域角度看相当于输入信号与一个参考正弦信号相乘，而平移的距离由此参考信号的频率决定，它们可以用乘法电路实现。</li>
</ol>
<h3 id="振幅调制原理">振幅调制原理</h3>
<p>调制:将要传送的信息装载到某一高频载频信号上去的过程 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-56-11.png" style="width:60.0%;height:60.0%"></p>
<p>调制可分为连续波调制和脉冲波调制 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-57-02.png" style="width:60.0%;height:60.0%"> 本章主要介绍的是调幅，调频与调相将在第七章中讲述。 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-58-10.png" style="width:60.0%;height:60.0%"></p>
<h4 id="调幅波的性质">调幅波的性质</h4>
<p>普通调幅波的数学表达式(一般考虑单音调制) <span class="math display">\[\begin{cases}
    载波信号：v_0=V_0cosw_0t\\
    调制信号：v_\Omega=V_\Omega cos\Omega t\\
    调幅信号(已调波)：v_{AM}=V_m(t)cosw_0t
\end{cases}\]</span> 因为调幅信号的振幅与调制信号成线性关系，所以<span class="math inline">\(V_m(t)=V_0+k_aV_\Omega cos\Omega t,k为比例常数\\\rightarrow V_m(t)=V_0(1+\frac{k_aV_\Omega}{V_0}cos\Omega t)=V_0(1+m_acos\Omega t),m_a=\frac{k_aV_\Omega}{V_0}:调幅度\in (0,1]\)</span> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-06-02.png" style="width:60.0%;height:60.0%"> 波形特点： 1. 调幅波的振幅（包络）变化规律与调制信号波形一致 2. 调幅度<span class="math inline">\(m_a\)</span>反映了调幅的强弱度 <span class="math display">\[\begin{cases}
    m_a=0,未调幅\\
    m_a=1,最大调幅\\
    m_a&gt;1,过调幅，包络失真
   \end{cases}\]</span></p>
<p>将调幅波的数学表达式展开，可得<span class="math inline">\(v(t)=V_0cosw_0t+\frac{1}{2}m_aV_0cos(w_0+\Omega)t+\frac{1}{2}m_aV_0cos(w_0-\Omega)t\)</span> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-14-07.png" style="width:60.0%;height:60.0%"> 调幅波包含三个频率分量，载波分量<span class="math inline">\(w_0\)</span>不含传输信息，上边频分量<span class="math inline">\(w_0+\Omega\)</span>,下边频分量<span class="math inline">\(w_0-\Omega\)</span>均含传输信息</p>
<p><strong>调幅过程实际上是 频谱搬移过程，即将调制信号的频谱搬移到载波附近，成为对称排列在载波频率两侧的上、下边频，幅度均等于<span class="math inline">\(\frac{1}{2}m_aV_0\)</span></strong></p>
<p>将普通调幅波输送功率至电阻R上时,载波与边频的功率有： 1. 载波频率<span class="math inline">\(P_{oT}=\frac{1}{2}\frac{V_o^2}{R}\)</span> 2. 上(小)边频<span class="math inline">\(P_{SB1}=P_{SB2}=\frac{1}{4}m_a^2P_{oT}\)</span> 3. 一周期平均输出功率<span class="math inline">\(P_AM=(1+\frac{1}{2}m_a^2)P_{oT}\)</span></p>
<p><strong>载波不含信号，但功率却占整个调幅波功率的绝大部分,效率很低</strong></p>
<h4 id="抑制载波的双边带调幅波与单边带调幅波">抑制载波的双边带调幅波与单边带调幅波</h4>
<p>为了克服普通调幅波效率低的缺点，提高设备的功率利用率，可以不发送载波，而只发送边带信号<span class="math inline">\(\rightarrow\)</span>抑制载波的双边带调幅波(DSB AM)</p>
<p>上边频与下边频的频谱分量对称含有相同的信息。 可仅发送单个边带信号<span class="math inline">\(\rightarrow\)</span>单边带通信(SSB) <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-23-38.png" style="width:60.0%;height:60.0%"> 残留边带调幅(记为VSB AM)它在发射端发送一个完整的边带信号、载波信号和另一个部分被抑制的边带信号.既保留了单边带调幅节省频带的优点，且具有滤波器易于实现、解调电路简单的特点</p>
<h3 id="振幅调整方法和电路">振幅调整方法和电路</h3>
<h4 id="概述">概述</h4>
<p>调幅波的共同之处都是在调幅前后产生了新的频率分量，均需用非线性器件来完成频率变换 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-25-06.png" style="width:60.0%;height:60.0%"> 按调制电路输出功率的高低分类： 1. 高电平调幅电路 　　一般置于发射机的最后一级，是在功率电平较高的情况下进行调制。 2. 低电平调幅电路 　　一般置于发射机的前级，再由线性功率放大器放大已调幅信号，得到所要求功率的调幅波。 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-08-35-28.png" style="width:60.0%;height:60.0%"></p>
<h4 id="低电平调幅电路">低电平调幅电路</h4>
<ol type="1">
<li>简单二极管调幅电路：
<ul>
<li>平方律调幅--二极管小信号时的工作状态</li>
<li>开关调幅--二极管大信号时的工作状态</li>
</ul></li>
<li>平衡调幅器 平衡调制是由两个简单的二极管调幅电路对称连接组成。载波成分由于对称而被抵消，在输出中不再出现。
<ol type="1">
<li>用处：产生DSB和SSB信号的基本电路<br>
</li>
<li>优点：可抑制单管调幅器频谱中所含的直流分量、载波分量以及载波的各次谐波分量</li>
<li>缺点：它虽然是调幅波，但因失去了载波，因而包络不能完全反映调制信号变化的规律，这就给以后的解调工作带来困难；普通调幅波的高频振荡是连续的，可是双边带调幅波在调制信号极性变化时，它的高频振荡的相位要发生180°的突变</li>
</ol></li>
<li>环形调制器 平衡调幅器加上两个二极管，并将四个二极管首尾相接构成环形，<strong>优点：振幅比平衡调制器提高了一倍，并抑制了低频<span class="math inline">\(\Omega\)</span>分量</strong></li>
<li>模拟相乘器 输出电压与输入电压关系：<span class="math inline">\(v_o(t)=kv_1(t)v_2(t)\)</span>，如果<span class="math inline">\(v_1(t)\)</span>为高频载波，<span class="math inline">\(v_2(t)\)</span>为低频调制信号，则输出为抑制载波的双边带调幅信号，若在调制信号上<span class="math inline">\(v_2(t)\)</span>叠加一直流电压，则可以得普通调幅信号的输出</li>
<li>单边带通信
<ol type="1">
<li>优点：
<ol type="1">
<li>节约频带</li>
<li>节省功率</li>
<li>受传播条件影响小,抗选择性衰落能力强</li>
<li>提高了信噪比</li>
</ol></li>
<li>缺点：
<ol type="1">
<li>单边带通信设备复杂、价格昂贵</li>
<li>收发信机需要很高的频率稳定度及其它技术措施 参数单边带方法</li>
</ol></li>
<li>产生单边带方法
<ol type="1">
<li>滤波法：DSB信号经过带通滤波器后，滤除下边带，就得到了SSB信号</li>
<li>移项法：利用移相的方法，消去不需要的边带</li>
<li>修正的移相滤波法</li>
</ol></li>
</ol></li>
</ol>
<h4 id="高电平调幅电路">高电平调幅电路</h4>
<ol type="1">
<li>集电极调幅 工作在过压区，调制信号经低频变压器加载集电极与直流电源串馈，高频载波经高频变压器加到基极回路</li>
<li>基极调幅 工作在欠压区，将基极供电电压与调制信号相加</li>
</ol>
<h3 id="振幅解调检波原理与电路">振幅解调（检波）原理与电路</h3>
<h4 id="概述-1">概述</h4>
<p>振幅解调(又称检波)：振幅调制的逆过程 作用：从已调制的高频振荡中恢复出原来的调制信号 检波器也属于频谱搬移 从频谱看，检波是将幅度调制波中的边带信号不失真地从载波频率附近搬移到零频率附近 　 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-09-40-46.png"> 检波器分类： 1. 包络检波：平方率检波，峰值包络检波，平均包络检波 2. 同步检波：乘积型，叠加型</p>
<h4 id="二极管峰值包络检波器">二极管峰值包络检波器</h4>
<p><img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-09-46-16.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>大信号检波原理：
<ul>
<li>二极管单向导电特性</li>
<li>检波负载RC的充放电过程(充电时间常数小，放电时间常数大) 通过调节电路中的R,C,可改变充电时间常数，最后让<span class="math inline">\(v_C\)</span>接近<span class="math inline">\(v_i\)</span> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-09-44-44.png"></li>
</ul></li>
<li>包络检波器的质量指标
<ol type="1">
<li>电压传输系数(检波效率)<span class="math inline">\(K_d=\frac{输出电压V_\Omega}{输入包络振幅m_aV_i}\)</span>,<span class="math inline">\(K_d=cos\theta,\theta\approx\sqrt[3]{\frac{3\pi R_d}{R}}\\\theta:电流通角，R：检波器负载电阻，R_d：检波器二极管内阻\)</span></li>
<li>等效输入电阻<span class="math inline">\(R_{id}=\frac{R}{2K_d}\approx R/2\)</span>,即大信号二极管的输入电阻约等于负载电阻的一半</li>
</ol></li>
<li>失真
<ol type="1">
<li>惰性失真(对角线切割失真)
<ul>
<li>原因：时间常数RC太大，当调幅波包络朝较低值变化时，电容上的电荷来不及释放以跟踪其变化，所造成的失真</li>
<li>不产生失真的条件：<span class="math inline">\(RC\Omega_{max}&lt;\frac{\sqrt{1-m_a^2}}{m_a}\)</span>,工程上按<span class="math inline">\(RC\Omega_{max}\le1.5\)</span>计算</li>
</ul></li>
<li>负峰切割失真(底部切割失真)
<ul>
<li>原因：由于<span class="math inline">\(C_c\)</span>的存在使得检波器的交直流电阻不一样,产生了<span class="math inline">\(V_R\)</span>反偏压，它有可能阻止二极管导通，从而产生失真</li>
<li>不产生失真的条件:<span class="math inline">\(m_a&lt;\frac{R_g}{R+R_g}=\frac{R_\smile}{R},R_\smile:交流电阻，R:直流电阻\)</span></li>
</ul></li>
<li>非线性失真 由检波二极管伏安特性曲线的非线性所引起</li>
<li>频率失真
<ul>
<li>原因：滤波电容<span class="math inline">\(C\)</span>影响检波上限频率<span class="math inline">\(\Omega_{max}\)</span>和耦合电容<span class="math inline">\(C_c\)</span>影响检波下限频率<span class="math inline">\(\Omega_{min}\)</span></li>
<li>不产生失真条件：<span class="math inline">\(C_c&gt;&gt;\frac{1}{\Omega_{min}R_g},C&lt;&lt;\frac{1}{\Omega_{max}R}\)</span></li>
</ul></li>
</ol></li>
</ol>
<h4 id="同步检波电路">同步检波电路</h4>
<p>同步检波：不含载频分量，解调时必须在检波器输入端另加一个与发射载波同频同相并保持同步变化的参考信号，此参考信号与调幅信号共同作用于非线性器件电路，经过频率变换，恢复出调制信号 同步检波也可应用于普通调幅信号的解调<span class="math inline">\(\rightarrow\)</span>为了改善性能 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-05-16.png" style="width:60.0%;height:60.0%"> 产生本地振荡信号的方法:</p>
<ol type="1">
<li>由发送端发出导频信号，控制本地振荡器，使本地振荡器的频率和相位与发送端一致。</li>
<li>对于双边带调制来说，可以从双边带调制信号中提取所需的同频同相的载波信号作本地振荡信号。对于单边带调制信号来说，无法直接从单边带信号中提取载波信号，因此在发射单边带信号的同时，还发射受到一定程度抑制的载波信号（称为导频信号）。在接收端，用导频信号控制本机振荡信号使其同步。</li>
<li>采用锁相方法从抑制载波的信号中提取载波 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-08-59.png"> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-09-28.png" style="width:60.0%;height:60.0%"></li>
</ol>
<h3 id="混频器原理与电路">混频器原理与电路</h3>
<h4 id="概述-2">概述</h4>
<p>混频器作用：混频即对信号进行频率变换，将其载频变换到某一固定的频率上(常称为中频)，而保持原信号的特征(如调幅规律)不变。<strong>变频的优点</strong>：变频可提高接收机的灵敏度，提高接收机的选择性，工作稳定性好，波段工作时其质量指标一致性好。<strong>变频的缺点</strong>：容易产生镜像干扰、中频干扰等干扰 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-25-48.png" style="width:60.0%;height:60.0%"> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-26-42.png"> 1. 叠加型混频器: 根据所用非线性器件的不同，叠加型混频器有下列几种： - 晶体三极管混频器：具有一定混频增益 - 场效应管混频器：交调、互调干扰少 - 二极管平衡混频器和环形混频器 ：动态范围大，组合频率干扰少 2. 乘积型混频器：模拟乘法器＋带通滤波器</p>
<h4 id="晶体三极管混频器">晶体三极管混频器</h4>
<p><img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-29-39.png"> 主要采用变跨导分析法：在混频时，混频管可看成一个参数(跨导)在改变的线性元件，即变跨导线件元件。其变频跨导被定义为<span class="math inline">\(g_c=\frac{输出中频电流振幅I_i}{输入高频电压振幅V_{Sm}}=\frac{1}{2}g_1\)</span></p>
<h4 id="晶体管二极管混频器">晶体管二极管混频器</h4>
<p><img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-33-16.png" style="width:60.0%;height:60.0%"> 1. 平衡混频器<br>
2. 环形混频器</p>
<h4 id="混频器的干扰">混频器的干扰</h4>
<ol type="1">
<li><p>有用信号谐波和本振信号谐波产生的干扰--组合频率干扰(干扰哨声) 混频器输出信号中所包含的各种频率分量为<span class="math inline">\(f_k=|\pm pf_o\pm qf_s|\)</span>,p,q为任意正整数，分别代表本振频率和信号频率的谐波次数，只有p=q=1时对应的频率<span class="math inline">\(f_o-f_s\)</span>为所需要的中频信号，这意味着<span class="math inline">\(f_o=f_i+f_s\)</span></p>
<p>如果某些组合频率落在谐振回路的通频带内，这些组合频率分量就和有用的中频分量一样，通过中放进入检波器，并在检波电路中与有用信号产生差拍，这时在接收机的输出端将产生哨叫声，形成有害的干扰。这种干扰又称为干扰哨叫，产生条件<span class="math inline">\(f_s=\frac{p\pm1}{q-p}f_i\)</span></p></li>
<li><p>外来干扰信号和本振产生的干扰</p>
<ol type="1">
<li>组合副波道干扰 如果混频器之前的输入回路和高频放大器的选择性不够好，除了要接收的有用信号外，干扰信号也会进入混频器。当干扰频率<span class="math inline">\(f_n\)</span>与本振频率<span class="math inline">\(f_o\)</span>满足 <span class="math display">\[\begin{cases}
  -pf_o+qf_n\approx f_i\\
  pf_o-qf_n\approx f_i
 \end{cases}\]</span> 会产生组合副波道干扰</li>
<li>副波道干扰 在组合副波道干扰中，某些特定频率形成的干扰称为副波道干扰。这种干扰主要有中频干扰和镜像干扰。
<ol type="1">
<li>中频干扰：当干扰信号的频率等于或接近<span class="math inline">\(f_i\)</span>时的干扰。</li>
<li>镜像频率干扰:当外来干扰信号的频率<span class="math inline">\(f_n=f_o+f_i=f_s&#39;\)</span>时的干扰，<span class="math inline">\(f_n=f_o+f_i=f_s+2f_i\)</span></li>
</ol></li>
</ol></li>
<li><p>其他类型的干扰</p>
<ol type="1">
<li>交叉调制(交调)干扰 当所接收电台的信号和干扰电台同时进入接收机输入端时，如果接收机调谐于信号频率，可以清楚地收到干扰信号电台的声音，若接收机对接收信号频率失谐，干扰台的声音也消失,<strong>原因：由混频器3次方以上的非线性传输特性产生的。</strong></li>
<li>互相调制(互调)干扰 当两个或两个以上的干扰进入到混频器的输入端时，它们与本振电压<span class="math inline">\(v_0\)</span>一起加到混频管的发射结。由于器件的非线性作用，它们将产生一系列组合频率分量。如果某些分量的频率等于或接近于中频时，就会形成干扰，称为互调干扰。假设有两个干扰信号进入到混频器，若两干扰信号形成的新的组合频率<span class="math inline">\(|\pm mf_1\pm nf_2|\)</span>与信号频率<span class="math inline">\(f_s\)</span>相近，即组合频率与本振频率<span class="math inline">\(f_0\)</span>之差落在中频范围<span class="math inline">\(f_0-|\pm mf_1\pm nf_2|=f_i\)</span>,就会造成强烈干扰</li>
<li>阻塞干扰 当一个强干扰信号进入接收机输入端后，由于输入电路抑制不良，会使前端电路内放大器或混频器的晶体管处于严重的非线性区域，使输出信噪比大大下降。这种现象称为阻塞干扰。</li>
<li>相互混频 由于本振源内存在杂散边带功率，强干扰与杂散边带噪声混频产生的频率分量落在中频通带内形成中频噪声</li>
</ol></li>
</ol>
<p>综上所述，减小各种干扰的措施可归纳为： 1. 提高混频级前端电路(天线回路和高放)的选择性 2. 合理地选择中频，能有效地减小组合频率干扰 3. 采用各种平衡电路 4. 合理地选择混频管的静态工作点 5. 采用倍频程滤波器抑制二阶互调</p>
<h2 id="自问自答">自问自答</h2>
<ol type="1">
<li><p>为什么在信号传播过程中需要对信号进行调制？</p>
<p>在信号传输过程中，不妨从切实可行的天线选择出发思考。为使天线能有效地发送和接收电磁波，天线的几何尺寸必须和信号波长相比拟，一般不宜短于1／4波长。对于音频信号，一般频率在20Hz～20kHz，其波长为15～15000km，如果使用天线传输天线长度应在3.75～3750km，不容易实现。因此需要将信号调制到高频，使用小尺寸天线处理。</p></li>
<li><p>在同步检波电路中，产生本地信号的方法往往有哪些呢？</p>
<ol type="1">
<li>由发送端发出导频信号，控制本地振荡器，使本地振荡器的频率和相位与发送端一致。</li>
<li>对于双边带调制来说，可以从双边带调制信号中提取所需的同频同相的载波信号作本地振荡信号。</li>
<li>对于单边带调制信号来说，无法直接从单边带信号中提取载波信号，因此在发射单边带信号的同时，还发射受到一定程度抑制的载波信号（称为导频信号）。在接收端，用导频信号控制本机振荡信号使其同步</li>
</ol></li>
<li><p>为什么要对电路进行变频处理？</p>
<ol type="1">
<li>变频可提高接收机的灵敏度</li>
<li>提高接收机的选择性</li>
<li>工作稳定性好</li>
<li>波段工作时其质量指标一致性好</li>
</ol></li>
</ol>
<h2 id="未解答的疑惑">未解答的疑惑</h2>
<ol type="1">
<li>如何理解混频器和变频器的区别</li>
<li>如何区分不同干扰的类型</li>
<li>如何判断不同混频器的优缺点</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第四章知识小结</title>
    <url>/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="概述">概述</h2>
<p>谐振功率放大器的主要任务是用来放大高频大信号，主要用于发射机的末级，使其获得 足够的高频功率并馈送到天线辐射出去，谐振功率放大器主要解决的问题是高效率和高功率输出</p>
<p><strong>谐振功率放大器与小信号谐振放大器以及非谐振功率放大器有什么异同之处呢？</strong>：谐振 功率放大器与小信号谐振放大器相同之处是,它们放大的信号均为高频信号,而且放大器的 负载均为谐振回路。而不同之处为，激励信号幅度大小不同，放大器工作点不同，晶体管动 态范围不同。小信号谐振放大器的激励信号幅度小,工作点取在特性曲线的中间，放大后电流为完整的正弦波，小信号谐振放大器也称为线性谐振放大器。谐振功率放大器的激励信号通常大于IV ,工作点一般取在截止偏压以下，只有当信号幅度大于管子的截止偏压时管子才导通，它放大后的电流为余弦脉冲状电流波形 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-19-11.png"> 谐振功率放大器与非谐振功率放大器都要求输出功率大和效率高。功率放大器实质上是一个能量转换器，即把电源供给的直流能量转化为交流能量,能量转换的能力即功率放大器的效率。谐振功率放大器通常用来放大窄带高频信号（信号的通带宽度只有其中心频率的 1%或更小）,其工作状态通常选为丙类工作状态,为了不失真地放大信号，它的负载必须是谐振回路。而非谐振放大器又可分为低频功率放大器和宽带高频功率放大器。低频功率放大器的负载为无调谐负载,如电阻、变压器等,通常工作在甲类或乙类工作状态；宽带高频功率放大器则是以频率响应很宽的传输线作负载，放大器可在很宽的范围内变换工作频率，而不必重新调谐 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-20-57.png"> 由于谐振功率放大器通常工作于丙类工作状态，属于非线性电路。因此,不能采用线性 等效电路进行分析，<strong>通常采用折线近似分析法进行分析</strong></p>
<h2 id="谐振功率放大器的工作原理">谐振功率放大器的工作原理</h2>
<h3 id="谐振功率放大器的原理及电压电流波形">谐振功率放大器的原理及电压电流波形</h3>
<p><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-21-42.png"> 如上图所示，谐振功率放大器电路由晶体管，LC谐振回路和直流供电回路组成，晶体管负责将供电电源的直流能量转换为交流能量的过程中其开关控制左右，谐振回路则是晶体管的负载，直流供电电路为各级提供适当工作状态和能源，<span class="math inline">\(V_{BB}\)</span>为基极偏置，<span class="math inline">\(V_{CC}\)</span>为集电极电源，由于基极为负偏压，晶体管工作状态为丙类工作状态，在此电路中外部电路关系式为 <span class="math display">\[v_{BE}=-V_{BB}+V_{bm}coswt\\v_{CE}=V_{CC}-V_{cm}coswt\]</span>,晶体管内部特性为<span class="math inline">\(i_c=g_c(v_{BE}-V_{BZ})\)</span>,上式为晶体管的转移特性曲线表达式，由下图可以进一步得到<span class="math display">\[V_{bm}cos\theta_c=|V_{BB}|+V_{BZ}\rightarrow cos\theta_c=\frac{|V_{BB}|+V_{BZ}}{V_{bm}}\]</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-28-35.png"></p>
<h3 id="谐振功率放大器的功率关系和放大器的效率">谐振功率放大器的功率关系和放大器的效率</h3>
<p>功率放大器的作用原理是利用输入到基极的信号来控制集电极的直流电源所供给的直流功率，使其转变为交流信号功率输出。这种转换不可能是百分之百的，因为直流电源所供给的功率<span class="math inline">\(P_=\)</span>除了转变为交流输出功率<span class="math inline">\(P_o\)</span>的那一部分外，还有一部分功率以热能的形式消耗在集电极上，成为集电极耗散功率<span class="math inline">\(P_c\)</span>,由能量守恒定律有<span class="math inline">\(P_==P_o+P_c\)</span>,为了说明晶体管放大器转换能力，采用集电极效率<span class="math inline">\(\eta_c=\frac{P_o}{P_=}=\frac{P_o}{P_o+P_c}\)</span>,由此可得出以下结论：1. 尽量降低集电极耗散功率<span class="math inline">\(P_c\)</span>,集电极效率<span class="math inline">\(\eta_c\)</span>自然会提高，这样给定<span class="math inline">\(P_=\)</span>，<span class="math inline">\(P_o\)</span>就会增大。2. 如果维持<span class="math inline">\(P_c\)</span>不超过规定值，提高集电极效率会使交流输出功率增加</p>
<p>谐振功率放大器工作在丙类工作状态时<span class="math inline">\(\theta_c&lt;90°,\theta_c:\)</span>半通角，集电极余弦电流脉冲可分解为傅里叶级数<span class="math display">\[i_c=I_{C0}+I_{cm1}coswt+I_{cm2}cos2wt+\dots\]</span> 因此，谐振功率放大器各功率关系如下：<span class="math display">\[P_==V_{CC}\cdot I_{C0},P_o=\frac{1}{2}I_{cm1}^2R_p,P_c=P_=-P_o,\eta_c=\frac{1}{2}\xi g_1(\theta_c)\]</span>,式中<span class="math inline">\(\xi=\frac{V_{cm}}{V_{CC}}\)</span>称为集电极电压利用系数，<span class="math inline">\(g_1(\theta_c)=\frac{I_{cm1}}{I_{c0}}\)</span>称为波形系数，他是半通角的函数,<span class="math inline">\(\theta_c\)</span>越小，<span class="math inline">\(g_1(\theta_c)\)</span>越大，由以上分析可知：<strong>谐振功率放大器的工作特点是，基极偏置为负值;半通角<span class="math inline">\(\theta_c&lt;90°\)</span>,即丙类工作状态;负载为LC谐振回路</strong></p>
<h2 id="晶体管谐振功率放大器的折线近似分析法">晶体管谐振功率放大器的折线近似分析法</h2>
<h3 id="晶体管特性曲线的理想化及其解析式">晶体管特性曲线的理想化及其解析式</h3>
<p>通常在谐振功率放大器的分析计算时需要对晶体管的转移特性和输出特性的实际特性进行折线理想化,根据理想化原理,晶体管的静态转移特性可用交横轴于<span class="math inline">\(V_{BZ}\)</span>的一条直线来表示(<span class="math inline">\(V_{BZ}\)</span>为截止偏压),若用<span class="math inline">\(g_c\)</span>代表这条直线的斜率，则<span class="math inline">\(i_c=g_c(v_{BE}-V_{BZ}),v_{BE}&gt;V_{BZ},g_c=\frac{\Delta i_c}{\Delta v_{BE}}|_{v_{CE}为常数}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-46-27.png"> 由上图可见，在饱和区，根据理想化原理，集电极电流只受集电极电压的控制,而与基极电压无关，理想化特性曲线对不同的<span class="math inline">\(V_{BE}\)</span>值 ，重合为一条通过原点的斜线。我们称此斜线为临界线。<strong>临界线的左侧为饱和区,在此也称为过压区;临界线的右侧为放大区,也称为欠压区</strong>,<strong>若临界线的斜率为<span class="math inline">\(g_{cr}\)</span>,则临界线方程可写为<span class="math inline">\(i_c=g_{cr}v_{CE}\)</span></strong>,因此,在非线性谐振功率放大器中，常常根据集电极电流是否进入饱和区，将放大区的工作状态分为欠压工作状态、过压工作状态和临界工作状态</p>
<h3 id="集电极余弦电流脉冲的分解">集电极余弦电流脉冲的分解</h3>
<p>不论是工作在哪个区域，集电极电流都是周期性脉冲序列，可以用傅里叶级数求系数的方法，来求出它的直流、基波与各次谐波的数值。下面只讨论尖顶余弦脉冲电流的分解，将上一节的<span class="math inline">\(i_C,v_{BE},v_{CE}\)</span>的表达式联立化简可以得到以下表达式 <span class="math display">\[cos\theta_c=\frac{V_{BB}+V_{BZ}}{V_{bm}},\frac{i_C}{i_{C_{max}}}=\frac{coswt-cos\theta_c}{1-cos\theta_c}\\i_{C_{max}}=g_cV_{bm}(1-cos\theta_c)=g_{cr}(V_{CC}-V_{cm})(V_{cm}=\xi V_{CC})=g_{cr}(1-\xi)V_{CC}\]</span>,若将尖顶脉冲分解为傅里叶级数，则有<span class="math display">\[i_C=I_{C0}+I_{cm1}coswt+I_{cm2}cos2wt+...+I_{cmn}cosnwt\\I_{C0}=i_{C_{max}}\alpha_0(\theta_c),I_{cm1}=i_{C_{max}}\alpha_1(\theta_c),I_{cmn}=i_{C_{max}}\alpha_n(\theta_c)\]</span>,<span class="math inline">\(\alpha_n\)</span>是<span class="math inline">\(\theta_c\)</span>的函数，称为尖顶余弦脉冲的分解系数，通常为了兼顾功率与效率，最佳通角取70°左右，考试时一般会给出<span class="math inline">\(\alpha_0(70°)=0.253，\alpha_1(70°)=0.436\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-00-56.png"></p>
<h3 id="谐振功率放大器的动态特性与负载特性">谐振功率放大器的动态特性与负载特性</h3>
<ol type="1">
<li>动态特性 动态特性是在考虑了负载的反作用后,晶体管的集电极电流<span class="math inline">\(i_c\)</span>与<span class="math inline">\(v_{CE},v_{BE}\)</span>同时变化时的关系曲线，常称为交流负载线或工作路,将上一节的<span class="math inline">\(i_C,v_{BE},v_{CE}\)</span>的表达式联立化简可以得到在<span class="math inline">\(i_C-v_{CE}\)</span>坐标平面上的动态特性曲线方程<span class="math display">\[i_c=-g_c(\frac{V_{bm}}{V_{cm}})[v_{CE}-\frac{V_{bm}V_{CC}-V_{BZ}V_{cm}-V_{BB}V_{cm}}{V_{bm}}]\\=g_d(v_{CE}-V_0),g_d=-g_c(\frac{V_{bm}}{V_{cm}}),V_0=\frac{V_{bm}V_{CC}-V_{BZ}V_{cm}-V_{BB}V_{cm}}{V_{bm}}\]</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-07-42.png"></li>
<li>负载特性 根据以上动态特性曲线的分析，当谐振功放的负载<span class="math inline">\(R_p\)</span>变化时，由于<span class="math inline">\(V_{cm}\)</span>与<span class="math inline">\(R_p\)</span>有关,则动态特性曲线的斜率<span class="math inline">\(g_d\)</span>也发生变化，当负载电阻<span class="math inline">\(R_p\)</span>由小至大变化时,动态特性曲线的斜率也由小到大变化 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-10-04.png">
<ol type="1">
<li>欠压工作状态：当负载变大时，集电极电流脉冲的幅值和半通角变化不大，因此其直流分量，基波分量也变化不大，但其交流输出电压明显增大 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-13-23.png"></li>
<li>临界工作状态：工作在临界工作状态时，集电极电流脉冲波形仍为一个尖顶余弦脉冲，直流分量、基波分量与欠压工作状态时相差不大,而此时对应的交流输出电压<span class="math inline">\(V_{cm}\)</span>较大，管子的压降<span class="math inline">\(v_{CE_{max}}\)</span>较小 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-15-21.png"></li>
<li>过压工作状态:此时集电极电流脉冲波形由尖顶脉冲变为凹顶脉冲，其幅值与下凹点随负载变化均发生明显变化，但输出电压变化不明显 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-18-45.png"> 根据以上分析可以做出谐振功率放大器的负载特性曲线，并进一步得到功率效率随负载的变化趋势 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-18-58.png"></li>
</ol></li>
</ol>
<h3 id="各极电压对工作状态的影响">各极电压对工作状态的影响</h3>
<p>在实际应用中，放大器的各极电压发生改变时，放大器的工作状态也会发生改变,下面的分析主要是结合图像分析其电流电压变化趋势，然后根据前面讲述的功率与电压电流的关系，进一步推导得到功率的变化趋势，具体一点可以概括为：<span class="math inline">\(P_=\)</span>曲线形状与<span class="math inline">\(I_{c0}\)</span>曲线相同，<span class="math inline">\(P_o\)</span>曲线形状与<span class="math inline">\(I_{cm1}^2\)</span>曲线相同，<span class="math inline">\(P_c\)</span>则由两者之差求出</p>
<ol type="1">
<li>改变<span class="math inline">\(V_{CC}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-24-33.png"><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-24-41.png"></li>
<li>改变<span class="math inline">\(V_{bm}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-25-22.png"><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-25-33.png"></li>
<li>改变<span class="math inline">\(V_{BB}\)</span>:改变<span class="math inline">\(V_{BB}\)</span> ，其工作状态的变化与改变<span class="math inline">\(V_{bm}\)</span>对工作状态的影响是一样的。这是因为无论是<span class="math inline">\(V_{BB}\)</span>还是<span class="math inline">\(V_{bm}\)</span>的变化，其结果都是引起<span class="math inline">\(v_{BE}\)</span>的变化,增加<span class="math inline">\(V_{bm}\)</span>等效于减少<span class="math inline">\(V_{BB}\)</span>的绝对值，所以改变<span class="math inline">\(V_{BB}\)</span>的图只需要将<span class="math inline">\(V_{bm}\)</span>增加的反向改为<span class="math inline">\(|V_{BB}|\)</span>减小的方向即可</li>
</ol>
<h3 id="谐振功率放大器的计算">谐振功率放大器的计算</h3>
<p>谐振功率放大器的主要指标是功率和效率，精确计算较为困难,一般只做工程估算</p>
<ol type="1">
<li>计算功率放大器的指标时，首先要求得集电极电流脉冲的两个主要参量<span class="math inline">\(i_{C_{max}}\)</span>和<span class="math inline">\(\theta_c\)</span></li>
<li>计算电流余弦脉冲的各谐波分量</li>
<li>利用上列数据求出对应的功率和效率</li>
<li>求出最佳负载电阻<span class="math inline">\(R_P=\frac{(\xi V_{CC})^2}{2P_o}\)</span></li>
</ol>
<h2 id="谐振功率放大器电路">谐振功率放大器电路</h2>
<p>在实际的谐振功率放大器电路中，为了使放大器正常工作且输出功率大,传输效率高, 都有相应的输入、输出匹配电路以及合适的直流馈电电路</p>
<ol type="1">
<li><p>直流馈电电路：直流馈电电路包括集电极馈电电路和基极馈电电路，且馈电方式均可分为串联馈电和并联馈电两种,由下图可见串联馈电就是指晶体管，谐振回路，电源三者串联连接，并联则是并联连接 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-07-08-49-24.png"></p></li>
<li><p>输出匹配电路：在实际功放电路中，为了使谐振功率放大器有效地放大信号，在负载上获得最大功率输出，常在晶体管和负载之间加接输出四端网络，<strong>输出四端网络的作用主要是匹配、滤波和隔离</strong>，其主要可以分为<span class="math inline">\(\pi\)</span>型匹配网络和复合输出回路(将天线（负载）回 路通过互感或其他形式与集电极调谐回路相耦合),中介回路效率<span class="math inline">\(\eta_k=1-\frac{Q_L}{Q_0}\)</span>,天线功率<span class="math inline">\(P_A=P_o\cdot\eta_k,\eta_k=1-\frac{Q_L}{Q_0}\)</span></p></li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>锦标赛排序</title>
    <url>/2022/05/03/%E9%94%A6%E6%A0%87%E8%B5%9B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="锦标赛排序">锦标赛排序</h1>
<h2 id="前言">前言</h2>
<p>这种排序方式的经典应用来自百度的一道面试题：给出一个长度是N的数组，现在要找出最小的两个元素，最少要多少次比较？</p>
<span id="more"></span>
<h2 id="原理">原理</h2>
<p>竞标赛排序又叫树型排序，属于选择排序的一种，其目的是克服直接选择排序不能保留比较结果，不断重复比较的缺点，它的基本思想是首先取得n个元素的关键词，进行两两比较，得到n/2个比较优胜者，然后再两两比较找到第一小的那个，然后把最小那个元素对应的叶子节点的值变为无穷大，那么在搜索第二小值时，我们就只需要比较最小值叶子节点所在的子树即可，就达到了logn次比较的目标，然后一直重复该过程，所以其时间复杂度为O(n*log2n),空间复杂度为O（N）(需要2n-1个节点存放树) <strong>示意图</strong> <img src="https://s2.loli.net/2022/05/03/Igw4nbJCiX7SLDY.png" alt="锦标赛排序-1.png"> <img src="https://s2.loli.net/2022/05/03/rfcWwBUMAl7uzgp.png" alt="锦标赛排序-2.png"> ## 代码实现（python） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, _data, _id):</span><br><span class="line">        self.data = _data</span><br><span class="line">        self.id = _id</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.id, self.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Adjust(data, idx):</span><br><span class="line">    while (idx != 0):</span><br><span class="line">        if (idx % 2 == 1):</span><br><span class="line">            if (data[idx].data &lt; data[idx + 1].data):</span><br><span class="line">                data[(idx - 1) // 2] = data[idx]</span><br><span class="line">            else:</span><br><span class="line">                data[(idx - 1) // 2] = data[idx + 1]</span><br><span class="line">            idx = (idx - 1) // 2</span><br><span class="line">        else:</span><br><span class="line">            if (data[idx - 1].data &lt; data[idx].data):</span><br><span class="line">                data[idx // 2 - 1] = data[idx - 1]</span><br><span class="line">            else:</span><br><span class="line">                data[idx // 2 - 1] = data[idx]</span><br><span class="line">            idx = idx // 2 - 1</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Sort(data):</span><br><span class="line">    length = len(data)</span><br><span class="line">    n = 1</span><br><span class="line">    while n &lt; length:</span><br><span class="line">        n &lt;&lt;= 1</span><br><span class="line">        # print(&quot;n=&quot;,n)</span><br><span class="line">    nTreeSize = 2 * n - 1</span><br><span class="line">    nodes = []</span><br><span class="line">    for i in range(nTreeSize):</span><br><span class="line">        nodes.append(Node(0, 0))</span><br><span class="line">    # 初始化竞赛数数据</span><br><span class="line">    for i in range(n - 1, nTreeSize):</span><br><span class="line">        idx = i - (n - 1)</span><br><span class="line">        if idx &lt; length:</span><br><span class="line">            nodes[i] = Node(data[idx], i)</span><br><span class="line">        else:</span><br><span class="line">            nodes[i] = Node(9999, -1)</span><br><span class="line">    for i in range(n - 2, -1, -1):</span><br><span class="line">        if (nodes[i * 2 + 1].data &lt; nodes[i * 2 + 2].data):</span><br><span class="line">            nodes[i] = nodes[i * 2 + 1]</span><br><span class="line">        else:</span><br><span class="line">            nodes[i] = nodes[i * 2 + 2]</span><br><span class="line">    # 实现排序</span><br><span class="line">    B = []</span><br><span class="line">    for i in range(0, length):</span><br><span class="line">        # 取出最小的</span><br><span class="line">        B.append(nodes[0].data)</span><br><span class="line">        nodes[nodes[0].id].data = 9999</span><br><span class="line">        Adjust(nodes, nodes[0].id)</span><br><span class="line">    return B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    Arr = [2,5,9,1,11,20,15,7,4,6]</span><br><span class="line">    Arr2 = Sort(Arr)</span><br><span class="line">    print(&quot;newArr=&quot;,Arr2)</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 参考资料 <a href="https://www.cnblogs.com/james1207/p/3323115.html">james1207</a> <a href="https://blog.csdn.net/mmmmmmmmzw/article/details/105216255">mmmmmmmmzw</a></p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模笔记(司守奎)</title>
    <url>/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/</url>
    <content><![CDATA[<hr>
<h1 id="数学建模笔记司守奎">数学建模笔记（司守奎）</h1>
<h2 id="线性规划">线性规划</h2>
<ol type="1">
<li>定义： 在一组线性条件限制下，求一线性目标函数最大或最小的问题</li>
<li>标准的matlab形式：<span class="math inline">\(min f^T x,\)</span> <span class="math inline">\(s.t. \begin{cases} A\cdot x \le b\\ Aeq \cdot x = beq \\ lb \le x \le ub \end{cases}\)</span> 其中<span class="math inline">\(f,x,b,beq,lb,u\)</span>为列向量，<span class="math inline">\(A，Aeq\)</span>为矩阵</li>
<li>matlab相关求解命令为 <span class="math inline">\([x,val]=linprog(f,A,b,Aeq,beq,lb,ub)\)</span></li>
</ol>
<span id="more"></span>
<h2 id="整数规划">整数规划</h2>
<ol type="1">
<li>定义： 数学规划中的变量（部分或全部）限制为整数时，称为整数规划</li>
<li>分类： 根据变量整数是部分还是全部可分为纯整数规划和混合整数规划</li>
<li>求解方法：
<ol type="1">
<li>分支定界法（纯或混）</li>
<li>割平面法（纯或混）</li>
<li>隐枚举法（01规划）
<ul>
<li>过滤隐枚举法</li>
<li>分支隐枚举法</li>
</ul></li>
<li>匈牙利法（指派问题）</li>
<li>蒙特卡洛法（各种类型）</li>
</ol></li>
</ol>
<h3 id="型整数规划">0-1型整数规划</h3>
<ol type="1">
<li>定义：整数规划的一种特殊情况，变量仅取值0或1 应用范围可分为以下几种情况</li>
</ol>
<h4 id="相互排斥的约束条件">相互排斥的约束条件</h4>
<p>也就是说题目中的某一种条件只有一个量，如果给了这个1，同类的都为0，较为典型的问题有运输问题，只用一种方式运输，用火车运了，其他的运输栏都为0，其约束条件可进一步简化为 <span class="math display">\[y_i=\begin{cases}
1,第i个元素起约束作用\\
0,第i个元素不起作用，i=1,2.....,m\\
\end{cases}\]</span> <span class="math display">\[a_{i1}x_1+...a_{in}x_n\le b_i+(1-y_i)M,i=1,2...,m,\\
y_1+\dots+y_m=1
\]</span> 由约束条件很容易看出，当<span class="math inline">\(y_i\)</span>等于1,就只有这个约束起作用，其他的都是多余的</p>
<h4 id="固定费用的问题">固定费用的问题</h4>
<p>在讨论线性规划时，有些问题要求固定费用，这种问题可以通过改变为混合整数规划来解决，数学模型可表示为 <span class="math inline">\(y_i\epsilon\le x_i\le y_i M\)</span> 其中<span class="math inline">\(\epsilon\)</span>为充分小的正常数；M为充分大的正常数，表明<span class="math inline">\(x_i&gt;0\)</span>时，<span class="math inline">\(y_i\)</span>必须为1，<span class="math inline">\(x_i=0\)</span>时<span class="math inline">\(y_i\)</span>必须为0,<span class="math inline">\([x_i]\)</span>表示采用i方式生产时产量，<span class="math inline">\(y_i\)</span>表示是否用第i种方式生产</p>
<h4 id="指派问题">指派问题</h4>
<p>指派问题描述的是分配n个人去做n件事情，每个人做且仅做一件事情，且分配第i个人去做第j件事情，花费<span class="math inline">\(C_{ij}\)</span>单位时间，求如何分配使总时间最小，这类问题的关键就是要求出分配矩阵，数学形式可表现为 <span class="math inline">\(x_{ij}=\begin{cases} 1,第i人做第j项工作\\ 0,第i人做第j项工作\\ \end{cases}\)</span> 数学模型为：<span class="math inline">\(min \sum_{i=1}^N \sum_{j=1}^N c_{ij}x_{ij}\)</span> <span class="math inline">\(s.t. \begin{cases}  \sum_{i=1}^N x_{ij}=1,i=1,2,...,n\\  \sum_{j=1}^N x_{ij}=1,j=1,2,...,n\\  x_{ij}=0 or 1,i,j=1,...,n  \end{cases}\)</span></p>
<h3 id="蒙特卡洛法随机取样法">蒙特卡洛法（随机取样法）</h3>
<ol type="1">
<li>又被称为计算机随机模拟法，它是基于对大量数据的统计结果来实现一些确定性问题的计算</li>
<li>使用该方法必须使用计算机生成相关分布的随机数</li>
</ol>
<h3 id="整数线性规划的计算机求解">整数线性规划的计算机求解</h3>
<ol type="1">
<li>整数规划的求解用Lingo等专用软件比较方便，对于整数线性规划也可以用matlab的intlinprog函数求解，<strong>但其的缺点是必须把所有的决策变量化为一维决策变量，变量替换后，约束条件很难写出</strong>，最好用lingo</li>
<li>matlab求解混合整数线性规划的命令是</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【x,fval】=intlinprog(f,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure>
<p>对应以下数学模型 <span class="math inline">\(min_x f^Tx,\)</span> <span class="math inline">\(s.t. \begin{cases} x(intcon)为整数\\ A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb \le x \le ub \\ \end{cases}\)</span> 式中：<span class="math inline">\(f,x,intcon,b,beq,lb,ub为列向量；A，Aeq为矩阵\)</span></p>
<h2 id="非线性规划">非线性规划</h2>
<h3 id="非线性规划模型">非线性规划模型</h3>
<ol type="1">
<li>定义：如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题</li>
<li>通过投资决策问题归纳非线性规划数学模型的一般形式 总资金A元，投资第i个项目花<span class="math inline">\(a_i\)</span>元，预计可收益<span class="math inline">\(b_i\)</span>元 选择最佳投资方案 投资决策变量 <span class="math inline">\(x_i=\begin{cases} 1,决定投资第i个项目\\ 0,决定不投资第i个项目\\ \end{cases}\)</span> 则该模型可用下列数学模型表示 <span class="math inline">\(max\, Q = \frac{\sum_{i=1}^n b_i x_i} {\sum_{i=1}^n a_i x_i} s.t. \begin{cases} 0 &lt; \sum_{i=1}^n a_i x_i \le A ,\\ x_i(1-x_i)=0,i=1,...,n\\ \end{cases}\)</span></li>
<li>根据2中例题，非线性规划问题可进一步概括为： <span class="math inline">\(min\,f(x)\\ s.t. \begin{cases} h_j(x)\le0,j=1,2,...,q\\ g_i(x)=0,i=1,2,...,p\\ \end{cases}\)</span> 其中<span class="math inline">\(x=[x_1,...,x_n]^T\)</span>为模型的决策变量，<span class="math inline">\(f\)</span>为目标函数，<span class="math inline">\(g_i和h_j\)</span>为约束函数，<span class="math inline">\(g_i(x)=0\)</span>为等式约束，<span class="math inline">\(h_j(x)\le0\)</span>为不等式约束</li>
<li>对一个实际问题，要将其规为非线性规划问题时，一般要注意以下几点
<ol type="1">
<li>确定供选方案</li>
<li>提出追求目标</li>
<li>给出价值标准</li>
<li>寻求限制条件</li>
</ol></li>
<li>线性规划与非线性规划的区别：线性规划最优解只能在可行域的边界上达到（特别是顶点），而非线性规划最优解可在可行域任一点达到</li>
<li>非线性规划的matlab表示 <span class="math inline">\(minf(x)\\ s.t. \begin{cases} A\cdot x \le b,\\ Aeq \cdot x=beq,\\ c(x)\le0\\ ceq(x)=0,\\ lb\le x \le ub \end{cases}\)</span> 式中的<span class="math inline">\(f(x)\)</span>为标量函数，<span class="math inline">\(A,b,Aeq,beq,lb,ub\)</span>为相应维数的矩阵和向量，<span class="math inline">\(c(x),ceq(x)\)</span>为非线性向量函数 matlab命令为</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br><span class="line"># x返回决策变量x的取值，fval返回目标函数取值，fun是M文件自定义函数f(x),x0是x的初始值</span><br><span class="line">nonlcon是用M文件定义的c(x)ceq(x)，options定义优化参数</span><br></pre></td></tr></table></figure>
<h3 id="无约束问题的matlab解法">无约束问题的Matlab解法</h3>
<ol type="1">
<li>在matlab工具箱中，用于求无约束极小值的函数有fminunc和fminsearch，用法分别为</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminunc(fun,x0,options)</span><br><span class="line">[x,fval]=fminsearch(fun,x0,options) #只能求初始值附近的一个极小值点</span><br></pre></td></tr></table></figure>
<h3 id="约束极值问题">约束极值问题</h3>
<ol type="1">
<li>定义：带有约束条件的极值问题，也叫规划问题</li>
</ol>
<h4 id="二次规划">二次规划</h4>
<ol type="1">
<li>定义：若某非线性规划的目标函数为自变量x的二次函数，约束条件又全为线性的，称这种规划为二次规划</li>
<li>Matlab中二次规划的数学模型可表述为 <span class="math display">\[min\, \frac{1}{2}x^THx+f^Tx,\\
s.t. \begin{cases}
Ax\le b\\
Aeq \cdot x=beq,\\
lb\le x\le ub
\end{cases}
H为实对称矩阵，\\
\]</span> matlab求解二次规划的命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="罚函数法">罚函数法</h4>
<ol type="1">
<li>利用罚函数法可以将非线性规划问题的求解转化为求一系列无约束极值的问题，也把这种方法叫做序列无约束最小化技术</li>
<li>罚函数求解非线性规划问题的思想是利用问题中的约束函数作出适当的罚函数，由此构造出带参数的增广目标函数，把问题转换为无约束非线性规划问题，主要有两种形式，一种叫外罚函数法，另一种叫内罚函数法</li>
<li>外罚函数法： 考虑问题：<span class="math display">\[minf(x)\\
s.t.\begin{cases}
g_i(x) \le 0,i=1,...,r\\
h_j(x) \ge 0,j=1,...,s\\
k_m(x) =0,m=1,...,t
\end{cases}\]</span>取一个充分大的数M&gt;0,构造函数<span class="math inline">\(P(x,M)=f(x)+M\sum_{i=1}^nmax(g_i(x),0)-M\sum_{j=1}^nmin(h_j(x),0)+M\sum_{m=1}^n |k_m(x)|\)</span>,则以增广目标函数<span class="math inline">\(P(x,M)\)</span>为目标函数的无约束极值问题<span class="math inline">\(minP(x,M)\)</span>的最优解也是原问题的最优解</li>
<li><ol type="1">
<li>如果非线性规划问题要求实时算法，可以使用罚函数算法，但计算精度较低</li>
<li>如果不要求实时算法，要求高精度,可以使用lingo或matlab的fmincon命令求解</li>
</ol></li>
</ol>
<h4 id="matlab求约束极值问题">matlab求约束极值问题</h4>
<ol type="1">
<li><p>在matlab工具箱中，用于求解约束最优化问题的函数有fminbnd,fmincon,quadprog,fseminf,fminimax函数</p></li>
<li><p>fminbnd函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminbnd(fun,x1,x2,options) </span><br><span class="line"># 用于求单变量非线性函数在[x1,x2]上极小值</span><br><span class="line"># 返回极小点x和函数的极小值</span><br></pre></td></tr></table></figure></p></li>
<li><p>fseminf函数 用于求下列模型 <span class="math display">\[minf(x),\\
s.t. \begin{cases}
A \cdot x \le b,\\
Aeq \cdot x =beq,\\
lb\le x \le ub\\
c(x)\le0\\
ceq(x)\le0\\
K_i(x,w_i)\le0,1\le i\le n
\end{cases}其中c(x),ceq(x)为向量函数，K_i(x,w_i)为标量函数,w_1...为附加变量\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fseminf(fun,x0,ntheta,seminfcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure></p>
<p>fun定义目标函数f(x),x0为x初始值，ntheta是半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>个数，函数seminfcon用于定义非线性不等式约束<span class="math inline">\(c(x)\)</span>,非线性等式约束<span class="math inline">\(ceq(x)\)</span>和半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>的函数，seminfcon有两个输入参量x,s,s是推荐的采样步长 可以不使用</p></li>
<li><p>fminimax函数 用于求下列模型 <span class="math inline">\(min_xmax_iF_i(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)=0\\ \end{cases}\)</span> matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminimax(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="图与网络模型及方法">图与网络模型及方法</h2>
<h3 id="图的基本概念与数据结构">图的基本概念与数据结构</h3>
<ul>
<li>基本概念 图可由顶点集V和边集E表示，G=(V,E)，若各边加上方向则为有向图，否则为无向图，另外赋权图是指每条边都有一个(或多个)实数对应的图，该实数称为这条边的权，赋权图在实际情况中非常有用</li>
<li>数据结构 图的数据结构主要有两种方法
<ol type="1">
<li>邻接矩阵表示法</li>
<li>稀疏矩阵表示法</li>
</ol></li>
</ul>
<h3 id="最短路问题">最短路问题</h3>
<h4 id="两个指定顶点之间的最短路径">两个指定顶点之间的最短路径</h4>
<p><strong>问题简述</strong>：给定一个连接若干个城镇的铁路网络，在这个网络的两个指定城镇间，找一条最短铁路线 <strong>模型抽象</strong>：该问题我们可以构建一个赋权图G=(V,E,W),其中顶点集V表示各个小城镇，E为边的集合，邻接矩阵W表示各顶点间的距离，若顶点间无边，则w=∞，则问题可转换为求赋权图G中指定两个顶点<span class="math inline">\(u_0,v_0\)</span>间具有最小权的路，这条路称为<span class="math inline">\(u_0,v_0\)</span>间的最短路，它的权称为二者间的距离，记为<span class="math inline">\(d(u_0,v_0)\)</span> <strong>常用方法</strong>：</p>
<ol type="1">
<li>狄克斯特拉(Dijkstra)算法:基本思想为按距<span class="math inline">\(u_0\)</span>从近到远为顺序，依次求得<span class="math inline">\(u_0\)</span>到G的各顶点的最短路和距离，直至<span class="math inline">\(v_0\)</span>（或直至G所有顶点）</li>
</ol>
<h4 id="两个指定顶点间最短路的数学规划模型">两个指定顶点间最短路的数学规划模型</h4>
<p>假设有向图有n个顶点，现要求从顶点<span class="math inline">\(v_1-&gt;v_n\)</span>的最短路，仍然用E表示弧的集合，设<span class="math inline">\(W=(w_{ij})_{n×n}\)</span>为邻接矩阵，其分量为：<span class="math display">\[w_{ij}=\begin{cases}
弧v_iv_j的权值，v_iv_j\in E\\
∞，其他，
\end{cases}\]</span> 决策变量为<span class="math inline">\(x_{ij}\)</span>,当<span class="math inline">\(x_{ij}=1\)</span>,说明弧<span class="math inline">\(v_iv_j\)</span>位于顶点<span class="math inline">\(v_1\)</span>到顶点<span class="math inline">\(v_n\)</span>的最短路上，否则<span class="math inline">\(x_{ij}=0\)</span>,其数学规划表达式为<span class="math display">\[min\sum_{v_iv_j\in E}w_{ij}x_{ij},\\
s.t. \begin{cases}
\sum_{j=1,v_iv_j\in E}^n x_{ij}-\sum_{j=1,v_jv_i\in E}^n x_{ji}=\begin{cases}
1,i=1\\
-1,i=n\\
0,i\ne1,n
\end{cases}\\
x_{ij}=0或1
\end{cases}    \]</span></p>
<h4 id="每对顶点之间的最短路径">每对顶点之间的最短路径</h4>
<p>计算赋权图各队顶点之间的最短路径，调用方法有两种</p>
<ol type="1">
<li>Dijkstra算法 每次以不同的顶点作为起点，用Dijkstra算法算出该起点到其余顶点的最短路径，反复执行n-1次操作，就可得到从每一个顶点到其他顶点的最短路径，时间复杂度为<span class="math inline">\(O(n^3)\)</span></li>
<li>Floyd算法 递推产生一个矩阵序列<span class="math inline">\(A_1,...,A_k,...,A_n\)</span>,其中矩阵<span class="math inline">\(A_k\)</span>的第i行第j列元素<span class="math inline">\(A_k(i,j)\)</span>表示从顶点<span class="math inline">\(v_i\)</span>到顶点<span class="math inline">\(v_j\)</span>的路径经过顶点序号不大于k的最短路径长度，计算时用迭代公式<span class="math inline">\(A_k(i,j)=min(A_{k-1}(i,j),A_{k-1}(i,k)+A_{k-1}(k,j))\)</span>,k是迭代次数，i,j,k=1,2,...n,最后当k=n时，<span class="math inline">\(A_n\)</span>即是各顶点间的最短通路值</li>
</ol>
<h3 id="最小生成树问题">最小生成树问题</h3>
<h4 id="基本概念">基本概念</h4>
<p>连通的无圈图叫做树，记为T，其度为1的顶点称为叶子节点，显然有边的树至少有两个叶子顶点 若图G=(V(G),E(G))和树T=(V(T),E(T))满足<span class="math inline">\(V(G)=V(T),E(T)\subset E(G)\)</span>，则称T是G的生成树，图G连通的充要条件是G有生成树</p>
<h4 id="最小生成树">最小生成树</h4>
<p>欲修筑连接n个城市的铁路，已知i城与j城之间的铁路造价为<span class="math inline">\(c_{ij}\)</span>,设计一个线路图使总造价最低，这个问题的数学模型是在连通赋权图上求权最小的生成树，赋权图具有最小权的生成树叫做最小生成树 <strong>常用算法</strong>： 构造连通赋权图G=(V,E,W)的最小生成树，设置两个集合P和Q,其中P用于存放G的最小生成树的顶点，集合Q存放G的最小生成树的边。令集合P的初值为<span class="math inline">\(P={V_1}\)</span>(假设构造最小生成树时，从顶点<span class="math inline">\(v_1\)</span>)出发，集合Q的初值为<span class="math inline">\(Q=\varnothing\)</span></p>
<ol type="1">
<li>prim算法 从所有<span class="math inline">\(p\in P,v\in V-P\)</span>的边中，选取具有最小权值的边pv，将顶点v加入集合P中,将边pv加入集合Q中，如此重复，直到P=V时，最小生成树构造完毕，这是集合Q包含了最小生成树的所有边。</li>
<li>Kruskal算法 选<span class="math inline">\(e_1\in E(G)\)</span>，使得<span class="math inline">\(e_1\)</span>是权值最小的边, 若<span class="math inline">\(e_1,e_2,...,e_i,e_{i+1}\)</span>已选好，则从E(G)-{<span class="math inline">\(e_1,e_2,...,e_i\)</span>}中选取<span class="math inline">\(e_{i+1}\)</span>,使得<span class="math inline">\({e_1,e_2,...,e_i,e_{i+1}}\)</span>中无圈，<span class="math inline">\(e_{i+1}\)</span>是E(G)-<span class="math inline">\({e_1,e_2,...,e_i}\)</span>中权值最小的边，直到选得<span class="math inline">\(e_{|V|-1}\)</span>为止</li>
</ol>
<h3 id="网络最大流问题">网络最大流问题</h3>
<h4 id="基本概念-1">基本概念</h4>
<ol type="1">
<li>网络：给一个有向图D=(V,A),其中A为弧集，在V中指定一点，称为发点(记为<span class="math inline">\(v_s\)</span>),另一点称为收点(记为<span class="math inline">\(v_t\)</span>)，其余点为中间点，对于每一条弧<span class="math inline">\((v_i,v_j)\in A\)</span>，对应有一个<span class="math inline">\(c(v_i,v_j)\ge 0(或简写为c_{ij})\)</span>,称为弧的容量，通常把这样的有向图叫做一个网络，记为D=(V,A,C),其中C={<span class="math inline">\(c_{ij}\)</span>}</li>
<li>流：定义在弧集合A的一个函数<span class="math inline">\(f={f_{ij}={f(v_i,v_j)}}\)</span>，并称<span class="math inline">\(f_{ij}\)</span>为弧<span class="math inline">\((v_i,v_j)\)</span>上的流量</li>
<li><div id="hei">
最大流问题的线性规划表示
</div></li>
</ol>
<p><span class="math display">\[max\quad v(f),\\
s.t.\begin{cases}
\sum_{j:(v_i,v_j)\in A}f_{ij}-\sum_{j:(v_j,v_i\in A)}f_{ji}=\begin{cases}
v(f),i=s\\
-v(f),i=t\\
0,i\ne s,t,
\end{cases}\\
0\le f_{ij} \le c_{ij},\forall(v_i,v_j)\in A
\end{cases}\]</span></p>
<h3 id="最小费用最大流问题">最小费用最大流问题</h3>
<h4 id="最小费用最大流">最小费用最大流</h4>
<p>给定网络D=(V,A,C),每一弧<span class="math inline">\((v_i,v_j)\in A\)</span>上，除了已给容量<span class="math inline">\(c_{ij}\)</span>外，还给了一个单位流量的费用<span class="math inline">\(b(v_i,v_j)\ge 0(b_{ij})\)</span>，所谓最小费用最大流问题就是求一个发点<span class="math inline">\(v_s\)</span>到收点<span class="math inline">\(v_t\)</span>的最大流，使流的总输送费用<span class="math inline">\(\sum_{(v_i,v_j)\in A}b_{ij}f_{ij}\)</span>取最小值，最小费用最大值问题可以归结为两个线性规划问题，首先用一个线性规划模型求出最大流量<span class="math inline">\(v(f_{max})\)</span>，再用一个线性规划模型求出最大流对应最小费用 <span class="math display">\[min \sum_{(v_i,v_j)\in A}b_{ij}f_{ij}\\
s.t. \begin{cases}
0\le f_{ij} \le c_{ij},\forall(v_i,v_j)\in A\\
\sum_{j:(v_i,v_j)\in A}f_{ij}-\sum_{j:(v_j,v_i\in A)}f_{ji}=d_i\\
d_i=\begin{cases}
v(f_{max}),i=s\\
-v(f_{max}),i=t\\
0,i\ne s,t,\\
\end{cases}\\
\end{cases}
\]</span> <span class="math inline">\(v_{f_{max}}\)</span><a href="#网络最大流问题">上节</a>求得最大流流量</p>
<h3 id="matlab的图论工具箱">Matlab的图论工具箱</h3>
<p><img src="/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/2024-01-15-16-35-48.png"></p>
<h3 id="旅行商tsp问题">旅行商(TSP)问题</h3>
<ol type="1">
<li>问题描述：一推销员准备前往若干城市推销商品，然后回到驻地，如何为他设计一条最短的旅行路线(从驻地出发，经过每个城市恰好一次，最后返回驻地)，这个问题就被称为旅行商问题</li>
<li>数学抽象：用图论术语表示，就是在一个赋权完全图中，找出一个有最小权的Hamilton圈，这个圈就叫最优圈</li>
<li>数学模型：设城市的个数为n，<span class="math inline">\(d_{ij}\)</span>是两个城市i与j之间的距离，<span class="math inline">\(x_{ij}=0 or 1\)</span>(1表示走过城市i到城市j的路，0表示没有选择走这条路)，则有 <span class="math display">\[min \sum_{i\ne j}d_{ij}x_{ij}\\
s.t. \begin{cases}
\sum_{j=1}^n x_{ij}=1,i=1,2,\dots,n,(每个点只有一条边出去)\\
\sum_{i=1}^n x_{ij}=1,i=1,2,\dots,n,(每个点只有一条边进去)\\
\sum_{i,j\in s}x_{ij}\le|s|-1,2\le|s|\le n-1,s\subset{1,2,\dots,n},即s为{1,2,\dots,n}的真子集(除起点终点外，各点不构成圈)\\
x_{ij}\in {0,1},i,j=1,2,\dots,n,i\ne j
\end{cases}
\]</span></li>
</ol>
<h3 id="计划评审方法和关键路线法">计划评审方法和关键路线法</h3>
<p>这两个方法是网络分析的重要组成部分，已经合并为一种方法，国外称PERT/CPM，国内称为统筹方法</p>
<h4 id="计划网络图">计划网络图</h4>
<p>计划网络图中通常用圆圈表示事件，用箭线表示工作，用这种方法画出的网络图为计划网络图 <img src="/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/2024-01-15-16-35-14.png"> 虚作业用虚箭线表示，表示工时为0，不消耗任何资源的虚构作业，作用只是为了正确表述工作的前向后继关系 <strong>关键路线</strong>: 在计划网络图中，称从初始事件到最终事件的由各项工作连贯组成的一条路为路线，具有累计作业时间最长的路线称为关键路线</p>
<h4 id="时间参数">时间参数</h4>
<ol type="1">
<li>事件时间参数
<ol type="1">
<li>事件的最早时间</li>
<li>事件的最迟时间</li>
</ol></li>
<li>工作时间参数
<ol type="1">
<li>工作的最早可能开工时间与最早可能完工时间</li>
<li>最迟必须开工时间和最迟必须完工时间</li>
</ol></li>
<li>时差
<ol type="1">
<li>工作总时差</li>
<li>工作单时差</li>
</ol></li>
</ol>
<h4 id="计划网络图的计算">计划网络图的计算</h4>
<ol type="1">
<li>建立计划网络图 <img src="/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/2024-01-15-16-34-48.png"></li>
<li>写出相应的规划问题 <span class="math display">\[min\sum_{i\in V}x_i\\
s.t\begin{cases}
x_j\ge x_i+t_{ij},(i,j)\in A,i,j\in V\\
x_i\ge 0,i\in V\\
\end{cases}\]</span> V为所有时间集合，A为所有作业集合，<span class="math inline">\(x_i\)</span>为事件i的开始时间，<span class="math inline">\(t_{ij}\)</span>为作业(i,j)的计划时间</li>
<li>问题求解</li>
<li>将关键路线看为最长路 如果将关键路线看成最长路,则可以按照求最短路的方法(将求极小改为求极大)求出关键路线 设<span class="math inline">\(x_{ij}\)</span>为0-1变量，当作业(i,j)位于关键路线上取1，否则取0，数学规划问题写成 <span class="math display">\[max\sum_{(i,j)\in A}t_{ij}x_{ij}\\
s.t.\begin{cases}
\sum_{j:(i,j)\in A}x_{ij}-\sum_{j:(j,i)\in A}x_{ji}=\begin{cases}
1,i=1,\\
-1,i=n,\\
0,i\ne1,n,\\
\end{cases}\\
x_{ij}=0 or 1,(i,j)\in A
\end{cases}\]</span></li>
</ol>
<h2 id="插值与拟合">插值与拟合</h2>
<p>若仅已知函数<span class="math inline">\(f(x)\)</span>在某区间<span class="math inline">\([a,b]\)</span>上一系列点上的值<span class="math inline">\(y_i=f(x_i),i=0,1,\dots,n\)</span>，当需要在这些节点间的x上的函数值时，有两种方法：插值法，拟合法，二者都是根据一组数据构造一个函数作为近似，由于近似的要求不同，二者在数学方法上完全不同，需要我们根据实际情况考虑</p>
<h3 id="插值方法">插值方法</h3>
<p>在工程和数学应用中，若在平面上给定一组离散点列，要求一条曲线，把这些点按次序连接起来，称为插值，若已知n+1点<span class="math inline">\((x_i,y_i)(i=0,1,...,n)\)</span>,下面详细介绍各种插值函数</p>
<h4 id="分段线性插值">分段线性插值</h4>
<p>简单来说，将每两个相邻的节点用直线连起来，如此形成的一条折线就是分段线性插值函数，记住<span class="math inline">\(I_n(x_i)=y_i\)</span>,且<span class="math inline">\(I_n(x)\)</span>在每个小区间<span class="math inline">\([x_i,x_{i+1}]\)</span>是线性函数<span class="math inline">\((i=0,1,...,n-1)\)</span> <span class="math inline">\(I_n(x)\)</span>可以表示<span class="math inline">\(I_n(x)=\sum_{i=0}^ny_il_i(x)\)</span>,其中 <span class="math inline">\(l_i(x)=\begin{cases} \frac{x-x_{i-1}}{x_i-x_{i-1}},x\in[x_{i-1},x_i],i\ne 0,\\ \frac{x-x_{i+1}}{x_i-x_{i+1}},x\in[x_i,x_{i+1}],i\ne n,\\ 0,else\\ \end{cases}\)</span> <span class="math inline">\(l_n(x)\)</span>有良好的收敛性，即对于<span class="math inline">\(x\in[a,b]\)</span>,有<span class="math inline">\(\lim_{n \to \infty}I_n(x)=f(x)\)</span>,用<span class="math inline">\(I_n(x)\)</span>计算x点的插值时，只用到x左右的两个节点，计算量与节点个数n无关，但n越大，分段越多，插值误差越小</p>
<h4 id="拉格朗日插值多项式">拉格朗日插值多项式</h4>
<p>拉格朗日(Lagrange)插值的基函数为<span class="math display">\[l_i(x)=\frac{(x-x_0)...(x-x_{i-1})(x-x_{i+1})...(x-x_n)}{(x_i-x_0)...(x_i-x_{i-1})(x_i-x_{i+1})...(x_i-x_n)}\\
=\prod_{j=0,j\ne i}^n \frac{x-x_j}{x_i-x_j},i=0,1,...,n\\
l_i(x)是n次多项式，满足l_i(x_j)=\begin{cases}
0,j\ne i\\
1,j=i
\end{cases}\]</span> 综上，拉格朗日插值函数<span class="math display">\[L_n(x)=\sum_{i=0}^ny_il_i(x)=\sum_{i=0}^ny_i(\prod_{j=0,j\ne i}^n\frac{x-x_j}{x_i-x_j})\]</span></p>
<h4 id="样条插值">样条插值</h4>
<p>对于一些要求插值曲线具有较高的光滑程度，有连续曲率的数学物理问题，这时需要用样条插值</p>
<ol type="1">
<li>样条函数的概念 数学上将具有一定光滑性的分段多项式称为样条函数，具体地说，给定区间[a,b]的一个分划：<span class="math inline">\(\delta:a=x_0&lt;x_1&lt;\dots&lt;x_{n-1}&lt;x_n=b\)</span> 如果函数S(x)满足
<ol type="1">
<li>在每个小区间<span class="math inline">\([x_i,x_{i+1}](i=0,1,...,n-1)\)</span>上S(x)是m次多项式</li>
<li>S(x)在[a,b]上具有m-1阶连续导数 则称S(x)为关于分划<span class="math inline">\(\delta\)</span>的m次样条函数，其图形为m次样条曲线</li>
</ol></li>
<li>三次样条插值 利用样条函数进行插值，称为样条插值，三次样条插值函数就是把上面S(x)中的m=3,但是仅有这些条件是不足与确定所有待定参数，还需要额外的边界条件 常用的三次样条函数的边界条件有三种类型：
<ol type="1">
<li><span class="math inline">\(S&#39;(a)=y_0&#39;,S&#39;(b)=y_n&#39;\)</span>,有这种边界条件建立的样条插值函数称为<span class="math inline">\(f(x)\)</span>的完备三次样条插值函数，若<span class="math inline">\(f&#39;(x)\)</span>不知道，我们可以要求S'(x)与f'(x)在端点处近似相等，这时以<span class="math inline">\(x_0,x_1,x_2,x_3\)</span>为节点做一个三次Newton插值多项式,有这种边界条件建立的三次样条称为f(x)的Lagrange三次样条插值函数</li>
<li><span class="math inline">\(S&quot;(a)=y_0&quot;,S&quot;(b)=y_n&quot;,when y_0&quot;=y_n&quot;=0\)</span>,称为自然边界条件</li>
<li><span class="math inline">\(S&#39;(a+0)=S&#39;(b-0),S&quot;(a+0)=S&quot;(b-0)\)</span>,称为周期条件</li>
</ol></li>
</ol>
<h4 id="matlab插值工具箱">Matlab插值工具箱</h4>
<ol type="1">
<li>一维插值函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y=interp1(x0,y0,x,&#x27;method&#x27;)</span><br><span class="line">method 指定插值方法，默认为线性插值，其值可为</span><br><span class="line">&#x27;nearest&#x27; 最近项插值</span><br><span class="line">&#x27;linear&#x27; 线性插值</span><br><span class="line">&#x27;spline&#x27; 立方线条插值</span><br><span class="line">&#x27;cubic&#x27; 立方插值</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>三次样条插值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pp=csape(x0,y0,conds,valconds);y=fnval(pp,x);</span><br><span class="line">csape的返回值是pp形式，要求插值点函数值必须调用fnval，conds指定插值边界条件，valconds指定边界导数值</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p>二维插值 若节点是二维的，插值函数就是二元函数，即曲面</p>
<ol type="1">
<li>插值节点为网格节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z=interp2(x0,y0,z0,x,y,&#x27;method&#x27;)</span><br><span class="line">x0,y0分别为m,n维向量,表示节点,z0为n×m矩阵，表示节点值,x,y为一维数组，表示插值点，z表示得到的插值</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>插值节点为散乱节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZI=griddata(x,y,z,XI,YI)</span><br><span class="line">x,y,z指数据点横纵竖坐标,XI,YI给定的插值点横纵坐标,ZI网格(XI,YI)的函数值</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="曲线拟合的线性最小二乘法">曲线拟合的线性最小二乘法</h3>
<h4 id="线性最小二乘法">线性最小二乘法</h4>
<p>曲线拟合：已知一组(二维)数据，即平面上n个点<span class="math inline">\((x_i,y_i),i=1,2,...,n,x_i\)</span>互不相同，寻求一个函数(曲线)<span class="math inline">\(y=f(x)\)</span>,使<span class="math inline">\(f(x)\)</span>在某种准则下雨所有数据点最为接近，即曲线拟合的最好。 线性最小二乘法是解决曲线拟合最常用的方法，基本思路是，令 <span class="math inline">\(f(x)=a_1r_1(x)+a_2r_2(x)+\dots+a_mr_m(x)\)</span>,式中:<span class="math inline">\(r_k(x)\)</span>为事先选定好的一组线性无关的函数，<span class="math inline">\(a_k\)</span>为待定系数<span class="math inline">\((k=1,2,...,m&lt;n)\)</span> 拟合准则是使<span class="math inline">\(y_i(i=1,2,...,n)\)</span>与<span class="math inline">\(f(x_i)\)</span>的距离<span class="math inline">\(\delta_i\)</span>的平方和最小，称为最小二乘准则</p>
<h4 id="最小二乘法的matlab实现">最小二乘法的Matlab实现</h4>
<ol type="1">
<li>解方程组方法</li>
<li>多项式拟合法</li>
</ol>
<h3 id="最小二乘优化">最小二乘优化</h3>
<p>在无约束优化问题中，有些重要的特殊情形，比如目标函数有若干个函数的平方和构成，这类函数可以写成<span class="math inline">\(F(x)=\sum_{i=1}^mf_i^2(x),x\in R^n,x=[x_1,...,x_n]^T,m\ge n\)</span> 把极小化这类函数的问题<span class="math inline">\(min F(x)=\sum_{i=1}^mf_i^2(x)\)</span>称为最小二乘优化问题 matlab也提供一些函数优化此问题,有lsqlin,leqcurvefit,leqnonlin,lsqnonneg,也可以直接调用工具箱里命令cftool,该命令给出一维数据拟合的交互式环境</p>
<h3 id="曲线拟合和函数逼近">曲线拟合和函数逼近</h3>
<p>曲线拟合是指已知一组离散数据<span class="math inline">\({(x_i,y_i),i=1,...,n}\)</span>，选择一个较简单的函数<span class="math inline">\(f(x)\)</span>(如多项式),在一定准则(如最小二乘准则)下，最接近这些数据 如果已知一个较为复杂的连续函数<span class="math inline">\(y(x),x\in[a,b]\)</span>,要求选择一个较简单的函数<span class="math inline">\(f(x)\)</span>,在一定准则下最接近<span class="math inline">\(y(x)\)</span>，就是函数逼近 与曲线拟合的最小二乘准则对应，函数逼近常用的一种准则是最小平方逼近，即<span class="math inline">\(J=\int_{a}^{b} [f(x)-y(x)]^2\, {\rm d}x\)</span>达到最小，与曲线拟合一样，选一组函数构造<span class="math inline">\(f(x)\)</span>,代入使J达到最小</p>
<h2 id="微分方程建模感觉不太重要">微分方程建模(感觉不太重要)</h2>
<p>对于生活中的实际问题，我们往往需要将其化为微分方程的定解问题来求解，大致可分为以下几步：</p>
<ol type="1">
<li>根据实际要求要求确定要研究的量(自变量，未知函数，必要的参数)并确定坐标系</li>
<li>找出这些量所满足的基本规律(物理的，几何的，化学的或生物的等)</li>
<li>运用这些规律列出方程和定解条件 列方程常见方法：
<ul>
<li>按规律直接列方程</li>
<li>微元分析法与任意区域取积分方法</li>
<li>模拟近似法</li>
</ul></li>
</ol>
<h3 id="matlab求微分方程的符号解">Matlab求微分方程的符号解</h3>
<p>用matlab求解常微分方程的符号解，首先定义符号向量，然后调用命令dsolve，dsolve调用格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y1,...,yN]=dsolve(eqns,conds,Name,Value)</span><br><span class="line">eqns符号微分方程(组)，conds，初值条件或边值条件，Name,Value可选的成对参数</span><br></pre></td></tr></table></figure>
<h2 id="数理统计感觉不太重要">数理统计(感觉不太重要)</h2>
<p>数理统计研究对象主要是受随机因素影响的数据，面对一批数据进行分析建模，首先要掌握参数估计和假设检验这两个数理统计中最基本方法，给定数据符合一定分布要求后，才能建立回归分析和方差分析等数学模型</p>
<h2 id="时间序列">时间序列</h2>
<h3 id="简介">简介</h3>
<p>将预测对象按照时间顺序排列起来，构成一个所谓的时间序列，从所构成的这一组时间序列过去的变化规律，推断今后变化的可能性及变化趋势，变化规律，就是时间序列预测法</p>
<p>时间序列法其实也是一种回归模型，其基于原理是：一方面承认事物发展的延续性，运用过去时间序列的数据进行统计分析就能推测事物发展趋势，另一方面又充分考虑到偶然因素影响产生的随机性</p>
<p>其<strong>优点</strong>是简单易行，便于掌握，能充分运用原时间序列的各项数据，计算速度快，对模型参数有动态确定能力，精度较好，采用组合的时间序列或将时间序列和其他模型组合效果更好</p>
<p>其<strong>缺点</strong>是不能反映事物内在联系，不能分析两个因素间相关关系，只适用于短期预测</p>
<h3 id="确定性时间序列分析方法">确定性时间序列分析方法</h3>
<p>时间序列预测技术就是通过对预测目标自身时间序列的处理，来研究其变化趋势，一个时间序列往往是一下几类变化形式的叠加或耦合</p>
<ol type="1">
<li>长期趋势变动，他指时间序列朝着一定的方向持续上升或下降，或停留在某一水平上的倾向，反映了客观事物的主要变化趋势。</li>
<li>季节变动</li>
<li>循环变动，通常是周期为一年以上，由非季节因素引起的涨落起伏波形相似的波动</li>
<li>不规则变动，通常分为突然变动和随机变动</li>
</ol>
<p>通常用<span class="math inline">\(T_t\)</span>表示长期趋势项，<span class="math inline">\(S_t\)</span>表示季节变动趋势项，<span class="math inline">\(C_t\)</span>表示循环变动趋势项，<span class="math inline">\(R_t\)</span>表示随机干扰项，常见确定性时间序列模型类型如下 1. 加法模型： <span class="math inline">\(y_t=T_t+S_t+C_t+R_t\)</span> 2. 乘法模型： <span class="math inline">\(y_t=T_t\cdot S_t\cdot C_t\cdot R_t\)</span> 3. 混合模型： <span class="math display">\[y_t=T_t\cdot S_t+R_t\\
   y_t=S_t+T_t\cdot R_t\]</span> <span class="math inline">\(y_t\)</span>为观测目标的观测记录，均值<span class="math inline">\(E(R_t)=0\)</span>,方差<span class="math inline">\(Var(R_t)=\sigma^2\)</span> 如果在预测时间范围以内，无突然变动且随机变动的方差较小，且有理由认为过去和现在的演变趋势将继续发展到未来时，可用一些经验方法进行预测</p>
<h4 id="移动平均法">移动平均法</h4>
<p>设观测序列为<span class="math inline">\(y_1,...,y_T\)</span>,取移动平均的项数N&lt;T,一次移动平均值计算公式为： <span class="math display">\[M_t^{(1)}=\frac{1}{N}(y_t+y_{t-1}+\dots+y_{t-N+1})\\=\frac{1}{N}(y_{t-1}+\dots+y_{t_N})+\frac{1}{N}(y_t-y_{t-N})=M_{t-1}^{(1)}+\frac{1}{N}(y_t-y_{t-N})\]</span></p>
<p>二次移动平均值计算公式为 <span class="math display">\[M_t^{(2)}=\frac{1}{N}(M_t^{(1)}+\dots+M_{t-N+1}^{(1)})=M_{t-1}^{(2)}+\frac{1}{N}(M_t^{(1)}-M_{t-N}^{(1)})\]</span> 当预测目标的基本趋势是在某一水平上下波动时，可用一次移动平均方法建立预测模型,即 <span class="math display">\[\hat{y_{t+1} }=M_t^{(1)}=\frac{1}{N}(y_t+\dots+y_{t-N+1}),t=N,N+1,\dots,T\]</span> 其预测标准误差为<span class="math display">\[S=\sqrt{\frac{\sum_{t=N+1}^T(\hat{y_t}-y_t)^2}{T-N}}\]</span></p>
<p>最近N期序列值的平均值作为未来各期的预测结果，一般N取值为:<span class="math inline">\(5\le N\le 200\)</span>,当历史序列的基本趋势变化不大且序列中随机变动成分较多时，N的取值应较大一些,否则N的取值应小一些，在有确定的季节变动周期资料中，移动平均的项数应取周期长度，选择最佳N值的一个有效方法是编辑若干模型的预测误差，预测误差最小值为好</p>
<p>当预测目标基本趋势和某一线性模型吻合时，常用二次移动平均法，但序列同时存在线性趋势和周期波动时，可用趋势移动平均法建立预测模型： <span class="math inline">\(\hat{y_{T+m}}=a_T+b_Tm,m=1,2,\dots\)</span>,式中 <span class="math inline">\(a_T=2M_T^{(1)}-M_T^{(2)};b_T=\frac{2}{N-1}(M_T^{(1)}-M_T^{(2)})\)</span></p>
<h4 id="指数平滑法">指数平滑法</h4>
<p>一般来说历史数据对未来值的影响是随时间间隔增长而递减的，而上述移动平均法的权数都是两端项权数小，中间项权数大，不符合上诉规律，更好的方法是对各期观测值依时间顺序进行加权平均作为预测值，<strong>指数平滑法</strong>就满足这一要求，且具有简单递推形式</p>
<p>指数平滑法根据平滑次数的的不同，又分为一次指数平滑法，二次指数平滑法，和三次指数平滑法等</p>
<p><strong>一次指数平滑法</strong> 1. 预测模型</p>
<p>设时间序列为<span class="math inline">\(y_1,y_2,...,y_t,...,\alpha\)</span>为加权系数,<span class="math inline">\(0&lt;\alpha&lt;1\)</span>,一次指数平滑公式为: <span class="math inline">\(S_t^{(1)}=\alpha y_t+(1-\alpha)S_{t-1}^{(1)}=S_{t-1}^{(1)}+\alpha(y_t-S_{t-1}^{(1)})\)</span> 以这种平滑值进行预测，就是一次指数平滑法，预测模型为<span class="math inline">\(\hat{y_{t+1}}=S_t^{(1)}=\alpha y_t+(1-\alpha)\hat{y_t}\)</span></p>
<ol start="2" type="1">
<li><p>加权系数的选择</p>
<p>加权系数<span class="math inline">\(\alpha\)</span>的大小决定了在新预测值中新数据和原预测值所占的比重，<span class="math inline">\(\alpha\)</span>越大，新数据所占比重越大，原预测值所占比重越小，也可将上式改为<span class="math inline">\(\hat{t_{t+1}}=\hat{y_t}+\alpha(y_t-\hat{y_t})\)</span></p>
<p>这可看出新预测值是根据预测误差对原预测值进行修正得到的，<span class="math inline">\(\alpha\)</span>越大，修正幅度越大 其选取规则如下：</p>
<ul>
<li>如果时间序列波动不大，比较平稳，则α可取小一点以减少修正幅度，使预测模型能包含较长时间序列的信息</li>
<li>如果时间序列具有迅速且明显的变动倾向，则α应取大一点，使预测模型灵敏度高一些，以便迅速跟上数据的变化</li>
</ul></li>
<li><p>初始值的确定</p>
<p>用一次平滑法预测，除了选择合适的<span class="math inline">\(\alpha\)</span>，还要确定初始值<span class="math inline">\(s_0^{(1)}\)</span>,初始值是预测者估计指定的</p></li>
</ol>
<p><strong>二次指数平滑法</strong> 一次指数平滑法虽然克服了移动平均法的缺点，但当时间序列变动出现直线趋势时，用该方法预测由明显滞后偏差，应用二次指数平滑，用滞后偏差的规律建立直线趋势模型，计算公式如下 <span class="math inline">\(\begin{cases} S_t^{(1)}=\alpha y_t+(1-\alpha)S_{t-1}^{(1)}\\ S_t^{(2)}=\alpha S_t^{(1)}+(1-\alpha)S_{t-1}^{(2)} \end{cases}\)</span> 式中：<span class="math inline">\(S_t^{(1)}\)</span>为一次指数的平滑值，<span class="math inline">\(S_t^{(2)}\)</span>为二次平滑函数的平滑值</p>
<p>当时间序列<span class="math inline">\({y_t}\)</span>从某时期开始具有直线趋势，可用直线趋势模型 <span class="math inline">\(\hat{y_{t+m}}=a_t+b_tm,m=1,2,\dots,\)</span> <span class="math inline">\(\begin{cases}  a_t=2S_t^{(1)}-S_t^{(2)},\\  b_t=\frac{\alpha}{1-\alpha}(S_t^{(1)}-S_t^{(2)}) \end{cases}\)</span>进行预测</p>
<p><strong>三次指数平滑法</strong> 当时间序列的变动表现为二次曲线趋势，需要用三次指数平滑法，其在二次指数平滑基础上，再进行一次平滑，计算公式为 <span class="math inline">\(\begin{cases}  S_t^{(1)}=\alpha y_t+(1-\alpha)S_{t-1}^{(1)}\\  S_t^{(2)}=\alpha S_t^{(1)}+(1-\alpha)S_{t-1}^{(2)}\\  S_t^{(3)}=\alpha S_t^{(2)}+(1-\alpha)S_{t-1}^{(3)} \end{cases}\)</span> <span class="math inline">\(S_t^{(3)}\)</span>为三次指数平滑值</p>
<p>其预测模型为: <span class="math inline">\(\hat{y_{t+m}}=a_t+b_tm+C_tm^2,m=1,2,\dots,\)</span> <span class="math inline">\(\begin{cases}  a_t=3S_t^{(1)}-3S_t^{(2)}+S_t^{(3)},\\  b_t=\frac{\alpha}{2(1-\alpha)^2}((6-5\alpha)S_t^{(1)}-2(5-4\alpha)S_t^{(2)}+(4-3\alpha)S_t^{(3)})\\  c_t=\frac{\alpha^2}{2(1-\alpha)^2}(S_t^{(1)}-2S_t^{(2)}+S_t^{(3)}) \end{cases}\)</span></p>
<h4 id="差分指数平滑法">差分指数平滑法</h4>
<p>我们也可以从数据变换角度解决一次指数平滑法的滞后偏差问题，差分方法就是改变数据变动趋势的简易方法</p>
<p>下面以一阶差分指数平滑法为例，其公式如下 <span class="math inline">\(\nabla y_t=y_t-y_{t-1} \\ \nabla \hat{y_{t+1}}=\alpha \nabla y_t+(1-\alpha)\nabla\hat{y_t} \\\hat{y_{t+1}}=\nabla\hat{y_{t+1}}+y_t,\nabla\)</span>为差分记号</p>
<h4 id="具有季节性特点的时间序列的预测">具有季节性特点的时间序列的预测</h4>
<p>对于季节性时间序列的预测，要在数学上完全拟合其变化曲线是非常困难的，但预测的目的是为了找到时间序列的变化趋势，尽可能的做到精确，下面介绍季节系数法，计算步骤如下 1. 收集m年的每年各季度或各月份的时间序列样本数据<span class="math inline">\(a_{ij}\)</span>,i表示年份序号，j表示季度(月份)序号 2. 计算每年所有季度或月份算术平均值<span class="math inline">\(\bar{a}=\frac{1}{k}\sum_{i=1}^m\sum_{j=1}^n a_{ij},k=mn\)</span> 3. 计算同季度或同月份数据的算术平均值<span class="math inline">\(\bar{a_{.j}}=\frac{1}{m}\sum_{i=1}^ma_{ij}\)</span> 4. 计算季度(月份)系数<span class="math inline">\(b_j=\frac{\bar{a_{.j}}}{\bar{a}}\)</span> 5. 预测计算，当时间序列按季度列出，先求出预测年份(下一年)的年加权平均<span class="math inline">\(y_{m+1}=\frac{\sum_{i=1}^mw_iy_j}{\sum_{i=1}^mw_i}  \\y_i=\sum_{j=1}^na_{ij}\)</span>为第i年年合计数，<span class="math inline">\(w_i\)</span>为第i年权数,<span class="math inline">\(w_i=i\)</span>,再计算预测年份的季度平均值<span class="math inline">\(\bar{y_{m+1}}=y_{m+1}/n\)</span>,最后预测年份第j季度的预测值为<span class="math inline">\(y_{m+1,j}=b_j\bar{y_{m+1}}\)</span></p>
<h3 id="平稳时间序列模型">平稳时间序列模型</h3>
<p>这里的平稳指的是宽平稳，其特性是序列的统计特性不随时间Pinyin而变化，即均值和协方差不随时间平移而变化</p>
<h4 id="时间序列的基本概念">时间序列的基本概念</h4>
<p><em>平稳序列</em>:设随机序列<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>满足 - <span class="math inline">\(E(X_t)=\mu\)</span>=常数 - <span class="math inline">\(\gamma_{t+k,t}=\gamma_k(k=0,\pm1,\pm2,...)\)</span>与t无关，则称<span class="math inline">\(X_t\)</span>为平稳随机序列,坚持平稳序列</p>
<p><em>平稳白噪声序列</em>:设平稳序列<span class="math inline">\({\epsilon_t,t=0,\pm1,\pm2,...}\)</span>的自协方差函数为<span class="math inline">\(\gamma_k=\sigma^2\delta_{k,0}=\begin{cases}  0,k\ne0\\  \sigma^2,k=0 \end{cases}\)</span> 则称该序列为平稳白噪声序列</p>
<p><em>偏相关函数</em>:考虑由<span class="math inline">\({X_{t-1},X_{t-2},...,X_{t-k}}\)</span>对<span class="math inline">\(X_t\)</span>的线性最小均方估计，即选择系数<span class="math inline">\(\psi_{k,1},\psi_{k,2},...,\psi_{k,k}\)</span>,使得<span class="math inline">\(min\quad\delta=E[(X_t-\sum_{j=1}^k\psi_{k,j}X_{t-j})^2]\)</span>,<span class="math inline">\({\psi_{k,k},k=1,2,\dots}\)</span>称为<span class="math inline">\(X_t\)</span>的偏相关函数</p>
<p><em>ARMA时间序列</em>:ARMA时间序列可以分为三种类型 1. AR序列，即自回归序列(Auto Regressive Model) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为零均值平稳序列，满足下列模型 <span class="math inline">\(X_t=\psi_1 X_{t-1}+\psi_2 X_{t-2}+\dots+\psi_p X_{t-p}+\epsilon_t\)</span> <span class="math inline">\(\epsilon_t\)</span>为零均值，方差为<span class="math inline">\(\delta_\epsilon^2\)</span>的平稳白噪声，<span class="math inline">\(X_t\)</span>为阶数为p的自回归序列，简称AR(p)序列，<span class="math inline">\(\psi=[\psi_1,\psi_2,...,\psi_p]^T\)</span>为自回归参数向量,其分量为自回归系数 引入后移算子B辅助定义，算子B定义<span class="math inline">\(BX_t\equiv X_{t-1},B^kX_t\equiv X_{t-k}\)</span> 记算子多项式<span class="math inline">\(\psi(B)=1-\psi_1B-\psi_2B^2-...-\psi_pB^p\)</span> 则AR序列可改写为<span class="math inline">\(\psi(B)X_t=\epsilon_t\)</span></p>
<ol start="2" type="1">
<li><p>MA序列，即移动平均序列(Moving Average Model) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为零均值平稳序列，满足下列模型 <span class="math inline">\(X_t=\epsilon_t-\theta_1 \epsilon_{t-1}-\dots-\theta_q \epsilon_{t-q}\)</span> <span class="math inline">\(\epsilon_t\)</span>为零均值，方差为<span class="math inline">\(\delta_\epsilon^2\)</span>的平稳白噪声，<span class="math inline">\(X_t\)</span>为阶数为q的移动平均序列，简称MA(q)序列，<span class="math inline">\(\theta=[\theta_1,\theta_2,...,\theta_p]^T\)</span>为移动平均参数向量,其分量为移动平均系数，引入线性后移算子B，再定义一个和上面类似多项式,则可MA序列改写为<span class="math inline">\(X_t=\theta(B)\epsilon_t\)</span></p></li>
<li><p>ARMA序列，即自回归移动平均序列(Auto Regressive Moving Model) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为零均值平稳序列，满足下列模型 <span class="math inline">\(X_t-\psi_1 X_{t-1}-\psi_2 X_{t-2}-\dots-\psi_p X_{t-p}=\epsilon_t-\theta_1 \epsilon_{t-1}-\dots-\theta_q \epsilon_{t-q}\)</span> <span class="math inline">\(\epsilon_t\)</span>为零均值，方差为<span class="math inline">\(\delta_\epsilon^2\)</span>的平稳白噪声，<span class="math inline">\(X_t\)</span>为阶数为p,q的移动平均序列，简称ARMA(p,q)序列,利用后移算子可表为<span class="math inline">\(\psi(B)(X_t-\mu)-\theta(B)\epsilon_t\)</span></p>
<p>对于算子多项式<span class="math inline">\(\psi(B),\theta(B)\)</span>通常还要做下列假定</p>
<ol type="1">
<li>二者无公共因子，且<span class="math inline">\(\psi_p\ne0,\theta_q\ne0\)</span></li>
<li><span class="math inline">\(\psi(B)=0\)</span>的根全在单位圆外，称为模型平稳性条件</li>
<li><span class="math inline">\(\theta(B)=0\)</span>的根全在单位圆外，称为模型可逆性条件</li>
</ol></li>
</ol>
<h4 id="arma模型的构建和预报">ARMA模型的构建和预报</h4>
<p>在实际问题建模中，首先要进行模型的识别和定阶，即要判断AR(p),MA(q),ARMA(p,q)模型的类别，并估计阶数p,q，其实都归结到模型的定阶问题，当模型定阶后，就要对模型参数<span class="math inline">\(\psi,\theta\)</span>进行估计，完成后还需要对模型进行检验，检验<span class="math inline">\(\epsilon_t\)</span>是否为平稳白噪声</p>
<ol type="1">
<li>ARMA模型的构建
<ul>
<li>ARMA模型定阶的AIC准则：选p,q使<span class="math inline">\(min \quad AIC-nln\hat{\delta_\epsilon^2}+2(p+q+1)\)</span>,若序列含未知均值参数，修正为2(p+q+2)</li>
<li>ARMA模型的参数估计：直接用Matalb工具箱即可</li>
<li>ARMA模型检验的<span class="math inline">\(\chi^2\)</span>检验：给定显著性水平<span class="math inline">\(\alpha\)</span>，查表得上<span class="math inline">\(\alpha\)</span>分位数<span class="math inline">\(\chi_{\alpha}^2(L-r)\)</span>,当<span class="math inline">\(\chi^2&gt;chi_{\alpha}^2(L)\)</span>认为模型检验未通过</li>
</ul></li>
<li>ARMA序列的预报 时间序列的m步预报，是根据<span class="math inline">\({X_k,X_{k-1},...}\)</span>的取值对未来k+m时刻的随机变量<span class="math inline">\(X_{k+m}(m&gt;0)\)</span>做出估计，估计量记作<span class="math inline">\(\hat{X_k}(m)\)</span>，是<span class="math inline">\({X_k,X_{k-1},...}\)</span>的线性组合
<ul>
<li>AR(p)序列的预报:<span class="math inline">\(\begin{cases}  \hat{X_k(1)}=\psi_1X_k+\psi_2X_{k-1}+\dots+\psi_pX_{k-p+1}\\  \hat{X_k(2)}=\psi_1X_k(1)+\psi_2X_{k}+\dots+\psi_pX_{k-p+2}\\  ...\\  \hat{X_k(p)}=\psi_1X_k(p-1)+\psi_2X_{k}(p-2)+\dots+\psi_pX_{k}\\  \hat{X_k(m)}=\psi_1X_k(m-1)+\psi_2X_{k}(m-2)+\dots+\psi_p\hat{X_k(m-p)},m&gt;p\\ \end{cases}\)</span> 由此可见<span class="math inline">\(\hat{X_K}(m)(m\ge1)\)</span>仅依赖于<span class="math inline">\(X_t\)</span>的k时刻以前的p个时刻的值<span class="math inline">\(X_K,X_{k-1},\dots,X_{k-p+1}\)</span>,这是AR(p)序列预报的特点</li>
<li>MA(q)和ARMA(p,q)序列的预报 MA(q)序列 <span class="math inline">\(\hat{X_{k+1}^{(q)}}=\begin{bmatrix}  \theta_1 &amp;1&amp;0&amp;\cdots&amp;0\\  \theta_2 &amp;0&amp;1&amp;\cdots&amp;0\\  \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\  \theta_{q-1} &amp;0&amp;0&amp;\cdots&amp;1\\  \theta_q &amp;0&amp;0&amp;\cdots&amp;0\\ \end{bmatrix}\hat{X_{k}^{(q)}}-\begin{bmatrix} \theta_1\\ \theta_2\\ \vdots\\ \theta_1 \end{bmatrix}X_{k+1}\)</span> 递推初值可取<span class="math inline">\(\hat{X_{k_0}^{(q)}}=0(k_0)\)</span>较小，因为模型可逆性保证递推式渐进稳定，即当n充分大后，初始误差影响可以逐渐消失 ARMA(p,q)序列 <span class="math display">\[\hat{X_{k+1}^{(q)}}=\begin{bmatrix}
 -G_1 &amp;1&amp;0&amp;\cdots&amp;0\\
 -G_2 &amp;0&amp;1&amp;\cdots&amp;0\\
 \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
 -G_{q-1} &amp;0&amp;0&amp;\cdots&amp;1\\
 -G_q+\psi_q^* &amp;\psi_{q-1}^* &amp;\psi_{q-2}^*&amp;\cdots&amp;\psi_1^*\\
\end{bmatrix}\hat{X_{k}^{(q)}}\\+\begin{bmatrix}
G_1\\
G_2\\
\vdots\\
G_q\\
\end{bmatrix}X_{k+1}+\begin{bmatrix}
0\\
0\\
\vdots\\
0\\
\sum_{j=q+1}^p\psi_j^*X_{k+q+1-j}\\
\end{bmatrix},G_j:X_t=\sum_{j=0}^∞G_j\epsilon_{t-j}\]</span> 实际中，模型参数是未知的，若已建立了时间序列的模型，则理论模型的未知参数可用其估计替代，再用上面介绍的方法预报</li>
</ul></li>
</ol>
<h3 id="时间序列的matlab相关工具箱及命令">时间序列的Matlab相关工具箱及命令</h3>
<p>Matlab时间序列的相关指令在系统辨识，计量经济学，金融工具箱内</p>
<h3 id="arima序列与季节性序列">ARIMA序列与季节性序列</h3>
<p>在实践中遇到的时间序列往往有三个特性，趋势性，季节性，非平稳性，一般采用差分方法或其他时间序列变化方法消除趋势性季节性，使变换后序列为平稳序列，并假设为ARMA序列，再用上面介绍方法研究。</p>
<h4 id="arima序列及其预报">ARIMA序列及其预报</h4>
<p>对于非平稳序列，可借助差分运算使其平稳化，若<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为非平稳序列，若存在正整数d，使<span class="math inline">\(\nabla^dX_t=W_t\)</span>，且<span class="math inline">\({W_t,t=0,\pm1,\pm2,...}\)</span>是ARMA(p,q)序列，称<span class="math inline">\(X_t\)</span>为ARIMA(p,d,q)序列</p>
<p>ARIMA序列的预报(d=1,d=2) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>是ARIMA(p,d,q)序列 1. <span class="math inline">\(d=1,\nabla X_t=W_t \to\hat{X_k(m)}=\hat{X_k}(m-1)+\hat{W_k}(m)=X_k+\sum_{j=1}^m\hat{W_k}(j)\)</span> 2. <span class="math inline">\(d=2,\nabla^2 X_t=\hat{W_k}(m) \to\hat{X_k(m)}=X_k+\sum_{j=1}^m\hat{W_k}(j)(m+1-j)+m(X_k-X_{k-1})\)</span></p>
<h4 id="季节性序列及其预报">季节性序列及其预报</h4>
<p>由季节性因素或其他周期因素引起的周期性变化的时间序列，称为季节性时间序列，相应的模型为季节性模型，一般的，对周期为s的序列，先进行差分运算<span class="math inline">\(\nabla_sX_t=(1-B^s)X_t,\\\nabla_s^d=(1-B^s)^dX_t\)</span>,然后再进行ARIMA建模</p>
<h2 id="支持向量机">支持向量机</h2>
<p>支持向量机是数据挖掘中一项新技术，借助最优化方法解决机器学习问题的新工具，在模式识别等领域获得了广泛应用，其主要思想是找到一个超平面，使得它能够尽可能多地将两类数据点正确分开，同时使分开的两类数据点距离分类面最远</p>
<h3 id="支持向量分类机的基本原理">支持向量分类机的基本原理</h3>
<p>根据给定的训练集，<span class="math inline">\(T={[a_1,y_1],[a_2,y_2],\dots,[a_t,y_t]}\in(\Omega\times Y)^l\)</span>,<span class="math inline">\(a_i\in\Omega=R^n,\Omega\)</span>为输入空间，输入空间的每一个点<span class="math inline">\(a_i\)</span>由n个属性特征组成，<span class="math inline">\(y_i\in Y={-1,1},i=1,\dots,l\)</span> 寻找<span class="math inline">\(R^n\)</span>上的一个实值函数<span class="math inline">\(g(x)\)</span>,以便用分类函数<span class="math inline">\(f(x)=sgn(g(x))\)</span>推断任意一个模式x所对应的y值的问题为分类问题</p>
<h4 id="线性可分支持向量分类机">线性可分支持向量分类机</h4>
<p>考虑训练集T,若<span class="math inline">\(\exists \omega\in R^n,b\in R,\epsilon(&gt;0)\)</span>，使得对所有使<span class="math inline">\(y_i=1\)</span>的<span class="math inline">\(a_i\)</span>有<span class="math inline">\((\omega\cdots a_i)+b\ge\epsilon\)</span>,这里<span class="math inline">\((\omega\cdots a_i)\)</span>表示向量<span class="math inline">\(\omega,a_i\)</span>的内积，而对所有使<span class="math inline">\(y_i=-1\)</span>的<span class="math inline">\(a_i\)</span>有<span class="math inline">\((\omega\cdots a_i)+b\le-\epsilon\)</span>,则称训练集T线性可分，称相应的分类问题是线性可分的</p>
<p><em>规范超平面</em>：空间<span class="math inline">\(R^n\)</span>中超平面都可以写为<span class="math inline">\((\omega\cdot x)+b=0\)</span>的形式，参数<span class="math inline">\((w,b)\)</span>乘以任何一个非零参数后得到的是同一个超平面，定义满足条件<span class="math inline">\(\begin{cases}y_i[(\omega\cdot a_i+b)]\ge 0,\\min_{i=1,...,l}|(\omega\cdot a_i)+b|=1,i=1,...,l\\\end{cases}\)</span>的超平面为训练集T的规范超平面，</p>
<p><strong>当训练集T为线性可分时，存在唯一的规范超平面<span class="math inline">\((\omega\cdot x)+b=0\)</span>,使得<span class="math inline">\(\begin{cases}(\omega\cdot a_i)+b\ge 1,y_i=1\\(\omega\cdot a_i)+b\le -1,y_i=-1 \end{cases}\)</span>，其中=正负1的被称为普通支持向量</strong></p>
<p>支持向量机一般又可分为以下几类 - 线性支持向量机：除了普通支持向量分布在两个边界，其余的所有样本点分布在分类边界以外，这是构造的超平面是<strong>硬间隔超平面</strong>，若存在样本点在边界之间，需要进行软化处理，这是获得的就是<strong>软间隔超平面</strong>，软化方法就是加入一个调节因子</p>
<ul>
<li><p>非线性可分支持向量机：当两个凸包重合太大了，也就是软化的方法不适用的时候，采用映射的方法，换到另外一个高维空间域里进行分类。通过引进从输入空间 X 到另一个高维的 Hilbert 空间 H 的变换，空间H叫做特征空间。</p></li>
<li><p>C-支持向量机（非线性不可分）：映射到高维H空间之后还是不能直接可分，在H空间进行软化再分类。</p></li>
</ul>
<p>该模型主要是利用图像学原理，通过对凸包的研究把求超平面的问题转化成求约束下的优化问题，从而利用拉格朗日算子和KTT条件来求解。</p>
<h3 id="支持向量机的matlab命令">支持向量机的Matlab命令</h3>
<p>Matlab支持向量机的命令有，训练支持向量机分类器的函数svmtrain,使用支持向量机分类的函数svmclassify,指定支持向量机函数使用的序列最小化参数函数svmsmoset</p>
<h2 id="多元分析">多元分析</h2>
<p>多元分析是多变量的统计分析方法，是数理统计中应用广泛的一个重要分支</p>
<h3 id="聚类分析">聚类分析</h3>
<p>将认识对象进行分类是人类认识世界的一种重要方法，聚类分析作为一种定量方法，可以从数据分析的角度，给出一个更精确，细致的分类工具，聚类分析又被称为群分析，是对多个样本(或指标)进行定量分类的一种多元统计分析方法，对样本进行分类称为<strong>Q型聚类分析</strong>，对指标进行分类称为<strong>R型聚类分析</strong></p>
<h4 id="q型聚类分析">Q型聚类分析</h4>
<ol type="1">
<li><p>样本的相似性度量 要用数量化方法对事物进行分类，就必须用数量化方法描述事物之间的相似程度，对每个样本点的相似程度，一般利用距离来衡量，在这里距离的选择有很多种，最常用的是<strong>闵氏距离</strong>，绝对值距离，欧几里得距离，切比雪夫距离都是其的一些特例，其中最常用的还是<strong>欧几里得距离</strong>，其主要优点是当坐标轴进行正交旋转时，欧氏距离是保持不变的，因此，若对原坐标系进行平移和旋转变换，则变换后样本点的距离和变换前完全相同，闵氏距离也有一些缺点，<strong>需要量纲一致，需要避免变量的多重相关性</strong> 针对其缺点，马氏距离做出了相应的改进</p></li>
<li><p>类与类间的相似性度量 度量方法如下：</p>
<ul>
<li>最短距离法</li>
<li>最长距离法</li>
<li>重心法</li>
<li>类平均法</li>
<li>离差平方和法</li>
</ul></li>
<li><p>聚类图 Q型聚类结果可由一个聚类图表示出来，生成步骤如下</p>
<ol type="1">
<li>计算n个样本点两两之间的距离<span class="math inline">\({d_{ij}}\)</span>,记为矩阵<span class="math inline">\(D=(d_{ij})_{n\times n}\)</span></li>
<li>首先构造n个类，每一个类只包含一个样本点，每一类的平台高度均为0</li>
<li>合并距离最近的两类为新类，并且以这两类的距离值作为聚类图的平台高度</li>
<li>计算新类与当前各类的距离，若类的个数已经等于1，转入步骤5，否则回到步骤3</li>
<li>画聚类图</li>
<li>决定类的个数和类</li>
</ol></li>
<li><p>Matlab聚类分析的相关指令 pdist,linkage,cluster,zsore,dendrogram,clusterdata</p></li>
</ol>
<h4 id="r型聚类法">R型聚类法</h4>
<p>在实际工作中，变量聚类法的应用非常重要，人们希望能研究变量间的相似关系，按照变量的相似关系把它们聚合成若干个类，进而找出影响系统的主要因素 1. 变量相似性度量 在对变量进行聚类分析时，首先要确定变量的相似性度量，常用的变量相似性度量有<strong>相关系数</strong>和<strong>夹角余弦</strong> 各种定义的相似度量均需具有以下两个性质 1. <span class="math inline">\(|r_{jk}\le 1|,r_{jk}=r_{kj}\)</span>，越接近1，二者越相关，越接近0，相似性越弱 2. 变量聚类法 类似系统聚类法，在变量聚类中常用的是最长距离法和最短距离法</p>
<h3 id="主成分分析">主成分分析</h3>
<p>主成分分析的主要目的是希望用较少的变量去解释原来资料中大部分变异，通常是选出比元素变量个数少，能解释大部分资料中变异的几个新变量，即所谓的主成分，并用以解释资料的综合性指标，本质上是一种<strong>降维方法</strong></p>
<h4 id="分析步骤">分析步骤</h4>
<ol type="1">
<li>构建初始数据矩阵：矩阵的每一行表示一个样本，每一列表示一个原始指标，矩阵中每一个元素表示某一个样本在某一个指标下的得分</li>
<li>计算相关系数矩阵：对初始数据矩阵中的各个指标，求出相关系数矩阵</li>
<li>计算特征值和特征向量：计算样本相关系数矩阵的特征值和特征向量，计算完成和对特征值进行从大到小的排序</li>
<li>计算主成分贡献率和累积贡献率：每一个特征值对应一个主成分和贡献率，某特征值的贡献率=该特征值/所有特征值的和，该特征值对应的主成分即为对应的特征向量</li>
<li>选择保留的主成分：一般取累积贡献率超过80%的那些主成分作为最终结果，特征值对应的特征向量即为主成分的系数</li>
<li>利用系数分析主成分代表的含义</li>
<li>利用主成分进行后续的分析过程</li>
</ol>
<h4 id="不足与注意事项">不足与注意事项</h4>
<p><strong>不足</strong>：主成分的含义解释一般都带有一些模糊性，不像原始变量那样清楚确切，这是变量降维过程中必须付出的代价，只有当主成分个数远小于原始变量的个数才使用主成分分析</p>
<p><strong>注意事项</strong>： 在评价类模型中，不能先用主成分分析后再对主成分进行评价。</p>
<p>主成分分析可以用于聚类。因为聚类结果的维度往往很高，这时可以通过主成分分析法对聚类结果降维，从而在二维或三维空间中作出聚类结果图</p>
<h3 id="因子分析">因子分析</h3>
<p>因子分析可以看为主成分分析的推广，也是多元统计分析中常用的一种降维方式，他们的差别体现在： 1. 主成分分析将方差划分为不同的正交成分，而因子分析把方差划分为不同的起因因子 2. 主成分分析只是变量变换，因子分析需要构造因子模型 3. 主成分分析原始变量的线性组合表示新的综合变量，即主成分。因子分析潜在的假想变量和随机影响变量的线性组合表示原始变量</p>
<h4 id="因子分析模型">因子分析模型</h4>
<p>数学模型：<span class="math inline">\(\mathbf{X-\mu=\Lambda F+\epsilon}\\\mathbf{X,\mu,\Lambda,F,\epsilon}=\begin{bmatrix}X_1\\X_2\\\vdots\\X_p\end{bmatrix},\begin{bmatrix}\mu_1\\\mu_2\\\vdots\\\mu_p\end{bmatrix},\begin{bmatrix}\alpha_{11}\quad\alpha_{12}\quad\cdots\quad\alpha_{1m}\\\alpha_{21}\quad\alpha_{22}\quad\cdots\quad\alpha_{2m}\\\vdots\qquad\vdots\quad\ddots\quad\vdots\\\alpha_{p1}\quad\alpha_{p2}\quad\cdots\quad\alpha_{pm}\end{bmatrix},\begin{bmatrix}F_1\\F_2\\\vdots\\F_p\end{bmatrix},\begin{bmatrix}\epsilon_1\\\epsilon_2\\\vdots\\\epsilon_p\end{bmatrix}\)</span>,在上式中 称<span class="math inline">\(F_1,F_2,...,F_p\)</span>为公共因子，是不可观测的变量，其系数称为载荷因子，<span class="math inline">\(\epsilon_i\)</span>是特殊因子，不能被前m个公共因子包含的部分</p>
<h4 id="因子载荷矩阵的估计方法">因子载荷矩阵的估计方法</h4>
<p>用于估计<span class="math inline">\(\mathbf{\Lambda}\)</span> 1. 主成分分析法 2. 主因子法 3. 最大似然估计法</p>
<h4 id="因子旋转正交变换">因子旋转(正交变换)</h4>
<p>对因子载荷矩阵进行旋转的目的是使因子载荷矩阵结构简化，使载荷矩阵每列或行的元素平方值向0和1两极分化，主要正交旋转法有：方差最大法，四次方最大法，等量最大法</p>
<h4 id="因子得分">因子得分</h4>
<p>上述小节解决了用公共因子的线性组合表示一组观测变量的问题，如果利用因子做其他研究，比如作为自变量来做回归分析，对样本分类或平均，需要对公共因子测度，给出公共因子的值，其数学模型就是将上述数学模型的<span class="math inline">\(\mathbf{\mu}\)</span>移到等式右边 常用方法有: 巴斯莱特因子得分(加权最小二乘法),回归方法</p>
<p><strong>因子分析的步骤</strong>： 1. 选择分析的变量 2. 计算所选的原始变量的相关系数矩阵 3. 提出公共因子 4. 因子旋转 5. 计算因子得分</p>
<h3 id="判别分析">判别分析</h3>
<p>判别分析是根据所研究的个体的观测指标来推断该个体所属类型的一种统计方法，用统计方法表述，就是已有q个总体<span class="math inline">\(X_1,X_2,...,X_q\)</span>,他们的分布函数为<span class="math inline">\(F_1(x),F_2(x),...,F_q(x)\)</span>，对于给定样本X,要判断它来自哪个总体</p>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
</search>
