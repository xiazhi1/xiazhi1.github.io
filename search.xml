<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pr-learn</title>
    <url>/2022/02/01/PR/</url>
    <content><![CDATA[<h2 id="新手村">新手村</h2>
<h3 id="从pr的最简工作流讲起">01-从pr的最简工作流讲起</h3>
<ol type="1">
<li>pr的用途： pr是一款用于视频段落的组合和拼接，并提供一定特效和调色功能</li>
<li>项目窗口： 用于储存视频，音频，图片，序列等素材</li>
<li>序列窗口： 用于编辑音频，视频，可以多个轨道同时编辑</li>
<li>预览窗口： 用于实时预览时间线上的素材效果。</li>
<li>效果控件窗口 可以对素材的基本属性做出调整，也可以调整添加在素材上的效果参数</li>
<li>效果窗口： pr中需要用到的各种自带的效果</li>
<li>pr工作流程：
<ol type="1">
<li>素材窗口中导入素材</li>
<li>新建序列</li>
<li>通过剃刀工具（C）对素材进行裁剪</li>
<li>通过选择工具（V）对素材进行选择并删除</li>
<li>通过拼接完成对素材的剪辑</li>
<li>渲染输出成片</li>
</ol></li>
</ol>
<span id="more"></span>
<h3 id="剪辑多素材如何标记出入点">02-剪辑多素材如何标记出入点</h3>
<h4 id="导入素材">导入素材</h4>
<ol type="1">
<li>熟悉素材，选取合适的音乐</li>
<li>将素材和音乐导入pr素材窗口中</li>
</ol>
<h4 id="剪辑流程">剪辑流程</h4>
<ol start="3" type="1">
<li>反复感受音乐，对音乐做一个节奏和情绪上的区分</li>
<li>选取偏努力的和刻苦一些的素材，在素材窗口中，选取出入点，截取合适的段落，将素材拖到视频轨道上</li>
<li>对于前半段音乐节奏比较快的地方，选取的素材相应的要短一些，剪辑点可以密一些</li>
<li>选取成功，胜利一类的素材，放在音乐后半段</li>
<li>反复感受音乐节奏，可以在音乐有大的节拍的地方，将剪辑点对齐</li>
<li>反复预览视频，使视频剪辑点和音乐更契合</li>
<li>导出视频</li>
</ol>
<h4 id="寻找剪辑点干货">寻找剪辑点（干货）</h4>
<ol type="1">
<li><p>空格键Space播放和暂停</p></li>
<li><p>Left Right键 ：向前向后一帧 （比较细致，可以一直按，这样速度快一点）</p></li>
<li><p>shift+Left Right键：向前向后五帧（这个比较快）</p></li>
<li><p>J 左穿梭/倒放 K 停止穿梭 L 右穿梭/正放</p></li>
<li><p>Shift + L 慢速右穿梭 Shift + J 慢速左穿梭</p></li>
<li><p>穿梭键如果连按，可以加速，K和Space都可以停止播放 时间线窗口中时间帧的管理</p></li>
<li><p>End 跳转到序列-素材结束点 Home 跳转到序列-素材开始点 Shift + End 跳转到所选素材结束点 Up 跳转上一个编辑点 Down 跳转下一个编辑点</p></li>
<li><p>i o:设出入点 Shift + I 跳转入店 Shift + O 跳转出点 ‘ 提取 ， 插入 . 覆盖</p></li>
</ol>
<h3 id="如何制作抽帧卡点">03-如何制作抽帧/卡点</h3>
<h4 id="卡点操作">卡点操作：</h4>
<ol type="1">
<li>试听音乐，找出音乐中的卡顿点，即变化很大的点，然后标记他 #### 抽帧操作</li>
<li>对已经标记的卡顿点，然后将其后面一部分删掉，把再后面的往前面拖，这样就可以营造出卡点抽帧的效果来</li>
</ol>
<h3 id="如何添加字幕">04-如何添加字幕</h3>
<p>下载ARCTIMEPRO</p>
<h3 id="鬼畜视频基础制作倍速加重复">05-鬼畜视频基础制作（倍速加重复）</h3>
<p>鬼畜的最基本操作就是把某个搞笑的片段重复的，以较快的倍速播放，还可以设置倒放等操作</p>
<h3 id="常见操作键">06-常见操作键</h3>
<figure>
<img src="https://s2.loli.net/2022/02/11/2EfkAIH5lo8Uu1z.jpg" alt="v2-58c3473d36a4622235aa0eda5ca1de7c_r.jpg"><figcaption aria-hidden="true">v2-58c3473d36a4622235aa0eda5ca1de7c_r.jpg</figcaption>
</figure>
]]></content>
      <categories>
        <category>PR&#39;s area</category>
      </categories>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/03/19/Linux-%E6%89%BE%E5%9B%9Eroot%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="linux-centos7.6找回root密码">Linux-centos7.6找回root密码</h1>
<p>说来话长，笔者在某个晴朗的周六早晨进行了root密码找回的测试，本以为是一个依葫芦画瓢的操作，没想到却折磨了笔者一个上午的时间去完成，话不多说，直接上步骤</p>
<span id="more"></span>
<p>在开机出现如下界面时，快按e键(只有五秒停留时间，速度，不然就要进登录界面了)： <img src="https://s2.loli.net/2022/03/26/i6Df2velR4hAqad.png" alt="image-33.png"> 2. 在步骤一按下”e”键之后，出现如下界面，按 ↓键一直到底部找到“LANG=zh_CN.UTF-8”这句，在这句后面加上“init=/bin/sh”,然后按Ctrl+x进入单用户。 <img src="https://s2.loli.net/2022/03/26/wvr8bVFBCN9SGad.png" alt="image-35.png"> 3. 挂载文件系统为可写模式：mount –o remount,rw /(rw 后两个空格，一定要按步骤来) <img src="https://s2.loli.net/2022/03/26/blj4R9o8Pe7JMUm.png" alt="image-34.png"> 4. 执行passwd命令，修改root密码，密码要输入两次要求两次密码要一致。(你刚相信，我失败多次的原因之一在passwd后面没加root) <img src="https://s2.loli.net/2022/03/26/WhUlDFGXJ6SKIN5.png" alt="image-36.png"> 5. 如果之前系统启用了selinux，必须执行以下命令，否则将无法正常启动系统：touch /.autorelabel。然后执行命令exec /sbin/init来正常启动，或者用命令exec /sbin/reboot重启就OK了。</p>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin学习</title>
    <url>/2022/05/08/Gin%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="gin框架简介">00 Gin框架简介</h2>
<p>Gin是一个用Go语言编写的web框架，是一个拥有良好性能的API框架，其性能非常好，是GO世界里最流行的web框架，是一个简单易用的轻量级框架</p>
<span id="more"></span>
<h2 id="gin框架安装与使用">01 Gin框架安装与使用</h2>
<h3 id="安装">安装</h3>
<p>下载并安装Gin：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>
<h3 id="第一个gin实例">第一个Gin实例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    // 创建一个默认的路由引擎</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    // GET: 请求方式；/hello: 请求的路径</span><br><span class="line">    // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span><br><span class="line">    r.GET(&quot;/hello&quot;,func(c *gin.Context)&#123;</span><br><span class="line">        // c.JSON: 返回JSON格式的数据</span><br><span class="line">        c.JSON(200,gin.H&#123;</span><br><span class="line">            &quot;message&quot;:&quot;Hello world!&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    // 启动HTTP服务，默认在0.0.0.0：8080启动服务</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码保存并编译执行，<strong>注意</strong>：把终端切到文件目录下再执行，然后使用浏览器打开127.0.0.1：8080/hello就能看到一串JSON字符串</p>
<h2 id="restful-api">02 RESTful API</h2>
<p>REST代表一种软件架构风格，是Representational State Transfer的简称 简单来说，REST的含义就是客户端与web服务器之间进行交互时，使用HTTP协议中的四个请求方法代表不同的动作。</p>
<ul>
<li>GET用来获取资源</li>
<li>POST用来新建资源</li>
<li>PUT用来更新资源</li>
<li>DELETE用来删除资源 只要API程序遵循了REST风格，那就可以将其称为RESTful API。目前在前后端分离的架构中，前后端基本上都是通过RESTful API来进行交互 现在我们举一个编写管理书籍系统的例子，该系统可以进行对一本书进行查询，创建，更新，删除等操作，如果我们按照RESTful API设计，就如下表所示| 请求方法 | URL | 含义 | | -------- | ----- | ------------ | | GET | | 获取书籍信息 | | POST | | 新建书籍信息 | | PUT | | 更新书籍信息 | | DELETE | | 删除书籍信息 |</li>
</ul>
<h3 id="实例代码">实例代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;GET&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;POST&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.PUT(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;PUT&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.DELETE(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;DELETE&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gin渲染">03 Gin渲染</h2>
<h3 id="html渲染">HTML渲染</h3>
<p>我们首先定义一个存放模板文件的templates文件夹，然后在其内部根据业务分别定义一个posts文件夹和一个users文件夹 其中posts/index.html文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;posts/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;posts/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>users/index.html文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;users/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;users/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLGlob(&quot;templates/**/*&quot;)</span><br><span class="line">	//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)</span><br><span class="line">	r.GET(&quot;/posts/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;posts/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(&quot;users/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;users/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(&quot;:8080&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>互联网技术</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习训练Tips</title>
    <url>/2023/03/05/deeplearning-tips/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>笔者在刚接触深度学习时，曾因为找不到系统实验指南而抓耳挠腮，十分痛苦，在搜索了无数次资源加上n次痛苦的debug后终于跑起了第一个深度学习实验，为了记录下自己的debug心得和为后来者提供一些建议，所以写下此博客，不足之处，望多多指正</p>
<span id="more"></span>
<h1 id="初期准备">初期准备</h1>
<h2 id="系统选择">系统选择</h2>
<p>尽可能选择Linux系统，因为大部分论文实验都是在Linux系统下操作开发，可能到Windows系统上会有一些“水土不服”（别问我是怎么知道的。。。） 推荐租云服务器:便宜的服务器平台：<a href="https://www.autodl.com/home">AutoDL</a>[应该是市面上最便宜的，学生认证有优惠] 免费的服务器平台：<a href="https://colab.research.google.com/">Google Colab</a>[12小时会自动断开，不过免费，分配的卡也还不错！] 如果自己电脑显卡较好且内存充足，可以选择装虚拟机后显卡直通或装双系统，其中显卡直通笔者没试过，装双系统有点折磨，且不太方便（两个系统不能同时在线）</p>
<h2 id="深度学习环境配置">深度学习环境配置</h2>
<p>这里网上教程很多，这里推荐一个我当时配的参考博客： <a href="https://www.cnblogs.com/LXP-Never/p/15151578.html#blogTitle0">凌逆战的博客</a></p>
<h1 id="具体实操">具体实操</h1>
<p>这里我以当时我配的CVPR2020 best paper（Unsupervised Learning of Probably Symmetric Deformable 3D Objects from Images in the Wild）举例： 首先打开论文查看论文代码位置： <img src="https://s2.loli.net/2023/03/05/a7ELmUqVIp4ZPxe.png" alt="训练tips_1.png"> 点击代码位置后在GitHub中下载代码 然后根据项目处的readme文件按步骤一步步配置 Tips：请注意创建虚拟环境，详细请看<a href="https://blog.csdn.net/SARACH_WONG/article/details/89328307">conda创建环境</a> 通过创建环境我们可以在一台主机上同时配上不同实验的实验环境并进行训练</p>
]]></content>
      <categories>
        <category>AI笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2022/03/19/hexo-d%20%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="hexo-d-提交spawn-failed-的解决办法">hexo d 提交spawn failed 的解决办法</h1>
<h2 id="网络问题">网络问题</h2>
<p>这个问题很多都是因为网络问题引起的 我们可以</p>
<ul>
<li>重启电脑(请首先尝试)</li>
<li>科学上网问题</li>
</ul>
<h2 id="本地文件问题">本地文件问题</h2>
<h3 id="重置git的deploy文件夹">重置git的deploy文件夹</h3>
<p>删除博客文件夹的.deploy_git文件夹，然后在对这个文件git bash 后输入 git config --global core.autocrlf false</p>
<h3 id="多系统混合编写">多系统混合编写</h3>
<p>笔者就亲身经历过，可能是因为当时在同一台电脑上运行Linux和Windows，cd进.deploy_git文件夹，输入git config –-global core.autocrlf false。</p>
<h3 id="end">end</h3>
<p>最后直接hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mips</title>
    <url>/2023/05/15/mips/</url>
    <content><![CDATA[<h1 id="华中科技大学模拟与电路系统三实验汇总">华中科技大学模拟与电路系统（三）实验汇总</h1>
<h2 id="并行io接口实验">并行IO接口实验</h2>
<h3 id="实验任务">实验任务</h3>
<p>嵌入式计算机系统将独立按键以及独立开关作为输入设备，七段数码管作为输出设备。实现以下功能：</p>
<span id="more"></span>
<ol type="1">
<li><p>点击BTNC 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该二进制数的低8 位对应的二进制数值0 或1 显示到8 个七段数码管上。</p></li>
<li><p>点击BTNU 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该16 进制数据各位数字对应的字符0~F 显示到低4 位七段数码管上（高4 位七段数码管不显示）。</p></li>
<li><p>点击BTND 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该数据表示的无符号十进制数各位数字对应的字符0~9 显示到低5 位七段数码管上（高3 位七段数码管不显示）。</p></li>
</ol>
<p>程序控制方式提示：程序以七段数码管动态显示控制循环为主体，在循环体内的延时函数内循环读取按键键值以及开关状态，并根据按键值做相应处理。</p>
<h3 id="实验源码">实验源码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;xil_io.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;xgpio.h&quot;</span><br><span class="line">#include &quot;sleep.h&quot;</span><br><span class="line">#include &quot;xtmrctr.h&quot;</span><br><span class="line">#include &quot;xintc_l.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char button = 0x0;</span><br><span class="line">    char segtable[16]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e&#125;;</span><br><span class="line">    short segcode[8]=&#123;0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff&#125;;</span><br><span class="line">    short pos=0xff7f;</span><br><span class="line">    Xil_Out16(XPAR_GPIO_0_BASEADDR+XGPIO_TRI_OFFSET,0xffff);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI_OFFSET,0X0);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI2_OFFSET,0x0);</span><br><span class="line">    Xil_Out8(XPAR_GPIO_2_BASEADDR+XGPIO_TRI_OFFSET,0x1f);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        while((Xil_In8(XPAR_GPIO_2_BASEADDR+XGPIO_DATA_OFFSET)&amp;0X1f)!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            button = Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f;</span><br><span class="line">            short sw = Xil_In16(XPAR_GPIO_0_BASEADDR+XGPIO_DATA_OFFSET);</span><br><span class="line">			while((Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f)!=0);</span><br><span class="line">            switch (button)</span><br><span class="line">            &#123;</span><br><span class="line">            case 0x1:</span><br><span class="line">                for(int j=0;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;j)&amp;0x1];</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x2:</span><br><span class="line">                    for(int j=0;j&lt;4;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;(4*j))&amp;0xf];</span><br><span class="line">                    &#125;</span><br><span class="line">                    for(int j=4;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x10:</span><br><span class="line">                int a=sw;</span><br><span class="line">                for(int j=0;j&lt;5;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    switch (a%10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            case(0):segcode[7-j]=segtable[0];break;</span><br><span class="line">                            case(1):segcode[7-j]=segtable[1];break;</span><br><span class="line">                            case(2):segcode[7-j]=segtable[2];break;</span><br><span class="line">                            case(3):segcode[7-j]=segtable[3];break;</span><br><span class="line">                            case(4):segcode[7-j]=segtable[4];break;</span><br><span class="line">                            case(5):segcode[7-j]=segtable[5];break;</span><br><span class="line">                            case(6):segcode[7-j]=segtable[6];break;</span><br><span class="line">                            case(7):segcode[7-j]=segtable[7];break;</span><br><span class="line">                            case(8):segcode[7-j]=segtable[8];break;</span><br><span class="line">                            case(9):segcode[7-j]=segtable[9];break;</span><br><span class="line">                        &#125;    </span><br><span class="line">                    &#125;</span><br><span class="line">                    a/=10;</span><br><span class="line">                &#125;</span><br><span class="line">                    for(int j=5;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;                </span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;8;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA_OFFSET,pos);</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA2_OFFSET,segcode[i]);</span><br><span class="line">        for(int j=0;j&lt;10000;j++);</span><br><span class="line">        pos=pos&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    pos=0xff7f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2022/02/06/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="git学习">Git学习</h1>
<h2 id="创建版本库">创建版本库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit//创建目录</span><br><span class="line">$ cd learngit//切换目录</span><br><span class="line">$ pwd//显示当前目录</span><br><span class="line">$ ls -ah//显示目录</span><br><span class="line">$ git init//把目录变成可管理的仓库</span><br><span class="line">$ git add //把文件添加到仓库</span><br><span class="line">$ git commit -m&quot;&quot;//git commit告诉Git，把文件提交到仓库，-m用于添加对这次操作的说明</span><br><span class="line">$ cat readme.txt//查看readme.txt的内容</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>
<p>在Windows中当输入完txt内容后，按esc加：wq退出输入模式</p>
<span id="more"></span>
<h2 id="时光机穿梭">时光机穿梭</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status 命令可以让我们时刻掌握仓库当前的状态</span><br><span class="line">$ git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式</span><br><span class="line">提交修改和提交新文件步骤一样，$ git add $ git commit;不过在执行第二步之前可以运行 git status 看看当前仓库的状态</span><br></pre></td></tr></table></figure>
<h3 id="版本回退">版本回退</h3>
<p><code>git log</code>命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p>
<p>我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本</p>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<h3 id="工作区和暂存区">工作区和暂存区</h3>
<p><code>git add</code>命令实际上就是把要提交的所有修改（来自工作区的修改）放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<h3 id="管理修改">管理修改</h3>
<p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中</p>
<h3 id="撤销修改">撤销修改</h3>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p>
<h3 id="删除文件">删除文件</h3>
<p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交</p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了</p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code></p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本</p>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</file></file></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<h2 id="远程仓库">远程仓库</h2>
<p>1.创建自己的SSH Key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>
<h3 id="添加远程库">添加远程库</h3>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h3 id="从远程库克隆">从远程库克隆</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>
<h2 id="分支管理">分支管理</h2>
<h3 id="创建并合并分支">创建并合并分支</h3>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突">解决冲突</h3>
<p>冲突来源：<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="分支管理策略">分支管理策略</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并</p>
<h3 id="bug分支">Bug分支</h3>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h3 id="feature分支">Feature分支</h3>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="多人协作">多人协作</h3>
<h4 id="推送分支">推送分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<h4 id="抓取分支">抓取分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull//抓取分支</span><br></pre></td></tr></table></figure>
<h4 id="多人协作工作模式">多人协作工作模式</h4>
<ol type="1">
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>
<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>
<p>再pull：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<h4 id="小结">小结</h4>
<ul>
<li><p>查看远程库信息，使用<code>git remote -v</code>；</p></li>
<li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li>
<li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p></li>
<li><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li>
<li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li>
<li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h3 id="rebase">Rebase</h3>
<ul>
<li><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p></li>
<li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</p>
<p>指令是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br></pre></td></tr></table></figure>
<h3 id="标签管理">标签管理</h3>
<p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>。tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p>
<h4 id="创造标签">创造标签</h4>
<ul>
<li><p>标签不是按时间顺序列出，而是按字母排序的</p></li>
<li><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</p></li>
<li><p>命令<code>git tag -a &lt;tagname&gt; -m "blablabla..."</code>可以指定标签信息；</p></li>
<li><p>命令<code>git tag</code>可以查看所有标签。</p></li>
<li><p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p></li>
</ul>
<p>#### 操作标签</p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>互联网技术</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2022/02/01/%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="分治算法">分治算法</h2>
<h3 id="简要理解">简要理解</h3>
<p>分治算法由三部分组成：</p>
<ul>
<li>分：递归解决较小的问题（基本情况除外）</li>
<li>治：从子问题的解构建原问题的解</li>
</ul>
<span id="more"></span>
<h4 id="tips"><strong>Tips</strong>：</h4>
<ol type="1">
<li>传统上，在代码中至少含有两个递归调用的例程叫做分治算法，正文中只有一个递归调用的例程不是分治算法。</li>
<li>我们一般坚持子问题不相交，基本上要不重叠。</li>
</ol>
<h4 id="分治算法解决问题的特点"><strong>分治算法解决问题的特点</strong>：</h4>
<ol type="1">
<li>原问题规模通常比较大，不易直接解决，但问题缩小到一定程度能够较容易的解决。</li>
<li>问题可以分解为若干规模较小，求解方式相同（似）的子问题，且子问题之间求解是独立的，互不影响的。</li>
<li>合并问题分解的子问题可以得到问题的解</li>
</ol>
<h4 id="分治算法与递归的关系"><strong>分治算法与递归的关系</strong></h4>
<p>分治重要的是一种思想，注重的是问题分，治，合并的过程，而递归是一种方式（工具），这种方式通过方法自己调用自己形成一个来回的过程，分治就是利用了多次这样的来回过程。</p>
<h3 id="经典示例">经典示例</h3>
<ol type="1">
<li><strong>快速排序</strong> 快速排序的本质就是对基准数的两边分别递归进行查找交换，在这里，其满足分治算法中<em>分</em>：递归解决较小的问题：把整个数组的查找交换，分成对每个基准数的左右的查找交换的小问题。<em>治</em>：从子问题的解构建原问题的解：在对每个基准数左右进行排序后，整个大问题就已经排好了，就解决了原问题。</li>
<li><strong>最近点对</strong> 在二维坐标轴上有若干个点坐标，让你求出最近的两个点的距离，我们通常采用分治的方法来处理这种问题，按照x或者y的维度进行考虑，将数据分成两个区域，先分别计算(按照同方法)左右区域内最短的点对。然后根据这个两个中较短的距离向左和向右覆盖，计算被覆盖的左右点之间的距离，找到最小那个距离与当前最短距离比较即可。然后在每个区域的内部我们在进行像上面一样的操作</li>
</ol>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/02/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划">动态规划</h2>
<h3 id="简要理解">简要理解</h3>
<p>动态规划的思想是把问题划分为多个子问题，但子问题常常并不是互相独立的，当前子问题的解可看作是前面多个阶段的完整总结，所以它需要在子问题求解过程中进行多次判断与选择，与前面的问题相比，它现阶段一定要构成一种最优的结构，它满足最优化原理， <strong>最优化原理</strong>：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。同时，这样的最优策略是针对有已作出决策的总结，对后来的决策没有直接影响，只能借用目前最优策略的状态数据。这也被称之为无后效性。 <span id="more"></span> ### 求解思路 开始先要将问题按照一定顺序划分为各个阶段，然后确定每个阶段的状态，然后重点是根据决策的方法来确定状态转移方法，也就是说根据当前的状态确定下一阶段的状态，在这个过程中，下一状态的确定往往要参考之前的状态，因此需要在每一次状态转移过程中将当前的状态遍历记录，方便之后的查找。 ### 算法特点 * 需要在给定约束条件下优化某种指标时，动态规划是很有用的 * 问题可以分解为离散子问题是，可以用动态规划来解决 * 没有通用固定的公式，需要具体问题具体分析，这也就是其难点所在</p>
<h3 id="经典示例">经典示例</h3>
<p><strong>背包问题</strong>： 如果有一个小偷背有一个容量为4kg的背包去商场偷东西，可盗窃的物品有如下三件： 音响：3000 4kg 笔记本：2000 3kg 吉他：1500 1kg 每个物品只能偷一次，请问，小偷怎么偷收益最高 <strong>解决方法</strong> 我们可以考虑用画网格的方法来解决，我们构造下面的网格，每一行代表新添加的可以拿到物品，每一列代表当前容量，数字代表当前情况下可以拿的最大收益。这个过程就是动态规划的经典应用过程，就是保存上一步的结果，在这层进行决策时，与上一层结果比较，得到最优解 示意图如下： <img src="http://assets.processon.com/chart_image/61f9465b1e08530f015afacd.png" alt="alt"></p>
<p><strong>最长公共子串问题</strong> 如果用户在字典网站中查找单词时不小心拼错了，你必须猜测她原本要输入什么单词，例如啊彬想查单词fish，但不小心输入了hish，在网站的字典中，根本就没有这样的单词，但有类似的单词，那我们如何做这个判断呢？ 同样的，我们也可以构建一个网格，上方是输入单词的每个字母，左边是待匹配单词的字母，如果匹配就是左上角数字+1，最后比较整个方格中的最大值谁大，最大的就最匹配。 示意图如下： <img src="http://assets.processon.com/chart_image/61f9d53007912906b0b8147e.png" alt="alt"></p>
<p><strong>总结</strong> 从上面的两个例子可以看出，动态规划的核心是对上一步操作进行记忆，再与现在的操作进行对比，已得到最优解，同时，我们可以发现，不同问题中的动态规划虽然思路大体一致，都是保存上一步解并在确定这一步解时做参考，但具体实现上是完全不同的，所以说动态规划题并没有通用解法</p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2022/03/04/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>单调栈实际上也是栈，但他利用了一些巧妙的逻辑，让每次新元素入栈后，栈内元素都保持 有序（单调递增或单调递减），那么，这个逻辑是什么，其实很简单，以栈底-栈顶单调递增 为例，每次新元素入栈时，让栈内元素与新元素判断，比新元素大的栈内元素出栈即可。</p>
<span id="more"></span>
<h3 id="用途">用途</h3>
<p>单调栈的用途并不广泛，只处理一种典型问题，Next Greater Element</p>
<h3 id="单调栈模板">单调栈模板</h3>
<p>下面举一个例子说明其模板，现有这样一道题：给你一个数组nums，请你返回一个等长的结 果数组，结果数组中对应索引储存着下一个更大元素，如果没有更大的元素，就存-1，例如 输入数组 nums = [2,1,2,4,3],返回数组[4,2,4,-1,-1] 解释：第一个2后面比2大的数是4，第二个2后面比2大的数是4，4后面没有比4大的数，填 -1，3后面没有比3大的数，填-1.</p>
<ul>
<li>暴力解法：对每个元素的后面进行扫描，找到第一个更大的元素就可以了，时间复杂度为 <em>O（n^2）</em></li>
<li>单调栈法：把数组元素想象成并列的数，元素大小想象成树的高度，在某个位置时，后面 可见的第一颗树就是它的 Next Greater Number.
<ul>
<li>实现代码(C++)：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">  vector&lt;int&gt; res(nums.size()); // 存放答案的数组</span><br><span class="line">  stack&lt;int&gt; s;</span><br><span class="line">  // 倒着往栈里放</span><br><span class="line">  for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">      // 判定个子高矮</span><br><span class="line">      while (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123;</span><br><span class="line">          // 矮个起开，反正也被挡着了。。。</span><br><span class="line">          s.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      // nums[i] 身后的 next great number</span><br><span class="line">      res[i] = s.empty() ? -1 : s.top();</span><br><span class="line">      s.push(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这就是单调栈解决问题的模板，倒着入栈其实就是正着出栈，while循环是排除两颗高树间 的矮树，这个算法的复杂度只有O（n），尽管它存在for循环嵌套while循环，但要分析一个 算法的时间复杂度，要从整体入手，总共有n个元素，每个元素都被push入栈一次，最多被 pop一次，没有对于操作，计算规模与元素规模还是成正比的，也就是O（n）复杂度</p>
<h3 id="单调栈模板改良处理环形数组">单调栈模板改良处理环形数组</h3>
<p>同求next Greater Number 如果要求环形数组，怎么办 比如输入一个数组[2,1,2,4,3].返回数组[4,2,4,-1,4]拥有了环形属性，最后一个元素3绕 了一圈后找到了比自己大的元素4. 这种情况一般都是通过%运算符求模(余数)，来获得环形特效 对于这个问题还是要用单调栈解题模板，对环形需求，常用套路是将数组长度翻倍，我们也 可以不构造新数组，而是用循环数组来模拟数组长度翻倍的效果 示例代码（C++）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    vector&lt;int&gt; res(n);</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    // 假装这个数组长度翻倍了</span><br><span class="line">    for (int i = 2 * n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // 索引要求模，其他的和模板一样</span><br><span class="line">        while (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res[i % n] = s.empty() ? -1 : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考博客：<a href="https://labuladong.%20gitee.io/algo/2/21/51/">labuladong的算法小抄-单调栈结构解决三道算法题</a></p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的存储结构</title>
    <url>/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="图的存储结构">图的存储结构</h1>
<h2 id="前言">前言</h2>
<p>最近笔者在准备数据结构考试，故复习了些课本知识，发下自己对与图的存储结构还有诸多遗漏，故特意整理了些图的存储结构笔记，图的存储结构相对来说比较复杂，望大家复习时不要遗漏 <span id="more"></span> ## 邻接矩阵 该储存方式是由两个数组来表示图1，一个一维数组储存图中顶点信息，一个二维数组(即为邻接矩阵)储存图中的边或弧的信息 具体实例： <strong>无向图</strong> <img src="https://s2.loli.net/2022/05/02/jKxgNmBUbHko5ZX.png" alt="邻接矩阵-无向图.png"> 可以很容易看出无向图的边数组是一个对称矩阵。 有了该矩阵后，我们可以： 1. 判定任意两顶点是否有边无边 2. 确定某个顶点的度。就是该顶点的行(列)的元素之和。 3. 求某顶点的所有邻接点就是把矩阵该行元素全部扫描一遍，为一的就是邻接点 <strong>有向图</strong> <img src="https://s2.loli.net/2022/05/02/znGTpIKuiC6NfH8.png" alt="邻接矩阵-有向图.png"> 有向图讲究的入度和出度，入度对应列，出度对应行 <strong>带权值的有向图</strong> 就把有向图中为0的地方数组改为无穷，其余地方的值为该边上的权值即可 <strong>缺点</strong> 对于边数相对顶点较少的图，这种结构对储存空间造成极大浪费 ## 邻接表 顶点用一个一维数组储存，便于读取顶点信息，其次还要储存一个指向第一个邻接点的指针，便于查找该顶点的边信息 顶点所有邻接点构成一个线性表，用单链表储存，无向图称为顶点的边表，有向图称为顶点作为弧尾的出边表 具体实例如下： <strong>无向图</strong> <img src="https://s2.loli.net/2022/05/03/uTWl1rjJwQHo3AN.png" alt="邻接表-无向图.png"> 每个节点有data，firstedge两个域表示，data储存顶点信息，firstedge指针域，指向边表的第一个节点，边表节点由adjvex和next两个域组成，adjvex储存邻接点在顶点表的下标，next指向边表下一个节点的指针</p>
<p><strong>有向图</strong> 有向图的邻接表结构是类似的，但由于它有方向，我们以顶点为弧尾储存边表，很容易可以得到每个顶点的出度，如果要得到每个顶点的入度，可构建一个逆邻接表 示意图如下 <img src="https://s2.loli.net/2022/05/03/jcmVLbKYsDCf1yk.png" alt="邻接表-有向图.png"></p>
<p><strong>带权值的有向图</strong> 只需在边表节点定义中加一个weight的数据域，储存权值信息即可 <strong>缺点</strong> 对于有向图来说，邻接表不能同时了解入度出度问题 ## 十字链表 顶点表节点包括data，firstin，firstout，分别表示数据，入边表头指针，出边表头指针 边表节点结构包括tailvex，headvex，headlink，taillink，分别代表弧起点，弧终点，入边表指针域，指向终点相同的下一条边，出边表指针域，指向起点相同的下一条边，如果是网，还可以增加一个weight域来储存权值 示意图如下： <img src="https://s2.loli.net/2022/05/03/1QYCHpEr6waGAxh.png" alt="十字链表.png"></p>
<p><strong>优缺点</strong> 好处在于容易找到顶点的入出度，但其结构复杂点，但创建时间复杂度和邻接表相同，所以在有向图的应用中，它是一个非常好的模型</p>
<h2 id="邻接多重表">邻接多重表</h2>
<p>只需要在邻接表基础上，对边表节点进行一些改造，重新定义的边表结构如下：ivex，ilink，jvex，jlink，分别为边对应的两个顶点下标，指向依附ivex的下一条边，指向依附jvex的下一条边 <img src="https://s2.loli.net/2022/05/03/Y1nJSLVyEWPbI6t.png" alt="邻接多重表.png"></p>
<p><strong>与邻接表的区别</strong> 一条边在邻接表中要用两个节点表示，而在邻接多重表中只有一个节点，这样对边的操作更方便</p>
<h2 id="边集数组">边集数组</h2>
<p>有两个一维数组构成，一个储存顶点信息，一个储存边的信息，边数组数据元素由边起点下标begin，终点下标end，权值weight组成，它不适合对顶点操作，更适合对边的操作 <img src="https://s2.loli.net/2022/05/03/yOtG873msjzWafh.png" alt="边集数组.png"></p>
<h2 id="参考资料">参考资料</h2>
<p>程杰《大话数据结构》</p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法学习笔记</title>
    <url>/2022/01/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="贪心算法">贪心算法</h2>
<h3 id="简要理解">简要理解</h3>
<p>贪心算法是分阶段工作的，在每一个阶段，他都会选择工作它认为眼下所作决定最好的，它是不考虑将来结果的，他只在乎局部最优解，算法终止时，我们希望得到的局部最优的结构就是全局最优，如果是就说明算法是正确的，否则算法得到的是一个次最优解，如果不要求绝对最佳答案，有时可以用简单的贪心算法生成近似答案，它的好处是在处理较大数据，较复杂的问题时，一般时间复杂度与空间复杂度都比产生准确答案的复杂算法要快上很多倍得到一个几乎接近正确的答案。 <span id="more"></span></p>
<h3 id="经典示例">经典示例</h3>
<ul>
<li><strong>找零钱问题</strong>：为了使用货币找零钱，求找出零钱张数最少值，我们可以重复配发最大额货币，于是为了找一百七十五元，我们肯定先选一张一百的，再拿一张五十的，再拿一张二十，五块的，这里就用到了贪心算法每一步选取局部最优解的思想，而且在这个问题中，局部最优就是整体最优.</li>
<li><strong>求最快抵达路径</strong>：在北京的某个交通高峰期间，有些主要干道可能看起来是空空荡荡的，但你最好还是不要选择这条干道，因为交通可能会在你抵达是=时突然变得车水马龙。这就是贪心算法行不通的例子</li>
</ul>
<h3 id="经典应用">经典应用</h3>
<ol type="1">
<li><p><strong>作业调度问题</strong> 对于多个作业（假设每个作业需要批改时间不同），我们有多个老师参与批阅，假设每个老师批阅速度一致，我们该如何想办法让整体完成时间最快。 这里就可以用到贪心算法的思想，我们可以给第一个老师挑时间最短的。第二个挑第二短的，在这样依次下去，保证每个老师先拿到的作业都是目前它眼中最好批改的作业。 这样做，虽然不一定能使整体批阅时间达到最低，但是他决定使较为接近最低的答案。而且它的算法执行复杂度会比准确算法要低，如果数据很大，贪心算法的优势为变得越来越明显</p></li>
<li><p><strong>哈夫曼编码</strong></p>
<ul>
<li>哈夫曼编码是从底向顶的构造哈夫曼树，我们每次挑取两个权值最小的元素连接构成某节点的左右子树，然后把两个左右子树的权值相加，赋给连接这两颗子树的节点，再接着这么操作，就可以把一个字符串按权重大小编码且不影响读取，字符根节点往左为0，往右为1，那么出现频率最高的字符的位数一定是最小的，这样一来就可以减小空间成本</li>
<li>哈夫曼编码使用贪心算法的地方在于，他没有对整体数据进行分析，也是每次运行优先挑取两个权值最小的树，也就是局部最优解，这里就反映出了贪心算法的本质。</li>
<li>流程示例 <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F2018120514551994.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTk0NTU0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1646208341&amp;t=fe7ae4698acc0bcbf76d0734ca3ebdd9" alt="alt 哈夫曼树构建流程"></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2022/03/17/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h1 id="字典树">字典树</h1>
<h2 id="简介">简介</h2>
<p>字典树，又称单词查找树、前缀树，是一种树形结构，属于哈希树的变种，在统计、排序、保存大量字符串时具有很小的时间复杂度，常用于搜索引擎系统用于文本词频的统计，其优点在于利用字符串的公共前缀来减少查询时间，最大限度减少没有意义的字符串比较，查找效率比哈希树高。 <span id="more"></span> 比如我有"a","apple","appeal","bee","beef","cat"这七个单词，就能够组成下面图示的字典树，如果我们需要获得"apple"这个单词的信息，按顺序访问对应的结点即可 <img src="https://s2.loli.net/2022/03/26/pMQFd1OTDjorUu4.png" alt="字典树.png"> ### 字典树的性质 1. 根节点不包含字符，除根节点外每个结点有且仅有有一个字符 2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 3. 每个节点的所有子节点包含字符各不相同</p>
<h3 id="字典树的应用">字典树的应用</h3>
<ol type="1">
<li>字典：字符串集合对应一定的信息</li>
<li>计算热词：统计字符串在集合中出现的元素</li>
<li>串的快速检索：给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，按最早出现的顺序写出所有不在熟词表中的生词，我们可以把熟词建成字典树，然后读入文章进行比较</li>
<li>串排序：给出N个互不相同的仅由一个单词构成的英文名，让他们按字典序从小到大输出，采用数组的方式创建字典树，这棵树的每个节点的儿子很显然按照其字母大小排序，对这棵树进行先序遍历即可</li>
<li>最长公共前缀：对所有串建立字典树，对两个串的最长公共前缀长度就是他们所在节点的公共祖先个数 ## 具体实现 ### 顺序储存结构 #### 节点结构体定义 我们先开辟一个足够大的数组，这里我们使用静态链表的思想，用游标表示节点的后继，我们在结构体中开辟一个数组来描述节点的后继，这里可以确定其长度为26，然后再定义一个bool类型，判定是否为单词的结尾 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># define MAXSIZE 26</span><br><span class="line">struct node&#123;</span><br><span class="line">    bool flag;</span><br><span class="line">    int next[MAXSIZE];</span><br><span class="line">&#125;trie[100001]</span><br></pre></td></tr></table></figure> #### 插入操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Insert(char *str,int *space)</span><br><span class="line">&#123;</span><br><span class="line">    \*space表示第一个空闲节点的下标,str为插入的字符串，idx为挖掘层数，order将字符转化为在字母表中的顺序</span><br><span class="line">    *\</span><br><span class="line">    int order;</span><br><span class="line">    int idx; //从第一层开始向下挖掘</span><br><span class="line">    for(int i=0;i&lt;strlen(str);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(trie[idx].next[order] == 0)//idx没有该字符的子节点</span><br><span class="line">        &#123;</span><br><span class="line">            trie[idx].next[order] = space++;//启用第space号节点，copy新节点的编号</span><br><span class="line">            idx = trie[idx].next[order];//idx节点对应的后继为space</span><br><span class="line">            trie[idx].flag = false;//标记新节点不是单词的结尾</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">         idx = trie[idx].next[order];//前缀存在继续挖掘</span><br><span class="line">    &#125;</span><br><span class="line">    trie[idx].flag = true;//表示单词结尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 查询操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Find(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int order;</span><br><span class="line">    int idx=1;</span><br><span class="line">    for(int i=0;i&lt;strlen(str);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(trie[idx].next[order]==0)//若字母失配，匹配结束</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = trie[idx].next[order];//存在对应字母，匹配继续</span><br><span class="line">    &#125;</span><br><span class="line">    if (trie[idx].flag == false)//若成功匹配，但不为单词结尾</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 链式储存结构 #### 节点结构体定义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    Node *next[26];</span><br><span class="line">    bool flag;</span><br><span class="line">&#125;Node, *Trie;</span><br></pre></td></tr></table></figure> #### 插入操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void buildTrie(Trie root,char *word)</span><br><span class="line">&#123;</span><br><span class="line">    Trie pre = root;</span><br><span class="line">    Trie ptr;</span><br><span class="line">    int order;</span><br><span class="line">    for(int i=0;i&lt;strlen(word);++i)//字母序对应后继不存在</span><br><span class="line">    &#123;</span><br><span class="line">        order = word[i]-&#x27;a&#x27;;</span><br><span class="line">        if(pre-&gt;next[order] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = (Node *)malloc(sizeof(Node));//初始化新节点</span><br><span class="line">            for(int j=0;j&lt;26;++j)</span><br><span class="line">                ptr-&gt;next[j]==NULL;</span><br><span class="line">            ptr-&gt;fail = NULL;</span><br><span class="line">            ptr-&gt;flag = false;</span><br><span class="line">            pre-&gt;next[order] = ptr;//插入新节点</span><br><span class="line">        &#125;</span><br><span class="line">        pre = ptr-&gt;next[order];//用新节点作为下一次循环的根节点</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;flag = true;//修改flag表示为单词结尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 查询操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Find(char * str)</span><br><span class="line">&#123;</span><br><span class="line">    int order;</span><br><span class="line">    Trie pre= root</span><br><span class="line">    Trie ptr;</span><br><span class="line">    int length = strlen(str);</span><br><span class="line">    if(!length)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(pre-&gt;next[order] == NULL &amp;&amp; pre!=root)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next[order];</span><br><span class="line">    &#125;</span><br><span class="line">    if(pre-&gt;flag==false)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 例题详解 #### leetcode 720(词典中最长的单词) 题目描述如下： <img src="https://s2.loli.net/2022/03/17/tjBVbDG73lKdsMZ.png" alt="760.png"> ##### 思路和算法</li>
</ol>
<p>由于符合要求的单词的每个前缀都是符合要求的单词，因此可以使用字典树存储所有符合要求的单词。 创建字典树，遍历数组 words,并将每个单词插入字典树。当所有的单词都插入字典树之后，将答案初始化为空字符串，再次遍历数组 words，判断每个单词是否是符合要求的单词，并更新答案。如果一个单词是符合要求的单词，则比较当前单词与答案，如果当前单词的长度大于答案的长度，或者当前单词的长度等于答案的长度且当前单词的字典序小于答案的字典序，则将答案更新为当前单词。</p>
<h5 id="代码">代码</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAX_STR_LEN 32</span><br><span class="line"></span><br><span class="line">typedef struct Trie &#123;</span><br><span class="line">    struct Trie * children[26];</span><br><span class="line">    bool isEnd;</span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void initTrie(Trie * trie) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        trie-&gt;children[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    trie-&gt;isEnd = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insertTrie(Trie * trie, const char * word) &#123;</span><br><span class="line">    Trie * node = trie;</span><br><span class="line">    int len = strlen(word);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char ch = word[i];</span><br><span class="line">        int index = ch - &#x27;a&#x27;;</span><br><span class="line">        if (node-&gt;children[index] == NULL) &#123;</span><br><span class="line">            node-&gt;children[index] = (Trie *)malloc(sizeof(Trie));</span><br><span class="line">            initTrie(node-&gt;children[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEnd = true;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool searchTrie(const Trie * trie, const char * word) &#123;</span><br><span class="line">    Trie * node = trie;</span><br><span class="line">    int len = strlen(word);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char ch = word[i];</span><br><span class="line">        int index = ch - &#x27;a&#x27;;</span><br><span class="line">        if (node-&gt;children[index] == NULL || !node-&gt;children[index]-&gt;isEnd) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    return node != NULL &amp;&amp; node-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * longestWord(char ** words, int wordsSize)&#123;</span><br><span class="line">    Trie * trie = (Trie *)malloc(sizeof(Trie));</span><br><span class="line">    initTrie(trie);</span><br><span class="line">    for (int i = 0; i &lt; wordsSize; i++) &#123;</span><br><span class="line">        insertTrie(trie, words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    char * longest = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; wordsSize; i++) &#123;</span><br><span class="line">        if (searchTrie(trie, words[i])) &#123;</span><br><span class="line">            if (strlen(words[i]) &gt; strlen(longest) || (strlen(words[i]) == strlen(longest) &amp;&amp; strcmp(words[i], longest) &lt; 0)) &#123;</span><br><span class="line">                longest = words[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考资料： <a href="https://www.cnblogs.com/linfangnan/p/12655724.html">乌漆WhiteMoon：数据结构：字典树</a> <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">leetcode 730 词典中最长的单词</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第二章知识小结</title>
    <url>/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p><strong>本章与信号与系统知识有较多重复，仅记录部分重要的概念</strong></p>
<ol type="1">
<li><p>信号分类</p>
<table>
<thead>
<tr class="header">
<th>时间</th>
<th>连续</th>
<th>离散</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>连续</td>
<td>模拟</td>
<td>抽样</td>
</tr>
<tr class="even">
<td>离散</td>
<td>量化</td>
<td>数字</td>
</tr>
</tbody>
</table></li>
</ol>
<span id="more"></span>
<h2 id="离散时间信号-序列">离散时间信号-序列</h2>
<h3 id="常见序列">常见序列</h3>
<ol type="1">
<li><p>单位取样序列<span class="math display">\[\delta(n)=\begin{cases}
 1,n=0\\
 0,n\ne0
\end{cases},\delta(n-n_0)=\begin{cases}
 1,n=0\\
 0,n\ne0
\end{cases}\\
x(n)\delta(n)=x(0),x(n)\delta(n-n_0)=x(n_0),x(t)\delta(t)=x(0)\delta(t)\]</span></p></li>
<li><p>单位阶跃序列<span class="math display">\[u(n)=\begin{cases}
 1,n\ge0\\
 0,n&lt;0
\end{cases},\delta(n)=u(n)-u(n-1)\\
u(n)=\sum_{k=\infty}^n\delta(k)\quad u(n)=\sum_{k=0}^\infty\delta(n-k)\]</span></p></li>
<li><p>矩形序列<span class="math display">\[R_N(n)=\begin{cases}
 1,0\le n \le N-1\\
 0,others
\end{cases},R_N(n)=u(n)-u(n-N)\]</span></p></li>
<li><p>复指数序列和正弦序列<span class="math display">\[x(n)=e^{(\sigma+jw)n}=e^{\sigma n}cos(wn)+je^{\sigma n}sin(wn),w-数字域频率\\
比较：x_a(t)=Asin(\Omega t+\phi)=Asin(2\pi ft+\phi)\]</span>其中:<span class="math inline">\(\Omega=2\pi f\)</span>模拟域频率，<strong><span class="math inline">\(w=\Omega T(采样周期)\)</span></strong></p></li>
</ol>
<p>当<span class="math inline">\(w=0\)</span>时，<span class="math inline">\(cos(wn)\)</span>变化最慢，当<span class="math inline">\(w=\pi\)</span>时，<span class="math inline">\(cos(wn)\)</span>变化最快，在主值空间<span class="math inline">\([-\pi,pi]or[0,2\pi]\)</span>上，把<span class="math inline">\(w=0\)</span>附近称为数字低频，<span class="math inline">\(w=\pi\)</span>称为数字高频。<strong>这一特点与模拟正弦信号完全不同，后者<span class="math inline">\(\Omega\)</span>越大，变化越快，因为其连续取值</strong></p>
<h2 id="离散时间系统">离散时间系统</h2>
<h3 id="fir系统和iir系统">FIR系统和IIR系统</h3>
<p>FIR：有限冲激响应，IIR：无限冲激响应 <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-14-21-13-31.png"></p>
<h2 id="离散时间信号和系统的频域表示">离散时间信号和系统的频域表示</h2>
<h3 id="连续信号的ft">连续信号的FT</h3>
<p>重要性质1：当<span class="math inline">\(x(n)\)</span>为实序列时，<span class="math inline">\(X(e^{jw})\)</span>的幅值<span class="math inline">\(|X(e^{jw})|\)</span>在区间$0w<span class="math inline">\(内时偶对称函数，相位\)</span>arg[X(e^{jw})]$是奇对称函数</p>
<h3 id="离散时间信号的ft的性质">离散时间信号的FT的性质</h3>
<ol type="1">
<li><p>序列的FT的对称性</p>
<p><span class="math inline">\(x_e(n)=x_e^*(-n)\)</span> 共轭对称序列</p>
<p><span class="math inline">\(x_o(n)=-x_o^*(-n)\)</span> 共轭反对称序列</p>
<p><span class="math inline">\(x_e(e^{jw})=x_e^*(e^{-jw})\)</span> 共轭对称函数</p>
<p><span class="math inline">\(x_o(e^{jw})=-x_o^*(e^{-jw})\)</span> 共轭反对称函数</p>
<p>这表明<span class="math inline">\(x_o(n)\)</span>的实部和<span class="math inline">\(x_e(n)\)</span>的虚部为偶序列，<span class="math inline">\(x_o(n)\)</span>的虚部和<span class="math inline">\(x_e(n)\)</span>的实部为奇序列，进一步推导可以得到以下序列分解公式<span class="math display">\[x_e(n)=\frac{1}{2}[x(n)+x^*(-n)] \qquad x_o(n)=\frac{1}{2}[x(n)-x^*(-n)]\\x_e(e^{jw})=\frac{1}{2}[x(e^{jw})+x^*(e^{-jw})] \qquad x_o(e^{jw})=\frac{1}{2}[x(e^{jw})-x^*(e^{-jw})]\]</span></p>
<p>以及FT的共轭对称性<span class="math display">\[FT[x_r(n)]=X_e(e^{jw}),FT[jx_i(n)]=X_o(e^{jw})\\FT[x_e(n)]=X_R(e^{jw}),FT[x_o(n)]=jX_I(e^{jw})\]</span></p>
<p>当<span class="math inline">\(x(n)\)</span>为实序列时<span class="math display">\[若x(n)为实偶序列，则X(e^{jw})为实偶函数\\若x(n)为实奇序列，则X(e^{jw})为纯虚奇函数\]</span></p></li>
</ol>
<h2 id="连续时间信号的取样">连续时间信号的取样</h2>
<h3 id="取样信号的时域频域表示">取样信号的时域频域表示</h3>
<p>取样信号为<span class="math inline">\(\hat{x_a}(t)=x_a(t)p(t)=\sum_{n=-\infin}^\infin x_a(t)\delta(t-nT),p(t)=\sum_{n=-\infin}^\infin \delta(t-nT)\)</span>,其频谱则为<span class="math inline">\(\hat{X_a}(j\Omega)=FT[x_a(t)p(t)]=\frac{1}{2\pi}X_a(j\Omega)*P(j\Omega)=\frac{1}{T}\sum_{r=-\infin}^\infin X_a(j\Omega-jr\Omega_s),P(j\Omega)=\frac{2\pi}{T}\sum_{n=-\infin}^\infin\delta(j\Omega-jr\Omega_s)\)</span></p>
<p><strong>这表明取样信号的频谱就是模拟信号频谱的周期延拓，延拓周期的取样角频率为<span class="math inline">\(\Omega_s\)</span></strong></p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-14-21-56-22.png"></p>
<p><strong>若要不产生混叠，则要求<span class="math inline">\(\Omega_s\ge2\Omega_0,\Omega_s：奈奎斯特频率,\Omega_s/2\)</span>：折叠频率</strong></p>
<h3 id="频率归一化">频率归一化</h3>
<p>频率归一化讨论的是离散时间信号<span class="math inline">\(x(n)\)</span>的频谱<span class="math inline">\(X(e^{jw})\)</span>和取样信号<span class="math inline">\(\hat{x_a}(t)\)</span>的频谱<span class="math inline">\(\hat{X_a}(j\Omega)\)</span>之间的关系</p>
<p>取样信号的频谱为：<span class="math display">\[\hat{X_a}(j\Omega)=FT[\hat{x_a}(t)]=FT[x_a(t)p(t)]=FT[\sum_{n=-\infin}^\infin x_a(t)\delta(t-nT)]\\=\sum_{n=-\infin}^\infin x_a(nT)\cdot FT[\delta(t-nT)]=\sum_{n=-\infin}^\infin x_a(nT)e^{-j\Omega nT}\]</span></p>
<p>而离散时间信号的FT变换为： <span class="math display">\[X(e^{jw})|_{w=\Omega T}=\hat{X_a}(j\Omega)\]</span></p>
<p>比较可得出<span class="math display">\[X(e^{jw})|_{w=\Omega T}=\hat{X_a}(j\Omega)=\frac{1}{T}\sum_{r=-\infin}^\infin X_a(j\Omega-jr\Omega_s)\\=\frac{1}{T}\sum_{r=-\infin}^\infin X_a(j\frac{w}{T}-jr\frac{2\pi}{T})\]</span></p>
<p><strong>即在<span class="math inline">\(w=\Omega T\)</span>的条件下，离散时间信号的频谱与取样信号的相等，由于<span class="math inline">\(w=\Omega T=\frac{2\pi f}{f_s}(f_s为取样频率)\)</span>是<span class="math inline">\(f\)</span>对<span class="math inline">\(f_s\)</span>归一化的结果，因此可认为离散时间信号频谱是模拟信号频谱的周期延拓且在频率轴上进行归一化的结果</strong></p>
<h3 id="信号重建">信号重建</h3>
<p>如果取样信号频谱不存在混叠，让取样信号通过一理性低通滤波器，其特性为<span class="math inline">\(H(j\Omega)=\begin{cases}  T,|\Omega|\le\Omega_s/2\\  0,|\Omega|&gt;\Omega_s/2 \end{cases}\)</span>,其频谱特性为<span class="math inline">\(H(j\Omega)\hat{X_a}(j\Omega)=X_a(j\Omega),|\Omega\le\Omega_s/2|\)</span>,输出信号则为<span class="math display">\[x_a(t)=\frac{1}{2\pi}\int_{-\frac{\Omega_s}{2}}^{\frac{\Omega_s}{2}} X_a(j\Omega)e^{j\Omega t}\, {\rm d}\Omega=\sum_{n=-\infin}^\infin x(nT)\cdot S_a(t-nT)\\Sa(t-nT)=\frac{sin[\frac{\pi}{T}(t-NT)]}{\frac{\pi}{T}(t-nT)}为内插函数\]</span><strong>此处积分的详细步骤略过，结论：取样信号经过理想LPF后，完全可以把信号还原，而不损失任何信息，由于插值的唯一性，还原的信号也是唯一的</strong></p>
<h3 id="离散时间信号的取样">离散时间信号的取样</h3>
<p>其思路与连续时间信号取样类似</p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-12-53.png"></p>
<p>其可以看为一个信号调制的过程：<span class="math inline">\(x_p(n)=\sum_{n=-\infin}^\infin x(Nk)\delta(n-kN)\)</span>,频域表示为<span class="math inline">\(X_p(w)=\frac{1}{N}\sum_{n=0}^{N-1}X(w-kw_s),w_s\)</span>为取样频率，且<span class="math inline">\(w_s=\frac{2\pi}{N}\)</span> <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-16-29.png"></p>
<p><strong>为了不发生混叠，取样频率同样需满足<span class="math inline">\(w_s\ge2w_M\)</span></strong></p>
<p>若要恢复序列<span class="math inline">\(x(n)\)</span>，同样可以采用低通滤波器滤波恢复，其频率特性为<span class="math inline">\(H(w)=\begin{cases}  N,|w|\le w_s/2\\  0,|w|&gt; w_s/2 \end{cases}\)</span>,恢复的序列<span class="math inline">\(x_r(n)=\sum_{k=-\infin}^\infin x(kN)\frac{N}{\pi(n-kN)}sin[\frac{w_s}{2}(n-kN)]\)</span></p>
<h3 id="离散时间信号的取样和内插">离散时间信号的取样和内插</h3>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-25-46.png"> <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-26-29.png"> 1. 离散时间信号的抽取/减取样：<span class="math inline">\(x_d(n)=x(nN)=x_p(nN),FT(x_d(n))=X_d(w)=\sum_{n=-\infin}^\infin x_p(n)e^{-jwn/N}=X_p(w/N)=\sum_{n=-\infin}^\infin x_p(nN)e^{-jwn}\)</span></p>
<p><strong>取样序列和抽取序列的频谱只是频率尺度不同，注意，只有进行"过采样"，才允许进一步降低采样率，即进行“减采样”</strong></p>
<ol start="2" type="1">
<li>离散时间信号的内插/增采样：是抽取的逆过程，现在每相邻两个序列之间插入N-1个零值，再用低通滤波器得到内插后序列 <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-28-20.png"></li>
</ol>
<h2 id="全通系统和最小相位系统">全通系统和最小相位系统</h2>
<ol type="1">
<li>全通系统：全通系统是幅度响应<span class="math inline">\(|H(e^{jw})|\equiv C\)</span>（C为常数）的系统，系统函数:<span class="math inline">\(H_{ap}(z)=\frac{z^{-1}-a^*}{1-az^{-1}}\)</span>（一阶系统）,对于单位取样为实数的多阶系统，有<span class="math inline">\(H_{ap}(z)=A\prod^M_c\frac{z^{-1}-d_k}{1-d_kz^{-1}}\prod^M_r\frac{(z^{-1}-e_k^*)(z^{-1}-e_k)}{(1-e_kz^{-1})(1-e_k^*z^{-1})},|d_k|,|e_k|&lt;1\)</span>,<strong>全通系统的特点是每个极点<span class="math inline">\(z_p\)</span>都有一个与之配对的共轭倒数零点<span class="math inline">\(z_o=\frac{1}{z_p^*}\)</span>,且一阶全通滤波器的相位响应单调递减</strong></li>
<li>最小/大相位系统：系统函数<span class="math inline">\(H_{min}(z)\)</span>所有零极点都在单位圆内/外的系统，对于最小相位系统，存在一个稳定的因果逆系统<span class="math inline">\(H_{min}^{-1}(z)\)</span>,使得<span class="math inline">\(H_{min}(z)H_{min}^{-1}(z)=1\)</span></li>
<li>全通系统与最小相位系统级联：任何系统可表述为一个最小相位系统和一个全通系统级联,<span class="math inline">\(H(z)=H_min(z)H_{ap}(z)\)</span></li>
<li>相位延迟与群延迟：数字滤波器的相位延迟：<span class="math inline">\(T_p(w)=-\frac{\phi(w)}{w}\)</span>表示输入是频率为<span class="math inline">\(w\)</span>的单一正弦波的延迟时间，群延迟则定义为<span class="math inline">\(T_g(w)=-\frac{d\phi(w)}{dw}\)</span>表示某一频率<span class="math inline">\(w\)</span>邻域内的延迟性质</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模笔记</title>
    <url>/2022/12/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数学建模笔记姜启源">数学建模笔记（姜启源）</h1>
<h2 id="线性规划">线性规划</h2>
<ol type="1">
<li>定义： 在一组线性条件限制下，求一线性目标函数最大或最小的问题</li>
<li>标准的matlab形式：<span class="math inline">\(min f^T x,\)</span> <span class="math inline">\(s.t. \begin{cases} A\cdot x \le b\\ Aeq \cdot x = beq \\ lb \le x \le ub \end{cases}\)</span> 其中<span class="math inline">\(f,x,b,beq,lb,u\)</span>为列向量，<span class="math inline">\(A，Aeq\)</span>为矩阵</li>
<li>matlab相关求解命令为 <span class="math inline">\([x,val]=linprog(f,A,b,Aeq,beq,lb,ub)\)</span></li>
</ol>
<span id="more"></span>
<h2 id="整数规划">整数规划</h2>
<ol type="1">
<li>定义： 数学规划中的变量（部分或全部）限制为整数时，称为整数规划</li>
<li>分类： 根据变量整数是部分还是全部可分为纯整数规划和混合整数规划</li>
<li>求解方法：
<ol type="1">
<li>分支定界法（纯或混）</li>
<li>割平面法（纯或混）</li>
<li>隐枚举法（01规划）
<ul>
<li>过滤隐枚举法</li>
<li>分支隐枚举法</li>
</ul></li>
<li>匈牙利法（指派问题）</li>
<li>蒙特卡洛法（各种类型）</li>
</ol></li>
</ol>
<h3 id="型整数规划">0-1型整数规划</h3>
<ol type="1">
<li>定义：整数规划的一种特殊情况，变量仅取值0或1 应用范围可分为以下几种情况</li>
</ol>
<h4 id="相互排斥的约束条件">相互排斥的约束条件</h4>
<p>也就是说题目中的某一种条件只有一个量，如果给了这个1，同类的都为0，较为典型的问题有运输问题，只用一种方式运输，用火车运了，其他的运输栏都为0，其约束条件可进一步简化为 <span class="math inline">\(y_i=\begin{cases} 1,第i个元素起约束作用\\ 0,第i个元素不起作用，i=1,2.....,m\\ \end{cases}\)</span> $a_{i1}x_1+...a_{in}x_nb_i+(1-y_i)M,i=1,2...,m,\ y_1++y_m=1 $ 由约束条件很容易看出，当<span class="math inline">\(y_i\)</span>等于1,就只有这个约束起作用，其他的都是多余的</p>
<h4 id="固定费用的问题">固定费用的问题</h4>
<p>在讨论线性规划时，有些问题要求固定费用，这种问题可以通过改变为混合整数规划来解决，数学模型可表示为 <span class="math inline">\(y_i\epsilon\le x_i\le y_i M\)</span> 其中<span class="math inline">\(\epsilon\)</span>为充分小的正常数；M为充分大的正常数，表明<span class="math inline">\(x_i&gt;0\)</span>时，<span class="math inline">\(y_i\)</span>必须为1，<span class="math inline">\(x_i=0\)</span>时<span class="math inline">\(y_i\)</span>必须为0 <span class="math inline">\(【x_i】\)</span>表示采用i方式生产时产量，<span class="math inline">\(y_i\)</span>表示是否用第i种方式生产</p>
<h4 id="指派问题">指派问题</h4>
<p>指派问题描述的是分配n个人去做n件事情，每个人做且仅做一件事情，且分配第i个人去做第j件事情，花费<span class="math inline">\(C_{ij}\)</span>单位时间，求如何分配使总时间最小，这类问题的关键就是要求出分配矩阵，数学形式可表现为 <span class="math inline">\(x_{ij}=\begin{cases} 1,第i人做第j项工作\\ 0,第i人做第j项工作\\ \end{cases}\)</span> 数学模型为：<span class="math inline">\(min \sum_{i=1}^N \sum_{j=1}^N c_{ij}x_{ij}\)</span> <span class="math inline">\(s.t. \begin{cases}  \sum_{i=1}^N x_{ij}=1,i=1,2,...,n\\  \sum_{j=1}^N x_{ij}=1,j=1,2,...,n\\  x_{ij}=0 or 1,i,j=1,...,n  \end{cases}\)</span></p>
<h3 id="蒙特卡洛法随机取样法">蒙特卡洛法（随机取样法）</h3>
<ol type="1">
<li>又被称为计算机随机模拟法，它是基于对大量数据的统计结果来实现一些确定性问题的计算</li>
<li>使用该方法必须使用计算机生成相关分布的随机数</li>
</ol>
<h3 id="整数线性规划的计算机求解">整数线性规划的计算机求解</h3>
<ol type="1">
<li>整数规划的求解用Lingo等专用软件比较方便，对于整数线性规划也可以用matlab的intlinprog函数求解，<strong>但其的缺点是必须把所有的决策变量化为一维决策变量，变量替换后，约束条件很难写出</strong>，最好用lingo</li>
<li>matlab求解混合整数线性规划的命令是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【x,fval】=intlinprog(f,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> 对应以下数学模型 <span class="math inline">\(min_x f^Tx,\)</span> <span class="math inline">\(s.t. \begin{cases} x(intcon)为整数\\ A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb \le x \le ub \\ \end{cases}\)</span> 式中：<span class="math inline">\(f,x,intcon,b,beq,lb,ub为列向量；A，Aeq为矩阵\)</span></li>
</ol>
<h2 id="非线性规划">非线性规划</h2>
<h3 id="非线性规划模型">非线性规划模型</h3>
<ol type="1">
<li>定义：如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题</li>
<li>通过投资决策问题归纳非线性规划数学模型的一般形式 总资金A元，投资第i个项目花<span class="math inline">\(a_i\)</span>元，预计可收益<span class="math inline">\(b_i\)</span>元 选择最佳投资方案 投资决策变量 <span class="math inline">\(x_i=\begin{cases} 1,决定投资第i个项目\\ 0,决定不投资第i个项目\\ \end{cases}\)</span> 则该模型可用下列数学模型表示 <span class="math inline">\(max\, Q = \frac{\sum_{i=1}^n b_i x_i} {\sum_{i=1}^n a_i x_i} s.t. \begin{cases} 0 &lt; \sum_{i=1}^n a_i x_i \le A ,\\ x_i(1-x_i)=0,i=1,...,n\\ \end{cases}\)</span></li>
<li>根据2中例题，非线性规划问题可进一步概括为： <span class="math inline">\(min\,f(x)\\ s.t. \begin{cases} h_j(x)\le0,j=1,2,...,q\\ g_i(x)=0,i=1,2,...,p\\ \end{cases}\)</span> 其中<span class="math inline">\(x=[x_1,...,x_n]^T\)</span>为模型的决策变量，<span class="math inline">\(f\)</span>为目标函数，<span class="math inline">\(g_i和h_j\)</span>为约束函数，<span class="math inline">\(g_i(x)=0\)</span>为等式约束，<span class="math inline">\(h_j(x)\le0\)</span>为不等式约束</li>
<li>对一个实际问题，要将其规为非线性规划问题时，一般要注意以下几点
<ol type="1">
<li>确定供选方案</li>
<li>提出追求目标</li>
<li>给出价值标准</li>
<li>寻求限制条件</li>
</ol></li>
<li>线性规划与非线性规划的区别：线性规划最优解只能在可行域的边界上达到（特别是顶点），而非线性规划最优解可在可行域任一点达到</li>
<li>非线性规划的matlab表示 <span class="math inline">\(minf(x)\\ s.t. \begin{cases} A\cdot x \le b,\\ Aeq \cdot x=beq,\\ c(x)\le0\\ ceq(x)=0,\\ lb\le x \le ub \end{cases}\)</span> 式中的<span class="math inline">\(f(x)\)</span>为标量函数，<span class="math inline">\(A,b,Aeq,beq,lb,ub\)</span>为相应维数的矩阵和向量，<span class="math inline">\(c(x),ceq(x)\)</span>为非线性向量函数 matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br><span class="line"># x返回决策变量x的取值，fval返回目标函数取值，fun是M文件自定义函数f(x),x0是x的初始值</span><br><span class="line">nonlcon是用M文件定义的c(x)ceq(x)，options定义优化参数</span><br></pre></td></tr></table></figure> ### 无约束问题的Matlab解法</li>
<li>在matlab工具箱中，用于求无约束极小值的函数有fminunc和fminsearch，用法分别为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminunc(fun,x0,options)</span><br><span class="line">[x,fval]=fminsearch(fun,x0,options) #只能求初始值附近的一个极小值点</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="约束极值问题">约束极值问题</h3>
<ol type="1">
<li>定义：带有约束条件的极值问题，也叫规划问题</li>
</ol>
<h4 id="二次规划">二次规划</h4>
<ol type="1">
<li>定义：若某非线性规划的目标函数为自变量x的二次函数，约束条件又全为线性的，称这种规划为二次规划</li>
<li>Matlab中二次规划的数学模型可表述为 $min, x<sup>THx+f</sup>Tx,\ s.t.
<span class="math display">\[\begin{cases}
Ax\le b\\
Aeq \cdot x=beq,\\
lb\le x\le ub
\end{cases}\]</span>
H为实对称矩阵，\ $ matlab求解二次规划的命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="罚函数法">罚函数法</h4>
<ol type="1">
<li>利用罚函数法可以将非线性规划问题的求解转化为求一系列无约束极值的问题，也把这种方法叫做序列无约束最小化技术</li>
<li>罚函数求解非线性规划问题的思想是利用问题中的约束函数作出适当的罚函数，由此构造出带参数的增广目标函数，把问题转换为无约束非线性规划问题，主要有两种形式，一种叫外罚函数法，另一种叫内罚函数法</li>
<li>外罚函数法： 考虑问题：<span class="math inline">\(minf(x)\\ s.t.\begin{cases} g_i(x) \le 0,i=1,...,r\\ h_j(x) \ge 0,j=1,...,s\\ k_m(x) =0,m=1,...,t \end{cases}\)</span>取一个充分大的数M&gt;0,构造函数<span class="math inline">\(P(x,M)=f(x)+M\sum_{i=1}^nmax(g_i(x),0)-M\sum_{j=1}^nmin(h_j(x),0)+M\sum_{m=1}^n |k_m(x)|\)</span>,则以增广目标函数<span class="math inline">\(P(x,M)\)</span>为目标函数的无约束极值问题<span class="math inline">\(minP(x,M)\)</span>的最优解也是原问题的最优解</li>
<li><ol type="1">
<li>如果非线性规划问题要求实时算法，可以使用罚函数算法，但计算精度较低</li>
<li>如果不要求实时算法，要求高精度,可以使用lingo或matlab的fmincon命令求解</li>
</ol></li>
</ol>
<h4 id="matlab求约束极值问题">matlab求约束极值问题</h4>
<ol type="1">
<li>在matlab工具箱中，用于求解约束最优化问题的函数有fminbnd,fmincon,quadprog,fseminf,fminimax函数</li>
<li>fminbnd函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminbnd(fun,x1,x2,options) </span><br><span class="line"># 用于求单变量非线性函数在[x1,x2]上极小值</span><br><span class="line"># 返回极小点x和函数的极小值</span><br></pre></td></tr></table></figure></li>
<li>fseminf函数 用于求下列模型 <span class="math inline">\(minf(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)\le0\\ K_i(x,w_i)\le0,1\le i\le n \end{cases}其中c(x),ceq(x)为向量函数，K_i(x,w_i)为标量函数,w_1...为附加变量\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fseminf(fun,x0,ntheta,seminfcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> fun定义目标函数f(x),x0为x初始值，ntheta是半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>个数，函数seminfcon用于定义非线性不等式约束<span class="math inline">\(c(x)\)</span>,非线性等式约束<span class="math inline">\(ceq(x)\)</span>和半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>的函数，seminfcon有两个输入参量x,s,s是推荐的采样步长 可以不使用</li>
<li>fminimax函数 用于求下列模型 <span class="math inline">\(min_xmax_iF_i(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)=0\\ \end{cases}\)</span> matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminimax(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>次优查找树</title>
    <url>/2022/05/03/%E6%AC%A1%E4%BC%98%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="次优查找树">次优查找树</h1>
<h2 id="前言">前言</h2>
<p>关于静态查找表中对特定关键字进行顺序查找，折半查找或者分块查找，都是在查找表中各关键词被查找概率相同的前提下进行的，然而在查找表中各关键字查找概率不同的情况下，折半查找的效果其实是不好的。在查找成功的情况下，描述查找过程的判定树其带权路径长度之和（用PH表示）最小时，查找性能最优，称该二叉树为静态最优查找树 其中: PH = 所有节点所在的层次数*每个节点对应的概率值 由于构造最优查找树花费的时间代价较高，而且有一种构造方式创建的判定树的查找性能同最优查找树只差1%-2%，称这种极度接近于最优查找树的二叉树为次优查找树</p>
<span id="more"></span>
<h2 id="创建方法">创建方法</h2>
<p>首先取出标准每个关键字及其对应的权值，采用如下公式计算出每个关键字对应的一个值： <span class="math inline">\(\triangle P_i= \left|\sum\limits_{j=i+1}^hw_j-\sum\limits_{j=1}^{i-1}w_j\right|\)</span> 其中 wj 表示每个关键字的权值（被查找到的概率），h 表示关键字的个数。 表中有多少关键字，就会有多少个 △Pi ，取其中最小的做为次优查找树的根结点，然后将表中关键字从第 i 个关键字的位置分成两部分，分别作为该根结点的左子树和右子树。同理，左子树和右子树也这么处理，直到最后构成次优查找树完成。 ## 代码实现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int KeyType;　　// 定义关键字类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;　　// 定义元素类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">// 定义变量</span><br><span class="line">int i;</span><br><span class="line">int min;</span><br><span class="line">int dw;</span><br><span class="line"></span><br><span class="line">//创建次优查找树，R数组为查找表，sw数组为存储的各关键字的概率（权值），low和high表示的sw数组中的权值的范围</span><br><span class="line">void SecondOptimal(BiTree T, ElemType R[], float sw[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    // 由有序表R[low...high]及其累计权值表sw（其中sw[0]==0）递归构造次优查找树</span><br><span class="line">    i = low;</span><br><span class="line">    min = abs(sw[high] - sw[low]);</span><br><span class="line">    dw = sw[high] + sw[low - 1];</span><br><span class="line">    // 选择最小的△Pi值</span><br><span class="line">    for (int j = low+1; j &lt;=high; j++)</span><br><span class="line">　　&#123;</span><br><span class="line">        if (abs(dw - sw[j] - sw[j-1]) &lt; min)</span><br><span class="line">　　　　 &#123;</span><br><span class="line">            i = j;</span><br><span class="line">            min = abs(dw - sw[j] - sw[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    T = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">    T-&gt;data = R[i];　　// 生成结点（第一次生成根）</span><br><span class="line">    if (i == low) </span><br><span class="line">　　 　　T-&gt;lchild = NULL;　　// 左子树空</span><br><span class="line">    else SecondOptimal(T-&gt;lchild, R, sw, low, i - 1);　　// 构造左子树</span><br><span class="line">    if (i == high) </span><br><span class="line">　　 　　T-&gt;rchild = NULL;　　//右子树空</span><br><span class="line">    else </span><br><span class="line">　　　　SecondOptimal(T-&gt;rchild, R, sw, i + 1, high);　　//构造右子树   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 具体实例 <img src="https://s2.loli.net/2022/05/03/PduZa8y5MegBIEp.png" alt="次优生成树.png"> <strong>注意</strong> 在建立次优查找树时，由于只根据各关键字的P的值进行构建，没有考虑单个关键字的相应权值大小，有时会出现根节点权值比孩子节点权值还小，这时需要适当调整二者位置</p>
<h2 id="总结">总结</h2>
<p>由于使用次优查找树和最优查找树的性能差距很小，构造次优查找树的算法的时间复杂度为 O(nlogn)，因此可以使用次优查找树表示概率不等的查找表对应的静态查找表（又称为静态树表）。 ## 参考资料 <a href="https://www.cnblogs.com/lishanlei/p/10707664.html">如是说的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2022/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>首先堆又被称为完全二叉堆，因为它是一种逻辑上基于完全二叉树，物理上基于线性数据结构(如数组，链表等)的数据结构，堆根据其有序性可以被分为两种：大根堆(最大堆)-大根堆在逻辑上二叉树结构中满足根节点&gt;子节点，小根堆(最小堆)-小根堆在逻辑上二叉树结构满足根节点&lt;子节点</p>
<span id="more"></span>
<h1 id="常见应用">常见应用</h1>
<ol type="1">
<li>利用堆的性质找出一个序列中最大最小的元素</li>
<li>堆排序</li>
<li>建立优先级队列，快速获取队列中优先级最高</li>
<li>在n个元素中排出前k大元素的问题，可以建立一个小根堆，依次读入n个元素并调整，当堆的规模达到k+1时，剔除第一个元素，剩下k个较大元素，保持堆的规模不超过k，然后一直循环</li>
</ol>
<h1 id="具体操作">具体操作</h1>
<p>下面介绍的操作以大根堆为例</p>
<h2 id="堆的插入">堆的插入</h2>
<p>每次插入都先将新数据放在数组最后，由于从这个新数据的父节点到根节点必然为一个有序的序列，在插入后，我们需要从下而上依次比较使堆整体有序，比如我们有这样一个堆数组[10,7,2,5,1]，下面我们往这个堆插入16，具体流程图如下 <img src="https://s2.loli.net/2022/04/10/p2vDjPuXJs3iS6M.png" alt="堆示意图.png"></p>
<h2 id="堆的删除">堆的删除</h2>
<p>堆中删除需要把最后一个数据的值赋给根节点，然后再从根节点开始开始从上而下的调整，再从根节点开始进行一次从上向下调整，不断将根节点与其子节点比较调整直到堆恢复有序，下面，我们还是以堆数组[10,7,2,5,1]为例，下面我们删除10，具体流程图如下 <img src="https://s2.loli.net/2022/04/10/AkqT9yxutWCc2LM.png" alt="堆示意图2.png"></p>
<h1 id="堆的实现代码">堆的实现代码</h1>
<p>由于最近在学python，所以使用python代码实现，其他版本请百度,同时，因为最大堆和最小堆实现方式类似，下面我们只给出最大堆代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Array(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Achieve an Array by Python list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, size = 32):</span><br><span class="line">        self._size = size</span><br><span class="line">        self._items = [None] * size</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get items</span><br><span class="line">        :param index: get a value by index</span><br><span class="line">        :return: value</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._items[index]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, index, value):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        set item</span><br><span class="line">        :param index: giving a index you want to teset</span><br><span class="line">        :param value: the value you want to set</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._items[index] = value</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :return: the length of array</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._size</span><br><span class="line"></span><br><span class="line">    def clear(self, value=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        clear the Array</span><br><span class="line">        :param value: set all value to None</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for i in range(self._size):</span><br><span class="line">            self._items[i] = value</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        for item in self._items:</span><br><span class="line">            yield item</span><br><span class="line">          </span><br><span class="line">class MaxHeap(object):</span><br><span class="line">    def __init__(self, maxsize=None):</span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self._elements = Array(maxsize)</span><br><span class="line">        self._count = 0</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return self._count</span><br><span class="line"></span><br><span class="line">    def add(self, value):</span><br><span class="line">        if self._count &gt;= self.maxsize:</span><br><span class="line">            raise Exception(&#x27;full&#x27;)</span><br><span class="line">        self._elements[self._count] = value</span><br><span class="line">        self._count += 1</span><br><span class="line">        self._siftup(self._count-1)  # 维持堆的特性</span><br><span class="line"></span><br><span class="line">    def _siftup(self, ndx):</span><br><span class="line">        if ndx &gt; 0:</span><br><span class="line">            parent = int((ndx-1)/2)</span><br><span class="line">            if self._elements[ndx] &gt; self._elements[parent]:    # 如果插入的值大于 parent，一直交换</span><br><span class="line">                self._elements[ndx], self._elements[parent] = self._elements[parent], self._elements[ndx]</span><br><span class="line">                self._siftup(parent)    # 递归</span><br><span class="line"></span><br><span class="line">    def extract(self):</span><br><span class="line">        if self._count &lt;= 0:</span><br><span class="line">            raise Exception(&#x27;empty&#x27;)</span><br><span class="line">        value = self._elements[0]    # 保存 root 值</span><br><span class="line">        self._count -= 1</span><br><span class="line">        self._elements[0] = self._elements[self._count]    # 最右下的节点放到root后siftDown</span><br><span class="line">        self._siftdown(0)    # 维持堆特性</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def _siftdown(self, ndx):</span><br><span class="line">        left = 2 * ndx + 1</span><br><span class="line">        right = 2 * ndx + 2</span><br><span class="line">        # determine which node contains the larger value</span><br><span class="line">        largest = ndx</span><br><span class="line">        if (left &lt; self._count and     # 有左孩子</span><br><span class="line">                self._elements[left] &gt;= self._elements[largest] and</span><br><span class="line">                self._elements[left] &gt;= self._elements[right]):  # 原书这个地方没写实际上找的未必是largest</span><br><span class="line">            largest = left</span><br><span class="line">        elif right &lt; self._count and self._elements[right] &gt;= self._elements[largest]:</span><br><span class="line">            largest = right</span><br><span class="line">        if largest != ndx:</span><br><span class="line">            self._elements[ndx], self._elements[largest] = self._elements[largest], self._elements[ndx]</span><br><span class="line">            self._siftdown(largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_maxheap():</span><br><span class="line">    import random</span><br><span class="line">    n = 5</span><br><span class="line">    h = MaxHeap(n)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        h.add(i)</span><br><span class="line">    for i in reversed(range(n)):</span><br><span class="line">        assert i == h.extract()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="python中heapq模板">Python中heapq模板</h1>
<p>Python中创建一个堆可以直接使用list的创建方式H = [], 或者使用heapify()函数将一个存在的列表转为堆。</p>
<p>这个模块提供了下面几种堆的操作： heapq.heappush(heap, item) 往堆中插入一个值，同时要保持为最小堆。</p>
<p>heapq.heappop(heap) 返回堆中的最小值，并把它从堆中删除，同时保持为最小堆；如果堆为空，发生 IndexError。直接通过heap[0]可以获取最小值并不从堆中把它删除。</p>
<p>heapq.heappushpop(heap, item) 向堆中插入值后再弹出堆中的最小值，这个函数的速度比直接使用heappush() 和heappop()的效率更加高。</p>
<p>heapq.heapreplace(heap, item) 弹出和返回堆中的最小值再插入一个新的值。堆的大小没有改变。如果堆为空，产生 IndexError。 这一个操作也比直接使用heappush() 和heappop()的效率更加高，尤其适合使用在固定堆大小不变的情况。 与上一个函数相比，这个函数返回的值可能要比将要插入到堆的值大。</p>
<p>heapq.heapify(x) 将一个list转为最小堆，线性时间复杂度，O(n).</p>
<h1 id="重要应用-堆排序">重要应用-堆排序</h1>
<h2 id="简述-1">简述</h2>
<p>堆排序主要分为两个步骤</p>
<ol type="1">
<li>建堆
<ul>
<li>升序：建大堆</li>
<li>降序：建小堆</li>
</ul></li>
<li>利用堆删除的思想来排序，建堆和堆删除中都用到了向下调整，所以关键是要掌握向下调整 下面以升序为例简述下堆排序的流程：</li>
</ol>
<ul>
<li>首先应该建一个大堆，不能直接使用堆来实现，可以将需要排序的数组看作是一个堆，但需要把数组结构变为堆</li>
<li>从堆倒数第二行最右边开始依次往下调整直到调整到堆顶，这样就可以把数组调整成一个堆</li>
<li>然后按照堆删的思想将堆顶域堆底的数据交换，不同的是这里不删除最后一个元素</li>
<li>这样一来最大元素就在最后一个位置，然后从堆顶向下调整到倒数第二个元素，这样次大元素在堆顶，重复到只剩堆顶为止 流程图如下： <img src="https://s2.loli.net/2022/05/18/EewJOgZ5jr32a7p.gif" alt="堆排序示例.gif"></li>
</ul>
<h2 id="实现代码">实现代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 堆排序</span><br><span class="line">void AdjustDown(int* a, int n, int root)//向下调整</span><br><span class="line">&#123;</span><br><span class="line">	assert(a);</span><br><span class="line">	int parent = root;</span><br><span class="line">	int child = parent * 2 + 1;</span><br><span class="line">	while (child &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child])</span><br><span class="line">		&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[child] &gt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			Swap(&amp;a[child], &amp;a[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * 2 + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void HeapSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	assert(a);</span><br><span class="line"> </span><br><span class="line">    //建堆</span><br><span class="line">	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		AdjustDown(a, n, i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //交换</span><br><span class="line">	for (int i = n - 1; i &gt; 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		Swap(&amp;a[i], &amp;a[0]);</span><br><span class="line">		AdjustDown(a, i, 0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体应用">具体应用</h2>
<p>给定数组{33,44,21,8,19,123,46,78,11}如何求解其第一趟堆排序后的结果？ <img src="https://s2.loli.net/2022/05/18/Fad4QHSLjnrvOUE.png" alt="堆排序.png"></p>
<h2 id="总结">总结</h2>
<p>从上面的例子，我们可以看出，其实堆排序就是在树形结构下对父子节点不断进行交换，选出最大的放在堆顶，然后将对堆顶元素与堆底倒数第x个元素交换(x为当前循环趟数)，这样就起到了一趟选出一个剩余数组中最大值并放于剩余数组末尾的目的。它的特点是，一趟排序就能确定一个元素的最终位置，因为用了二叉树结构进行辅助排序，其时间复杂度显然为O(logn)</p>
<h1 id="leetcode例题">leetcode例题</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-product-after-k-increments/">6039-K次增加后的最大乘积</a></p>
<p>参考资料： <a href="https://blog.csdn.net/xiaomucgwlmx/article/details/103522410">OH,CGWLMXUP的博客</a> <a href="https://blog.csdn.net/qq_23869697/article/details/82735088">西檬饭的博客</a> <a href="https://blog.csdn.net/Edward_Asia/article/details/121419975">风继续吹TT的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树(Prim算法，Kruskcal算法)</title>
    <url>/2022/05/11/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最小生成树由一个经典的架电线的问题引出：在n个村庄间架电线，现在已经知道各村庄的相对距离，如果你是工程师，请问如何设计能使得总造价最小</p>
<h2 id="解决思路">解决思路</h2>
<p>首先可以分析得到这显然是一个带权值的图，即网结构，我们的目标可以抽象为用n-1条边把一个连通图连接起来，并使得权值最小，这就是我们常说的最小生成树问题，最经典的两种算法是：prim算法和kruskcal算法，下文将一一介绍 <img src="https://s2.loli.net/2022/05/12/9SoUqmLdXEpjTGz.png" alt="最小生成树.png"></p>
<span id="more"></span>
<h2 id="prim算法">prim算法</h2>
<h3 id="算法思路">算法思路</h3>
<p><strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，因为这里涉及到顶点与顶点的带权值边信息，所以我们考虑使用邻接矩阵作为储存结构来实现，如果不清楚邻接矩阵，请戳<a href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> <img src="https://s2.loli.net/2022/05/12/4B8ck6RtxqHmw9u.png" alt="最小生成树-邻接矩阵.png"> 这样一来，我们已经有了一个以邻接矩阵为存储结构的网，我们下面该如何求最小生成树呢?其实很简单，我们在prim算法的开头就说过，<strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，我们就先去一个顶点来研究，默认为v0，然后把v0在邻接矩阵中所对应的那一行信息取出(用一个lowcost数组保存)，目的是研究以v0为起点，与其相连最近的顶点。然后我们遍历一遍lowcost数组，找到其数组中除了本节点(即v0-0)外的最小值，记录下它的值与下标-<em>此时的low cost数组中lowcost[0]=0,表示该位置对应节点已加入最小生成树</em>，连接该下标所对应的顶点与v0，构成第一条电线，在这里对应的是v1，在找到v1后，我们把lowcost该位置的值设为0，表示该节点已经被纳入了最小生成树，然后我们再去取出v1在邻接矩阵中对应行的信息，将其与lowcost数组的对应值相比较，若更小则修改lowcost值，<strong>该操作的目的是找到v0,v1这两行连接信息中的最小值来形成第二根电线</strong>，接下来的操作也和上面的操作类似了，直到所有节点都添加到最小生成树中，lowcost数组全部置为0，表明最小生成树生成完毕。</p>
<h3 id="实现代码">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Prim算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree_Prim(MGraph G)&#123;</span><br><span class="line">	int min, i, j, k;</span><br><span class="line">	int adjvex[MAXVEX];	//保存相关顶点下标</span><br><span class="line">	int lowcost[MAXVEX];	//保存相关顶点间边的权值</span><br><span class="line">	lowcast[0] = 0;	//初始化第一个权值为0，即v0加入生成树，lowcost的值为0，在这里就是此下标的顶点已经加入生成树</span><br><span class="line">	adjvex[0] = 0;	//初始化第一个顶点下标为0</span><br><span class="line">	for(i = 1;i&lt;G.numVertexes;i++)&#123;	//循环除下标为0外的全部顶点</span><br><span class="line">		lowcost[i] = G.arc[0][i];		//将v0顶点与之有边的权值存入数组</span><br><span class="line">		adjvex[i] = 0;	//初始化都为v0的下标</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=1;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">		min = INFINITY;	//初始化最小权值为无穷大，通常设置为很大的数字</span><br><span class="line">		j = 1;</span><br><span class="line">		k = 0;</span><br><span class="line">		while(j&lt;G.numVertexes)&#123;		//循环全部顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min)&#123;	//如果权值不为0且权值小于min</span><br><span class="line">				min = lowcost[j];		//让当前权值成为最小值</span><br><span class="line">				k = j;		//将当前最小值的下标存入k</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;(%d,%d)&quot;,adjvex[k],k);	//打印当前顶点边中权值最小边</span><br><span class="line">		lowcost[k] = 0;	//将当前顶点的权值设置为0，表示此顶点已经完成任务</span><br><span class="line">		for(j=1;j&lt;G.numVertexes;j++)&#123;	//循环所有顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;	//若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值</span><br><span class="line">				lowcost[j] = G.arc[k][j];		//将较小权值存入lowcost</span><br><span class="line">				adjvex[j] = k;	//将下标为k的顶点存入adjvex</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由算法代码中的循环嵌套可知该算法时间复杂度为O(<span class="math inline">\(n^2\)</span>)</p>
<h2 id="kruskal算法">Kruskal算法</h2>
<h3 id="算法思路-1">算法思路</h3>
<p>与prim算法不同的是，prim算法以顶点为目标构造最小生成树，而Kruskal算法直接以边的目标去构造，每次找最小权值的边来构成最小生成树，但是，<strong>因为我们在构建时是以边为目标，必须要考虑边的闭环问题,因为可能出现要铺设九个村庄的电线，但在三个村庄间就出现了闭环，导致存在环与环之间无法互联的现象，这个问题出现的原因是因为我们如果只研究边的权值大小，会忽略顶点与顶点互联的要求</strong>，因为是对边的权值大小直接进行研究，这里我们最好使用边集数组作为存储结构，不会请戳<a href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> 这里我们需要先将边集数组按照权值从小到大进行下转换。 <img src="https://s2.loli.net/2022/05/12/n4ofahW37AziSxJ.png" alt="最小生成树-边集数组.png"> 我们对边集数组做循环遍历，每当你要添加一个边时，必须先调用一个find函数来判断该边对应的起点和终点在当前的最小生成树数组中是否会构成闭环，如果会，则舍弃接着往后，不会则添加，这个find函数借助了一个parent数组，我们将其初始化为0，每当添加一条边，就将对应起点的parent数组值修改为该边的终点，然后find函数判断连线顶点的尾部下标，如果和原来尾部对应下标经find函数处理返回值一致，说明形成了环，舍弃该边</p>
<h3 id="实现代码-1">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* kruskal算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree(MGraph G)&#123;	//生成最小生成树</span><br><span class="line">	int i, n, m;</span><br><span class="line">	Edge edges[MAXEDGE];	//定义边集数组</span><br><span class="line">	int parent[MAXVEX];	//定义一数组用来判断边与边是否形成环路</span><br><span class="line">	/* 此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码 */</span><br><span class="line">	for(i = 0;i&lt;G.numVertexes;i++)</span><br><span class="line">		parent[i] = 0;	//初始化数组值为0</span><br><span class="line">	for(i = 0;i&lt;G.numEdges;i++)&#123;	//循环每一条边</span><br><span class="line">		n = Find(parent, edges[i].begin);</span><br><span class="line">		m = Find(parent, edges[i].end);</span><br><span class="line">		if(n != m)&#123;		//假如n与m不等，说明此边没有与现有生成树形成环路</span><br><span class="line">			parent[n] = m;	//将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中</span><br><span class="line">			printf(&quot;(%d,%d) %d&quot;, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int* parent, int f)&#123;	//查找连线顶点的尾部下标</span><br><span class="line">	while(parent[f] &gt; 0)</span><br><span class="line">		f = parent[f];</span><br><span class="line">	return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为O(eloge),e为边数</p>
<h2 id="总结">总结</h2>
<p>对比两个算法来说，Kruskcal算法主要针对边来展开，边数少的时候效率会非常高，对于稀疏图有很大的优势，而Prim算法对于稠密图，边上非常多的情况会更好一些(个人认为是因为边数少是Kruskcal出现闭环的可能性小，在这种情况下，其效率会比Prim算法高很多，然后边数多了以后，出现闭环的可能性大大增加，导致其效率反而不如Prim算法了)</p>
<h2 id="参考资料">参考资料</h2>
<p>《大话数据结构》程杰</p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵的三元组表示</title>
    <url>/2022/05/17/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>在学习邻接矩阵时，我们会发现一个有意思的现象，有时100*100的矩阵中只储存了10个数据，我们把这种矩阵称为稀疏矩阵，其适用于一个阶数较大的矩阵中的非零元素个数相对于矩阵元素的总个数很小，如果这种稀疏矩阵用邻接矩阵来储存，这是浪费了很多空间的，那么我们应当如何在保留其矩阵信息的前提下，用一个好的结构来节省空间的开支呢？ <span id="more"></span> # 三元组 ## 定义 三元组是一种稀疏矩阵的压缩储存方式，其储存策略是只储存非零元素，它的储存方案是： 1. 储存非零元素 2. 同时储存该非零元素所对应的行下标和列下标 3. 稀疏矩阵中的每一个非零元素由一个三元组元素唯一确定，稀疏矩阵的所有非零元素构成三元组线性表，三元组的i为行下标，j为列下标，data域是对应的元素值 <img src="https://s2.loli.net/2022/05/17/iWxeFrpmwKM6jOB.png" alt="三元组.png"> ## 储存结构 下面直接上代码，注释写的比较清楚 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 100</span><br><span class="line"></span><br><span class="line">//定义三元组线性表中的数据元素存储结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int row;        //行号</span><br><span class="line">    int col;        //列号</span><br><span class="line">    ElemType d;     //元素值，ElemType为数据元素类型</span><br><span class="line"></span><br><span class="line">&#125; TupNode; //三元组定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义三元组线性表存储结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int rows;                   //行数值</span><br><span class="line">    int cols;                   //列数值</span><br><span class="line">    int nums;                   //非零元素个数</span><br><span class="line">    TupNode data[MaxSize];      //data数据域</span><br><span class="line"></span><br><span class="line">&#125; TSMatrix; //三元组顺序表定义</span><br></pre></td></tr></table></figure> ## 基本运算 ### 扫描二维矩阵，创建三元组 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以行序方式扫描二维矩阵A，将其非零的元素加入到三元组t</span><br><span class="line">//以3行4列的稀疏矩阵为例</span><br><span class="line">void CreatMat(TSMatrix *t, int arr[3][4])</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j;</span><br><span class="line">    t-&gt;rows = 3;</span><br><span class="line">    t-&gt;cols = 4;</span><br><span class="line">    t-&gt;nums = 0;</span><br><span class="line"></span><br><span class="line">    //扫描矩阵中的非零元素</span><br><span class="line">    for(i = 0; i &lt; 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; 4; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            //只存非零值，以三元组方式</span><br><span class="line">            if(arr[i][j] != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;data[t-&gt;nums].row = i;</span><br><span class="line">                t-&gt;data[t-&gt;nums].col = j;</span><br><span class="line">                t-&gt;data[t-&gt;nums].d = arr[i][j];</span><br><span class="line">                t-&gt;nums++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 将三元组指定位置元素值赋给对象 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将三元组线性表中指定位置的元素值赋值给变量x</span><br><span class="line">void arr_Assign(TSMatrix t , int *data , int i , int j)</span><br><span class="line">&#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    //i和j是否合法</span><br><span class="line">    if(i &gt;= t.rows || j &gt;= t.cols)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找到指定元素的行下标</span><br><span class="line">    while(k &lt; t.nums &amp;&amp; i &gt; t.data[k].row)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当找到指定元素的行下标后，再找到指定元素的列下标</span><br><span class="line">    while (k &lt; t.nums &amp;&amp; i == t.data[k].row &amp;&amp; j &gt; t.data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果指定元素的行和列都相等，说明找到了</span><br><span class="line">    if(t.data[k].row == i &amp;&amp; t.data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        *data = t.data[k].d;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //说明没找到</span><br><span class="line">        *data = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 对三元组元素赋值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//修改三元组元素中的值：执行A[i][j]=x</span><br><span class="line">void arr_Value(TSMatrix *t , int data , int i , int j)</span><br><span class="line">&#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    int k1;</span><br><span class="line">    //指定的行和列是否合法</span><br><span class="line">    if(i &gt;= t-&gt;rows || j &gt;= t-&gt;cols)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //先查找行</span><br><span class="line">    while(k &lt; t-&gt;nums &amp;&amp; i &gt; t-&gt;data[k].row)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找列</span><br><span class="line">    while(k &lt; t-&gt;nums &amp;&amp; i == t-&gt;data[k].row &amp;&amp; j &gt; t-&gt;data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当找到指定位置时直接修改</span><br><span class="line">    if(i == t-&gt;data[k].row &amp;&amp; j == t-&gt;data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        t-&gt;data[k].d = data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //如果指定位置不存在，则说明该元素值为0，此时插入</span><br><span class="line">        for(k1 = t-&gt;nums; k1 &gt;= k; k1--)</span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;data[k1+1].col = t-&gt;data[k1].col;</span><br><span class="line">            t-&gt;data[k1+1].row = t-&gt;data[k1].row;</span><br><span class="line">            t-&gt;data[k1+1].d = t-&gt;data[k1].d;</span><br><span class="line">        &#125;</span><br><span class="line">        //插入数据</span><br><span class="line">        t-&gt;data[k].row = i;</span><br><span class="line">        t-&gt;data[k].col = j;</span><br><span class="line">        t-&gt;data[k].d = data;</span><br><span class="line">        t-&gt;nums++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 参考资料 <a href="https://blog.csdn.net/qq_35733751/article/details/80843589">songly_的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络考前拾遗</title>
    <url>/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文只针对华中科技大学电子信息与通信学院计算机网络考试要求进行知识点归纳总结与提炼，内容不保证能满足各位读者的需求。</p>
<h2 id="第一章绪论">第一章：绪论</h2>
<h3 id="计算机网络的定义和发展历史了解">计算机网络的定义和发展历史(了解)</h3>
<p>网络:网络由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成</p>
<p>互联网：多个网络通过路由器互连起来，构成一个覆盖范围更大的网络，即互联网,互联网是网络的网络</p>
<p>因特网：因特网是世界上最大的互连网络</p>
<p>发展历史：计算机网络最早的起源来自美国军方搭建的APANET</p>
<span id="more"></span>
<p><strong>简答：列表对比说明互联网(Internet)和互连网(internet)两个概念的异同。</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-35-18.png"></p>
<h3 id="理解设计计算机网络的技术需求理解">理解设计计算机网络的技术需求(理解)</h3>
<ol type="1">
<li>可扩展的连通性</li>
<li>高性价比的资源共享</li>
<li>支持通用服务</li>
<li>可管理性</li>
</ol>
<h3 id="电路交换与分组交换掌握">电路交换与分组交换(掌握)</h3>
<p><strong>简答：简要说明电路交换的要点</strong></p>
<p>电路交换的要点包括:通信时需要经历三个阶段:建立连接、传送数据、释放连接;通信的双方之间需要建立一个专用的链路;通信过程中,沿着建立链路传输的数据无需路由;通信结束后,连接断开,链路资源被释放</p>
<p><strong>简答：简要说明分组交换的要点</strong></p>
<p>分组交换的要点包括:将完整的报文分割成为较小的数据段,在每个数据段前面加上必要的控制信息组成首部,就构成了分组;通信过程中,沿途交换机采用“存储-转发”方式,根据分组首部中的目的地信息进行转发;通信过程中,各数据分组被独立路由和转发。</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-45-41.png"></p>
<h2 id="第二章网络体系结构">第二章：网络体系结构</h2>
<h3 id="层次化体系结构的原理掌握">层次化体系结构的原理(掌握)</h3>
<p><strong>简答：简述网络体系结构采用分层设计的好处</strong></p>
<p>采用分层的网络体系结构的优势包括但不限于:</p>
<ol type="1">
<li>各层之间可以独立设计,便于分工协作,实现产业标准化;</li>
<li>层次化设计的灵活性好,一层发生变化不影响上下层;</li>
<li>层次化设计的扩展性好,各层可选用不同的技术来适应不同的应用需求。</li>
</ol>
<h3 id="网络体系结构的相关概念理解">网络体系结构的相关概念(理解)</h3>
<ol type="1">
<li>实体：任何可发送或接收数据的硬件或软件进程</li>
<li>对等实体：收发双方相同层次中的实体</li>
<li>协议：控制两个对等实体进行逻辑通信的规则的集合</li>
<li>协议的三要素：
<ol type="1">
<li>语法,即数据与控制信息的结构或格式。</li>
<li>语义,即需要发出何种控制信息、完成何种动作以及做出何种响应。</li>
<li>同步,即事件实现顺序的详细说明。</li>
</ol></li>
</ol>
<p><strong>简答：层次化网络体系结构中的服务与协议有何区别?</strong></p>
<p>层次化网络体系结构中,服务是垂直的,定义了该层能够代表它的用户完成的操作。上层是服务用户,下层是服务提供者。协议是水平的,定义的是对等实体间交换数据的格式、内容、时序,协议的实现保证了能够向上层提供服务。</p>
<h3 id="三种体系架构的模型与差异掌握">三种体系架构的模型与差异(掌握)</h3>
<figure>
<img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-00-22.png" alt="三种体系架构"><figcaption aria-hidden="true">三种体系架构</figcaption>
</figure>
<p><strong>简答：简述ISO/OSI参考模型各层功能与协议数据单元</strong></p>
<p>ISO/OSI参考模型各层功能自底向上分别为:</p>
<ol type="1">
<li>物理层:实现数据bitt在物理链路上的传输;数据单元：数据位(Bit)</li>
<li>数据链路层:处理相邻网络结点之间数据帧的传输;数据单元：数据帧</li>
<li>网络层:处理互联网络中主机之间的分组传输;数据单元：数据分组</li>
<li>传输层:实现终端主机进程之间的通信;数据单元：数据段</li>
<li>会话层:实现通信的会话管理等功能;数据单元：数据</li>
<li>表示层:实现不同表达形式数据之间的转换;数据单元：数据</li>
<li>应用层:实现应用特定操作,向用户提供相应的服务.数据单元：数据</li>
</ol>
<p><strong>简答：自上而下简述计算机网络体系结构的五层参考模型</strong></p>
<p>网络体系结构的五层模型,自上向下依次为应用层、传输层、网络层、数据链路层、物理层。</p>
<p>应用层:为用户的应用进程提供服务</p>
<p>传输层:为两个主机中进程之间的通信提供端到端服务</p>
<p>网络层:为分组交换网上的不同主机提供通信服务</p>
<p>数据链路层:在相邻结点间的链路上透明传送数据</p>
<p>物理层:在传输媒质上实现透明的比特流传送</p>
<h3 id="计算机网络的性能指标的计算方法掌握">计算机网络的性能指标的计算方法(掌握)</h3>
<p><strong>首先要区分比特和字节的概念</strong></p>
<p>1Byte(字节)=8bit(比特)</p>
<ol type="1">
<li>速率：连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率，基本单位：bit/s（bps），常用单位:kbps/Mbps <strong>这里的换算需要与计算机存储里面换算做区分，计算速率时:1k=1000,计算内存时：1k=1024</strong></li>
<li>带宽：表示网络的通信线路传送数据的能力，表示单位时间内从网络中某一点到另一点所能通过的<strong>最高数据率</strong>,单位与速率单位相同</li>
<li>吞吐量：表示单位时间内通过某个网络(或信道、接口)的数据量；用于测量实际上到底由多少数据量能通过网络，其受<strong>网络带宽或额定速率的限制</strong>,在部分习题中提出了<strong>计算网络最大吞吐率</strong>的要求：其计算公式可表述如下：<span class="math inline">\(最大吞吐量=\frac{发送窗口大小}{往返时延}\)</span></li>
<li>时延：
<ul>
<li>发送时延：<span class="math inline">\(\frac{分组长度}{发送速率}\)</span></li>
<li>传播时延：<span class="math inline">\(\frac{信道长度}{电磁波传播速率}\)</span></li>
<li>处理时延：一般不便于计算</li>
<li>排队时延：一般不考虑</li>
<li>总时延=发送时延+传播时延+处理时延+排队时延</li>
</ul></li>
<li>时延带宽积：其值等于传播时延*带宽，时延带宽积可视为以比特为单位的链路长度,等效于第一个比特到达接收方时发送方可以发送的比特数(链路满载)。</li>
<li>往返时延(RTT):链路双向交互一次的时间</li>
<li><span class="math inline">\(信道利用率=\frac{发送数据量}{信道总带宽\times往返时延}=\frac{有效传输时间}{往返传输时延（\ne RTT）}\)</span></li>
</ol>
<h2 id="第三章直连网络">第三章：直连网络</h2>
<h3 id="直连网络的概念了解">直连网络的概念(了解)</h3>
<p>直连网络：所有的主机通过某种物理媒质直接连接，是最简单的网络形式</p>
<p><strong>物理层的四个特性</strong>：</p>
<p>机械特性：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p>
<p>电气特性：指明在接口电缆的各条线上出现的电压的范围。</p>
<p>功能特性：指明某条线上出现的某一电平的电压表示何意。</p>
<p>规程特性：指明对于不同功能的各种可能事件的出现顺序。</p>
<h3 id="不同组帧方法了解">不同组帧方法(了解)</h3>
<p>组帧方法主要分为以下两种：</p>
<ol type="1">
<li>面向字节的协议：把每一帧看作一个字节集合，两种方法：字符计数法，起止标记法。</li>
<li>面向比特的协议：把数据帧看作比特的集合</li>
</ol>
<h3 id="差错控制的概念理解">差错控制的概念(理解)</h3>
<p>为什么进行差错检测？ 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错，这称为比特差错，使用差错检测码来检测是否产生比特差错，是数据链路层的重要问题之一。</p>
<p>常用的差错检测方法：</p>
<ol type="1">
<li>奇偶校验：添加一位奇偶校验位，能检测奇数个比特差错</li>
<li>循环冗余校验(CRC)：检测出一定数量的差错，其主要步骤如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-23-16.png"></li>
</ol>
<h3 id="可靠传输的概念和基本实现机制掌握">可靠传输的概念和基本实现机制(掌握)</h3>
<p>可靠传输：上文提到的比特差错只是传输差错的一种，传输差错还包括分组丢失，分组失序，分组重复</p>
<p>可靠传输的协议实现主要有以下几种：</p>
<ol type="1">
<li>停止等待协议（ARQ协议）</li>
<li>连续ARQ协议：包含两种策略：GO-BACK-N 和 选择性重传</li>
<li>滑动窗口协议</li>
</ol>
<p>停止等待协议示意图 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-40-13.png" alt="停止等待协议示意图"></p>
<p>连续ARQ协议两种策略的优缺点分析： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-44-52.png"></p>
<p><strong>注意，Go-Back-N协议如果帧序号为n个bit，其每次最多连续能传的帧数=<span class="math inline">\(2^{n}-1\)</span>，因为如果传<span class="math inline">\(2^n\)</span>个帧，如果接收方确认帧丢失，则会导致接收方无法辨别发送方发送的帧的新旧，GO-BACK-N也可以看为滑动窗口策略的一种特殊情况，即接收窗口为1</strong></p>
<p>滑动窗口协议的示意图： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-15.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-40.png"></p>
<p>三种协议的对比 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-11-11-19-01.png"></p>
<p><strong>简答：简述数据链路层实现可靠传输的基本方法。</strong></p>
<p>数据链路层实现可靠传输的基本设计方法包括:</p>
<ol type="1">
<li>确认机制:接收方给发送方发送ACK,反馈已正确接收的数据帧;</li>
<li>超时机制:发送方启动计时器,一旦出现超时则自动重传未确认的数据帧;</li>
<li>帧序号:标记数据帧,以便识别重复的数据帧</li>
</ol>
<h3 id="滑动窗口参数的计算方法掌握">滑动窗口参数的计算方法(掌握)</h3>
<p>选择重传策略的滑动窗口参数的要求如下图所示 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-48-38.png"></p>
<p><strong>广义来说：滑动窗口对于窗口的大小的限制可表述为：<span class="math inline">\(发送窗口+接收窗口\le2^{帧序号bit数}\)</span></strong></p>
<p><strong>具体细分到Go-Back-N协议和选择重传协议有：<span class="math display">\[Go-Back-N 发送窗口大小\le 2^{帧序号比特数}-1,\\
选择重传发送窗口大小\le 2^{帧序号比特数-1} \]</span></strong></p>
<h3 id="传统共享介质mac协议的设计要点理解">传统共享介质MAC协议的设计要点(理解)</h3>
<p><strong>简答：为什么在传统以太网的协议设计中,数据帧存在最短帧长的限制?</strong></p>
<p>传统以太网的MAC层协议为CSMA/CD,其中CD称为冲突检测,主要解决信号传播时延导致的媒质接入问题。在争用信道过程中,结点边发送数据边监听信道,如果在一个争用周期范围内未检测到冲突发生,则成功占用信道。IEEE 802.3规定当某个结点完成一帧数据接收后,首先要判断接收的帧长度,如果接收帧长度小于规定的帧最小长度,则表明冲突发生。</p>
<h3 id="csmacd协议的原理掌握">CSMA/CD协议的原理(掌握)</h3>
<p><strong>简答：简述传统以太网的CSMA/CD算法要点</strong></p>
<p>CSMA/CD全称为带有冲突检测的载波侦听多路接入(Carrier Sense Multiple Access with Collision Detect)。其基本思想是载波监听,多点接入,碰撞检测。每个站点发送数据之前必须侦听信道的忙、闲状态;如果信道空闲,立即发送数据,同时进行冲突检测;如果信道忙,站点继续侦听总线,直到信道变成空闲。如果在数据发送过程中检测到冲突,将立即停止发送数据并等待一段随机长的时间,然后重复上述过程。</p>
<h3 id="无线局域网mac协议设计要点理解">无线局域网MAC协议设计要点(理解)</h3>
<p><strong>简答：CSMA/CD算法为何不能应用于无线局域网</strong></p>
<p>CSMA/CD算法需要硬件一边发送数据一边监听共享链路的占用情况,在冲突窗口时间内没有检测出冲突就确定为发送成功。这些设计在无线链路上难以满足。首先,在无线网卡实现信号的同时发送和接收的难度和代价较高;其次,无线通信环境中信号传输路径复杂,存在绕射、折射、反射等多径,难以估算传输延时和判断是否存在冲突。</p>
<h3 id="csmaca协议的原理理解">CSMA/CA协议的原理(理解)</h3>
<p><strong>简答：无线局域网CSMA/CA如何实现冲突避免?</strong></p>
<p>冲突避免 Collision Avoidance,又称为虚拟载波侦听 (Virtual Carrier Sense),通过信令协商达到实际载波侦听的效果。协议约定在发送数据帧之前交换控制信息,发送方询问“Request to Send” (RTS),接收方收到 RTS后响应 “Clear to Send” (CTS),发送方收到 CTS, 则开始发送数据。在此过程中,如果其他结点收到 RTS或者 CTS,则停止发送,避免冲突。</p>
<h2 id="第四章分组交换网络">第四章：分组交换网络</h2>
<h3 id="数据报交换虚电路交换的原理理解">数据报交换、虚电路交换的原理(理解)</h3>
<p><strong>虚电路交换方法的健壮性不如数据报交换方法</strong></p>
<p><strong>简答：对比虚电路和数据报两种分组交换技术</strong></p>
<p>数据报交换的思想是网络不负责提供可靠传输保证,分组中包括源/目的地址,沿途交换机根据该地址独立处理和转发分组。 虚电路交换的思想是网络提供可靠传输保证,传输过程包括连接建立、数据传输、连接释放等阶段。在连接建立过程中,交换机协商分配局部的虚电路号并预留资源;数据传输过程中,分组首部内包含有本地交换所需的虚电路号,交换机根据虚电路号转发分组。</p>
<h3 id="局域网扩展网桥生成树算法的基本概念理解">局域网扩展，网桥，生成树算法的基本概念(理解)</h3>
<p><strong>局域网扩展的基本概念</strong>：局域网（LAN）扩展是指通过不同的技术手段，将原有的局域网范围进行扩大，以覆盖更大的区域或连接更多的设备。这种扩展可以通过多种方式实现：</p>
<ol type="1">
<li>无线局域网扩展：如Wi-Fi</li>
<li>有线局域网扩展：使用更长的网线等传输媒介，扩大局域网范围</li>
<li>虚拟局域网(VLAN)：通过在网络交换机上配置虚拟局域网，可以将原有的物理局域网划分为多个逻辑上独立的虚拟局域网，实现不同部门或功能的隔离和管理，同时在逻辑上连接它们，形成一个扩展的网络。</li>
<li>子网划分： 将原有的单一子网划分为多个子网，每个子网可以有自己的IP地址范围和路由规则，使得网络可以更有效地支持不同的设备和服务</li>
<li>中继器和网桥： 使用中继器和网桥等设备，可以将原有的局域网连接到其他局域网，实现不同物理位置之间的网络扩展。</li>
<li>广域网连接： 通过使用广域网（WAN）连接技术，如专线、VPN（虚拟专用网络）等，将不同地理位置的局域网连接起来，形成一个更大范围的网络。</li>
</ol>
<p><strong>网桥的基本概念</strong>：网桥工作在数据链路层，对接收到的帧进行过滤转发，通过网桥可以连接多个局域网，以建立更大的局域网</p>
<p>网桥可分为基本网桥和学习网桥，基本网桥将收到的帧向所有端口转发，这样效率很低，不能隔离碰撞域，常用的是学习网桥，采用选择性转发的方法，维护一个转发表，根据转发表（站表）确定转发端口，不向无关端口转发（能有效隔离碰撞域，效率高）。</p>
<p><strong>生成树算法的基本概念</strong>：生成树算法是为了解决广播风暴的问题而提出的一种算法，因为根据网桥的工作原理，帧有可能在环形网络中兜圈子而产生广播风暴。生成树算法通过从网络中剪掉一些链路，构造出该网络的生成树来解决广播风暴问题</p>
<p><strong>简答：简述透明网桥的要点?其在环状拓扑结构下可能发生什么问题?</strong></p>
<p>透明网桥通过逆向自主学习方式构建MAC转发表 透明网桥在环状拓扑结构下可能发生广播风暴(绕弯子)现象,生成树算法可以有效解决该问题。</p>
<p><strong>简答：什么是广播风暴</strong></p>
<p>网桥工作在数据链路层。网桥根据数据帧的源地址与目的地址来决定是否接收和转发该帧。随着网络规模的扩大与用户结点数的增加,可能出现“端口-结点地址表”中没有的结点地址信息,此时网桥无从决定应该从哪个端口转发,只能在所有端口广播。这种盲目广播会使帧的数量按指数规律增长,造成网络中无用的通信量剧增,形成“广播风暴”。</p>
<p><strong>简答：虚拟局域网是不是一种新的局域网?</strong></p>
<p>虚拟局域网是局域网交换机给用户提供的一种服务,并不是一种新型局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符,称为VLAN标记,用来指明发送该帧的工作站属于哪一个VLAN。局域网交换机根据VLAN标记,对于到来流量进行转发。属于同一个VLAN标记的工作站可以相互访问。</p>
<p><strong>数据帧转发过程中IP地址和MAC地址的变化情况</strong></p>
<ol type="1">
<li>当帧经过交换机时不会更改其源MAC地址和目标MAC地址</li>
<li>当帧通过路由器时，进行路由转发，IP地址是不会变的，MAC地址一定会变</li>
<li>当帧在同一个子网的主机之间进行转发，IP和MAC地址都不会改变</li>
<li>当帧在不同子网的主机进行转发时(使用NAT技术将内网IP转为外网公用IP)时，IP地址和MAC地址会发生改变</li>
</ol>
<h3 id="共享式以太网与交换式以太网的区别理解">共享式以太网与交换式以太网的区别(理解)</h3>
<p><strong>简答：共享式局域网与交换式局域网有哪些区别?</strong></p>
<p>共享式局域网的核心设备是集线器,在任何一个时刻只能有一个结点通过共享信道发送数据。该网络内每个结点处于同一个冲突域内,结点得到的平均带宽约等于总带宽/结点数。 交换式局域网的核心设备是交换机,可以在它的多个端口之间建立多个并发连接,从而实现了结点之间数据的并发传输。该网络内结点的通信不存在冲突,结点得到接近总带宽的带宽。</p>
<h3 id="以太网中继器集线器网桥交换机的功能与区别掌握">以太网中继器、集线器、网桥、交换机的功能与区别(掌握)</h3>
<p><strong>简答：简述中继器、集线器、网桥、交换机等设备的区别</strong></p>
<p>这4 种设备都是用于互联、扩展局域网的连接设备,但它们工作的层次和实现的功能不同:</p>
<ol type="1">
<li>中继器(Repeater),工作在物理层,解决数字信号在长距离基带传输中的失真和衰减问题,通过信号再生提升信号波形和强度的质量。</li>
<li>集线器(Hub),工作在物理层,相当于一个多端口的中继器。集线器可以将多个结点连接成为一个共享式以太网。</li>
<li>网桥(Network Bridge),工作在数据链路层,可以互联不同的物理层、不同的 MAC 子层以及不同速率的以大网,具有过滤帧、存储转发帧的功能。</li>
<li>交换机(Switch),,工作在数据链路层,相当于一个多端口的网桥。允许端口之间建立多个并发的连接,实现多个结点之间的并发传输。</li>
</ol>
<h2 id="第五章网络互联">第五章：网络互联</h2>
<h3 id="ip尽力服务的服务模型ip数据包转发原理理解">IP尽力服务的服务模型，IP数据包转发原理(理解)</h3>
<p><strong>IP尽力服务</strong>是一种服务模型，也称为“Best Effort Service”，是指在计算机网络中，网络设备尽其所能地传输数据，但不保证数据包的可靠性、顺序或时延。这种服务模型主要用于互联网中的IP网络，其中数据包以最佳可能的方式进行传输，但网络不提供对数据包的任何特殊处理或保证。</p>
<p><strong>IP数据包转发原理</strong>：</p>
<ol type="1">
<li>数据包的封装</li>
<li>路由器查找</li>
<li>数据包转发</li>
<li>数据包到达目标设备</li>
</ol>
<p><strong>简答：解释Everything over IP和IP over Everything的含义</strong></p>
<p>Everything over IP:从协议栈来看,TCP/IP网络可以为各式各样的应用提供服务,在IP层上面可以有很多的应用程序。 IP over everything:从协议栈看,TCP/IP网络也允许IP协议在各种异构网络构成互联网上运行,在IP层以上无需关心下层的物理网络实现。</p>
<h3 id="ipv4分段与重组的概念与计算掌握">IPv4分段与重组的概念与计算(掌握)</h3>
<p>IPv4分段与重组是一种处理大数据包的机制，允许将大于网络链路允许的最大传输单元（MTU）的IPv4数据包进行分割，并在到达目的地后重新组装这些分段。这是为了适应网络链路上的不同MTU和确保数据的正确传输。</p>
<p>在了解如何计算IPv4的分段和重组之前，我们需要了解IPv4数据报的首部格式 其示意图如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-38-31.png"></p>
<p>各参数含义如下：</p>
<ol type="1">
<li>版本：表示IP协议版本</li>
<li>首部长度，取值以4为单位，最小值为5，20字节，最大值为15，表明首部包含20字节固定部分和最大40字节可变部分</li>
<li>可选字段：用于排错，很少使用</li>
<li>填充字段：确保首部长度为4的整数倍，用全0填充</li>
<li>区分服务：很少使用</li>
<li>总长度：表示IP数据报总长度</li>
<li>标识：属于同一数据包的各分片应该具有相同标识</li>
<li>标志：各比特定义为:
<ul>
<li>DF位：1/0 表示是否允许分片</li>
<li>MF位：1/0 表示后面是否还有分片</li>
<li>保留位：必须为0</li>
</ul></li>
<li>片偏移：指出其数据载荷部分在原数据基础上偏移了多少位，以八个字节为单位</li>
</ol>
<p>其计算常涉及到如何将大数据包分为更小的片段进行传输，具体操作可以通过下图来理解 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-34-47.png"></p>
<p>值得注意的是：<strong>在IP层的计算中，IP实际的数据段需要减去首部长度，但如果题目说的是TCP传输层的报文传入下层IP层传输，则不需要减去TCP传输层的首部长度，因为IP层的数据载荷就是整个TCP报文</strong></p>
<h3 id="ipv4地址以及cidr设计和规划的概念与计算方法掌握">IPv4地址以及CIDR设计和规划的概念与计算方法(掌握)</h3>
<h4 id="ipv4的分类编址">IPv4的分类编址</h4>
<p>IP地址往往进行分类编址 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-56-24.png"></p>
<p><strong>且在每个网络的主机号中，全0的最小地址作为网络地址，全1的最大地址作为广播地址不可分配</strong></p>
<p>常用的3类网络的网络数和主机数的关系如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-59-13.png"></p>
<h4 id="ipv4划分子网">IPv4划分子网</h4>
<p>对于网络中的网络，我们往往是直接在该网络中分配子网，而不是申请新的网络号，这可表述为<strong>借用主机地址作为网络地址</strong></p>
<p>我们可以用IP地址与子网掩码相与得到网络地址，其计算如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-04-24.png"></p>
<p><strong>给定一个分类的IP地址和子网掩码，即可计算子网划分细节</strong>：</p>
<ol type="1">
<li><span class="math inline">\(子网数量=2^{子网掩码1数-网络号}\)</span></li>
<li><span class="math inline">\(子网可分配给主机的IP地址数量=2^{子网掩码0数}-2\)</span></li>
<li><span class="math inline">\(子网网络地址=子网地址，子网广播地址=下一个子网地址-1\)</span></li>
<li><span class="math inline">\(子网分配给主机的最小地址=子网地址+1，子网分配给主机的最大地址=下一个子网地址-2\)</span></li>
</ol>
<h4 id="ipv4无分类编址超网--cidr">IPv4无分类编址(超网)--CIDR</h4>
<p>CIDR使用斜线记法，在<strong>斜线后面写上网络前缀所占比特数量</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-12-35.png"></p>
<p><strong>CIDR的最长前缀匹配原则</strong></p>
<p>在路由器间进行转发时，我们采用最长前缀匹配原则将到来的IP分组进行转发，如果一个IP分组与两个网络的网络号都匹配，选择两个网络号中，长度最长的那个网络作为IP地址的下一跳路由器</p>
<p><strong>简答：说明IP地址与硬件地址的区别</strong></p>
<p>IP地址是连接互联网上的主机标识符;IP地址也被称为逻辑地址,其分配可以被静态指定也可以被动态分配;IPv4是32bit的,IPv6是128bit的。 硬件地址也被称为物理地址,用于标识每个网络接口设备;IEEE系列标准规定了MAC地址的格式,由48bit构成,由网卡制造商在生产时内置。</p>
<h3 id="arp协议dhcp协议nat协议icmp协议了解">ARP协议，DHCP协议，NAT协议，ICMP协议(了解)</h3>
<ol type="1">
<li>ARP协议用于将IP地址映射到MAC地址</li>
<li>DHCP协议用于将域名映射到IP地址(<strong>域名与IP地址不是一一对应的关系</strong>)</li>
<li>NAT协议用于在私有网络和公共网络中映射IP地址，允许多个设备享有一个IP地址</li>
<li>ICMP用于IP网络上的检错</li>
</ol>
<p><strong>简答：ARP协议向网络层提供了转换地址的服务,是否属于数据链路层?</strong></p>
<p>这种说法是错误的。ARP 不是向网络层提供服务,它本身就是网络层的一部分,帮助向传输层提供服务。数据链路层不存在IP地址问题,数据链路层协议把比特串从线路的一端传送到另一端。</p>
<h3 id="基于距离向量和基于链路状态的路由算法的原理与计算掌握">基于距离向量和基于链路状态的路由算法的原理与计算(掌握)</h3>
<p><strong>简答：简述距离向量路由算法原理,该算法有哪些不足?</strong></p>
<p>该算法定义距离向量信息为当前结点到达每一个其他结点的代价,通过邻结点之间多轮次两两交换距离向量信息,基于Bellman-ford算法逐步更新到全网其它结点的最短路径下一跳。 该算法的不足包括,构造距离向量需要知道全网结点数量规模,可能产生无穷计算问题。</p>
<p><strong>简答：“好消息传得快,坏消息传得慢”描述的是哪个路由算法,如何克服?</strong></p>
<p>这是距离向量路由算法的缺点。其原因是,路由交换时依赖两两信息交换,无法得到全局准确信息,导致计算到无穷。该问题无法通过算法改进彻底解决,在该算法对应的RIP协议中,通过设定路由跳数最大值来加以克服。RIP约定值为16即表示不可达,避免计算到无穷。</p>
<p><strong>简答：对比距离向量路由算法和链路状态路由算法的差异。</strong></p>
<p>距离向量路由算法:与邻结点交互全局信息,每个结点仅与直接相连的结点通信,交互的信息是到达其余所有结点的距离,路由计算采用Bellman-ford算法。 链路状态路由算法:与全局结点交互局部信息,每个结点通过洪泛方式与其他所有结点通信,交互的信息是该结点相连链路的状态,路由计算采用Dijkstra算法。</p>
<h3 id="路由器与交换机的区别掌握">路由器与交换机的区别(掌握)</h3>
<p><strong>简答：作为中间设备,转发器、网桥、路由器和网关有何区别?</strong></p>
<p>将网络互相连接起来要使用一些中间设备:</p>
<ol type="1">
<li>物理层使用的中间设备叫做转发器。</li>
<li>数据链路层使用的中间设备叫做网桥或桥接器。</li>
<li>网络层使用的中间设备叫做路由器。</li>
<li>在网络层以上使用的中间设备叫做网关。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li>
</ol>
<h3 id="自治系统的概念域内路由与域间路由的概念理解">自治系统的概念，域内路由与域间路由的概念(理解)</h3>
<h4 id="自治系统">自治系统</h4>
<p>因特网将整个互联网划分为许多较小的自治系统 AS。</p>
<p>一个自治系统是一个互联网，其最重要的特点就是自治系统有权自主地决定在本系统内应采用何种路由选择协议。</p>
<p>一个自治系统内的所有网络都属于一个行政单位(例如，一个公司，一所大学，政府的一个部门，等等)来管辖。</p>
<p>一个自治系统的所有路由器在本自治系统内都必须是连通的。</p>
<h4 id="域内路由与域间路由">域内路由与域间路由</h4>
<p><strong>简答：IGP和EGP这两类协议的主要区别是什么?</strong></p>
<p>IGP是内部网关协议,即在一个自治系统内部使用的路由选择协议,代表性的包括RIP和OSPF协议。IGP的路由选择主要采用最短路径的算法。 EGP是外部网关协议,用于自治系统之间路由选择,目前使用最多的外部网关协议是BGP协议。EGP的路由选择受多种因素影响,通常不使用最短路径。</p>
<h3 id="路径向量路由算法的原理与bgp协议实现理解">路径向量路由算法的原理与BGP协议实现(理解)</h3>
<p><strong>路径向量路由算法</strong></p>
<p>想法：</p>
<ul>
<li>对距离向量进行扩展使其能够快速检测环路</li>
<li>支持灵活的路由策略</li>
<li>避免无穷计算问题</li>
</ul>
<p>核心思想 : 通告整条路径</p>
<p>距离向量 : 发送到每一个目的地 d 的距离向量</p>
<p>路径向量 : 发送到每一个目的地 d 的路径向量</p>
<p><strong>BGP协议</strong></p>
<ol type="1">
<li>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 （不能兜圈子），而并非要寻找一条最佳路由</li>
<li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 BGP 发言人</li>
<li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换BGP 报文以建立 BGP 会话 ( session)，利用 BGP 会话交换路由信息。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站 。</li>
</ol>
<p><strong>简答：RIP、OSPF、BGP的承载协议有何不同,有何考虑?</strong></p>
<ol type="1">
<li>RIP采用UDP协议。RIP在1980年代早期开发,其只需要与邻结点交互信息。UDP虽然无可靠性保证,但传输开销较小,可以满足RIP的需求。</li>
<li>OSPF采用IP协议。OSPF在1980年代末期开发,其需要在全网交互信息。当时TCP/IP架构已经形成,直接使用IP协议,易于在路由器上实现链路状态信息的洪泛。</li>
<li>BGP采用TCP协议。BGP协议在不同的自治系统之间交换路由信息,交换域间路由信息需要可靠传输保证,所以选择TCP。</li>
</ol>
<h3 id="ipv6协议了解">IPv6协议(了解)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-23-41.png"></p>
<h2 id="第六章端到端协议">第六章：端到端协议</h2>
<h3 id="传输协议udp与tcp的实现要点和对比理解">传输协议UDP与TCP的实现要点和对比(理解)</h3>
<p>UDP协议的实现要点：</p>
<ol type="1">
<li>无连接的</li>
<li>支持单播、多播和广播</li>
<li>面向应用报文</li>
<li>向上传提供无连接不可靠传输服务(适用于IP电话，视频会议等实时应用)</li>
<li>首部短，仅8字节</li>
</ol>
<p>TCP协议实现要点：</p>
<ol type="1">
<li>面向连接</li>
<li>一对一可靠通信</li>
<li>面向字节流</li>
<li>可靠传输，使用流量控制和拥塞控制</li>
<li>首部最小20字节，最大60字节</li>
</ol>
<p>UDP与TCP的对比 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-32-56.png"></p>
<p><strong>简答：为什么说UDP是面向报文的,而TCP是面向字节流的?</strong></p>
<p>UDP对应用程序交下来的报文,在添加首部后就向下交付IP层。UDP待交付的报文,既不合并,也不拆分,因此UDP是面向报文的。</p>
<p>TCP将应用层发送的报文看成是一串字节流,并对把每一个字节都进行编号,传输保证每一个字节都正确无误地传送到对方。因此TCP是面向字节流的。</p>
<h3 id="tcp连接的三次握手与四次挥手掌握">TCP连接的三次握手与四次挥手(掌握)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-47-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-48-36.png"></p>
<p><strong>简答：为什么在TCP连接建立时要使用三报文握手?</strong></p>
<p>如果不采用三报文握手,而是仅仅两报文握手。一旦滞留在网络中某处的陈旧的SYN报文段抵达接收方,就会让接收方误以为这是一个新的连接而进入连接等待状态,导致接收方资源被占用而无法释放。</p>
<p><strong>简答：为什么TCP连接释放比连接建立过程多一次交互?</strong></p>
<p>TCP三次握手是确保两个站点都对当前建立连接进行确认,避免两个站点过去发送的连接建立请求延后到达后导致一方进入资源等待状态而空等。 TCP四次挥手在三次握手基础上增加一次,原因是接收方需要等待上层应用将数据取走,因此接收方一次表示确认收到释放请求,一次再发起释放请求。</p>
<h3 id="tcp流量控制滑动窗口掌握">TCP流量控制(滑动窗口)(掌握)</h3>
<p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收 一般我们采用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-46-04.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-45-43.png"></p>
<p><strong>简答：TCP发送窗口的大小取决于流量控制还是拥塞控制?</strong></p>
<p>TCP发送窗口的上限值是Min [rwnd,cwnd],即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。当接收窗口小于拥塞窗口时,发送窗口的大小取决于流量控制,即取决于接收端的接收能力;当拥塞窗口小于接收窗口时,则发送窗口的大小取决于拥塞控制,即取决于整个网络的拥塞状况。</p>
<h2 id="第七章拥塞控制">第七章：拥塞控制</h2>
<h3 id="拥塞控制的概念以及与流量控制的区别理解">拥塞控制的概念以及与流量控制的区别(理解)</h3>
<p><strong>简答：流量控制和拥塞控制的最主要的区别是什么?</strong></p>
<p>流量控制是在一条TCP连接中的接收端采用的措施,用来限制对方(发送端)发送报文段的速率,以免在接收端来不及接收。流量控制只控制一个发送端。 拥塞控制是用来控制TCP连接中发送端发送报文段的速率,以免使互联网中的某处产生过载。拥塞控制可能会同时控制许多个发送端,限制它们的发送速率。</p>
<h3 id="tcp拥塞控制的主要机制掌握">TCP拥塞控制的主要机制(掌握)</h3>
<p>常用的机制主要是慢开始和拥塞避免 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-52-05.png"></p>
<p>为了进一步改进性能，又提出了快重传和快恢复算法 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-54-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-55-01.png"></p>
<h3 id="tcp拥塞控制与流量控制的综合计算掌握">TCP拥塞控制与流量控制的综合计算(掌握)</h3>
<p>仅举一例 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-56-31.png"></p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">湖科大计算机网络微课堂</a></li>
<li>Computer Networks: A Systems Approach, 5th Edition</li>
<li>华中科技大学电子信息与通信学院计算机网络课程组提供的优秀课件和资料</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法</title>
    <url>/2022/02/01/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="递归算法">递归算法</h2>
<h2 id="什么是递归">什么是递归？</h2>
<p>递归，在计算机科学中是指一种通过重复把问题分解为同类的子问题而解决问题的方法，通俗来讲，递归表现为函数调用函数本身。在知乎上有一个比喻递归非常形象的例子。 “递归最恰当的比喻，就是查词典。我们使用的词典，本身就是递归，为了解释一个词，需要使用更多的词。当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。”. <span id="more"></span> ### 递归的特点 事实上，递归有两个显著的特征，终止条件和自身调用： * <strong>自身调用</strong>：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，都是调用自身的同一个函数 * <strong>终止条件</strong>：递归必须有一个终止的条件，即不能无线循环的调用自己</p>
<h3 id="递归与栈的关系">递归与栈的关系</h3>
<p>递归的过程也可以理解为出入栈的过程 比如说我们利用递归计算3的阶乘，因为3&gt;1,所以进入下一个递归，2&gt;1，再进入下一个递归，1=1，开始计算，依序返回，在这里，我们可以发现先进去的3反而是最后执行的，这就类似于栈的性质</p>
<h3 id="递归的经典应用场景">递归的经典应用场景</h3>
<ul>
<li>阶乘问题</li>
<li>二叉树深度</li>
<li>汉诺塔问题</li>
<li>斐波那契数列</li>
<li>快速排序，归并排序（分治算法中体现递归）</li>
<li>遍历文件，解析xml文件</li>
</ul>
<h3 id="递归解题思路">递归解题思路</h3>
<ol type="1">
<li>定义函数功能</li>
<li>寻找递归终止条件</li>
<li>递推函数的等价关系式</li>
</ol>
<h3 id="递归存在的问题">递归存在的问题</h3>
<ol type="1">
<li>递归调用层级太多，导致栈溢出问题</li>
<li>递归重复计算，导致效率低下</li>
</ol>
<h4 id="栈溢出问题">栈溢出问题：</h4>
<ul>
<li>每一次函数调用在内存栈中分配空间，然而每个进程的栈容量是有限的</li>
<li>当递归调用的层级太多时就会，就会超出栈的容量，从而导致调用栈溢出</li>
<li>其实，我们在前面小节也讨论了。递归过程类似于出栈入栈，如果递归次数过多，栈的深度就需要越深，最后栈容量就不够了</li>
</ul>
<h4 id="重复计算导致效率低下">重复计算导致效率低下</h4>
<p>递归处理时，有些问题如果不加以处理，会造成多次重复计算，降低程序的运行效率</p>
<p>参考：https://mp.weixin.qq.com/s/tqGKHZzSyDBgEp-oWsOztQ</p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>锦标赛排序</title>
    <url>/2022/05/03/%E9%94%A6%E6%A0%87%E8%B5%9B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="锦标赛排序">锦标赛排序</h1>
<h2 id="前言">前言</h2>
<p>这种排序方式的经典应用来自百度的一道面试题：给出一个长度是N的数组，现在要找出最小的两个元素，最少要多少次比较？</p>
<span id="more"></span>
<h2 id="原理">原理</h2>
<p>竞标赛排序又叫树型排序，属于选择排序的一种，其目的是克服直接选择排序不能保留比较结果，不断重复比较的缺点，它的基本思想是首先取得n个元素的关键词，进行两两比较，得到n/2个比较优胜者，然后再两两比较找到第一小的那个，然后把最小那个元素对应的叶子节点的值变为无穷大，那么在搜索第二小值时，我们就只需要比较最小值叶子节点所在的子树即可，就达到了logn次比较的目标，然后一直重复该过程，所以其时间复杂度为O(n*log2n),空间复杂度为O（N）(需要2n-1个节点存放树) <strong>示意图</strong> <img src="https://s2.loli.net/2022/05/03/Igw4nbJCiX7SLDY.png" alt="锦标赛排序-1.png"> <img src="https://s2.loli.net/2022/05/03/rfcWwBUMAl7uzgp.png" alt="锦标赛排序-2.png"> ## 代码实现（python） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, _data, _id):</span><br><span class="line">        self.data = _data</span><br><span class="line">        self.id = _id</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.id, self.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Adjust(data, idx):</span><br><span class="line">    while (idx != 0):</span><br><span class="line">        if (idx % 2 == 1):</span><br><span class="line">            if (data[idx].data &lt; data[idx + 1].data):</span><br><span class="line">                data[(idx - 1) // 2] = data[idx]</span><br><span class="line">            else:</span><br><span class="line">                data[(idx - 1) // 2] = data[idx + 1]</span><br><span class="line">            idx = (idx - 1) // 2</span><br><span class="line">        else:</span><br><span class="line">            if (data[idx - 1].data &lt; data[idx].data):</span><br><span class="line">                data[idx // 2 - 1] = data[idx - 1]</span><br><span class="line">            else:</span><br><span class="line">                data[idx // 2 - 1] = data[idx]</span><br><span class="line">            idx = idx // 2 - 1</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Sort(data):</span><br><span class="line">    length = len(data)</span><br><span class="line">    n = 1</span><br><span class="line">    while n &lt; length:</span><br><span class="line">        n &lt;&lt;= 1</span><br><span class="line">        # print(&quot;n=&quot;,n)</span><br><span class="line">    nTreeSize = 2 * n - 1</span><br><span class="line">    nodes = []</span><br><span class="line">    for i in range(nTreeSize):</span><br><span class="line">        nodes.append(Node(0, 0))</span><br><span class="line">    # 初始化竞赛数数据</span><br><span class="line">    for i in range(n - 1, nTreeSize):</span><br><span class="line">        idx = i - (n - 1)</span><br><span class="line">        if idx &lt; length:</span><br><span class="line">            nodes[i] = Node(data[idx], i)</span><br><span class="line">        else:</span><br><span class="line">            nodes[i] = Node(9999, -1)</span><br><span class="line">    for i in range(n - 2, -1, -1):</span><br><span class="line">        if (nodes[i * 2 + 1].data &lt; nodes[i * 2 + 2].data):</span><br><span class="line">            nodes[i] = nodes[i * 2 + 1]</span><br><span class="line">        else:</span><br><span class="line">            nodes[i] = nodes[i * 2 + 2]</span><br><span class="line">    # 实现排序</span><br><span class="line">    B = []</span><br><span class="line">    for i in range(0, length):</span><br><span class="line">        # 取出最小的</span><br><span class="line">        B.append(nodes[0].data)</span><br><span class="line">        nodes[nodes[0].id].data = 9999</span><br><span class="line">        Adjust(nodes, nodes[0].id)</span><br><span class="line">    return B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    Arr = [2,5,9,1,11,20,15,7,4,6]</span><br><span class="line">    Arr2 = Sort(Arr)</span><br><span class="line">    print(&quot;newArr=&quot;,Arr2)</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 参考资料 <a href="https://www.cnblogs.com/james1207/p/3323115.html">james1207</a> <a href="https://blog.csdn.net/mmmmmmmmzw/article/details/105216255">mmmmmmmmzw</a></p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
