<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度学习训练Tips</title>
    <url>/2023/03/05/deeplearning-tips/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>笔者在刚接触深度学习时，曾因为找不到系统实验指南而抓耳挠腮，十分痛苦，在搜索了无数次资源加上n次痛苦的debug后终于跑起了第一个深度学习实验，为了记录下自己的debug心得和为后来者提供一些建议，所以写下此博客，不足之处，望多多指正</p>
<span id="more"></span>
<h1 id="初期准备">初期准备</h1>
<h2 id="系统选择">系统选择</h2>
<p>尽可能选择Linux系统，因为大部分论文实验都是在Linux系统下操作开发，可能到Windows系统上会有一些“水土不服”（别问我是怎么知道的。。。） 推荐租云服务器:便宜的服务器平台：<a href="https://www.autodl.com/home">AutoDL</a>[应该是市面上最便宜的，学生认证有优惠] 免费的服务器平台：<a href="https://colab.research.google.com/">Google Colab</a>[12小时会自动断开，不过免费，分配的卡也还不错！] 如果自己电脑显卡较好且内存充足，可以选择装虚拟机后显卡直通或装双系统，其中显卡直通笔者没试过，装双系统有点折磨，且不太方便（两个系统不能同时在线）</p>
<h2 id="深度学习环境配置">深度学习环境配置</h2>
<p>这里网上教程很多，这里推荐一个我当时配的参考博客： <a href="https://www.cnblogs.com/LXP-Never/p/15151578.html#blogTitle0">凌逆战的博客</a></p>
<h1 id="具体实操">具体实操</h1>
<p>这里我以当时我配的CVPR2020 best paper（Unsupervised Learning of Probably Symmetric Deformable 3D Objects from Images in the Wild）举例： 首先打开论文查看论文代码位置： <img src="https://s2.loli.net/2023/03/05/a7ELmUqVIp4ZPxe.png" alt="训练tips_1.png"> 点击代码位置后在GitHub中下载代码 然后根据项目处的readme文件按步骤一步步配置 Tips：请注意创建虚拟环境，详细请看<a href="https://blog.csdn.net/SARACH_WONG/article/details/89328307">conda创建环境</a> 通过创建环境我们可以在一台主机上同时配上不同实验的实验环境并进行训练</p>
]]></content>
      <categories>
        <category>AI笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/03/19/Linux-%E6%89%BE%E5%9B%9Eroot%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="linux-centos7.6找回root密码">Linux-centos7.6找回root密码</h1>
<p>说来话长，笔者在某个晴朗的周六早晨进行了root密码找回的测试，本以为是一个依葫芦画瓢的操作，没想到却折磨了笔者一个上午的时间去完成，话不多说，直接上步骤</p>
<span id="more"></span>
<p>在开机出现如下界面时，快按e键(只有五秒停留时间，速度，不然就要进登录界面了)： <img src="https://s2.loli.net/2022/03/26/i6Df2velR4hAqad.png" alt="image-33.png"> 2. 在步骤一按下”e”键之后，出现如下界面，按 ↓键一直到底部找到“LANG=zh_CN.UTF-8”这句，在这句后面加上“init=/bin/sh”,然后按Ctrl+x进入单用户。 <img src="https://s2.loli.net/2022/03/26/wvr8bVFBCN9SGad.png" alt="image-35.png"> 3. 挂载文件系统为可写模式：mount –o remount,rw /(rw 后两个空格，一定要按步骤来) <img src="https://s2.loli.net/2022/03/26/blj4R9o8Pe7JMUm.png" alt="image-34.png"> 4. 执行passwd命令，修改root密码，密码要输入两次要求两次密码要一致。(你刚相信，我失败多次的原因之一在passwd后面没加root) <img src="https://s2.loli.net/2022/03/26/WhUlDFGXJ6SKIN5.png" alt="image-36.png"> 5. 如果之前系统启用了selinux，必须执行以下命令，否则将无法正常启动系统：touch /.autorelabel。然后执行命令exec /sbin/init来正常启动，或者用命令exec /sbin/reboot重启就OK了。</p>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin学习</title>
    <url>/2022/05/08/Gin%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="gin框架简介">00 Gin框架简介</h2>
<p>Gin是一个用Go语言编写的web框架，是一个拥有良好性能的API框架，其性能非常好，是GO世界里最流行的web框架，是一个简单易用的轻量级框架</p>
<span id="more"></span>
<h2 id="gin框架安装与使用">01 Gin框架安装与使用</h2>
<h3 id="安装">安装</h3>
<p>下载并安装Gin：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>
<h3 id="第一个gin实例">第一个Gin实例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    // 创建一个默认的路由引擎</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    // GET: 请求方式；/hello: 请求的路径</span><br><span class="line">    // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span><br><span class="line">    r.GET(&quot;/hello&quot;,func(c *gin.Context)&#123;</span><br><span class="line">        // c.JSON: 返回JSON格式的数据</span><br><span class="line">        c.JSON(200,gin.H&#123;</span><br><span class="line">            &quot;message&quot;:&quot;Hello world!&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    // 启动HTTP服务，默认在0.0.0.0：8080启动服务</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码保存并编译执行，<strong>注意</strong>：把终端切到文件目录下再执行，然后使用浏览器打开127.0.0.1：8080/hello就能看到一串JSON字符串</p>
<h2 id="restful-api">02 RESTful API</h2>
<p>REST代表一种软件架构风格，是Representational State Transfer的简称 简单来说，REST的含义就是客户端与web服务器之间进行交互时，使用HTTP协议中的四个请求方法代表不同的动作。</p>
<ul>
<li>GET用来获取资源</li>
<li>POST用来新建资源</li>
<li>PUT用来更新资源</li>
<li>DELETE用来删除资源 只要API程序遵循了REST风格，那就可以将其称为RESTful API。目前在前后端分离的架构中，前后端基本上都是通过RESTful API来进行交互 现在我们举一个编写管理书籍系统的例子，该系统可以进行对一本书进行查询，创建，更新，删除等操作，如果我们按照RESTful API设计，就如下表所示| 请求方法 | URL | 含义 | | -------- | ----- | ------------ | | GET | | 获取书籍信息 | | POST | | 新建书籍信息 | | PUT | | 更新书籍信息 | | DELETE | | 删除书籍信息 |</li>
</ul>
<h3 id="实例代码">实例代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;GET&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;POST&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.PUT(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;PUT&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.DELETE(&quot;/book&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;DELETE&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gin渲染">03 Gin渲染</h2>
<h3 id="html渲染">HTML渲染</h3>
<p>我们首先定义一个存放模板文件的templates文件夹，然后在其内部根据业务分别定义一个posts文件夹和一个users文件夹 其中posts/index.html文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;posts/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;posts/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>users/index.html文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;users/index.html&quot;&#125;&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;users/index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLGlob(&quot;templates/**/*&quot;)</span><br><span class="line">	//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)</span><br><span class="line">	r.GET(&quot;/posts/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;posts/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(&quot;users/index&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H&#123;</span><br><span class="line">			&quot;title&quot;: &quot;users/index&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(&quot;:8080&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>互联网技术</tag>
      </tags>
  </entry>
  <entry>
    <title>A Survey of Positional Encoding in Transformer</title>
    <url>/2024/09/16/A-Survey-of-Positional-Encoding-in-Transformer/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>与RNN、CNN等模型不同，Transformer模型中用到的attention机制无法捕捉输入顺序，这导致其无法区分不同位置的Token，因此我们需要额外引入<strong>位置信息</strong>到Transformer中，这也就引发了研究者们对位置编码的研究，具体而言，位置编码大体上可以分为以下几类：</p>
<ul>
<li>绝对位置编码： 直接将位置信息以某种方式编码成向量，加入到输入中。</li>
<li>相对位置编码： 对Attention结构进行微调，使其有能力辨别不同位置的Token</li>
<li>其他位置编码： 包括相对位置编码和绝对位置编码的混合使用等其他不同寻常的位置编码</li>
</ul>
<p>此外，对于位置编码而言，其长度外推性也是一个十分重要的考量，在此我们将单开一个章节讨论各种位置编码的长度外推性。</p>
<span id="more"></span>
<h2 id="absolute-position-embedding">Absolute Position Embedding</h2>
<p>从形式上来看，绝对位置编码是相对实现起来较为简单的方案，一般来说，绝对位置编码会被加入到输入中。即在输入的第<span class="math inline">\(k\)</span>个向量<span class="math inline">\(x_k\)</span>中加入位置向量<span class="math inline">\(p_k\)</span>，即<span class="math inline">\(x_k&#39; = x_k + p_k\)</span>。具体而言，绝对位置编码还可以分为以下几个小类</p>
<h3 id="训练式">训练式</h3>
<p>最简单的方法是不进行特意设计位置编码，而是直接将位置编码可作为可训练参数，与模型其他参数一起，在训练过程中更新。这种方法因为其简单的实现方法往往应用较广，BERT,GPT等语言模型都是用这种方法。视觉里面的许多模型也使用这种方法，例如Mage, MAE , MAR等我们较为关注的掩码自回归模型等。</p>
<p>对于训练式位置编码，虽然其简单易实现，但是其最大的缺点是其没有外推性，即如果预训练最大长度为512时，那么在推理的时候，模型也就最多只能处理长度为512的序列。但也并非绝对，在苏神的博客<a href="https://kexue.fm/archives/7947">层次分解位置编码，让BERT可以处理超长文本</a>中，提出了通过使用层次分解位置编码，让BERT可以处理超长文本。其核心思路是通过层次分解，在已训练好的绝对位置编码向量上，通过线性插值的方式，得到新的位置编码向量。这样一来能实现在原来的参数基础上，能表示<span class="math inline">\(n^2\)</span>的长度编码，且前n个位置编码与原编码相容。</p>
<h3 id="三角式">三角式</h3>
<p>三角式绝对位置编码，则是在Transformer原文<a href="https://papers.cool/arxiv/1706.03762">《Attention is all you need》</a>中提出的显式解，其公式表达为： <span class="math display">\[\begin{cases}
    p_{k,2i} = sin(\frac{k}{10000^{2i/d}}) \\
    p_{k,2i+1} = cos(\frac{k}{10000^{2i/d}})
\end{cases}\qquad(1)\]</span></p>
<p>其中<span class="math inline">\(d\)</span>为位置向量的维度，<span class="math inline">\(k\)</span>为位置索引，<span class="math inline">\(i\)</span>为维度索引。</p>
<p>三角式位置编码的特点是拥有显式生成规律，其具有一定的外推性，另外得益于三角函数的性质，位置<span class="math inline">\(\alpha+\beta\)</span>的向量可表示为位置为<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>的向量的线性组合，这使得三角函数天生具有相对位置计算的性质。可惜的是这类绝对位置编码最近很少使用，<strong>待考证其原因。</strong></p>
<h3 id="递归式">递归式</h3>
<p>在递归式绝对位置编码中，其往往实现为在输入之后衔接一层RNN，然后再接Transformer,那么其在结构上就有了通过RNN学习到位置信息的可能，比如从一个向量<span class="math inline">\(p_0\)</span>开始，通过<span class="math inline">\(p_{k+1} = f(p_k)\)</span>得到位置<span class="math inline">\(k+1\)</span>的位置向量，在ICML2020的论文<a href="https://papers.cool/arxiv/2003.09229">《Learning to Encode Position for Transformer with Continuous Dynamical Model》</a>中，作者提出用微分方程建模位置编码，<span class="math inline">\(dp_t/d_t=h(p_t,t)\)</span>，并使用神经网络来拟合<span class="math inline">\(h(p_t)\)</span>，从而得到位置向量。此方法也被称为<strong>FLOATER</strong>。</p>
<h2 id="relative-position-embedding">Relative Position Embedding</h2>
<p>与绝对位置编码不同的是，相对位置编码并没有完整的去建模每个输入的位置信息，而是在计算Attention的时候考虑了当前位置和被attention的位置的相对距离，对于相对位置编码来说，其实现上可能相较绝对位置编码更为复杂，但是其可解释性和灵活性更强。</p>
<h3 id="经典式">经典式</h3>
<p>相对位置编码起源于Google论文<a href="https://papers.cool/arxiv/1803.02155">《Self-Attention with Relative Position Representations》</a>，后面的各种相对位置编码变体基本上也是在此基础上的不同修改。</p>
<p>一般认为，相对位置编码是从绝对位置编码启发而来，考虑一般的带绝对位置编码的Attention: <span class="math display">\[\begin{cases}
    q_i = (x_i + p_i)W_Q \\
    k_j = (x_j + p_j)W_K \\
    v_j = (x_j + p_j)W_V \\
    a_{i,j} = softmax(q_i k_j^T) \\
    o_i = \sum_{j} a_{i,j} v_j
\end{cases}\qquad(2)\]</span></p>
<p>在此处，初步展开<span class="math inline">\(q_ik_j^T\)</span>，有： <span class="math display">\[q_ik_j^T = (x_i + p_i)W_Q(x_j + p_j)^TW_K^T = (x_iW_Q+p_iW_Q)(W_K^Tx_j^T+W_K^Tp_j^T)\qquad (3) \]</span></p>
<p>为了引入相对位置信息，Google将第一项位置去掉，第二项<span class="math inline">\(p_jW_K^T\)</span>保留，并将其记为<span class="math inline">\(R_{i-j}\)</span>，即： <span class="math display">\[a_{i,j}=softmax(x_iW_Q(x_jW_K+R_{i,j}^K)^T)\qquad(4)\]</span> 并将<span class="math inline">\(o_i\)</span>表达式中的<span class="math inline">\(p_jW_v\)</span>替换为<span class="math inline">\(R_{i,j}^V\)</span>，即： <span class="math display">\[o_i = \sum_{j} a_{i,j} (x_jW_V+R_{i,j}^V)\qquad(5)\]</span></p>
<p>替代的向量<span class="math inline">\(R_{i,j}^K\)</span>和<span class="math inline">\(R_{i,j}^V\)</span> 通常是只依赖与相对距离<span class="math inline">\(i-j\)</span>,并会进行截断以适应不同的距离 <span class="math display">\[R_{i,j}^K = p_K[clip(i-j,p_{min},p_{max})]\\
R_{i,j}^V = p_V[clip(i-j,p_{min},p_{max})]\qquad(6)\]</span></p>
<p>这样就通过有限个位置编码实现了表达任意长度的相对位置(因为进行了截断操作)。</p>
<h3 id="xlnet式">XLNET式</h3>
<p>XLNET式源自Transformer-XL<a href="https://papers.cool/arxiv/1901.02860">《Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context》</a>，其源自于对上面的<span class="math inline">\(q_ik_j^T\)</span>的完全展开： <span class="math display">\[q_ik_j^T = x_iW_QW_K^T x_j^T+x_iW_QW_K^Tp_j^T+p_iW_QW_K^Tx_j^T+p_iW_QW_K^Tp_j^T\qquad(7)\]</span></p>
<p>Transformer-XL的做法是直接将上式的<span class="math inline">\(p_j\)</span>替换为相对位置向量<span class="math inline">\(R_{i-j}\)</span>，两个<span class="math inline">\(p_i\)</span>则直接替换为两个可训练的向量<span class="math inline">\(u,v\)</span>: <span class="math display">\[x_iW_QW_K^Tx_j^T+x_iW_QW_{K,R}^TR_{i-j}^T+uW_K^Tx_j^T+vW_{K,R}^TR_{i-j}^T\qquad(8)\]</span></p>
<p>此外，<span class="math inline">\(v_j\)</span>上的位置偏置就直接去掉了，直接令<span class="math inline">\(o_i=\sum_ja_{i,j}x_jW_V\)</span>，从此工作后，后面的相对位置编码工作都只加到Attention矩阵而不加到<span class="math inline">\(v_j\)</span>上去了。</p>
<h3 id="t5式">T5式</h3>
<p>T5式相对位置编码源自于T5<a href="https://papers.cool/arxiv/1910.10683">《Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer》</a>，里面对展开式(7)进行了更详细的含义划分，其分别理解为"输入-输入"，"输入-位置"，"位置-输入"，"位置-位置"四项注意力组合，其认为输入信息和位置信息应该是独立的，那么"输入-位置"和"位置-输入"的注意力可以删掉 而其实位置-位置的注意力是一个只依赖于<span class="math inline">\((i,j)\)</span>的标量，可以直接作为参数训练出来，即简化为 <span class="math display">\[x_iW_QW_K^Tx_j^T=\beta_{i,j}\qquad(9)\]</span></p>
<p>也就是其只是在Attention矩阵的基础上加一个可训练的偏置项<span class="math inline">\(\beta_{i,j}\)</span> 就实现了相对位置编码。</p>
<h3 id="deberta式">DeBERTa式</h3>
<p>DeBERTa式相对位置编码源自于DeBERTa<a href="https://papers.cool/arxiv/2006.03654">《DeBERTa: Decoding-enhanced BERT with Disentangled Attention》</a>，其也是从展开式(7)出发，但是其丢弃的是第四项位置-位置注意力，保留第2、3项并且替换为相对位置编码 <span class="math display">\[q_ik_j^T = x_iW_QW_K^Tx_j^T+x_iW_QW_K^TR_{i,j}^T+R_{j,i}W_QW_{K}^Tx_{j}^T\qquad(10)\]</span></p>
<h2 id="other-position-embedding">Other Position Embedding</h2>
<h3 id="复数式">复数式</h3>
<p>该想法来自论文<a href="https://openreview.net/attachment?id=Hke-WTVtwr&amp;name=original_pdf">《Encoding word order in complex embeddings 》</a>。其使用复数域词向量编码词序，是第一个将复数的虚部域具体含义(词序)联系起来的工作。其推导出了复数域的词向量形式： <span class="math display">\[f(j,pos)=[r_{j,1}e^{i(w_{j,1}pos+\theta_{j,1})},\dots,r_{j,2}e^{i(w_{j,2}pos+\theta_{j,2})},\dots,r_{j,D}e^{i(w_{j,D}pos+\theta_{j,D})}]\qquad(11)\\r_j:振幅,w_j:角频率，\theta_j：初相位\]</span></p>
<p>复数词向量的振幅<span class="math inline">\(r_j\)</span>只与词<span class="math inline">\(w_j\)</span>有关，对应token embedding。 角频率<span class="math inline">\(w_j\)</span>可以表示词对位置的敏感程度，角频率越小对位置越不敏感，但其缺点在于因为需要维护振幅、角频率和初相位，参数量相当于三倍</p>
<h3 id="rope">RoPE</h3>
<p>RoPE由苏剑林老师在<a href="https://arxiv.org/pdf/2104.09864">《ROFORMER: ENHANCED TRANSFORMER WITH ROTARY POSITION EMBEDDING》</a>中提出，其将绝对位置编码和相对位置编码融为一体。简单来说其对attention里面的向量内积先用复数表示为: <span class="math display">\[&lt;q_m,k_n&gt;=Re[q_mk_n^*]\qquad(12)\]</span> 进一步将<span class="math inline">\(q_m,k_n\)</span>分别乘以<span class="math inline">\(e^{im\theta},e^{in\theta}\)</span>变为<span class="math inline">\(q_me^{im\theta},k_ne^{in\theta}\)</span>,然后放到内积变为: <span class="math display">\[&lt;q_me^{im\theta},k_ne^{in\theta}&gt;=Re[q_mk_n^*e^{i(m-n)\theta}]\qquad(13)\]</span> 上式就得出了内积只依赖于相对位置<span class="math inline">\(m-n\)</span>的结论，巧妙地将绝对位置和相对位置结合到一起。 这样一来，我们得到了二维情况下用复数表示的RoPE: <span class="math display">\[f(q,m)=R_f(q,m)e^{i\theta_f(q,m)}=||q||e^{i(\theta(q)+m\theta)}\qquad(14)\]</span> 还可以将其写为矩阵形式： <span class="math display">\[f(q,m)=\begin{pmatrix}
    cos m\theta &amp; -sin m\theta \\
    sin m\theta &amp; cos m\theta \\
\end{pmatrix}\begin{pmatrix}
    q_0\\
    q_1
\end{pmatrix}\qquad(15)\]</span></p>
<p>其优势是通过绝对位置编码的方式实现了相对位置编码，现在得到了广泛使用</p>
<h2 id="length-extrapolation">Length Extrapolation</h2>
<p>长度外推一般指的是不需要用长序列数据进行额外的训练，只用短序列语料对模型进行训练，就可以得到一个能够处理和预测长序列的模型。但是值得注意的是长度外推不能以牺牲远程依赖为代价，这样还不如直接截断文本进行生成。</p>
<p>在长度外推问题中，遇到的主要问题有以下两点： 1. 预测时用到了没有被训练过的位置编码 2. 预测时注意力机制所处理的tokens数量远超训练时的数量</p>
<p>事实上，对于相对位置编码的Transformer可以通过简单的Attention Mask一次性解决上述问题，并取得解决SOTA的效果。其具体操作时将预测时的attention变为局部attention, 每个token只看到训练长度个token 且此时的局部attention也不会比训练时使用更多的位置编码, 这样就一次性解决了上面的问题，且不用重新训练模型。</p>
<h3 id="alibi">ALIBI</h3>
<p>ALIBI是第一篇明确研究Transformer长度外推性的工作，其出自论文<a href="https://papers.cool/arxiv/2108.12409">《Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation》</a>。它主要是在Softmax之前，将attention的计算从<span class="math inline">\(q_m^Tk_n\)</span>改为 <span class="math display">\[q_m^Tk_n-\lambda|m-n|\qquad (16)\]</span> ALIBI相较于上面用attention mask解决长度外推问题的基线模型，减去的非负矩阵更光滑 <img src="/2024/09/16/A-Survey-of-Positional-Encoding-in-Transformer/2024-09-18-15-58-00.png"> 但是从(16)中可以看出ALIBI是只能辨别相对距离远近，而无法正确识别位置信息的,因为<span class="math inline">\(|m-n|=|n-m|\)</span>。其主要是在单项语言模型上效果较好，因为单项语言模型不加位置编码也能取到较好效果</p>
<h3 id="kerple">KERPLE</h3>
<p>KERPLE来自论文<a href="https://papers.cool/arxiv/2205.09921">《KERPLE: Kernelized Relative Positional Embedding for Length Extrapolation》</a>,是ALIBI的简单推广，引入了两个训练参数<span class="math inline">\(r_1,r_2\)</span>来一般化式(16): <span class="math display">\[\begin{cases}
    q_m^Tk_n-r_1|m-n|^{r_2},\qquad r_1&gt;0,0&lt;r_2\le2\\
    q_m^Tk_n-r_1log(1+r_2|m-n|),\qquad r_1,r_2&gt;0\\
\end{cases}\qquad(17)\]</span></p>
<p>其既完成了一般化又有可训练参数</p>
<h3 id="sandwich">Sandwich</h3>
<p>Sandwich出自论文<a href="https://papers.cool/arxiv/2212.10356">《Dissecting Transformer Length Extrapolation via the Lens of Receptive Field Analysis》</a>，将式(16)替换为 <span class="math display">\[q_m^Tk_n+\lambda p_m^Tp_n\qquad(18)\]</span> 其中<span class="math inline">\(p_m,p_n\)</span>是Sinusoidal 位置编码，<span class="math inline">\(\lambda&gt;0\)</span>是超参数</p>
<h3 id="xpos">XPOS</h3>
<p>XPOS出自论文<a href="https://papers.cool/arxiv/2212.10554">A Length-Extrapolatable Transformer</a>, 其是对RoPE的推广： <span class="math display">\[RoPE:q_m\rightarrow R_mq_m, k_n\rightarrow R_nk_n\qquad XPOS: q_m\rightarrow R_mq_m\xi^m,k_n\rightarrow R_nk_n\xi^{-n}\qquad(19)\]</span> 这样一来attention的计算变为 <span class="math display">\[q_m^Tk_n=q_m^TR_{n-m}k_n\xi^{m-n}\qquad(20)\]</span> 最后的结果只依赖于相对位置<span class="math inline">\(m-n\)</span>,但其指数部分是<span class="math inline">\(m-n\)</span>而非绝对值，导致其总有一边是发散的</p>
<h3 id="基于rope的长度外推">基于RoPE的长度外推</h3>
<p>最近一年内，大部分的LLM的长度外推新工作都集中在研究基于RoPE的长度外推，其备受推崇的原因在于： 1. RoPE不带显示的远程衰减，这对于旨在Long Context的模型至关重要 2. RoPE是一种真正的位置编码，通过不同频率的三角函数有效区分长程短程，达到了类似层次位置编码的效果 3. RoPE直接作用于Q、K，不改变Attention形式，与Flash Attention更契合，更容易Scale Up</p>
<h4 id="pi">PI</h4>
<p>PI(Positional Interpolation) 由Meta在论文<a href="https://papers.cool/arxiv/2306.15595">《Extending Context Window of Large Language Models via Positional Interpolation》</a>提出，其通过位置内插的方法将预测长文本的位置编码乘上放缩因子<span class="math inline">\(\frac{L_{train}}{L_{test}}\)</span>缩放到训练长度内，但其缺点是会压缩临近Token的距离，扰乱局部分辨率，但其优势在于可以通过微调快速弥补此处的问题，适用于做模型初始化后做进一步微调得到长文本模型。</p>
<h4 id="leaky-rerope-and-rerope">Leaky ReRoPE and ReRoPE</h4>
<p>直接外推的问题是远处越界，位置内插的问题是局部失真，Leaky ReRoPE和ReRoPE通过先设定一个窗口大小<span class="math inline">\(w\)</span>,再将相对位置分为两部分，在窗口不改变相对位置实现"局部不失真"，在窗口外使用位置内插实现"远处不越界" <img src="/2024/09/16/A-Survey-of-Positional-Encoding-in-Transformer/2024-09-18-16-43-38.png"></p>
<p>如果将内插因子<span class="math inline">\(k\)</span>取到无穷大，即可得到极简的ReRoPE，在窗口外的位置编码都变为<span class="math inline">\(w\)</span>,则其对任意长的序列都不会越界，但问题在于二者的实现稍微麻烦，因为二者的相对位置是分段线性的，所以朴素实现需要算两次Attention矩阵后再拼接</p>
<h4 id="ntk-rope">NTK-RoPE</h4>
<p>NTK-RoPE的思路是将原本是<span class="math inline">\(\theta_i=10000^{-2i/d}\)</span>,现在改为了<span class="math inline">\(\theta_i=(10000k)^{-2i/d}\)</span>,<span class="math inline">\(k\)</span>的取值是通过令<span class="math inline">\(i=d/2-1\)</span>时的Scale正好等于内插Scale<span class="math inline">\(\frac{L_{train}}{L_{test}}\)</span>,求解得出<span class="math inline">\(k=(\frac{L_{test}}{L_{train}})^{d/(d-2)}\)</span></p>
<h4 id="yarn">YaRN</h4>
<p>YaRN出自<a href="https://papers.cool/arxiv/2309.00071">《 YaRN: Efficient Context Window Extension of Large Language Models》</a>，是一种免训练长度外推方案，其只改变<span class="math inline">\(\theta_i\)</span>的值，不改变Attention和RoPE形式，所以不会有额外的实现成本和推理成本，其可用公式表达为： <span class="math display">\[\theta_i^{new}=[\gamma_i+(1-\gamma_i)\frac{L_{train}}{L_{test}}]\theta_i,\gamma_i=\begin{cases}
    1,\qquad r_i&gt;\tau\\
    0,\qquad r_i&lt;1\\
    \frac{r_i-1}{\tau-1}.\qquad others
\end{cases}\qquad(21)\]</span> <img src="/2024/09/16/A-Survey-of-Positional-Encoding-in-Transformer/2024-09-18-19-20-15.png"> YaRN认为较大的较大的<span class="math inline">\(\theta_i\)</span>意味着转速越快，周期越短，于是在<span class="math inline">\(m−n\)</span>从0到<span class="math inline">\(L_{train}−1\)</span>期间，它已经被转了很多圈，也就是说圆上的每一个点几乎都被训练过，因此这些<span class="math inline">\(\theta_i\)</span>几乎不存在OOD问题；相反，对于较小的<span class="math inline">\(\theta_i\)</span>，当<span class="math inline">\(m−n\)</span>从<span class="math inline">\(0\)</span>到<span class="math inline">\(L_{train}−1\)</span>时它可能还没转完一圈，这种情况下被训练过的点顶多只是圆上的一条弧，如果测试时遇到更大的<span class="math inline">\(L_{test}\)</span>，那么就超出了训练过的弧范围，从而有无法预估的表现，这时候就需要通过内插将它压缩到原本的弧内。</p>
<p>具体到上面的公式中的<span class="math inline">\(\theta_i\)</span>,可以算出周期为<span class="math inline">\(T_i=2\pi/\theta_i\)</span>,然后定义训练时所转的“圈数”为<span class="math inline">\(r_i=\frac{\theta_iL_{train}}{L_{test}}\)</span>,再设一个阈值<span class="math inline">\(\tau\)</span>区分是否充分训练 二者间线性插值过渡即可得出上述推导</p>
<h4 id="dynamic-scaling">Dynamic Scaling</h4>
<p>上面提到的免训练长度外推方法，都无法使得模型在训练长度<span class="math inline">\(L_{train}\)</span>内的效果保持不变,一般的解决方法时随着训练长度变化动态调整各个外推方法的Scale因子，这就是<strong>Dynamic Scaling</strong></p>
<p>以YaRN为例，里面与长度相关的缩放因子是<span class="math inline">\(s=\frac{L_{test}}{L_{train}}\)</span>, Dynamic Scaling将其换为动态的<span class="math inline">\(s(pos)=\frac{max(L_{train},pos+1)}{L_{train}}\)</span>, 其中pos是当前token的位置编号，这个改动意味着Dynamic Scaling试图为每个位置找到最小的、理论上对模型效果影响也最小的Scale因子</p>
<h2 id="reference">Reference</h2>
<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/626828066">【OpenLLM 009】大模型基础组件之位置编码-万字长文全面解读LLM中的位置编码与长度外推性（上）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/629015933">【OpenLLM 010】大模型基础组件之位置编码-万字长文全面解读LLM中的位置编码与长度外推性（ 中）</a></li>
<li>苏剑林. (Mar. 23, 2021). 《Transformer升级之路：2、博采众长的旋转式位置编码 》[Blog post]. Retrieved from https://kexue.fm/archives/8265</li>
<li>苏剑林. (Feb. 03, 2021). 《让研究人员绞尽脑汁的Transformer位置编码 》[Blog post]. Retrieved from https://kexue.fm/archives/8130</li>
<li>苏剑林. (Jan. 26, 2024). 《Transformer升级之路：16、“复盘”长度外推技术 》[Blog post]. Retrieved from https://kexue.fm/archives/9948</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>计算机视觉</category>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>pr-learn</title>
    <url>/2022/02/01/PR/</url>
    <content><![CDATA[<h2 id="新手村">新手村</h2>
<h3 id="从pr的最简工作流讲起">01-从pr的最简工作流讲起</h3>
<ol type="1">
<li>pr的用途： pr是一款用于视频段落的组合和拼接，并提供一定特效和调色功能</li>
<li>项目窗口： 用于储存视频，音频，图片，序列等素材</li>
<li>序列窗口： 用于编辑音频，视频，可以多个轨道同时编辑</li>
<li>预览窗口： 用于实时预览时间线上的素材效果。</li>
<li>效果控件窗口 可以对素材的基本属性做出调整，也可以调整添加在素材上的效果参数</li>
<li>效果窗口： pr中需要用到的各种自带的效果</li>
<li>pr工作流程：
<ol type="1">
<li>素材窗口中导入素材</li>
<li>新建序列</li>
<li>通过剃刀工具（C）对素材进行裁剪</li>
<li>通过选择工具（V）对素材进行选择并删除</li>
<li>通过拼接完成对素材的剪辑</li>
<li>渲染输出成片</li>
</ol></li>
</ol>
<span id="more"></span>
<h3 id="剪辑多素材如何标记出入点">02-剪辑多素材如何标记出入点</h3>
<h4 id="导入素材">导入素材</h4>
<ol type="1">
<li>熟悉素材，选取合适的音乐</li>
<li>将素材和音乐导入pr素材窗口中</li>
</ol>
<h4 id="剪辑流程">剪辑流程</h4>
<ol start="3" type="1">
<li>反复感受音乐，对音乐做一个节奏和情绪上的区分</li>
<li>选取偏努力的和刻苦一些的素材，在素材窗口中，选取出入点，截取合适的段落，将素材拖到视频轨道上</li>
<li>对于前半段音乐节奏比较快的地方，选取的素材相应的要短一些，剪辑点可以密一些</li>
<li>选取成功，胜利一类的素材，放在音乐后半段</li>
<li>反复感受音乐节奏，可以在音乐有大的节拍的地方，将剪辑点对齐</li>
<li>反复预览视频，使视频剪辑点和音乐更契合</li>
<li>导出视频</li>
</ol>
<h4 id="寻找剪辑点干货">寻找剪辑点（干货）</h4>
<ol type="1">
<li><p>空格键Space播放和暂停</p></li>
<li><p>Left Right键 ：向前向后一帧 （比较细致，可以一直按，这样速度快一点）</p></li>
<li><p>shift+Left Right键：向前向后五帧（这个比较快）</p></li>
<li><p>J 左穿梭/倒放 K 停止穿梭 L 右穿梭/正放</p></li>
<li><p>Shift + L 慢速右穿梭 Shift + J 慢速左穿梭</p></li>
<li><p>穿梭键如果连按，可以加速，K和Space都可以停止播放 时间线窗口中时间帧的管理</p></li>
<li><p>End 跳转到序列-素材结束点 Home 跳转到序列-素材开始点 Shift + End 跳转到所选素材结束点 Up 跳转上一个编辑点 Down 跳转下一个编辑点</p></li>
<li><p>i o:设出入点 Shift + I 跳转入店 Shift + O 跳转出点 ‘ 提取 ， 插入 . 覆盖</p></li>
</ol>
<h3 id="如何制作抽帧卡点">03-如何制作抽帧/卡点</h3>
<h4 id="卡点操作">卡点操作：</h4>
<ol type="1">
<li>试听音乐，找出音乐中的卡顿点，即变化很大的点，然后标记他 #### 抽帧操作</li>
<li>对已经标记的卡顿点，然后将其后面一部分删掉，把再后面的往前面拖，这样就可以营造出卡点抽帧的效果来</li>
</ol>
<h3 id="如何添加字幕">04-如何添加字幕</h3>
<p>下载ARCTIMEPRO</p>
<h3 id="鬼畜视频基础制作倍速加重复">05-鬼畜视频基础制作（倍速加重复）</h3>
<p>鬼畜的最基本操作就是把某个搞笑的片段重复的，以较快的倍速播放，还可以设置倒放等操作</p>
<h3 id="常见操作键">06-常见操作键</h3>
<figure>
<img src="https://s2.loli.net/2022/02/11/2EfkAIH5lo8Uu1z.jpg" alt="v2-58c3473d36a4622235aa0eda5ca1de7c_r.jpg"><figcaption aria-hidden="true">v2-58c3473d36a4622235aa0eda5ca1de7c_r.jpg</figcaption>
</figure>
]]></content>
      <categories>
        <category>PR&#39;s area</category>
      </categories>
  </entry>
  <entry>
    <title>mips</title>
    <url>/2023/05/15/mips/</url>
    <content><![CDATA[<h1 id="华中科技大学模拟与电路系统三实验汇总">华中科技大学模拟与电路系统（三）实验汇总</h1>
<h2 id="并行io接口实验">并行IO接口实验</h2>
<h3 id="实验任务">实验任务</h3>
<p>嵌入式计算机系统将独立按键以及独立开关作为输入设备，七段数码管作为输出设备。实现以下功能：</p>
<span id="more"></span>
<ol type="1">
<li><p>点击BTNC 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该二进制数的低8 位对应的二进制数值0 或1 显示到8 个七段数码管上。</p></li>
<li><p>点击BTNU 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该16 进制数据各位数字对应的字符0~F 显示到低4 位七段数码管上（高4 位七段数码管不显示）。</p></li>
<li><p>点击BTND 按键时，计算机读入一组16 位独立开关状态作为一个二进制数据，并将该数据表示的无符号十进制数各位数字对应的字符0~9 显示到低5 位七段数码管上（高3 位七段数码管不显示）。</p></li>
</ol>
<p>程序控制方式提示：程序以七段数码管动态显示控制循环为主体，在循环体内的延时函数内循环读取按键键值以及开关状态，并根据按键值做相应处理。</p>
<h3 id="实验源码">实验源码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;xil_io.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;xgpio.h&quot;</span><br><span class="line">#include &quot;sleep.h&quot;</span><br><span class="line">#include &quot;xtmrctr.h&quot;</span><br><span class="line">#include &quot;xintc_l.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char button = 0x0;</span><br><span class="line">    char segtable[16]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e&#125;;</span><br><span class="line">    short segcode[8]=&#123;0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff&#125;;</span><br><span class="line">    short pos=0xff7f;</span><br><span class="line">    Xil_Out16(XPAR_GPIO_0_BASEADDR+XGPIO_TRI_OFFSET,0xffff);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI_OFFSET,0X0);</span><br><span class="line">    Xil_Out16(XPAR_GPIO_1_BASEADDR+XGPIO_TRI2_OFFSET,0x0);</span><br><span class="line">    Xil_Out8(XPAR_GPIO_2_BASEADDR+XGPIO_TRI_OFFSET,0x1f);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        while((Xil_In8(XPAR_GPIO_2_BASEADDR+XGPIO_DATA_OFFSET)&amp;0X1f)!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            button = Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f;</span><br><span class="line">            short sw = Xil_In16(XPAR_GPIO_0_BASEADDR+XGPIO_DATA_OFFSET);</span><br><span class="line">			while((Xil_In8(XPAR_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET)&amp;0x1f)!=0);</span><br><span class="line">            switch (button)</span><br><span class="line">            &#123;</span><br><span class="line">            case 0x1:</span><br><span class="line">                for(int j=0;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;j)&amp;0x1];</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x2:</span><br><span class="line">                    for(int j=0;j&lt;4;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=segtable[(sw&gt;&gt;(4*j))&amp;0xf];</span><br><span class="line">                    &#125;</span><br><span class="line">                    for(int j=4;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 0x10:</span><br><span class="line">                int a=sw;</span><br><span class="line">                for(int j=0;j&lt;5;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    switch (a%10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            case(0):segcode[7-j]=segtable[0];break;</span><br><span class="line">                            case(1):segcode[7-j]=segtable[1];break;</span><br><span class="line">                            case(2):segcode[7-j]=segtable[2];break;</span><br><span class="line">                            case(3):segcode[7-j]=segtable[3];break;</span><br><span class="line">                            case(4):segcode[7-j]=segtable[4];break;</span><br><span class="line">                            case(5):segcode[7-j]=segtable[5];break;</span><br><span class="line">                            case(6):segcode[7-j]=segtable[6];break;</span><br><span class="line">                            case(7):segcode[7-j]=segtable[7];break;</span><br><span class="line">                            case(8):segcode[7-j]=segtable[8];break;</span><br><span class="line">                            case(9):segcode[7-j]=segtable[9];break;</span><br><span class="line">                        &#125;    </span><br><span class="line">                    &#125;</span><br><span class="line">                    a/=10;</span><br><span class="line">                &#125;</span><br><span class="line">                    for(int j=5;j&lt;8;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        segcode[7-j]=0xff;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;                </span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;8;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA_OFFSET,pos);</span><br><span class="line">        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR+XGPIO_DATA2_OFFSET,segcode[i]);</span><br><span class="line">        for(int j=0;j&lt;10000;j++);</span><br><span class="line">        pos=pos&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    pos=0xff7f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>jittor与pytorch的区别一览</title>
    <url>/2024/01/14/jittor%E4%B8%8Epytorch%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%80%E8%A7%88/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最近在完成一个利用Jittor复现GaussianSplatting的项目，里面用到了清华大学自主开发的深度学习框架jittor，因为GaussianSplatting官方代码是基于Pytorch和CUDA，所以复现过程中遇到了许许多多的问题，这里记录一下，希望能对读者有所帮助</p>
<span id="more"></span>
<h2 id="jittor安装问题">jittor安装问题</h2>
<p>经过测试发现，在1.3.7.3往后的jittor版本，在Linxu系统上安装通过不了CUDA测试，里面生成的变量都有问题，无法正确计算data属性，推荐安装版本1.3.6.5, 1.3.7.3,另外jittor安装CUDA版本一般都需要你安装配套的CUDNN</p>
<h2 id="jittor梯度求法">jittor梯度求法</h2>
<p>jittor和torch生成的变量var与tensor相比，有个比较重要的区别就是jittor.var没有grad属性,grad只能通过创建优化器，然后对优化器参数求jt.opt_grad，并且jittor无法实现对非叶子节点的梯度保留</p>
<h2 id="jittor的c和cuda扩展">jittor的C++和CUDA扩展</h2>
<p>相对于Pytorch来说，jittor主要为python环境设计，没有提供类似于Pytorch的C++和CUDA扩展，这导致无法复用GaussianSplatting的CUDA光栅化器，最后采用的解决方法是利用python和jittor手写一个光栅化器</p>
<h2 id="jittor.meshgrid">jittor.meshgrid</h2>
<p>jittor.meshgrid默认的indexing是ij，而torch.meshgrid默认的indexing是xy</p>
<h2 id="jittor中的no_grad">jittor中的no_grad</h2>
<p>与pytorch不同的是 jittor中no_grad方法里的梯度无法重新设置梯度，因为jittor不存在设置require_grad的方法，所以一定要注意不要把你需要计算梯度的参量，比如优化器参量放入道no_grad函数里，jittor不支持像pytorch那样的nn.paremeter()函数来将张量设置为可优化的，有梯度的</p>
<h2 id="jittor优化器的状态参数">jittor优化器的状态参数</h2>
<p>与pytorch优化器不同的是 pytorch优化器的状态参数都存在优化器.stact属性中。jittor不存在这个属性，但jittor的param_groups属性储存了优化器参数，每个优化器参数里面又存有其对应的状态参数，如果你想修改优化器状态参数，请采用param_groups获取优化器参数，并修改其中的状态参数部分即可</p>
<h2 id="cuda占用参数空间过多">CUDA占用参数空间过多</h2>
<p>因为 jittor 通过 jt.flags.use_cuda 设置是否使用 GPU，所有的 jt.Var 根据此开关自动使用 cpu 或者 gpu 计算，不需要关心 var 所在的设备。这导致很多参数全部都是无脑的放在CUDA设备上，对显卡资源丰富的人来说，这显然不是个问题，但如果你的卡的显存有限，且模型较大，这会使你很容易就显存爆炸或参数空间溢出</p>
<p>如果你的显存空间爆炸，推荐你可以尝试在定义并使用完函数的局部变量后，及时将其del删除，然后利用jt.gc()函数回收参数空间</p>
<h2 id="jittor调试技巧">jittor调试技巧</h2>
<p>因为jittor默认是异步执行的，这可以大大加快其运算速度，但这在调试时非常难以准确定位错误发生位置，推荐关闭延迟执行，可以在环境变量中将export lazy_execution=0 或者在python代码中jt.flags.lazy_execution=0</p>
<h2 id="jittor模型的保存和加载">jittor模型的保存和加载</h2>
<p>与pytorch不同的是 jittor.save函数只支持dict方式保存参数，而且目前经过测试发现其对pth，pt格式的文件的保存读取会报错，建议使用pkl文件格式</p>
<h2 id="总结">总结</h2>
<p>以上是本人在编写jittor项目是遇到的一些比较大的Bug,也有一些比较小的问题没有一一列举，因为jittor和pytorch大部分函数和属性还是比较相似的，一些比较简单的问题，可以直接问chatGPT就可以解决，这里只记录了一些我认为比较重要或比较难发现的区别，如果你在复现jittor时，遇到了一些问题，你可以参考我的GitHub仓库里转换好的模型<a href="https://github.com/xiazhi1/JGaussian">JGaussian</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2022/02/06/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="git学习">Git学习</h1>
<h2 id="创建版本库">创建版本库</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit//创建目录</span><br><span class="line">$ cd learngit//切换目录</span><br><span class="line">$ pwd//显示当前目录</span><br><span class="line">$ ls -ah//显示目录</span><br><span class="line">$ git init//把目录变成可管理的仓库</span><br><span class="line">$ git add //把文件添加到仓库</span><br><span class="line">$ git commit -m&quot;&quot;//git commit告诉Git，把文件提交到仓库，-m用于添加对这次操作的说明</span><br><span class="line">$ cat readme.txt//查看readme.txt的内容</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>
<p>在Windows中当输入完txt内容后，按esc加：wq退出输入模式</p>
<span id="more"></span>
<h2 id="时光机穿梭">时光机穿梭</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status 命令可以让我们时刻掌握仓库当前的状态</span><br><span class="line">$ git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式</span><br><span class="line">提交修改和提交新文件步骤一样，$ git add $ git commit;不过在执行第二步之前可以运行 git status 看看当前仓库的状态</span><br></pre></td></tr></table></figure>
<h3 id="版本回退">版本回退</h3>
<p><code>git log</code>命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p>
<p>我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本</p>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<h3 id="工作区和暂存区">工作区和暂存区</h3>
<p><code>git add</code>命令实际上就是把要提交的所有修改（来自工作区的修改）放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<h3 id="管理修改">管理修改</h3>
<p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中</p>
<h3 id="撤销修改">撤销修改</h3>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p>
<h3 id="删除文件">删除文件</h3>
<p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交</p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了</p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code></p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本</p>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</file></file></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<h2 id="远程仓库">远程仓库</h2>
<p>1.创建自己的SSH Key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>
<h3 id="添加远程库">添加远程库</h3>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h3 id="从远程库克隆">从远程库克隆</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>
<h2 id="分支管理">分支管理</h2>
<h3 id="创建并合并分支">创建并合并分支</h3>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突">解决冲突</h3>
<p>冲突来源：<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="分支管理策略">分支管理策略</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并</p>
<h3 id="bug分支">Bug分支</h3>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h3 id="feature分支">Feature分支</h3>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="多人协作">多人协作</h3>
<h4 id="推送分支">推送分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<h4 id="抓取分支">抓取分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull//抓取分支</span><br></pre></td></tr></table></figure>
<h4 id="多人协作工作模式">多人协作工作模式</h4>
<ol type="1">
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>
<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>
<p>再pull：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<h4 id="小结">小结</h4>
<ul>
<li><p>查看远程库信息，使用<code>git remote -v</code>；</p></li>
<li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li>
<li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p></li>
<li><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li>
<li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li>
<li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h3 id="rebase">Rebase</h3>
<ul>
<li><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p></li>
<li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</p>
<p>指令是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br></pre></td></tr></table></figure>
<h3 id="标签管理">标签管理</h3>
<p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>。tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p>
<h4 id="创造标签">创造标签</h4>
<ul>
<li><p>标签不是按时间顺序列出，而是按字母排序的</p></li>
<li><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</p></li>
<li><p>命令<code>git tag -a &lt;tagname&gt; -m "blablabla..."</code>可以指定标签信息；</p></li>
<li><p>命令<code>git tag</code>可以查看所有标签。</p></li>
<li><p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p></li>
</ul>
<p>#### 操作标签</p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>互联网技术</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2022/03/19/hexo-d%20%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="hexo-d-提交spawn-failed-的解决办法">hexo d 提交spawn failed 的解决办法</h1>
<h2 id="网络问题">网络问题</h2>
<p>这个问题很多都是因为网络问题引起的 我们可以</p>
<ul>
<li>重启电脑(请首先尝试)</li>
<li>科学上网问题</li>
</ul>
<h2 id="本地文件问题">本地文件问题</h2>
<h3 id="重置git的deploy文件夹">重置git的deploy文件夹</h3>
<p>删除博客文件夹的.deploy_git文件夹，然后在对这个文件git bash 后输入 git config --global core.autocrlf false</p>
<h3 id="多系统混合编写">多系统混合编写</h3>
<p>笔者就亲身经历过，可能是因为当时在同一台电脑上运行Linux和Windows，cd进.deploy_git文件夹，输入git config –-global core.autocrlf false。</p>
<h3 id="end">end</h3>
<p>最后直接hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
]]></content>
      <categories>
        <category>互联网技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2022/02/01/%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="分治算法">分治算法</h2>
<h3 id="简要理解">简要理解</h3>
<p>分治算法由三部分组成：</p>
<ul>
<li>分：递归解决较小的问题（基本情况除外）</li>
<li>治：从子问题的解构建原问题的解</li>
</ul>
<span id="more"></span>
<h4 id="tips"><strong>Tips</strong>：</h4>
<ol type="1">
<li>传统上，在代码中至少含有两个递归调用的例程叫做分治算法，正文中只有一个递归调用的例程不是分治算法。</li>
<li>我们一般坚持子问题不相交，基本上要不重叠。</li>
</ol>
<h4 id="分治算法解决问题的特点"><strong>分治算法解决问题的特点</strong>：</h4>
<ol type="1">
<li>原问题规模通常比较大，不易直接解决，但问题缩小到一定程度能够较容易的解决。</li>
<li>问题可以分解为若干规模较小，求解方式相同（似）的子问题，且子问题之间求解是独立的，互不影响的。</li>
<li>合并问题分解的子问题可以得到问题的解</li>
</ol>
<h4 id="分治算法与递归的关系"><strong>分治算法与递归的关系</strong></h4>
<p>分治重要的是一种思想，注重的是问题分，治，合并的过程，而递归是一种方式（工具），这种方式通过方法自己调用自己形成一个来回的过程，分治就是利用了多次这样的来回过程。</p>
<h3 id="经典示例">经典示例</h3>
<ol type="1">
<li><strong>快速排序</strong> 快速排序的本质就是对基准数的两边分别递归进行查找交换，在这里，其满足分治算法中<em>分</em>：递归解决较小的问题：把整个数组的查找交换，分成对每个基准数的左右的查找交换的小问题。<em>治</em>：从子问题的解构建原问题的解：在对每个基准数左右进行排序后，整个大问题就已经排好了，就解决了原问题。</li>
<li><strong>最近点对</strong> 在二维坐标轴上有若干个点坐标，让你求出最近的两个点的距离，我们通常采用分治的方法来处理这种问题，按照x或者y的维度进行考虑，将数据分成两个区域，先分别计算(按照同方法)左右区域内最短的点对。然后根据这个两个中较短的距离向左和向右覆盖，计算被覆盖的左右点之间的距离，找到最小那个距离与当前最短距离比较即可。然后在每个区域的内部我们在进行像上面一样的操作</li>
</ol>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2022/03/17/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h1 id="字典树">字典树</h1>
<h2 id="简介">简介</h2>
<p>字典树，又称单词查找树、前缀树，是一种树形结构，属于哈希树的变种，在统计、排序、保存大量字符串时具有很小的时间复杂度，常用于搜索引擎系统用于文本词频的统计，其优点在于利用字符串的公共前缀来减少查询时间，最大限度减少没有意义的字符串比较，查找效率比哈希树高。 <span id="more"></span> 比如我有"a","apple","appeal","bee","beef","cat"这七个单词，就能够组成下面图示的字典树，如果我们需要获得"apple"这个单词的信息，按顺序访问对应的结点即可 <img src="https://s2.loli.net/2022/03/26/pMQFd1OTDjorUu4.png" alt="字典树.png"> ### 字典树的性质 1. 根节点不包含字符，除根节点外每个结点有且仅有有一个字符 2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 3. 每个节点的所有子节点包含字符各不相同</p>
<h3 id="字典树的应用">字典树的应用</h3>
<ol type="1">
<li>字典：字符串集合对应一定的信息</li>
<li>计算热词：统计字符串在集合中出现的元素</li>
<li>串的快速检索：给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，按最早出现的顺序写出所有不在熟词表中的生词，我们可以把熟词建成字典树，然后读入文章进行比较</li>
<li>串排序：给出N个互不相同的仅由一个单词构成的英文名，让他们按字典序从小到大输出，采用数组的方式创建字典树，这棵树的每个节点的儿子很显然按照其字母大小排序，对这棵树进行先序遍历即可</li>
<li>最长公共前缀：对所有串建立字典树，对两个串的最长公共前缀长度就是他们所在节点的公共祖先个数 ## 具体实现 ### 顺序储存结构 #### 节点结构体定义 我们先开辟一个足够大的数组，这里我们使用静态链表的思想，用游标表示节点的后继，我们在结构体中开辟一个数组来描述节点的后继，这里可以确定其长度为26，然后再定义一个bool类型，判定是否为单词的结尾 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># define MAXSIZE 26</span><br><span class="line">struct node&#123;</span><br><span class="line">    bool flag;</span><br><span class="line">    int next[MAXSIZE];</span><br><span class="line">&#125;trie[100001]</span><br></pre></td></tr></table></figure> #### 插入操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Insert(char *str,int *space)</span><br><span class="line">&#123;</span><br><span class="line">    \*space表示第一个空闲节点的下标,str为插入的字符串，idx为挖掘层数，order将字符转化为在字母表中的顺序</span><br><span class="line">    *\</span><br><span class="line">    int order;</span><br><span class="line">    int idx; //从第一层开始向下挖掘</span><br><span class="line">    for(int i=0;i&lt;strlen(str);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(trie[idx].next[order] == 0)//idx没有该字符的子节点</span><br><span class="line">        &#123;</span><br><span class="line">            trie[idx].next[order] = space++;//启用第space号节点，copy新节点的编号</span><br><span class="line">            idx = trie[idx].next[order];//idx节点对应的后继为space</span><br><span class="line">            trie[idx].flag = false;//标记新节点不是单词的结尾</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">         idx = trie[idx].next[order];//前缀存在继续挖掘</span><br><span class="line">    &#125;</span><br><span class="line">    trie[idx].flag = true;//表示单词结尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 查询操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Find(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int order;</span><br><span class="line">    int idx=1;</span><br><span class="line">    for(int i=0;i&lt;strlen(str);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(trie[idx].next[order]==0)//若字母失配，匹配结束</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = trie[idx].next[order];//存在对应字母，匹配继续</span><br><span class="line">    &#125;</span><br><span class="line">    if (trie[idx].flag == false)//若成功匹配，但不为单词结尾</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 链式储存结构 #### 节点结构体定义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    Node *next[26];</span><br><span class="line">    bool flag;</span><br><span class="line">&#125;Node, *Trie;</span><br></pre></td></tr></table></figure> #### 插入操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void buildTrie(Trie root,char *word)</span><br><span class="line">&#123;</span><br><span class="line">    Trie pre = root;</span><br><span class="line">    Trie ptr;</span><br><span class="line">    int order;</span><br><span class="line">    for(int i=0;i&lt;strlen(word);++i)//字母序对应后继不存在</span><br><span class="line">    &#123;</span><br><span class="line">        order = word[i]-&#x27;a&#x27;;</span><br><span class="line">        if(pre-&gt;next[order] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = (Node *)malloc(sizeof(Node));//初始化新节点</span><br><span class="line">            for(int j=0;j&lt;26;++j)</span><br><span class="line">                ptr-&gt;next[j]==NULL;</span><br><span class="line">            ptr-&gt;fail = NULL;</span><br><span class="line">            ptr-&gt;flag = false;</span><br><span class="line">            pre-&gt;next[order] = ptr;//插入新节点</span><br><span class="line">        &#125;</span><br><span class="line">        pre = ptr-&gt;next[order];//用新节点作为下一次循环的根节点</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;flag = true;//修改flag表示为单词结尾</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 查询操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Find(char * str)</span><br><span class="line">&#123;</span><br><span class="line">    int order;</span><br><span class="line">    Trie pre= root</span><br><span class="line">    Trie ptr;</span><br><span class="line">    int length = strlen(str);</span><br><span class="line">    if(!length)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        order = str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(pre-&gt;next[order] == NULL &amp;&amp; pre!=root)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next[order];</span><br><span class="line">    &#125;</span><br><span class="line">    if(pre-&gt;flag==false)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 例题详解 #### leetcode 720(词典中最长的单词) 题目描述如下： <img src="https://s2.loli.net/2022/03/17/tjBVbDG73lKdsMZ.png" alt="760.png"> ##### 思路和算法</li>
</ol>
<p>由于符合要求的单词的每个前缀都是符合要求的单词，因此可以使用字典树存储所有符合要求的单词。 创建字典树，遍历数组 words,并将每个单词插入字典树。当所有的单词都插入字典树之后，将答案初始化为空字符串，再次遍历数组 words，判断每个单词是否是符合要求的单词，并更新答案。如果一个单词是符合要求的单词，则比较当前单词与答案，如果当前单词的长度大于答案的长度，或者当前单词的长度等于答案的长度且当前单词的字典序小于答案的字典序，则将答案更新为当前单词。</p>
<h5 id="代码">代码</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAX_STR_LEN 32</span><br><span class="line"></span><br><span class="line">typedef struct Trie &#123;</span><br><span class="line">    struct Trie * children[26];</span><br><span class="line">    bool isEnd;</span><br><span class="line">&#125; Trie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void initTrie(Trie * trie) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        trie-&gt;children[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    trie-&gt;isEnd = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insertTrie(Trie * trie, const char * word) &#123;</span><br><span class="line">    Trie * node = trie;</span><br><span class="line">    int len = strlen(word);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char ch = word[i];</span><br><span class="line">        int index = ch - &#x27;a&#x27;;</span><br><span class="line">        if (node-&gt;children[index] == NULL) &#123;</span><br><span class="line">            node-&gt;children[index] = (Trie *)malloc(sizeof(Trie));</span><br><span class="line">            initTrie(node-&gt;children[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEnd = true;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool searchTrie(const Trie * trie, const char * word) &#123;</span><br><span class="line">    Trie * node = trie;</span><br><span class="line">    int len = strlen(word);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char ch = word[i];</span><br><span class="line">        int index = ch - &#x27;a&#x27;;</span><br><span class="line">        if (node-&gt;children[index] == NULL || !node-&gt;children[index]-&gt;isEnd) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    return node != NULL &amp;&amp; node-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * longestWord(char ** words, int wordsSize)&#123;</span><br><span class="line">    Trie * trie = (Trie *)malloc(sizeof(Trie));</span><br><span class="line">    initTrie(trie);</span><br><span class="line">    for (int i = 0; i &lt; wordsSize; i++) &#123;</span><br><span class="line">        insertTrie(trie, words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    char * longest = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; wordsSize; i++) &#123;</span><br><span class="line">        if (searchTrie(trie, words[i])) &#123;</span><br><span class="line">            if (strlen(words[i]) &gt; strlen(longest) || (strlen(words[i]) == strlen(longest) &amp;&amp; strcmp(words[i], longest) &lt; 0)) &#123;</span><br><span class="line">                longest = words[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考资料： <a href="https://www.cnblogs.com/linfangnan/p/12655724.html">乌漆WhiteMoon：数据结构：字典树</a> <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">leetcode 730 词典中最长的单词</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2022/03/04/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>单调栈实际上也是栈，但他利用了一些巧妙的逻辑，让每次新元素入栈后，栈内元素都保持 有序（单调递增或单调递减），那么，这个逻辑是什么，其实很简单，以栈底-栈顶单调递增 为例，每次新元素入栈时，让栈内元素与新元素判断，比新元素大的栈内元素出栈即可。</p>
<span id="more"></span>
<h3 id="用途">用途</h3>
<p>单调栈的用途并不广泛，只处理一种典型问题，Next Greater Element</p>
<h3 id="单调栈模板">单调栈模板</h3>
<p>下面举一个例子说明其模板，现有这样一道题：给你一个数组nums，请你返回一个等长的结 果数组，结果数组中对应索引储存着下一个更大元素，如果没有更大的元素，就存-1，例如 输入数组 nums = [2,1,2,4,3],返回数组[4,2,4,-1,-1] 解释：第一个2后面比2大的数是4，第二个2后面比2大的数是4，4后面没有比4大的数，填 -1，3后面没有比3大的数，填-1.</p>
<ul>
<li>暴力解法：对每个元素的后面进行扫描，找到第一个更大的元素就可以了，时间复杂度为 <em>O（n^2）</em></li>
<li>单调栈法：把数组元素想象成并列的数，元素大小想象成树的高度，在某个位置时，后面 可见的第一颗树就是它的 Next Greater Number.
<ul>
<li>实现代码(C++)：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">  vector&lt;int&gt; res(nums.size()); // 存放答案的数组</span><br><span class="line">  stack&lt;int&gt; s;</span><br><span class="line">  // 倒着往栈里放</span><br><span class="line">  for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">      // 判定个子高矮</span><br><span class="line">      while (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123;</span><br><span class="line">          // 矮个起开，反正也被挡着了。。。</span><br><span class="line">          s.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      // nums[i] 身后的 next great number</span><br><span class="line">      res[i] = s.empty() ? -1 : s.top();</span><br><span class="line">      s.push(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这就是单调栈解决问题的模板，倒着入栈其实就是正着出栈，while循环是排除两颗高树间 的矮树，这个算法的复杂度只有O（n），尽管它存在for循环嵌套while循环，但要分析一个 算法的时间复杂度，要从整体入手，总共有n个元素，每个元素都被push入栈一次，最多被 pop一次，没有对于操作，计算规模与元素规模还是成正比的，也就是O（n）复杂度</p>
<h3 id="单调栈模板改良处理环形数组">单调栈模板改良处理环形数组</h3>
<p>同求next Greater Number 如果要求环形数组，怎么办 比如输入一个数组[2,1,2,4,3].返回数组[4,2,4,-1,4]拥有了环形属性，最后一个元素3绕 了一圈后找到了比自己大的元素4. 这种情况一般都是通过%运算符求模(余数)，来获得环形特效 对于这个问题还是要用单调栈解题模板，对环形需求，常用套路是将数组长度翻倍，我们也 可以不构造新数组，而是用循环数组来模拟数组长度翻倍的效果 示例代码（C++）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    vector&lt;int&gt; res(n);</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    // 假装这个数组长度翻倍了</span><br><span class="line">    for (int i = 2 * n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // 索引要求模，其他的和模板一样</span><br><span class="line">        while (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res[i % n] = s.empty() ? -1 : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考博客：<a href="https://labuladong.%20gitee.io/algo/2/21/51/">labuladong的算法小抄-单调栈结构解决三道算法题</a></p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/02/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划">动态规划</h2>
<h3 id="简要理解">简要理解</h3>
<p>动态规划的思想是把问题划分为多个子问题，但子问题常常并不是互相独立的，当前子问题的解可看作是前面多个阶段的完整总结，所以它需要在子问题求解过程中进行多次判断与选择，与前面的问题相比，它现阶段一定要构成一种最优的结构，它满足最优化原理， <strong>最优化原理</strong>：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。同时，这样的最优策略是针对有已作出决策的总结，对后来的决策没有直接影响，只能借用目前最优策略的状态数据。这也被称之为无后效性。 <span id="more"></span> ### 求解思路 开始先要将问题按照一定顺序划分为各个阶段，然后确定每个阶段的状态，然后重点是根据决策的方法来确定状态转移方法，也就是说根据当前的状态确定下一阶段的状态，在这个过程中，下一状态的确定往往要参考之前的状态，因此需要在每一次状态转移过程中将当前的状态遍历记录，方便之后的查找。 ### 算法特点 * 需要在给定约束条件下优化某种指标时，动态规划是很有用的 * 问题可以分解为离散子问题是，可以用动态规划来解决 * 没有通用固定的公式，需要具体问题具体分析，这也就是其难点所在</p>
<h3 id="经典示例">经典示例</h3>
<p><strong>背包问题</strong>： 如果有一个小偷背有一个容量为4kg的背包去商场偷东西，可盗窃的物品有如下三件： 音响：3000 4kg 笔记本：2000 3kg 吉他：1500 1kg 每个物品只能偷一次，请问，小偷怎么偷收益最高 <strong>解决方法</strong> 我们可以考虑用画网格的方法来解决，我们构造下面的网格，每一行代表新添加的可以拿到物品，每一列代表当前容量，数字代表当前情况下可以拿的最大收益。这个过程就是动态规划的经典应用过程，就是保存上一步的结果，在这层进行决策时，与上一层结果比较，得到最优解 示意图如下： <img src="http://assets.processon.com/chart_image/61f9465b1e08530f015afacd.png" alt="alt"></p>
<p><strong>最长公共子串问题</strong> 如果用户在字典网站中查找单词时不小心拼错了，你必须猜测她原本要输入什么单词，例如啊彬想查单词fish，但不小心输入了hish，在网站的字典中，根本就没有这样的单词，但有类似的单词，那我们如何做这个判断呢？ 同样的，我们也可以构建一个网格，上方是输入单词的每个字母，左边是待匹配单词的字母，如果匹配就是左上角数字+1，最后比较整个方格中的最大值谁大，最大的就最匹配。 示意图如下： <img src="http://assets.processon.com/chart_image/61f9d53007912906b0b8147e.png" alt="alt"></p>
<p><strong>总结</strong> 从上面的两个例子可以看出，动态规划的核心是对上一步操作进行记忆，再与现在的操作进行对比，已得到最优解，同时，我们可以发现，不同问题中的动态规划虽然思路大体一致，都是保存上一步解并在确定这一步解时做参考，但具体实现上是完全不同的，所以说动态规划题并没有通用解法</p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>贪心算法学习笔记</title>
    <url>/2022/01/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="贪心算法">贪心算法</h2>
<h3 id="简要理解">简要理解</h3>
<p>贪心算法是分阶段工作的，在每一个阶段，他都会选择工作它认为眼下所作决定最好的，它是不考虑将来结果的，他只在乎局部最优解，算法终止时，我们希望得到的局部最优的结构就是全局最优，如果是就说明算法是正确的，否则算法得到的是一个次最优解，如果不要求绝对最佳答案，有时可以用简单的贪心算法生成近似答案，它的好处是在处理较大数据，较复杂的问题时，一般时间复杂度与空间复杂度都比产生准确答案的复杂算法要快上很多倍得到一个几乎接近正确的答案。 <span id="more"></span></p>
<h3 id="经典示例">经典示例</h3>
<ul>
<li><strong>找零钱问题</strong>：为了使用货币找零钱，求找出零钱张数最少值，我们可以重复配发最大额货币，于是为了找一百七十五元，我们肯定先选一张一百的，再拿一张五十的，再拿一张二十，五块的，这里就用到了贪心算法每一步选取局部最优解的思想，而且在这个问题中，局部最优就是整体最优.</li>
<li><strong>求最快抵达路径</strong>：在北京的某个交通高峰期间，有些主要干道可能看起来是空空荡荡的，但你最好还是不要选择这条干道，因为交通可能会在你抵达是=时突然变得车水马龙。这就是贪心算法行不通的例子</li>
</ul>
<h3 id="经典应用">经典应用</h3>
<ol type="1">
<li><p><strong>作业调度问题</strong> 对于多个作业（假设每个作业需要批改时间不同），我们有多个老师参与批阅，假设每个老师批阅速度一致，我们该如何想办法让整体完成时间最快。 这里就可以用到贪心算法的思想，我们可以给第一个老师挑时间最短的。第二个挑第二短的，在这样依次下去，保证每个老师先拿到的作业都是目前它眼中最好批改的作业。 这样做，虽然不一定能使整体批阅时间达到最低，但是他决定使较为接近最低的答案。而且它的算法执行复杂度会比准确算法要低，如果数据很大，贪心算法的优势为变得越来越明显</p></li>
<li><p><strong>哈夫曼编码</strong></p>
<ul>
<li>哈夫曼编码是从底向顶的构造哈夫曼树，我们每次挑取两个权值最小的元素连接构成某节点的左右子树，然后把两个左右子树的权值相加，赋给连接这两颗子树的节点，再接着这么操作，就可以把一个字符串按权重大小编码且不影响读取，字符根节点往左为0，往右为1，那么出现频率最高的字符的位数一定是最小的，这样一来就可以减小空间成本</li>
<li>哈夫曼编码使用贪心算法的地方在于，他没有对整体数据进行分析，也是每次运行优先挑取两个权值最小的树，也就是局部最优解，这里就反映出了贪心算法的本质。</li>
<li>流程示例 <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F2018120514551994.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTk0NTU0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1646208341&amp;t=fe7ae4698acc0bcbf76d0734ca3ebdd9" alt="alt 哈夫曼树构建流程"></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>微波射频电路重点概念</title>
    <url>/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>主要根据老师发的pdf的概念进行详细介绍和扩展</p>
<span id="more"></span>
<h2 id="第四章噪声与非线性失真">第四章：噪声与非线性失真</h2>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-05-19-09-53-47.png"></p>
<h3 id="噪声系数和等效噪声温度的概念">1.噪声系数和等效噪声温度的概念</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-27-16-32-52.png"> 噪声系数定义：<span class="math inline">\(F=\frac{SNR_i}{SNR_o}=\frac{P_i/N_i}{P_o/N_o}&gt;1=1+\frac{\overline{(V_n+I_nR_S)^2}}{4kTR_sB}\)</span> 由上式可知：有噪网络的噪声系数一定大于1，噪声系数与网络内部噪声大小和外部源噪声都有关，与源噪声温度T有关--测量噪声系数时，规定标准噪声温度<span class="math inline">\(T_0=290k\)</span>,与源内阻<span class="math inline">\(R_s\)</span>有关--噪声匹配--噪声系数最小--最佳源内阻</p>
<p>等效噪声温度定义：将网络视为无噪，其内部噪声折合到输入源端，视为由某电阻在温度<span class="math inline">\(T_e\)</span>产生的白噪声 <img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-27-16-40-05.png"></p>
<p><strong>习题2.1补充</strong>：均方值噪声电压电流计算公式 <span class="math display">\[\overline{V_n^2}=4kTRB,\overline{I_n^2}=\frac{4kTB}{R},k=1.380*10^{-23}J/K:波尔茨曼常数\]</span></p>
<p><strong>习题2.4补充</strong>：多级线性网络级联的噪声系数， 已知级间均匹配，带宽均为B,则有以下关系： 总噪声系数<span class="math inline">\(F=F_1+\frac{F_2-1}{G_{p1}}+\frac{F_3-1}{G_{p1}G_{p2}}+...\)</span> 总等效噪声温度<span class="math inline">\(T_e=T_{e1}+\frac{T_{e2}}{G_{p1}}+\frac{T_{e3}}{G_{p1}G_{p2}}+...\)</span></p>
<p>结论如下</p>
<ol type="1">
<li>系统前级，特别是第一级的噪声系数对系统影响最大</li>
<li>增大第一级的增益可以减少后级对系统噪声系数的影响</li>
</ol>
<p>等效噪声温度与噪声系数的关系如下图 <img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-27-16-40-57.png"></p>
<h3 id="为什么无源网络的噪声系数f等于插入损耗l">2.为什么无源网络的噪声系数F等于插入损耗L？</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-27-16-47-13.png"></p>
<h3 id="有源器件非线性的影响有哪些一个信号两个以上信号">3.有源器件非线性的影响有哪些？（一个信号，两个以上信号）</h3>
<ol type="1">
<li>输入端仅有一个信号：谐波；增益压缩</li>
<li>输入端有两个以上信号：堵塞；交叉调制；互相调制</li>
</ol>
<h3 id="db增益压缩点的概念和产生的原因">4.1dB增益压缩点的概念和产生的原因？</h3>
<p>1dB增益压缩点定义为使增益比线性放大器增益下降1dB所对应的输入信号幅度值，其产生原因是在晶体管放大器当信号增大时，出现饱和，平均跨导随输入信号幅度的增大而减小。</p>
<p><strong>所以要注意在计算题中遇到1dB压缩点时，此时的实际增益等于线性放大器原增益-1dB</strong></p>
<h3 id="三阶互调的概念和产生的原因">5.三阶互调的概念和产生的原因？</h3>
<p>三阶互调定义：由非线性器件的三次方项引起的互调称为三阶互调，其产生原因是两个以上信号通过非线性器件时产生的组合频率（主要由非线性三次方项产生）形成对有用信号的干扰</p>
<h3 id="三阶互调失真比和三阶互调截点的概念以及它们之间的关系">6.三阶互调失真比和三阶互调截点的概念，以及它们之间的关系</h3>
<p>三阶互调失真比IMD3定义：某一输入信号幅度<span class="math inline">\(V_m\)</span>下，三阶互调分量的幅度与基波幅度之比：<span class="math inline">\(IMD3=\frac{3a_3V_m^2}{4a_1}\)</span>,也可表示为功率之比:<span class="math inline">\(P_{IMD3}=\frac{P_{03}}{P_{01}}=(IMD3)^2\rightarrow P_{IMD3}(dB)=P_{03}(dBm)-P_{01}(dBm)\)</span></p>
<p>三阶互调截点<span class="math inline">\(IP_3\)</span>定义：三阶互调截点为三阶互调功率和基波功率相等的点，此点对应的输入功率表示为<span class="math inline">\(IIP_3\)</span>，对应的输出功率表示为<span class="math inline">\(OIP_3\)</span></p>
<p>三阶互调失真比与三阶互调截点的关系可通过下例具体说明 <img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-28-16-12-39.png"></p>
<h3 id="灵敏度的定义和计算公式">7.灵敏度的定义和计算公式</h3>
<p>灵敏度定义：在给定接收机的解调器前端所要求的最低信噪比条件下，接收机所能检测的最低输入电平（功率） <img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-28-16-23-16.png"> 灵敏度<span class="math inline">\(P_{in,min}(dBm)=k[T_a+(F-1)T_0](dBm/HZ)+10l gB+(SNR)_{o,min}(dB)\)</span> 其中除SNR外的部分被称为基底噪声<span class="math inline">\(F_t\)</span>,其描述了系统的总噪声,当<span class="math inline">\(T_a=T_0\)</span>时，基底噪声<span class="math inline">\(F_t\)</span>可简化为<span class="math inline">\(F_t(dBm)=-174(dBm/Hz)+NF(dB)+10lgB\)</span></p>
<p>从上面的表达式可得出以下结论：系统的基底噪声越大，要求输出的信噪比越高（输出信号质量好），为保证此输出质量所要输入的信号最低电平就越高，即灵敏度越低</p>
<h3 id="动态范围的定义和公式">8.动态范围的定义和公式</h3>
<p>接收机(或放大器)动态范围=<span class="math inline">\(\frac{允许的最大输入电平P_{in,max}}{允许的最小输入电平P_{in,min}}\)</span>,影响最小输入电平的因素--基底噪声，影响最大输入电平的因素--非线性失真,用dB表示为<span class="math inline">\(DR_l(dB)=P_{in,max}(dBm)-P_{in,min}(dBm)\)</span></p>
<p>定义方法：</p>
<ol type="1">
<li>线性动态范围<span class="math inline">\(DR_l:P_{in,max} 1dB压缩点对应的输入电平/P_{in,min} 灵敏度\)</span></li>
<li>无杂散动态范围<span class="math inline">\(DR_f:P_{in,max} 1dB压缩点对应的输入电平/P_{in,min} 基底噪声\)</span>,其对数定义为<span class="math inline">\(DR_f=\frac{1}{3}[2IIP_3(dBm)+F_t(dB)]-[F_t(dB)+(SNR)_{o,min}(dB)]\)</span></li>
</ol>
<h2 id="第五章发射接收机结构">第五章：发射、接收机结构</h2>
<h3 id="射频发射机的基本组成及功能">1.射频发射机的基本组成及功能</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-13-59-45.png"></p>
<h3 id="射频接收机的基本组成及功能">2.射频接收机的基本组成及功能</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-14-00-34.png"></p>
<h3 id="超外差式接收机结构方案框图与设计动机为什么要下变频">3.超外差式接收机结构方案(框图)与设计动机(为什么要下变频)</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-15-58-26.png"></p>
<p><strong>为什么要下变频？</strong></p>
<ol type="1">
<li>为了解决选择性，因为GSM通信系统的特点是信道带宽远比载频小，这导致射频段选择信道非常困难，因为其要求滤波器Q值极高，同一接收机如果应用于不同信道的话，射频滤波器的中心频率必须变化，解决措施就是降低频率选信道，这是下变频的原因之一</li>
<li>为了使接收机达到稳定的高增益，经过下变频后增益分散在各频段，易稳定，中频频率低且固定，增益大而稳定</li>
<li>在较低的固定中频上解调或A/D变换也相对容易</li>
</ol>
<h3 id="超外差式接收机的主要缺点高中频和低中频的利弊">4.超外差式接收机的主要缺点，高中频和低中频的利弊</h3>
<p>超外差式接收机的主要缺点在于变频器引入了众多的组合频率干扰，引起了寄生通道干扰，其中镜像频率干扰是其中一种重要的寄生通道干扰</p>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-16-08-45.png"></p>
<h3 id="二次变频接收机结构方案框图与设计动机为什么要二次变频">5.二次变频接收机结构方案(框图)与设计动机(为什么要二次变频)</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-16-10-52.png"></p>
<p><strong>设计动机</strong>：为了解决中频选择碰到的‘灵敏度’和‘选择性’的矛盾，可以采用二次混频方案，也可以说是为了兼顾前面高中频和低中频的利弊，设计出的最佳方案</p>
<p><strong>中频选择原则</strong>：I中频采用高中频值，以提高镜像频率抗拒比，II中频采用低中频值，利于提取有用信道，抑制邻道干扰</p>
<h3 id="直接下变频接收机结构方案框图特征与优缺点">6.直接下变频接收机结构方案(框图)，特征与优缺点</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-16-14-07.png"></p>
<h3 id="镜像抑制接收机结构方案框图与工作原理">7.镜像抑制接收机结构方案(框图)与工作原理</h3>
<p>镜像抑制接收机是采用改变电路结构来抑制超差式接收机中的镜像频率干扰，用两个相互正交的两个本振信号去与来自LNA的射频信号混频，再将其中一路相移90°，然后叠加，就可以得到抑制镜像频率的中频信号，<strong>这是因为正交信号混频后再相移叠加会将其中的镜像频率抵消掉</strong></p>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-16-43-49.png"></p>
<h3 id="数字中频接收机结构方案框图特征与优缺点">8.数字中频接收机结构方案(框图)，特征与优缺点</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-29-16-46-49.png"></p>
<h3 id="直接变换与两步变换发射机方案的概念各自优缺点">9.直接变换与两步变换发射机方案的概念，各自优缺点</h3>
<ol type="1">
<li>直接变换法：将调制和上变频合二为一，在一个电路里完成</li>
<li>两步法：将调制和上变频分开，先在较低的中频上进行调制，然后将已调信号上变频搬移到发射的载频上</li>
<li>直接变换法简单，但是有明显的缺点，由于发射信号是以本振频率为中心的通带信号，经功率放大或发射后的强信号会泄漏或反射回来影响本振，牵引本振频率。</li>
<li>两次变换法明显可以减弱直接变换法的缺点，而且由于调制是在较低的中频上进行，正交的两支路容易一致。其缺点是二次上变换后必须采用滤波器滤除另一个不要的边带，为了达到发射机的性能指标，对这个滤波器的要求是比较高的。</li>
</ol>
<h2 id="第七章射频放大器设计">第七章：射频放大器设计</h2>
<h3 id="射频放大器七个主要指标的定义">1.射频放大器七个主要指标的定义</h3>
<ol type="1">
<li>工作频率和带宽：工作频率就是放大器能够正常工作的频率范围<span class="math inline">\(f_1~f_2\)</span>，最大的工作频率与最小的工作频率之差就是放大器的带宽B</li>
<li>增益：增益是表示放大电路对有用信号的放大能力，通常用在中心频率上用功率增益G表示:<span class="math inline">\(G=P_{out}/P_{in}\)</span>,增益通常用分贝(dB)表示</li>
<li>输入输出反射系数及电压驻波比(VSWR):反射系数<span class="math inline">\(\Gamma\)</span>表征放大器的输入输出端口对信号反射的大小，即失配程度，一般用放大器两端口的S参数<span class="math inline">\(S_{11},S_{22}\)</span>来计算，并用dB表示。反射系数一般是一个复数，包含幅度和相位，电压驻波比(VSWR)等于<span class="math inline">\(VSWR=\frac{1+|\Gamma|}{1-|\Gamma|}\)</span></li>
<li>噪声系数：噪声系数NF是用来描述放大器本身产生噪声电平大小，定义F如下，<span class="math inline">\(F=\frac{输入端信噪比}{输出端信噪比}=\frac{S_i/N_i}{S_o/N_o}=\frac{S_i/N_i}{S_i\cdot}=\frac{N_o}{G\cdot N_i}=1+N_x\)</span>,<span class="math inline">\(N_x\)</span>是由放大器内部产生的噪声，噪声系数一般用dB表示<span class="math inline">\(NF=10lgF\)</span></li>
<li>增益平坦度：指在一定温度下，在整个工作频率范围内，放大器增益变化的范围。增益平坦度可由下式定义：<span class="math inline">\(\Delta G=|G_{max}-G_{min}|dB,\Delta G:增益平坦度,G_{max}/G_{min}:增益-频率曲线幅度最大/小值\)</span></li>
<li>1dB压缩点输出功率<span class="math inline">\(P_{1dB}\)</span>：当功率增益比小信号线性增益G0下降1dB时，称为“1dB压缩点增益<span class="math inline">\(G_{1dB}\)</span> ” ，对应的输出功率称为“1dB压缩点输出功率<span class="math inline">\(P_{1dB}\)</span>。<span class="math inline">\(P_{1dB}\)</span>是表示一个放大器的非线性特性和功率输出能力的一项重要指标</li>
<li>三阶截点(<span class="math inline">\(IP3\)</span>):三阶截点是描述放大器线性程度的一个重要指标。 IP3可以从基波分量和三阶互调分量与输入功率之间的关系曲线得到，它们线性延长的交点，即为三阶截点（IP3）</li>
</ol>
<h3 id="双分立元件l形匹配网络设计方法结合圆图">2.双分立元件L形匹配网络设计方法(结合圆图)</h3>
<p>Smith圆图可以相对快速并精确的设计匹配网络，且其复杂程度几乎和匹配网络的元件数目无关，此外通过观察阻抗在Smith圆图上的变换过程，可以体会到每个电路元件对实现特定匹配状态的贡献，负载连接电抗元件之后在Smith圆图上的效果有以下三点：</p>
<ol type="1">
<li>电抗元件与复数阻抗串联将导致圆图上的相应阻抗点沿等电阻圆移动</li>
<li>并联将导致Smith圆图上的相应导纳点沿等电导圆移动</li>
<li>如果连接的是电感，则Smith圆图中参量点将向上半圆移动，如果连接的是电容，则参量点将向下半圆移动</li>
</ol>
<p>其常规设计程序包括以下六个步骤</p>
<ol type="1">
<li>求出归一化源阻抗和负载阻抗</li>
<li>在Smith圆图中过源阻抗的相应点画出等电阻圆和等电导圆</li>
<li>在Smith圆图中过负载阻抗的共轭复数点画出等电阻圆和等电导圆</li>
<li>找出第二步和第三步所画圆的交点，交点的个数就是可能存在的L型匹配网络的数目</li>
<li>先沿着相应的圆将源阻抗点移动到上述交点，然后再沿相应的圆移动到负载的共轭点，根据这两次移动过程就可以求出电感和电容的归一化值</li>
<li>根据给定的工作频率确定电感和电容的实际值</li>
</ol>
<h3 id="无源偏置电路的设计方法">3.无源偏置电路的设计方法</h3>
<p>偏置网络分为无源网络和有源网络，无源网络是最简单的偏置电路，通常由电阻网络构成，它为射频晶体管提供合适的工作电压和电流</p>
<h3 id="为什么低噪声放大器要放在接收机前级结合圆图说明低噪声放大器噪声匹配为什么一般不选择最小噪声系数">4.为什么低噪声放大器要放在接收机前级？结合圆图说明低噪声放大器噪声匹配为什么一般不选择最小噪声系数</h3>
<p>接收机的前端为了保证整个系统的噪声要求，在低噪声前提下对信号进行放大是系统的基本要求，因此接收机初级放大器都是低噪声放大器。</p>
<p>因为放大器的低噪声要求和其他参数，如稳定性，增益等相冲突，最小噪声系数的点可能会是一个不稳定区域内点，因此设计低噪声放大器一般很难直接选用最小噪声点，而是在优先考虑噪声系数的情况下，保证放大器的稳定和增益与噪声系数的兼顾原则。</p>
<h3 id="前馈线性化技术的框图和工作原理">5.前馈线性化技术的框图和工作原理</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-30-11-19-31.png"></p>
<h2 id="第八章微波混频器">第八章：微波混频器</h2>
<h3 id="线性频谱搬移时域和频域特性">1.线性频谱搬移，时域和频域特性</h3>
<p>混频的本质是在做线性频谱搬移，其时域特性表现为：输入输出波形相同，载频不同，频域特性表现为：输入输出频谱结构，带宽相同，载频不同</p>
<h3 id="混频器的四个主要指标定义增益噪声三阶截点隔离度">2.混频器的四个主要指标定义(增益，噪声，三阶截点，隔离度)</h3>
<ol type="1">
<li>增益：混频器的增益为频率变换增益，定义为输出中频信号的大小与输入射频信号大小之比。电压增益<span class="math inline">\(A_v\)</span>与功率增益<span class="math inline">\(G_p\)</span>分别定义为<span class="math inline">\(A_v=\frac{V_{IF}}{V_{RF}},G_p=\frac{P_{IF}}{P_{RF}}\)</span></li>
<li>噪声：混频器的噪声有两种定义，分别为单边噪声和双边噪声，单边噪声是指射频信号位于本振的一边，经过混频后，镜像频段和射频信号段一起被搬移到中频的噪声，双边噪声是指射频信号位于本振的两边，不存在镜像频率带来的噪声，仅考虑射频信号端的噪声，单边噪声是双边噪声的两倍(高3dB)</li>
<li>三阶互调截点：设混频器输入两个射频信号<span class="math inline">\(f_{RF1},f_{RF2}\)</span>,它们的三阶互调分量与本振混频后也位于中频带宽内，就会对有用中频产生干扰。与放大器的三阶互调截点定义相同，是三阶互调产生的中频分量与有用中频相等时的输入信号功率记为<span class="math inline">\(IIP_3\)</span></li>
<li>隔离度：混频器三个端口的任意两个端口之间的距离都很重要，隔离度一般大于20dB，滤波电路可以对信号隔离有一定帮助</li>
</ol>
<h3 id="单管跨导混频器工作原理线性时变工作状态时变偏置和时变跨导">3.单管跨导混频器工作原理(线性时变工作状态，时变偏置和时变跨导)</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-30-15-21-52.png"></p>
<p>单管跨导混频器的线性时变工作状态必须满足的条件</p>
<ol type="1">
<li>两个输入：<span class="math inline">\(v_{RF}(t)=V_{RF}cos\omega_{RF}t,v_{LO}(t)=V_{LO}cos\omega_{LO}t\)</span></li>
<li>一大一小：且<span class="math inline">\(V_{LO}&gt;&gt;V_{RF}\)</span></li>
</ol>
<p>时变偏置：<span class="math inline">\(V_{GSQ}(t)=-V_{GG}+v_{LO}(t)\)</span> 时变跨导：<span class="math inline">\(g_m(t)=g_{m0}+g_{m1}cos\omega_{LO}(t)+g_{m2}cos2\omega_{LO}t+\dots\)</span> 变频跨导：<span class="math inline">\(g_{fc}=\frac{I_{IF}}{V_{RF}}=\frac{1}{2}g_{m1}\)</span>,时变跨导基波分量的一半 变频增益：<span class="math inline">\(A_v=g_{fc}R_L\)</span></p>
<ol type="1">
<li>不同的本振幅度，变频跨导不同</li>
<li>相同的本振幅度下，偏置不同，变频跨导也不同</li>
<li>中频输出回路的功能是选频滤波和阻抗变换</li>
<li>中频陷波的目的是为了减少混入输入端的中频干扰和噪声</li>
<li>本振注入方式可以从栅极或源极注入，栅极注入的优点是需要的本振功率小但是LO口和RF口隔离度差，源极注入的优点是隔离度好但缺点是负反馈导致混频增益下降，且需提供更多输入功率</li>
</ol>
<h3 id="吉尔伯特双平衡混频器工作原理射频小信号本振大信号和优点">4.吉尔伯特双平衡混频器工作原理(射频小信号，本振大信号)和优点</h3>
<p><strong>应用目的:改善混频器口间隔离不好的缺点，电路特点：射频级为差分输入输出线性放大器，本振级为双差分对开关，中频输出口为平衡输出</strong></p>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-30-15-44-19.png"></p>
<p>该模拟乘法器并不能真正实现两个信号的相乘，但可以按两个信号的大小情况讨论其输出</p>
<ol type="1">
<li><span class="math inline">\(v_1,v_2\)</span>均为小信号，则输出电流可简化为<span class="math inline">\(i=I_0(\frac{q}{2kT})^2v_1v_2\)</span>,其实现了输入电压<span class="math inline">\(v_1,v_2\)</span>的理想相乘--<strong>输出频率等于<span class="math inline">\(w_1\pm w_2\)</span>,幅度成正比</strong>，缺点是输入信号动态范围小，层级系数<span class="math inline">\(I_0(\frac{q}{2kT})^2\)</span>与温度T有关</li>
<li>一个为大信号一个为小信号，输出电流则正比于小信号幅度和小信号放大级跨导，与大信号幅度无关-----优点：输出不含射频和本振分量，口间隔离好；线性范围较大，<strong>输出频率等于<span class="math inline">\(pw_2+w_1(P=1,3,5...)\)</span></strong></li>
<li>均为大信号，输出电流与两输入信号幅度均无关，<strong>输出频率等于<span class="math inline">\(（2m-1）w_2+（2n-1）w_1(P=1,3,5...)\)</span></strong></li>
</ol>
<p>优点：</p>
<ol type="1">
<li>口间隔离好--输出不含射频和本振分量</li>
<li>线性范围较大--射频输入极是差分放大器，线性范围比单管大；输出采用双平衡，抵消了射频的偶次失真项</li>
</ol>
<h2 id="第九章射频振荡器">第九章：射频振荡器</h2>
<h3 id="反馈型振荡器的三个条件平衡条件起振条件稳定条件">1.反馈型振荡器的三个条件(平衡条件，起振条件，稳定条件)</h3>
<ol type="1">
<li>平衡条件：反馈振荡器的环路增益为<span class="math inline">\(T(jw)=A(jw)\cdot F(jw)\)</span>,振荡平衡时，在频率<span class="math inline">\(\omega_{osc}\)</span>有<span class="math inline">\(T(jw_{osc})=1\)</span>,振幅平衡条件：<span class="math inline">\(|T(jw_{osc})|=|A(jw_{osc})F(jw_{osc})|=1\)</span>,相位平衡条件:<span class="math inline">\(\psi_{T(jw_{osc})}=2n\pi\)</span></li>
<li>起振条件：振幅条件：<span class="math inline">\(|T(jw)|=|A(jw)F(jw)|&gt;1\)</span>,相位平衡条件:<span class="math inline">\(\psi_{T(jw)}=0\)</span></li>
<li>稳定条件：振幅条件：<span class="math inline">\(\frac{\alpha T}{\alpha V_i}|_{平衡点}&lt;0\)</span>,相位条件：<span class="math inline">\(\frac{\alpha \psi_T}{\alpha w}|_{平衡点}&lt;0\)</span></li>
</ol>
<h3 id="锁相环pll的结构框图工作原理和特点">2.锁相环PLL的结构框图，工作原理和特点</h3>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-30-15-59-11.png"></p>
<p>工作原理与特点</p>
<p><img src="/2024/05/19/%E5%BE%AE%E6%B3%A2%E5%B0%84%E9%A2%91%E7%94%B5%E8%B7%AF%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5/2024-04-30-15-59-47.png"></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>微波射频电路</tag>
      </tags>
  </entry>
  <entry>
    <title>图的存储结构</title>
    <url>/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="图的存储结构">图的存储结构</h1>
<h2 id="前言">前言</h2>
<p>最近笔者在准备数据结构考试，故复习了些课本知识，发下自己对与图的存储结构还有诸多遗漏，故特意整理了些图的存储结构笔记，图的存储结构相对来说比较复杂，望大家复习时不要遗漏 <span id="more"></span> ## 邻接矩阵 该储存方式是由两个数组来表示图1，一个一维数组储存图中顶点信息，一个二维数组(即为邻接矩阵)储存图中的边或弧的信息 具体实例： <strong>无向图</strong> <img src="https://s2.loli.net/2022/05/02/jKxgNmBUbHko5ZX.png" alt="邻接矩阵-无向图.png"> 可以很容易看出无向图的边数组是一个对称矩阵。 有了该矩阵后，我们可以： 1. 判定任意两顶点是否有边无边 2. 确定某个顶点的度。就是该顶点的行(列)的元素之和。 3. 求某顶点的所有邻接点就是把矩阵该行元素全部扫描一遍，为一的就是邻接点 <strong>有向图</strong> <img src="https://s2.loli.net/2022/05/02/znGTpIKuiC6NfH8.png" alt="邻接矩阵-有向图.png"> 有向图讲究的入度和出度，入度对应列，出度对应行 <strong>带权值的有向图</strong> 就把有向图中为0的地方数组改为无穷，其余地方的值为该边上的权值即可 <strong>缺点</strong> 对于边数相对顶点较少的图，这种结构对储存空间造成极大浪费 ## 邻接表 顶点用一个一维数组储存，便于读取顶点信息，其次还要储存一个指向第一个邻接点的指针，便于查找该顶点的边信息 顶点所有邻接点构成一个线性表，用单链表储存，无向图称为顶点的边表，有向图称为顶点作为弧尾的出边表 具体实例如下： <strong>无向图</strong> <img src="https://s2.loli.net/2022/05/03/uTWl1rjJwQHo3AN.png" alt="邻接表-无向图.png"> 每个节点有data，firstedge两个域表示，data储存顶点信息，firstedge指针域，指向边表的第一个节点，边表节点由adjvex和next两个域组成，adjvex储存邻接点在顶点表的下标，next指向边表下一个节点的指针</p>
<p><strong>有向图</strong> 有向图的邻接表结构是类似的，但由于它有方向，我们以顶点为弧尾储存边表，很容易可以得到每个顶点的出度，如果要得到每个顶点的入度，可构建一个逆邻接表 示意图如下 <img src="https://s2.loli.net/2022/05/03/jcmVLbKYsDCf1yk.png" alt="邻接表-有向图.png"></p>
<p><strong>带权值的有向图</strong> 只需在边表节点定义中加一个weight的数据域，储存权值信息即可 <strong>缺点</strong> 对于有向图来说，邻接表不能同时了解入度出度问题 ## 十字链表 顶点表节点包括data，firstin，firstout，分别表示数据，入边表头指针，出边表头指针 边表节点结构包括tailvex，headvex，headlink，taillink，分别代表弧起点，弧终点，入边表指针域，指向终点相同的下一条边，出边表指针域，指向起点相同的下一条边，如果是网，还可以增加一个weight域来储存权值 示意图如下： <img src="https://s2.loli.net/2022/05/03/1QYCHpEr6waGAxh.png" alt="十字链表.png"></p>
<p><strong>优缺点</strong> 好处在于容易找到顶点的入出度，但其结构复杂点，但创建时间复杂度和邻接表相同，所以在有向图的应用中，它是一个非常好的模型</p>
<h2 id="邻接多重表">邻接多重表</h2>
<p>只需要在邻接表基础上，对边表节点进行一些改造，重新定义的边表结构如下：ivex，ilink，jvex，jlink，分别为边对应的两个顶点下标，指向依附ivex的下一条边，指向依附jvex的下一条边 <img src="https://s2.loli.net/2022/05/03/Y1nJSLVyEWPbI6t.png" alt="邻接多重表.png"></p>
<p><strong>与邻接表的区别</strong> 一条边在邻接表中要用两个节点表示，而在邻接多重表中只有一个节点，这样对边的操作更方便</p>
<h2 id="边集数组">边集数组</h2>
<p>有两个一维数组构成，一个储存顶点信息，一个储存边的信息，边数组数据元素由边起点下标begin，终点下标end，权值weight组成，它不适合对顶点操作，更适合对边的操作 <img src="https://s2.loli.net/2022/05/03/yOtG873msjzWafh.png" alt="边集数组.png"></p>
<h2 id="参考资料">参考资料</h2>
<p>程杰《大话数据结构》</p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微波技术基础第一二章知识小结</title>
    <url>/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>因为第一章绪论内容较少，所以将第一章内容与第二章合并</p>
<h2 id="绪论">绪论</h2>
<h3 id="微波的概念">微波的概念</h3>
<p>顾名思义“微波”是波长极短，频率极高的电磁波。在电磁波谱中是介于普通线电波与红外线之间的波段。因此，波长的长与短、频率的高与低都是相对的，在微波波段内部又可划分为分米波、厘米波、毫米波和亚毫米波.</p>
<span id="more"></span>
<p>不同频率的电磁波，其传播特性不同，适用场合也不同</p>
<p><img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-19-58-33.png" style="width:60.0%;height:60.0%"></p>
<p>从上图可以看出，本课程要学习的微波，频率范围在<span class="math inline">\(300MHz\sim 3000GHz\)</span>,波长范围在<span class="math inline">\(0.1mm\sim 1dm\)</span></p>
<h2 id="传输线理论概述">传输线理论概述</h2>
<h3 id="微波传输线及其分类">微波传输线及其分类</h3>
<p>定义：凡能够引导微波沿一定方向传输的导波装置称为传输线。作用：1.引导微波传输。2. 构成各种微波元器件</p>
<p>分类：根据传输线结构和电磁波的特点可分为：</p>
<ol type="1">
<li>TEM波及准TEM波传输线 例如：双导线、同轴线、带状线、微带线</li>
<li>TE波和TM波传输线 例如：矩形波导、圆波导等</li>
<li>表面波传输线 例如：介质波导、介质镜像线等</li>
</ol>
<p>传输线的性能要求和应用范围：</p>
<ul>
<li>性能要求：工作频带宽；功率容量大；工作稳定性好；损耗小；尺寸小和成本低。</li>
<li>应用范围：
<ul>
<li>米波或分米波：双导线、同轴线</li>
<li>厘米波：空心金属波导管、带状线、微带线</li>
<li>毫米波：空心金属波导管、介质波导、介质镜像线、微带线</li>
</ul></li>
</ul>
<p>传输线理论的研究问题：</p>
<ul>
<li>横向问题：研究电磁波在传输线横截面内电场、磁场的分布规律，即场结构、模、波型。通过求解电磁场的边值问题来解决</li>
<li>研究电磁波沿传输线轴向的传播特性和场的分布规律。采用的方法：场的分析方法、路的分析方法。路的分析方法简便、易懂，本章采用路的方法来研究双导线的纵向问题</li>
</ul>
<h3 id="长线与分布参数电路">长线与分布参数电路</h3>
<p>长线与短线：如果传输线的几何长度<span class="math inline">\(L\)</span>与工作波长<span class="math inline">\(\lambda\)</span>可比拟或<span class="math inline">\(L&gt;&gt;\lambda\)</span>时，传输线称为长线，否则称为短线，<span class="math inline">\(\frac{L}{\lambda}\)</span>-电长度，当电长度&lt;0.1,为短线，做集总参数处理(导线无L,R,C,G),反之则为长线，做分布参数电路处理(导线有L,R,C,G)</p>
<h3 id="分析方法">分析方法</h3>
<ul>
<li>场的方法：以E、H为研究对象，从麦克斯韦尔方程出发, 解满足边界条件的波动方程, 得出传输线上电场和磁场的解, 进而研究传输特性的横向分布及纵向传输特性。该方法严格、精确, 但数学计算复杂、繁琐，解析方程求解困难</li>
<li>路的方法：在一定的条件下，以U、I为对象，从传输线方程出发, 求出满足边界条件的电压、 电流波动方程的解, 分析电压波和电流波随时间和空间的变化规律,即用电路理论来研究纵向传输特性。本质上是化场为路。该方法有足够的精度, 数学上较为简便, 因此被广泛采用。</li>
</ul>
<p><strong>传输线（长线）理论就是研究TEM波传输线的分布参数的电路理论</strong></p>
<h2 id="长线方程及其解">长线方程及其解</h2>
<h3 id="长线方程">长线方程</h3>
<p><img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-20-24-37.png" style="width:60.0%;height:60.0%"></p>
<p>设位置z处的电压和电流的复振幅分别为<span class="math inline">\(\dot{U},\dot{I}\)</span>,而在位置<span class="math inline">\(z+dz\)</span>处的电压和电流的复振幅分别为<span class="math inline">\(\dot{U}+d\dot{U},\dot{I}+d\dot{I}\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-20-38-38.png"> 则有<span class="math display">\[\begin{cases}
    (\dot{U}+d\dot{U})-\dot{U}=(Rdz+jwLdz)(\dot{I}+d\dot{I})\\
    (\dot{I}+d\dot{I})-\dot{I}=(Gdz+jwCdz)\dot{U}
\end{cases}\]</span> 忽略第一式中的高阶微分项,并将dz除到左端，得 <span class="math display">\[\begin{cases}
    \frac{d\dot{U}}{dz}=(R+jwL)\dot{I}=Z\dot{I},\quad Z=R+jwL\\
    \frac{d\dot{I}}{dz}=(R+jwC)\dot{U}=Y\dot{U},\quad Y=G+jwC\\
\end{cases}\]</span></p>
<p><strong>这就是均匀传输线方程，也称为长线方程</strong></p>
<h3 id="长线方程的解">长线方程的解</h3>
<p>求解上一小节提到的长线方程，可得长线方程的解为 <span class="math display">\[\begin{cases}
    \dot{U}(z)=A_1e^{\gamma z}+A_2e^{-\gamma z}\\
    \dot{I}(z)=\frac{1}{Z_0}(A_1e^{\gamma z}-A_2e^{-\gamma z})\\
\end{cases}\]</span> 式中，第1项表示向负z方向传播的波，第2项表示向正z方向传播的波。A1和A2则分别表示向负z和正z方向传输的波的复振幅，它们是待定的积分常数，取决于传输线的负载端或源端的边界条件.<span class="math inline">\(Z_0=\frac{Z}{Y}\)</span>(特性阻抗),<span class="math inline">\(\gamma=\sqrt{ZY}=\alpha+j\beta\)</span>(传播常数)</p>
<p>边界条件通常有以下三种： 1. 已知负载端电压,电流<span class="math inline">\(\dot{U_L},\dot{I_L}\)</span> 2. 已知源端电压,电流<span class="math inline">\(\dot{U_g},\dot{I_g}\)</span> 3. 已知信源电动势，内阻电压,负载阻抗<span class="math inline">\(E_g,Z_g,Z_L\)</span></p>
<p>这里仅讨论第一种情况：</p>
<p><span class="math inline">\(\because \dot{U}(0)=\dot{U_L}=A_1+A_2\\\quad\dot{I}(0)=\dot{I}(L)=\frac{1}{Z_0}(A_1-A_2)\)</span> 联立即可求出<span class="math inline">\(A_1,A_2\)</span>，进而解出整个方程</p>
<p>在微波波段，若传输线所用导体为良导体，且媒质是低损耗的，则有<span class="math inline">\(R&lt;&lt;wL,G&lt;&lt;wC\)</span>,故可认为<span class="math inline">\(R=G=0\)</span>，则此传输线为均匀无耗线。<strong>均匀无耗线是本章讨论的重点</strong></p>
<p>故在长线方程求解过程中，用到的参数<span class="math inline">\(\gamma,Z_0\)</span>可化简为 <span class="math display">\[\gamma=j\beta,\beta=w\sqrt{LC}\\Z_0=\sqrt{\frac{L}{C}}\]</span></p>
<p>因此均匀无耗传输线上的电压，电流为 <span class="math display">\[\begin{cases}
    \dot{U(z)}=\dot{U_L}cos\beta z+j\dot{I_L}Z_0sin\beta z\\
    \dot{I(z)}=\dot{I_L}cos\beta z+j\frac{\dot{U_L}}{Z_0}sin\beta z
\end{cases}\]</span></p>
<h3 id="解的物理意义">解的物理意义</h3>
<p>电压和电流均可表示为入射波和反射波的叠加，且都是行波（波的传播过程中只有相位的变化，而无幅度的变化），<strong>两个行波之和不一定是行波</strong></p>
<h2 id="长线的参量">长线的参量</h2>
<h3 id="特性参量">特性参量</h3>
<p>指由长线的结构、尺寸、填充的媒质及工作频率决定的参量。（和负载无关），主要包括特性阻抗<span class="math inline">\(Z_0\)</span>,传播常数<span class="math inline">\(\gamma\)</span>,相速<span class="math inline">\(V_p\)</span>,波长<span class="math inline">\(\lambda\)</span></p>
<ol type="1">
<li>特性阻抗<span class="math inline">\(Z_0\)</span> 将传输线上行波电压与行波电流之比定义为传输线的特性阻抗,亦即入射波电压与电流复量之比或反射波电压与电流复量之比的负值，用<span class="math inline">\(Z_0\)</span>来表示, 其倒数称为特性导纳, 用<span class="math inline">\(Y_0\)</span>来表示。根据定义有<span class="math inline">\(Z_0=\frac{U^+(z)}{I^+(z)}=\sqrt{\frac{Z}{Y}}=\sqrt{\frac{R+jwL}{G+jwC}}\)</span>。可见特性阻抗<span class="math inline">\(Z_0\)</span>通常是个复数, 且与工作频率有关。 它由传输线填充的介质、线的横向尺寸和横截面内电磁场的分布状态决定而与线长度、负载及信源无关, 故称为特性阻抗。 对于无耗均匀传输线,<span class="math inline">\(Z_0=\sqrt{\frac{L}{C}}\)</span>,纯电阻，与频率无关</li>
<li>传播常数<span class="math inline">\(\gamma\)</span> 传播常数<span class="math inline">\(\gamma\)</span>是描述传输线上导行波沿导波系统传播过程中衰减和相移的参数,<span class="math inline">\(\gamma=\sqrt{ZY}=\sqrt{(R+jwL)(G+jwC)}=\alpha+j\beta\)</span>,对于均匀无耗传输线，有<span class="math inline">\(\gamma=jw\sqrt{LC}=j\beta\)</span></li>
<li>相速<span class="math inline">\(V_p\)</span>和工作波长<span class="math inline">\(\lambda\)</span> 传输线上的相速定义为行波等相位面沿传输方向的传播速度, 用<span class="math inline">\(v_p=\frac{w}{\beta}\)</span>表示，对于无耗传输线<span class="math inline">\(\beta=w\sqrt{LC},\therefore v_p=\frac{1}{\sqrt{LC}}\)</span> 传输线的工作波长定义为：同一时刻，线上行波相位相差2π的两点间的距离，用λ表示 <span class="math inline">\(\lambda=\frac{2\pi}{\beta}=\frac{2\pi}{w\sqrt{LC}}=\frac{v_p}{f}\)</span> 对于均匀无耗传输线来说, 由于β与ω成线性关系, 故导行波的相速与频率无关, 也称为无色散波。当传输线有损耗时, β不再与ω成线性关系, 使相速<span class="math inline">\(v_p\)</span>与频率<span class="math inline">\(f\)</span>有关,这就称为色散特性</li>
</ol>
<h3 id="工作参量">工作参量</h3>
<p>与长线终端负载有关的参量，主要包括输入阻抗，反射系数，驻波比</p>
<ol type="1">
<li><p>输入阻抗Z(z) 输入阻抗Z(z)定义：传输线上任意位置处的总电压与总电流复量之比，称为该处的输入阻抗<span class="math inline">\(Z_{in}\)</span>，即从该位置朝负载方向看去的等效阻抗。推导得出<span class="math inline">\(Z(z)=Z_0\frac{Z_L+jZ_0tan\beta z}{Z_0+jZ_Ltan\beta z}\)</span> 上式表明: 均匀无耗传输线上任意一点的输入阻抗与该点的<strong>位置</strong>、传输线的<strong>特性阻抗</strong>、<strong>终端负载阻抗</strong>及<strong>工作频率</strong>有关</p>
<p>输入阻抗表达式有多种变形</p>
<ol type="1">
<li><span class="math display">\[if\qquad d=n\lambda/2(n=1,2,3,\dots)\\\because\beta d=n\pi,\therefore Z(z+d)=Z(z)\]</span> 可见均匀无耗线上的阻抗具有<span class="math inline">\(\lambda/2\)</span>周期性</li>
<li><span class="math display">\[if\qquad d=(2n-1)\lambda/4(n=1,2,3,\dots)\\\because\beta d=(2n-1)\pi/2,\therefore Z(z+d)Z(z)=Z_0^2\]</span> 可见均匀无耗线上的阻抗具有<span class="math inline">\(\lambda/4\)</span>变换性 <span class="math display">\[感性\leftrightarrow容性\\大于Z_0的电阻\leftrightarrow小于Z_0的电阻\\开路\leftrightarrow短路\]</span></li>
<li>当终端负载<span class="math inline">\(Z_L=Z_0\)</span>，即终端接有匹配负载时，传输线任意位置输入阻抗等于<span class="math inline">\(Z_0\)</span>,与传输线无限长等效，只有入射波无反射波，行波状态，阻抗匹配</li>
</ol></li>
<li><p>（电压）反射系数<span class="math inline">\(\Gamma(z)\)</span></p>
<ol type="1">
<li>定义：传输线上任意一点z处的反射波电压与入射波电压之比为电压反射系数，记为<span class="math inline">\(\Gamma(z)=\frac{U^-(z)}{U^+(z)}\)</span>,若为无耗传输线，则其任一位置上的反射系数为<span class="math inline">\(\Gamma(z)=\frac{U^-(z)}{U^+(z)}=\Gamma_Le^{-j2\beta z},\Gamma_L=\frac{U_L^-}{U_L^+}=|\Gamma_L|e^{j\psi_L},0\le|\Gamma_L|\le1\qquad -\pi\le\psi_L\le\pi,\\\therefore \Gamma(z)=|\Gamma_L|e^{j\psi},0\le|\Gamma|\le1,\psi=\psi_L-2\beta z\)</span></li>
<li>无耗传输线上<span class="math inline">\(Z(z)\)</span>与<span class="math inline">\(\Gamma(z)\)</span>的关系 <span class="math display">\[Z(z)=Z_0\frac{1+\Gamma(z)}{1-\Gamma(z)}\quad or \quad\Gamma(z)=\frac{Z(z)-Z_0}{Z(z)+Z_0}\\\therefore \Gamma_L=\frac{Z_L-Z_0}{Z_L+Z_0}\]</span> 可见<span class="math inline">\(Z(z)与\Gamma(z)\)</span>具有相同的周期<span class="math inline">\(\lambda/2\)</span></li>
</ol></li>
<li><p>驻波比<span class="math inline">\(\rho\)</span>与行波比<span class="math inline">\(k\)</span></p>
<ol type="1">
<li>驻波比：传输线上最大电压（或者电流）振幅值与最小电压（或电流）振幅值之比，称为驻波比，记为<span class="math inline">\(\rho=\frac{|\dot{U}|_{max}}{|\dot{U}|_{min}}\)</span> <span class="math display">\[\because \Gamma(z)=|\Gamma_L|e^{j(\psi_L-2\beta z)}且\dot{U}=U^+(1+\Gamma)=U_L^+e^{j\beta z}(1+\Gamma(z))\\\therefore \dot{U}=U_L^+e^{j\beta z}(1+|\Gamma|e^{j(\psi_L-2\beta z)})\]</span>对上式求U的模可以看出,当<span class="math inline">\(2\beta z-\psi_L=2n\pi\)</span>时,<span class="math inline">\(n=0,1,2...\)</span>,<span class="math inline">\(|\dot{U}_{max}|=|U_L^+|(1+|\Gamma|)\)</span>,当<span class="math inline">\(2\beta z-\psi_L=(2n+1)\pi\)</span>时,<span class="math inline">\(n=0,1,2...\)</span>,<span class="math inline">\(|\dot{U}_{min}|=|U_L^+|(1-|\Gamma|)\)</span>,进一步化简有<span class="math inline">\(\rho=\frac{1+|\Gamma|}{1-|\Gamma|},1\le\rho\le\infty,|\Gamma|=\frac{\rho-1}{\rho+1}\)</span></li>
<li>行波比：<span class="math inline">\(K=\frac{|\dot{U}|_{min}}{|\dot{U}|_{max}}=\frac{1}{\rho},0\le k\le1\)</span></li>
</ol></li>
</ol>
<h2 id="均匀无耗线的工作状态的分析">均匀无耗线的工作状态的分析</h2>
<p>对于无耗传输线, 负载阻抗不同则波的反射也不同; 反射波不同则合成波不同; 合成波的不同意味着传输线有不同的工作状态。根据终端负载的情况, 无耗传输线有三种工作状态:行波状态，驻波状态，行驻波状态，下面将分别讨论</p>
<h3 id="行波状态">行波状态</h3>
<p>当传输线是无限长，或其终端接有等于传输线的特性阻抗的负载时，信号源传向负载的能量将被负载完全吸收，而无反射，此时称传输线工作于行波状态。这时候也称传输线与负载处于匹配状态，即<span class="math inline">\(Z_L=Z_0\)</span>，终端匹配，无反射。</p>
<ol type="1">
<li><p>电压及电流 <span class="math display">\[\because U^-=I^-=0\\\therefore\begin{cases}
   \dot{U}(z)=\dot{U_L^+}e^{j\beta z}\\
   \dot{I}(z)=\dot{I_L^+}e^{j\beta z}\\
\end{cases}\]</span> 可见传输线上只有入射行波,行波状态下，均匀无耗线上各点电压复振幅的值是相同的，各点电流复振幅的值也是相同的，不随z而变化，只是U及I的相位随z的减少而滞后,线上任一处的U和I同相位，即它们的瞬时值是同相的</p></li>
<li><p>工作参量 <span class="math display">\[Z(z)=Z_L=Z_0=\sqrt{\frac{L}{C}}\\\Gamma(z)=0,\rho=1,k=1\]</span></p></li>
</ol>
<h3 id="驻波状态">驻波状态</h3>
<p>当传输线终端是短路、开路，或接有纯电抗性（电感性或电容性）负载时，由于负载不吸收能量，因而，从信号源传向负载的入射波在终端产生全反射，线上的入射波与反射波相叠加，从而形成了纯驻波状态，即<span class="math inline">\(Z_L=0,\infty,\pm jX\)</span>时，负载不吸收能量，终端全反射，线上纯驻波</p>
<h4 id="终端短路">终端短路</h4>
<ol type="1">
<li>电压及电流 <span class="math display">\[\because \dot{U_L}=0,\therefore\begin{cases}
   \dot{U}(z)=j\dot{I_L}Z_0sin\beta z\\
   \dot{I}(z)=\dot{I_L}Z_0cos\beta z\\
\end{cases}\\\because \dot{U_L^+}=\frac{\dot{U_L}+\dot{I_L}Z_0}{2},\dot{U_L}=0,\therefore \dot{I_L}=2\dot{I_L^+}\\\therefore\begin{cases}
   u(z,t)=2|\dot{U_L^+}|sin\beta zcos(wt+\psi+\pi/2)\\
   i(z,t)=2|\dot{I_L^+}|cos\beta zcos(wt+\psi)
\end{cases}\]</span> 由此可知，电压电流在时间相位与空间分布上相差<span class="math inline">\(\pi/2\)</span>，z相差<span class="math inline">\(\frac{\lambda}{4}\)</span>,当<span class="math inline">\(\beta z=n\pi\)</span>时，即<span class="math inline">\(z=\frac{n\pi}{\beta}=\frac{n\lambda}{2}(n=0,1,2,...)\)</span>,为电压驻波波节点，电流驻波波腹点；当<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2}\)</span>时，即<span class="math inline">\(z=(2n+1)\frac{\pi}{2\beta}=(2n+1)\frac{\lambda}{4}(n=0,1,2,...)\)</span>,为电压驻波波腹点，电流驻波波节点</li>
<li>工作参量
<ol type="1">
<li><span class="math inline">\(Z(z)=jZ_0tan\beta z\)</span>，纯电抗</li>
<li><span class="math inline">\(\Gamma(z)=-e^{-j2\beta z},|\Gamma_L|=1,\psi_L=-\pi\)</span></li>
<li><span class="math inline">\(\rho=\infty,k=0\)</span></li>
<li>当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(1,3,5....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(1,3,5....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯感抗。当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(2,4,6....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(2,4,6....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯容抗，在<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2},z=(2n+1)\frac{\lambda}{4}\)</span>时，<span class="math inline">\(Z(z)=\infty\)</span>,为并联谐振，在<span class="math inline">\(\beta z=n\pi,z=n\frac{\lambda}{2}\)</span>时，<span class="math inline">\(Z(z)=0\)</span>,为串联谐振</li>
</ol></li>
</ol>
<h4 id="终端开路">终端开路</h4>
<ol type="1">
<li>电压及电流 <span class="math display">\[\because\dot{I_L}=0,\therefore \begin{cases}
   \dot{U}(z)=2\dot{U_L^+}Z_0cos\beta z\\
   \dot{I}(z)=j2\dot{I_L^+}Z_0sin\beta z\\
\end{cases}\]</span> <span class="math inline">\(z=\frac{n\pi}{\beta}=\frac{n\lambda}{2}(n=0,1,2,...)\)</span>,为电压波腹点，电流波节点；当<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2}\)</span>时，即<span class="math inline">\(z=(2n+1)\frac{\pi}{2\beta}=(2n+1)\frac{\lambda}{4}(n=0,1,2,...)\)</span>,为电压驻波波节点，电流驻波波腹点 实际上终端开口的传输线并不是开路传输线, 因为在开口处会有辐射，<strong>理想的终端开路线是在终端开口处接上λ/4短路线来实现的。</strong></li>
<li>工作参量
<ol type="1">
<li><span class="math inline">\(Z(z)=-jZ_0cot\beta z\)</span>，纯电抗</li>
<li><span class="math inline">\(\Gamma(z)=e^{-j2\beta z},|\Gamma_L|=1,\psi_L=0\)</span></li>
<li><span class="math inline">\(\rho=\infty,k=0\)</span></li>
<li>当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(1,3,5....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(1,3,5....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯容抗。当<span class="math inline">\(\beta z\)</span>在第<span class="math inline">\(2,4,6....\times \frac{\pi}{2}\)</span>的范围内,即<span class="math inline">\(z\)</span>为<span class="math inline">\(2,4,6....\times \frac{\lambda}{4}\)</span>范围内，<span class="math inline">\(Z(z)\)</span>为纯感抗，在<span class="math inline">\(\beta z=(2n+1)\frac{\pi}{2},z=(2n+1)\frac{\lambda}{4}\)</span>时，<span class="math inline">\(Z(z)=0\)</span>,为串联谐振，在<span class="math inline">\(\beta z=n\pi,z=n\frac{\lambda}{2}\)</span>时，<span class="math inline">\(Z(z)=\infty\)</span>,为并联谐振</li>
</ol></li>
</ol>
<h4 id="终端接纯电抗z_lpm-jx">终端接纯电抗(<span class="math inline">\(Z_L=\pm jX\)</span>)</h4>
<p>纯电抗性负载是指传输线终端接有纯电感性或纯电容性负载时的情况,因为一段长为<span class="math inline">\(l(0&lt;l&lt;\lambda/4)\)</span>的终端短路线或开路线的输入阻抗为<span class="math inline">\(\pm jX\)</span>,所以可用一段长为<span class="math inline">\(l\)</span>的终端短路线或开路线等效代替,该方法称为<strong>延长线段法</strong> 1. 当<span class="math inline">\(Z_L=+jX\)</span>时，延长线段为<span class="math inline">\(l_e\)</span>的短路线<span class="math inline">\(\because jZ_0tan\beta l_e=+jX,\therefore l_e=\frac{\lambda}{2\pi}tan^{-1}(\frac{X}{Z_0})(0&lt;l_e&lt;\lambda/4)\)</span> 2. 当<span class="math inline">\(Z_L=-jX\)</span>时，延长线段为<span class="math inline">\(l_c\)</span>的开路线<span class="math inline">\(\because -jZ_0cot\beta l_c=-jX,\therefore l_c=\frac{\lambda}{2\pi}cot^{-1}(\frac{X}{Z_0})(0&lt;l_c&lt;\lambda/4)\)</span> 根据上面分析，终端接有纯电抗性负载的传输线，其上的电压、电流和输入阻抗也呈纯驻波状态。终端既不是电压的节腹点，也不是电流的节腹点,且<strong>当负载为纯电感时，距负载最近的为电压波腹点，负载为纯电容时，距负载最近的为电压波节点</strong> 3. 工作参量 <span class="math inline">\(\Gamma_L=\frac{\pm jX-Z_0}{\pm jX+Z_0}=|\Gamma_L|e^{j\psi_{\Gamma_L}},|\Gamma_L|=1,\psi_{\Gamma_L}=arctan(\frac{\pm2XZ_0}{X^2-Z_0^2}),\rho=\infty,K=0\)</span>,<strong>其终端处的反射系数不再是-1或+1，而是一个带有初相角的复数</strong></p>
<h3 id="行驻波状态">行驻波状态</h3>
<p>若传输线终端接有复数阻抗<span class="math inline">\(Z_L=R\pm jX\)</span>，或实数阻抗<span class="math inline">\(Z_L=R\neq Z_0\)</span>，此时，入射波能量一部分被负载吸收，剩余的能量反射回源。故线上为驻波与行波的迭加，即为行驻波状态。</p>
<ol type="1">
<li><p>电压及电流 <span class="math display">\[|\dot{U}(z)|=|\dot{U_L^+}|\sqrt{1+|\Gamma_L|^2+2|\Gamma_L|cos(\psi_L-2\beta z)}\\|\dot{I}(z)|=|\dot{I_L^+}|\sqrt{1+|\Gamma_L|^2-2|\Gamma_L|cos(\psi_L-2\beta z)}\]</span> 当<span class="math inline">\(\psi_L-2\beta z=-2n\pi,z=\frac{\psi_L\lambda}{4\pi}+\frac{n\lambda}{2}\)</span>,<span class="math inline">\(|\dot{U}(z)|\)</span>具有最大值<span class="math inline">\(|\dot{U}_L^+|(1+|\Gamma_L|)\)</span>,<span class="math inline">\(|\dot{I}(z)|\)</span>具有最小值<span class="math inline">\(|\dot{I}_L^+|(1-|\Gamma_L|)\)</span>,当<span class="math inline">\(\psi_L-2\beta z=-(2n+1)\pi,z=\frac{\psi_L\lambda}{4\pi}+\frac{(2n+1)\lambda}{4}\)</span>,<span class="math inline">\(|\dot{U}(z)|\)</span>具有最小值<span class="math inline">\(|\dot{U}_L^+|(1-|\Gamma_L|)\)</span>,<span class="math inline">\(|\dot{I}(z)|\)</span>具有最大值<span class="math inline">\(|\dot{I}_L^+|(1+|\Gamma_L|)\)</span></p>
<p>可见：行驻波状态传输线上电压与电流节腹点的分布规律与驻波状态时一样，节点与腹点相距λ/4，而且传输线上电压的腹点即电流的节点，电压的节点即电流的腹点。但不同的是：</p>
<ol type="1">
<li><span class="math inline">\(Z_L=R\neq Z_0\)</span>时，终端为节腹点，<span class="math inline">\(Z_L=R&gt;Z_0\)</span>,则<span class="math inline">\(z=0\)</span>处是电压腹点，电流节点，<span class="math inline">\(Z_L=R&lt;Z_0\)</span>,则<span class="math inline">\(z=0\)</span>处是电压节点，电流腹点</li>
<li><span class="math inline">\(Z_L=R\pm jX\)</span>时，<span class="math inline">\(\psi_l=arctan(\frac{\pm2XZ_0}{R^2+X^2-Z_0^2})\)</span>,对应的分别为感性/容性复阻抗，离开终端第一个出现的时电压腹/节点</li>
</ol></li>
<li><p>工作参量</p>
<ol type="1">
<li><span class="math inline">\(Z(z)=Z_0\frac{Z_L+jZ_0tan\beta z}{Z_0+jZ_Ltan\beta z}=Z_0\frac{1+\Gamma(z)}{1-\Gamma(z)}\)</span></li>
<li><span class="math inline">\(\Gamma(z)=|\Gamma_L|e^{j(\psi_L-2\beta z)}=\frac{Z(z)-Z_0}{Z(z)+Z_0}\)</span></li>
<li><span class="math inline">\(\rho=\frac{1+|\Gamma_L|}{1-|\Gamma_L|},1&lt;\rho&lt;\infty\)</span></li>
<li>在电压腹点(电流节点)有<span class="math inline">\(Z=\rho Z_0=R_{max}\)</span>,在电压节点(电流腹点)有<span class="math inline">\(Z=KZ_0=R_{min}\)</span>,进一步有<span class="math inline">\(R_{min}R_{max}=Z_0^2\)</span></li>
</ol></li>
<li><p>沿线阻抗分布特点</p>
<ol type="1">
<li>沿线阻抗周期性变化。在波腹、波节点处，阻抗呈现阻性（X = 0），阻抗变化周期为λ/2。在电压腹点处，阻抗出现最大值，且为纯电阻，相当于并联谐振，在电压节点处，阻抗出现最小值，且为纯电阻，相当于串联谐振。</li>
<li>每隔λ/4，阻抗性质变换一次，即具有“λ/4阻抗变换特性”</li>
<li>每隔λ/2，阻抗性质重复一次，即具有“λ/2抗重复特性”。因此，长度为λ/2或其整数倍时，不论终端接什么样的负载，其输入阻抗都和负载阻抗相等。</li>
</ol></li>
</ol>
<h2 id="史密斯圆图">史密斯圆图</h2>
<p>史密斯圆图是一种微波工程中最常用的图形工具，把特征参数和工作参数形成一体，采用图解法解决的一种专用Chart</p>
<h3 id="阻抗圆图">阻抗圆图</h3>
<h4 id="原理">原理</h4>
<p>在传输线问题的计算中常涉及要找出输入阻抗和反射系数的关系，我们可以将二者间的关系式绘制成曲线图，用图解的方法进行运算，则可以使计算大为简化。由于这些曲线实际上是一些圆，故名圆图.</p>
<p>定义： <span class="math inline">\(\frac{Z(z)}{Z_0}=Z&#39;(z)=R&#39;(z)+jX&#39;(z),Z&#39;：归一化阻抗，R&#39;：归一化电阻，X&#39;：归一化电抗\)</span>,所以有<span class="math inline">\(Z&#39;(z)=\frac{1+\Gamma(z)}{1-\Gamma(z)}\qquad\Gamma(z)=\frac{Z&#39;(z)-1}{Z&#39;(z)+1}\)</span></p>
<p>由于均匀无耗线上任一点的归一化阻抗与该点的反射系数具有一一对应的关系，因此可以将归一化阻抗实部及虚部的等值线画在以极坐标表示的反射系数的复平面上，这样构成的图形称为阻抗圆图。</p>
<h4 id="圆图的反射系数">圆图的反射系数</h4>
<p><span class="math display">\[\Gamma(z)=\Gamma_Le^{-j2\beta z}=|\Gamma_L|e^{j(\psi_L-2\beta z)}=|\Gamma_L|e^{j\psi}\]</span> <span class="math inline">\(|\Gamma|=\)</span>常数的曲线为一系列的同心圆簇，称为等<span class="math inline">\(|\Gamma|\)</span>圆，由于<span class="math inline">\(|\Gamma|=\frac{\rho+1}{\rho-1}\)</span>，所以在圆图上不画出等<span class="math inline">\(|\Gamma|\)</span>圆，只是在图中横轴上标出对应于<span class="math inline">\(|\Gamma|\)</span>的<span class="math inline">\(\rho\)</span>值(右半横轴)和K值(左半横轴)，<span class="math inline">\(\psi=\)</span>常数的曲线为一系列的径向射线簇，称为等<span class="math inline">\(\psi\)</span>线，在圆图上也不画出，而是在单位圆上标出,上半圆<span class="math inline">\(0\le\psi\le180^{\circ}\)</span>,下半圆<span class="math inline">\(-180^{\circ}\le\psi\le0\)</span>,且<span class="math inline">\(\psi=\psi_L-2\beta z=\psi_L-4\pi(\frac{z}{\lambda})\)</span>,故<span class="math inline">\(\psi\)</span>的变化对应线上电长度的变化 <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-10-18-11.png" style="width:60.0%;height:60.0%"></p>
<h4 id="圆图上的归一化阻抗">圆图上的归一化阻抗</h4>
<p><span class="math display">\[\because Z&#39;(z)=R&#39;(z)+jX&#39;(z)=\frac{1+\Gamma}{1-\Gamma},\Gamma=\Gamma_r+j\Gamma_i\\\therefore (\Gamma_r-\frac{R&#39;}{1+R&#39;})^2+\Gamma_i^2=(\frac{1}{1+R&#39;})^2\\(\Gamma_r-1)^2+(\Gamma_i-\frac{1}{X&#39;})=(\frac{1}{X&#39;})^2\]</span> 以上两方程为<span class="math inline">\(\Gamma_r+j\Gamma_i\)</span>平面上的等<span class="math inline">\(R&#39;\)</span>圆簇，等<span class="math inline">\(X&#39;\)</span>圆簇</p>
<ol type="1">
<li>等R′圆簇为R′＝常数时在<span class="math inline">\(\Gamma\)</span>平面上的圆簇,圆心坐标为<span class="math inline">\((\Gamma_r=\frac{R&#39;}{1+R&#39;},0),\)</span>半径为<span class="math inline">\(\frac{1}{1+R&#39;}\)</span>;可发现：
<ol type="1">
<li>所有等R′圆的圆心都在横轴上；</li>
<li><span class="math inline">\(\Gamma_r\)</span>与半径之和恒为1。故所有的等R′圆都相切于点（1，0）；</li>
<li>因为R&gt;0,所以所有的等R′圆都在单位圆内。其中单位圆： R′=0; 点(1,0), R′=<span class="math inline">\(\infty\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-10-35-35.png"></li>
</ol></li>
<li>等X′圆簇为X′＝常数时在<span class="math inline">\(\Gamma\)</span>平面上的圆簇,圆心坐标为<span class="math inline">\((\Gamma_r=1,\Gamma_i=\frac{1}{X&#39;})\)</span>,半径为<span class="math inline">\(\frac{1}{X&#39;}\)</span>;可发现：
<ol type="1">
<li>所有等R′圆的圆心都在<span class="math inline">\(\Gamma_r=1\)</span>上；</li>
<li>圆心纵坐标大小恒等于半径。故所有的等X′圆都相切于点（1，0）；</li>
<li>当X'&gt;0,等X'圆在上半平面，当X'&lt;0,等X'圆在下半平面，当X'=0,等X'圆在横轴，当X'=<span class="math inline">\(\infty\)</span>,等X'圆为点(1,0) <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-10-35-52.png"></li>
</ol></li>
<li>等X′圆的X′值直接标在图上，等R'圆的R'值直接由其与横轴交点处读取，又因为右半横轴对应<span class="math inline">\(\psi=0,\Gamma=|\Gamma|,\therefore Z&#39;=\frac{1+|\Gamma|}{1-|\Gamma|}=\rho\rightarrow R&#39;=\rho\)</span>,又因为左半横轴对应<span class="math inline">\(\psi=180^{\circ},\Gamma=-|\Gamma|,\therefore Z&#39;=\frac{1-|\Gamma|}{1+|\Gamma|}=K\rightarrow R&#39;=K\)</span></li>
</ol>
<h4 id="意义">意义</h4>
<ol type="1">
<li>三个特殊点
<ol type="1">
<li>坐标原点O，<span class="math inline">\(Z&#39;=R&#39;=1,X&#39;=0,\Gamma=0,\rho=K=1\)</span>代表了线上的行波工作状态，称为匹配点</li>
<li>横轴右端点，<span class="math inline">\(R&#39;=X&#39;=\infty,Z=\infty,\Gamma=1,\psi=0^{\circ},\rho=\infty\)</span>代表线上的开路处，称为开路点</li>
<li>横轴的左端点,<span class="math inline">\(R&#39;=X&#39;=Z&#39;=0,\Gamma=-1,\psi=180^{\circ},\rho=\infty\)</span>代表线上的短路处，称为短路点</li>
</ol></li>
<li>三条特殊线
<ol type="1">
<li>右半横轴（不包括两端点）:<span class="math inline">\(1&lt;R&#39;=\rho&lt;\infty,X&#39;=0,Z&#39;=R&#39;,\Gamma=|\Gamma|,\psi=0^{\circ}\)</span>代表行驻波状态的电压腹点，电流节点。称为电压波腹线</li>
<li>左半横轴（不包括两端点）:<span class="math inline">\(0&lt;R&#39;=K&lt;1,X&#39;=0,Z&#39;=R&#39;,\Gamma=-|\Gamma|,\psi=180^{\circ}\)</span>代表行驻波状态的电压节点，电流腹点。称为电压波节线</li>
<li>单位圆:<span class="math inline">\(R&#39;=0,Z&#39;=\pm jX&#39;,|\Gamma|=1\)</span>代表线上全驻波状态时节腹点之间的线段,半圆周<span class="math inline">\(\frac{\lambda}{4}\)</span></li>
</ol></li>
<li>两个半平面
<ol type="1">
<li>上半平面， X′&gt;0，电抗是感性，为感性平面</li>
<li>下半平面， X′&lt;0，电抗是容性，为容性平面</li>
<li>代表线上为行驻波状态时，节腹点之间的各<span class="math inline">\(\lambda/4\)</span>的线段</li>
</ol></li>
<li>两个旋转方向
<ol type="1">
<li>向电源:从负载移向信号源，圆图上顺时针方向旋转,z 增加</li>
<li>向负载: 从信号源移向负载，圆图上逆时针方向旋转, z减小</li>
</ol></li>
</ol>
<h3 id="导纳圆图">导纳圆图</h3>
<p>导纳圆图为阻抗圆图旋转<span class="math inline">\(180^{\circ}\)</span>所得，一般应用时圆图时不对圆图做旋转，而是将阻抗点旋转<span class="math inline">\(180^{\circ}\)</span>得到其导纳值 <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-11-11-12.png" style="width:60.0%;height:60.0%"></p>
<h2 id="长线的阻抗匹配">长线的阻抗匹配</h2>
<h3 id="阻抗匹配的概念">阻抗匹配的概念</h3>
<p>阻抗匹配通常包含两个方面的含义：1. 如何才能使得负载从信号源得到最大的功率。2. 如何才能消除传输线上的反射波。对于均匀无耗线来说，一般有三种阻抗匹配状态，对应传输线上三种不同的状态。1. 负载阻抗匹配：<span class="math inline">\(Z_L=Z_0\)</span>：行波匹配，传输线上只有从信号源到负载的入射波而无反射波。2. 源阻抗匹配：<span class="math inline">\(Z_g=Z_0\)</span>，传输线和信号源是匹配的，这种信号源称为“匹配源”，即使负载阻抗不匹配，负载的反射波也将被匹配源所吸收，始端不再产生新的反射。3. 源共轭匹配: <span class="math inline">\(Z_{in}=Z_g^*\)</span>--信号源输出功率最大</p>
<h3 id="阻抗匹配的重要性">阻抗匹配的重要性</h3>
<ol type="1">
<li>信号源共轭匹配时，信号源可以输出最大功率</li>
<li>尽量使传输系统处于或接近行波状态是很必要的，此时匹配负载可以从匹配源输出功率中吸收最大功率，传输线中的功率损耗最小、传输效率最高，传输线功率容量最大，行波状态时信号源工作稳定</li>
</ol>
<h3 id="阻抗匹配的方法">阻抗匹配的方法</h3>
<p>阻抗匹配：<span class="math inline">\(Z_L=Z_0、Z_g=Z_0、Z_{in}=Z_g^*\)</span>:只有当三者相等且都为纯电阻时，才能同时实现匹配,但<span class="math inline">\(Z_g,Z_L\)</span>一般为复阻抗，无耗传输线<span class="math inline">\(Z_0\)</span>为纯阻抗，很难同时满足匹配，<strong>为实现匹配，一般在信号源和终端负载处加始端和终端匹配装置，本节着重讨论负载阻抗匹配的方法</strong></p>
<p>负载阻抗匹配的方法从频率上可划分为窄带匹配和宽带匹配，从实现手段上可划分为<span class="math inline">\(\lambda/4\)</span>阻抗变换器法和支节调配法(利用并联/串联电抗性元件进行匹配)</p>
<h4 id="lambda4阻抗变换器法"><span class="math inline">\(\lambda/4\)</span>阻抗变换器法</h4>
<p>原理：利用<span class="math inline">\(\lambda/4\)</span>传输线的阻抗变化作用,<span class="math inline">\(Z_{in}(l)=Z_0\frac{Z_L+jZ_0tan\beta l}{Z_0+jZ_Ltan\beta l}\overset{l=\lambda/4}{\rightarrow} Z_{in}(l=\lambda/4)=\frac{Z_0^2}{Z_L}\)</span> 1. 负载阻抗<span class="math inline">\(Z_L=R_L\neq Z_0\)</span>为纯电阻时,在终端与主传输线（特性阻抗为<span class="math inline">\(Z_0\)</span>）之间串联一段长为<span class="math inline">\(\lambda/4\)</span>,特性阻抗为<span class="math inline">\(Z_{01}\)</span>的传输线，为实现匹配，<span class="math inline">\(Z_{in}=Z_0\rightarrow Z_{01}=\sqrt{Z_0Z_L}\)</span> 2. 负载阻抗<span class="math inline">\(Z_L\)</span>＝<span class="math inline">\(R_L+jX_L\)</span>为复阻抗时,若仍利用λ/4线进行阻抗匹配，则需先变换为实阻抗。 1. 法1：将λ/4线接于主传输线中的电压波节点或波腹点处 <span class="math inline">\(\because\)</span> 电压波节点或波腹点处，<span class="math inline">\(Z_{in}=Z_0/\rho\)</span>或<span class="math inline">\(Z_{in}=\rho Z_0\)</span>为纯电阻 2. 法2：将λ/4线仍接在终端，但在终端再并联长为l的短路线等。确定长度l：使特性阻抗为<span class="math inline">\(Z_{02}\)</span>，长度为l的短路线的输入导纳等于<span class="math inline">\(-jB_L\)</span>，抵消负载中的电纳部分<span class="math inline">\(jB_L\)</span>，使终端等效负载为纯电阻性的 以上方法只能调配一个频率点，属于窄带阻抗匹配 <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-41-37.png" style="width:60.0%;height:60.0%"></p>
<h4 id="利用并联电抗性元件进行匹配的支节调配器">利用并联电抗性元件进行匹配的支节调配器</h4>
<p>支节调配器法：在主传输线上某位置并联或串联长度可调的 短路线（或开路线）进行阻抗调配的方法。它是通过附加反射来抵消传输线上原存在的反射波达到匹配的目的。常用并联电抗性元件的方法</p>
<p>支节调配器：是由距离负载的某位置上的并联或串联终端短路或开路的传输线（又称支节）构成的。支节数可以是一条、两条、三条或更多。 讨论 (1)单株线调配器、(2)双株线调配器、(3)三株线调配器</p>
<ol type="1">
<li><p>单株线调配器 在主传输线上距负载d处，并联一长度为l的短路（或开路）支节，d，l可调节 工作原理：1. 在距离负载d（d&lt;λ/2）处的线上总可以找到归一化导纳为<span class="math inline">\(y_1=1+jb_1\)</span>的点(由此可确定d)；2. 在该处并联一个归一化电纳<span class="math inline">\(y_2=-jb_1\)</span>(由此可确定l),可实现与主传输线的匹配，<span class="math inline">\(y=y_1+y_2=1\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-42-11.png" style="width:60.0%;height:60.0%"> 理论上：若d在λ/2范围内可变化，B2可在<span class="math inline">\(\pm\infty\)</span>间任意调节,则可对任何有耗负载进行调配。缺点：窄频带匹配，当工作频率变化时，d和l都需重新调节，负载不同，d和l都需要改变</p></li>
<li><p>双株线调配器 距负载两个固定的位置处各并联一个短路线（或开路线）支节，固定<span class="math inline">\(d_1,d_2\)</span>，<span class="math inline">\(d_2\)</span>一般取λ/8,λ/4或3λ/8，但不能选λ/2(否则相当于一个固定位置的单支节),调节<span class="math inline">\(l_1,l_2\)</span> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-42-37.png" style="width:60.0%;height:60.0%"> <img src="/2023/11/21/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-14-42-56.png" style="width:60.0%;height:60.0%"> 缺点：窄带，存在死区，某些情况得不到匹配，只适用于匹配由负载产生的驻波比较小的传输线系统</p></li>
<li><p>三株线调配器 距负载三个固定的位置处，各并联一个短路线（或开路线）支节，主要用于缓解双株线调配器的死区问题</p></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>微波技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习要点</title>
    <url>/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>参考许毅平老师的复习要点进行补充整理</p>
<span id="more"></span>
<h2 id="第一章操作系统概论">第一章：操作系统概论</h2>
<h3 id="操作系统的发展历史定义作用功能特征分类发展动力和研究方向">1. 操作系统的发展历史、定义、作用、功能、特征、分类、发展动力和研究方向</h3>
<ul>
<li><p>操作系统的形成和发展：</p>
<ol type="1">
<li>人工操作阶段</li>
<li>半自动控制阶段</li>
<li>多道程序设计与操作系统形成</li>
<li>操作系统分类</li>
</ol></li>
<li><p>操作系统定义为用以控制和管理系统资源，方便用户使用计算机的程序集合</p></li>
<li><p>操作系统的作用可从以下几个观点来分析：</p>
<ol type="1">
<li>服务用户观点：操作系统作为用户接口和公共服务程序</li>
<li>进程交互观点：操作系统作为进程执行的控制者和协调者</li>
<li>系统实现观点：操作系统作为扩展机或虚拟机</li>
<li>资源管理观点：操作系统作为资源的管理者和控制者</li>
</ol></li>
<li><p>从资源管理的观点来看,操作系统具有五项主要功能</p>
<ol type="1">
<li>处理器管理</li>
<li>存储管理</li>
<li>设备管理</li>
<li>文件管理</li>
<li>联网与通信管理</li>
</ol></li>
<li><p>操作系统作为一个并发系统，其主要特性如下：</p>
<ol type="1">
<li>并发性</li>
<li>共享性</li>
<li>虚拟性</li>
<li>异步性</li>
</ol></li>
<li><p>按照功能、特点和使用方式，可以把操作系统分为三种基本类型：1. 批处理操作系统 2. 分时操作系统 3. 实时操作系统</p></li>
<li><p>操作系统进一步发展的主要动力：器件快速更新换代；计算机体系结构不断发展；提高系统资源利用率的需要；让用户使用计算机越来越方便的需要；满足用户新要求，提供给用户新服务</p></li>
<li><p>功能分类：微机操作系统，网络操作系统，并行操作系统，分布式操作系统，嵌入式操作系统，多核操作系统，云操作系统</p></li>
<li><p>发展方向：云计算；框计算</p></li>
</ul>
<h3 id="操作系统在计算机系统中的地位以及与其他软件的联系与区别">2. 操作系统在计算机系统中的地位以及与其他软件的联系与区别</h3>
<p>操作系统是最靠近硬件的一层软件，它一方面直接和硬件交互，在裸机上运行，将硬件的复杂性封装起来，负责管理和控制机器硬件并对其做首次扩充和改造，主要做好资源的调度和分配、信息的存取和保护、并发活动的协调与控制等工作；另一方面和上层的支撑软件和应用软件交互，把他们和计算机硬件隔离开来，为程序员提供方便的编程接口，有力的功能支撑，良好的运行环境，使计算机系统成为完整，可用，高效的计算平台</p>
<p>操作系统与支撑软件和应用软件的主要区别是：虽然它们都是软件，但操作系统有权分配资源，而其他软件只能通过操作系统使用资源，两者之间是控制与被控制的关系，操作系统直接作用在硬件上，隔离其他上层软件，为其提供接口服务，因此操作系统是软件系统的核心，是各种软件的基础运行平台</p>
<h3 id="操作系统的资源管理技术复用虚拟和抽象">3. 操作系统的资源管理技术：复用、虚拟和抽象</h3>
<ol type="1">
<li>资源复用：目的是解决物理资源数量不足</li>
<li>资源虚拟：目的是解决物理资源数量不足，提供服务的能力和水平</li>
<li>资源抽象：目的是处理系统的复杂性，解决资源的易用性</li>
</ol>
<h4 id="资源复用">资源复用</h4>
<p>可分为空分复用共享和时分复用共享</p>
<ol type="1">
<li>空分复用共享：资源分割成多个更小的分配单元，供进程使用</li>
<li>时分复用共享：资源以整体为分配单元，在一个时段里供一个进程独占享用，分为以下两种
<ol type="1">
<li>时分独占式：进程获得时分独占式资源后，对资源执行多个操作，通常使用一个完整的周期后才会释放(如磁带)</li>
<li>时分共享式：指进程占用该类资源使用后，很可能随时被剥夺，被另一个进程抢占使用(如处理器，磁盘机)</li>
</ol></li>
</ol>
<h4 id="资源虚拟">资源虚拟</h4>
<p>资源转化、模拟或整合技术，可将物理上的一个资源变成逻辑上的多个对应物(或物理上多个变为逻辑上的一个)。空分复用分割实际存在的物理资源，虚拟实现虚构假想的虚拟同类资源。</p>
<h4 id="资源抽象">资源抽象</h4>
<p>资源抽象用于处理系统的复杂性，重点解决资源的易用性。资源抽象指通过创建软件来屏蔽硬件资源的物理特性和接口细节，简化对硬件资源的操作、控制和使用的一类技术。资源抽象可分为单级资源抽象和多级资源抽象</p>
<h3 id="操作系统三个最基本抽象进程抽象虚存抽象和文件抽象">4. 操作系统三个最基本抽象：进程抽象、虚存抽象和文件抽象</h3>
<h4 id="进程抽象">进程抽象</h4>
<p>进程是对于进入内存的执行程序在处理器上操作的状态集的一个抽象，进程抽象的效果是让用户感觉到有自己独享的处理器，从而可为用户提供多任务操作系统和分时操作系统</p>
<h4 id="虚存抽象">虚存抽象</h4>
<p>虚存抽象的效果是给用户造成假象，感觉独占了一个连续地址空间，编写应用程序的长度不受物理内存大小限制；虚存是通过结合对内存和外存的管理来实现的，把一个进程的虚存的内容存储在磁盘上，用内存作为磁盘的高速缓存，以此为用户提供比物理内存空间大得多的虚拟内存空间</p>
<h4 id="文件抽象">文件抽象</h4>
<p>文件是通过将文件中的字节映射到存储设备的物理块中来是实现文件抽象，文件抽象的效果是让用户感觉到总能满足自己对设备上信息的存取需求，而且使用十分方便。</p>
<h3 id="操作系统虚拟机及其实现原理">5. 操作系统虚拟机及其实现原理</h3>
<p>操作系统虚拟机=裸机+操作系统，操作系统虚拟机的组成：虚处理器，虚拟内存，虚拟辅存，虚拟设备</p>
<h3 id="多道程序设计定义实现基础基本原理主要特征">6. 多道程序设计定义、实现基础、基本原理、主要特征</h3>
<ul>
<li>多道程序设计是指允许多个作业(程序)同时进入计算机系统的内存并启动交替计算的方法</li>
<li>起因是高速CPU与低速I/O设备不匹配。</li>
<li>根本目的是提高CPU利用率，提高内存利用率，提高I/O利用率，增加系统吞吐量</li>
<li>运行特征：
<ul>
<li>多道：内存中同时存放几个作业</li>
<li>宏观上并行运行：都处于运行状态，但都未运行完</li>
<li>微观上串行运行：各作业交替使用CPU</li>
</ul></li>
<li>优缺点分析：
<ul>
<li>优点：提高了CPU利用率，提高了主存与I/O设备的利用率，改进了系统的吞吐率，充分发挥了系统的并行性</li>
<li>缺点：作业周转时间延长</li>
</ul></li>
<li>实现基础：实现多道程序设计必须解决三个问题，他们分别是存储保护和程序浮动，处理器的管理和调度，系统资源的管理和调度</li>
</ul>
<h3 id="程序接口与系统调用">7. 程序接口与系统调用</h3>
<p>操作系统提供两种调用服务和功能的接口：</p>
<ol type="1">
<li>程序接口：运行程序调用操作系统的服务和功能的接口。由一组系统调用组成，通过该接口，用户程序可获得操作系统底层服务，使用或访问系统的软硬件资源</li>
<li>操作接口：操作系统为用户提供的操作控制计算机工作和提供服务手段的集合，通常有操作命令、图像操作界面、作业控制语言等实现手段</li>
</ol>
<ul>
<li>内核会提供一系列实现预定功能的内核函数，通过一组称为<strong>系统调用</strong>的接口呈现给用户</li>
<li>系统调用把应用程序的请求传达给内核，内核调用对应的内核函数完成请求所需处理后，再将处理结果返回给应用程序。内核的主体是系统调用的集合，可以把内核看成特殊的公共子程序，系统调用是应用程序获得操作系统服务的唯一途径，系统调用是一种中介，把用户与硬件隔离开来，应用程序通过系统调用才能请求系统服务和使用系统资源</li>
<li>系统调用的作用：
<ul>
<li>内核可基于权限和规则对资源访问进行裁决，保证系统的安全性</li>
<li>系统调用封装资源抽象，提供一致性接口，避免用户使用资源时可能发生的错误，且使编程方便效率高</li>
</ul></li>
</ul>
<h4 id="系统调用与函数调用的区别">系统调用与函数调用的区别</h4>
<ol type="1">
<li>调用形式和实现方式不同：函数调用一般调用指令，其转向地址包含在跳转语句中，系统调用不包含处理程序入口，仅提供功能号，按功能号调用</li>
<li>被调用代码的位置不同：函数调用时，调用程序和被调用代码在同一程序中，系统调用的处理代码在调用程序之外(在操作系统中)</li>
<li>提供方式不同：函数由编译系统提供，不同编译系统提供的的函数可以不同。系统调用由操作系统提供，对设计好的操作系统，系统调用的功能，种类与数量固定不变。</li>
</ol>
<h3 id="操作接口与系统程序">8. 操作接口与系统程序</h3>
<ul>
<li>操作接口：操作系统为用户操作控制计算机工作和提供服务的手段集合，通常可借助操作控制命令、图形操作界面(命令)、以及作业控制语言(命令)等来实现</li>
<li>系统程序：系统程序虽非操作系统的核心，但却必不可少，为用户程序的开发、调试、执行和维护解决带有共性的问题或执行公共操作</li>
</ul>
<h3 id="操作系统内核功能及属性">9. 操作系统内核、功能及属性</h3>
<ul>
<li>内核定义为作为可信软件来提供支持进程并发执行的基本功能和基本操作的一组程序模块，内核通常驻留在内核空间，运行于核心态，具有访问硬设备和所有主存空间的权限，是仅有的能执行特权指令的那部分程序，内核可分类为单内核(又称宏内核)和微内核</li>
<li>单内核：将内核从整体上作为一个大进程实现，并同时运行在一个单独地址空间，所有内核服务在一个地址空间运行，相互之间直接调用函数，简单高效。优点是效率高，缺点是稳定性差</li>
<li>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的，功能被划分为独立的进程，进行间通过IPC通信，一个服务失效不会影响另一个服务。优点是模块化程度高，一个服务失效不会影响其他服务。</li>
<li>内核包含的基本功能
<ul>
<li>中断处理</li>
<li>时钟管理</li>
<li>进程调度</li>
<li>原语管理等</li>
</ul></li>
<li>内核的特性
<ul>
<li>内核由中断驱动的</li>
<li>内核是不可抢占的</li>
<li>内核可以在屏蔽中断状态下执行</li>
<li>内核可以使用特权指令</li>
</ul></li>
</ul>
<h3 id="操作系统的运行模式及分类">10. 操作系统的运行模式及分类</h3>
<p>操作系统按结构分类可分为单体式结构，层次式结构，虚拟机结构，微内核结构</p>
<p>从操作系统的运行方式来看，可分成：</p>
<ol type="1">
<li>嵌入应用进程中运行模型</li>
<li>作为独立进程运行模型</li>
</ol>
<h2 id="第二章处理器管理">第二章：处理器管理</h2>
<h3 id="可重入程序和可再用程序">1. 可重入程序和可再用程序</h3>
<ul>
<li>可重入程序：指能够被多个程序同时调用的程序，纯代码，在执行过程中不被修改</li>
<li>可再用程序：指在调用它的程序退出之前不允许其他程序调用的程序，被调用过程中可以有自身修改</li>
</ul>
<h3 id="为什么要引入进程进程的定义和属性进程的状态和转换进程的描述与组成进程上下文">2. 为什么要引入进程？进程的定义和属性、进程的状态和转换、进程的描述与组成、进程上下文</h3>
<h4 id="为什么要引入进程">为什么要引入进程</h4>
<p>为了刻画程序的并发性；解决资源的共享性；</p>
<h4 id="进程的定义和属性">进程的定义和属性</h4>
<ul>
<li>进程定义：进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位</li>
<li>进程属性：动态性；共享性；独立性；制约性；并发性</li>
</ul>
<h4 id="进程的状态和转换">进程的状态和转换</h4>
<ul>
<li>进程三态模型：运行状态；就绪状态；等待状态</li>
<li>进程状态转换图 <img src="/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/2024-05-15-15-51-35.png"></li>
</ul>
<h4 id="进程的描述与组成">进程的描述与组成</h4>
<p>进程映像：进程某时刻的内容和状态集合，包括：进程控制块，进程程序块，进程核心栈，进程数据块</p>
<h4 id="进程上下文">进程上下文</h4>
<ul>
<li>操作系统中把进程物理实体和支持进程运行的环境合称为进程上下文，进程上下文由用户级上下文，系统级上下文，寄存器上下文组成</li>
</ul>
<h3 id="进程切换切换时机和切换进程处理器状态转换">3. 进程切换、切换时机和切换进程、处理器状态转换</h3>
<ul>
<li>进程切换：让处于运行态的进程中断进行，让出处理器，这时要做一次进程上下文切换、即保存老进程的上下文而装入被保护了的进程的上下文，以便新进程运行</li>
<li>切换时机：请求调度的事件发生后，就会进行低级调度程序，低级调度程序选中新的就绪进程后，就会进行上下文切换，实际上，调度和切换并不一定能一气呵成，通常的做法是，有内核置上请求调度标志，延迟到上述工作完成后再进行调度和进程上下文切换</li>
<li>处理器状态转换：当中断/系统调用发生时，暂时中断正在执行的用户进程，将进程从用户状态转换到内核状态，去执行操作系统服务程序以获得服务，这就是一次状态转换</li>
<li>处理器转换步骤：
<ol type="1">
<li>保存被中断进程的处理器现场信息</li>
<li>处理器从用户态转换到核心态，以便执行服务程序或中断处理程序</li>
<li>如果处理中断，可根据规定的中断级设置中断屏蔽位</li>
<li>根据系统调用号或中断号，从系统调用表或中断入口表找到服务程序或中断处理程序地址</li>
</ol></li>
</ul>
<h3 id="多线程环境中进程与线程联系和区别线程的实现内核级线程和用户级线程">4. 多线程环境中进程与线程联系和区别、线程的实现(内核级线程和用户级线程)</h3>
<ul>
<li>进程是操作系统中除处理器外进行的资源分配和保护的基本单位，有独立的虚拟地址空间，容纳进程映像，并以进程为单位对各种资源实施保护</li>
<li>线程是操作系统进程中能够独立执行的实体，是处理器调度和分配的基本单位，线程是进程的组成成分，每个进程内运行包含多个并发执行的实体，这就是多线程</li>
<li>从实现角度看，线程分成用户级线程ULT,内核级线程KLT,混合式线程</li>
<li>用户级线程由用户应用程序建立、调度和管理的线程，优点是线程切换不调用内核，调度是应用程序特定的：可以选择最好的算法，ULT可运行在任何操作系统上(只需要线程库)；缺点是大多数系统调用是阻塞的，因此核心阻塞进程，故进程中所有线程将被阻塞；核心只将处理器分配给进程，同一进程中的两个线程不能同时运行在两个处理器上</li>
<li>内核级线程的优点是对多处理器，内核可以同时调度统一进程的多个线程，阻塞是在线程一级完成，内核例程是多线程的；缺点：在同一进程内的线程切换调用内核，导致速度下降</li>
<li>混合式线程的线程创建在用户空间完成，大量线程调度和同步在用户空间完成，程序员可以调整KLT数量，可取两者中最好的</li>
</ul>
<h3 id="特权指令与非特权指令程序状态字">5. 特权指令与非特权指令、程序状态字</h3>
<ul>
<li>从资源管理和控制程序执行的角度出发，将指令系统中的指令分作两部分：特权指令和非特权指令；特权指令是指只能提供给操作系统的核心程序使用的指令，如启动I/O设备，设置时钟等</li>
<li>操作系统引入程序状态字(PSW)来区别不同的处理器工作状态,PSW用来控制指令执行顺序并保留和指示与程序相关的系统状态，主要作用是实现程序状态的保护和恢复</li>
</ul>
<h3 id="处理器调度的层次处理器调度算法选择的准则">6. 处理器调度的层次；处理器调度算法选择的准则</h3>
<ul>
<li>作业从进入系统成为后备作业开始，直到运行结束退出系统为止，需经历不同级别的调度：高级调度：也叫作业调度；中级调度：也叫平衡调度；低级调度：也叫处理器/线程/进程调度</li>
<li>处理器选择调度算法的原则主要参考资源利用率，响应时间，周转时间，吞吐率，公平性</li>
</ul>
<h3 id="作业调度和低级调度算法">7. 作业调度和低级调度算法</h3>
<ul>
<li>作业调度：指按照某种算法从后备作业队列中选择部分作业进入内存运行，当作业运行结束后做好善后工作</li>
<li>作业调度程序的任务：选择作业，分配资源，创建进程，作业控制，后续处理</li>
<li>低级调度算法主要分为先来先服务算法，最短作业优先算法，最短剩余时间优先算法，最高响应比优先算法，优先级调度算法，时间片轮转调度算法，多级反馈队列调度</li>
<li>作业周转时间定义为完成时间-作业被提交给系统的时间，实际上等于等待时间和运行时间之和</li>
<li>作业的带权周转时间定义为作业的周转时间/运行时间，周转时间等于等待时间和运行时间之和，故带权周转时间总大于1</li>
</ul>
<h4 id="先来先服务算法fcfs">先来先服务算法(FCFS)</h4>
<p>先来先服务是按照作业进入系统后备队列的先后次序来挑选作业，先进入系统的作业优先被挑选进入内存，FCFS调度算法的平均作业周转时间与作业提交的顺序有关</p>
<h4 id="最短作业优先算法sjf">最短作业优先算法(SJF)</h4>
<p>最短优先算法以进入系统的作业所要求的CPU时间为标准，总选取估计计算时间最短的作业投入运行，算法易于实现，效率不高，主要弱点是忽视作业等待时间，会出现饥饿现象，其平均作业周转时间比FCFS要小，故它的调度性能比FCFS好</p>
<h4 id="最短剩余时间优先算法srtf">最短剩余时间优先算法(SRTF)</h4>
<p>SRTF把SJF算法改为抢占式的。一个新作业进入就绪状态，如果新作业需要的CPU时间比当前正在执行的作业剩余下来还需的CPU时间短，SRTF强行赶走当前正在执行作业，称最短剩余时间优先算法，此算法不但适用于JOB调度，同样也适用于进程调度</p>
<h4 id="最高响应比优先算法hrrf">最高响应比优先算法(HRRF)</h4>
<ul>
<li>FCFS与SJF是片面的调度算法。FCFS只考虑作业等候时间而忽视了作业的计算时间，SJF只考虑用户估计的作业计算时间而忽略了作业等待时间</li>
<li>HRRF是介乎这两者之间的折衷算法，既考虑作业等待时间，又考虑作业的运行时间，即照顾短作业又不使长作业的等待时间过长，改进了调度性能。</li>
<li>响应比=1+已等待时间/估计运行时间，短作业容易较高响应比，长作业等待时间足够长后，也将获得足够高的响应比，饥饿现象不会发生</li>
</ul>
<h4 id="优先级调度算法">优先级调度算法</h4>
<h5 id="静态优先数法">静态优先数法</h5>
<ul>
<li>使用外围设备频繁者优先数大，这样有利于提高效率；重要算题程序的进程优先数大，这样有利于用户；进入计算机时间长的进程优先数大，这样有利于缩短作业完成的时间；交互式用户的进程优先数大，这样有利于终端用户的响应时间等等</li>
</ul>
<h5 id="动态优先数法">动态优先数法</h5>
<ul>
<li>根据进程占用CPU时间多少来决定，当进程占用CPU时间越长，那么，在它被阻塞之后再次获得调度的优先级就越低，反之，进程获得调度的可能性越大</li>
<li>根据进程等待CPU时间多少来决定，当进程在就绪队列中等待时间越长，那么在他被阻塞之后再次获得调度的优先级就越高，反之，进程获得调度的可能性就越小</li>
</ul>
<h4 id="时间片轮转调度算法">时间片轮转调度算法</h4>
<ul>
<li>时间片调度：调度程序每次把CPU分配给就绪队列首进程使用一个时间片，就绪队列中的每个进程轮流的运行一个时间片，当这个时间片结束后，强迫一个进程让出处理器，让他排列到就绪队列的尾部，等待下一轮调度。</li>
<li>轮转策略可防止那些很少使用外围设备的进程过长的占用处理器而使得要使用外围设备的那些进程没有机会去启动外围设备</li>
<li>时间片长度变换的影响：过长：退化为FIFO算法，进程在一个时间片内都执行完，响应时间长。过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长，对响应时间要求等于进程数目乘时间片，时间片长度的影响因素，就绪进程的数目：数目越多，时间片越小，系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长</li>
</ul>
<h2 id="第三章同步通信与死锁">第三章：同步、通信与死锁</h2>
<h3 id="程序的顺序执行与并发执行">1. 程序的顺序执行与并发执行</h3>
<ul>
<li>程序的顺序执行：一个程序由若干个程序段组成，而程序段在顺序处理器上的执行是严格按序的，只有当前一个操作结束后，后继操作才能开始</li>
<li>程序的并发执行：一组进程的执行在时间上是重叠的，从宏观上，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态。从微观上看，任一时刻仅有一个进程在处理器上运行。</li>
</ul>
<h3 id="与时间相关错误相交和不相交并发进程">2. 与时间相关错误、相交和不相交并发进程</h3>
<ul>
<li>与时间相关的错误：对于一组交往的并发进程，执行的相对速度无法相互控制，各种与时间有关的错误就可能出现，其主要有两种表现形式：结果不唯一，永远等待</li>
<li>不相交的并发进程：一组并发进程分别在不同的变量集合上操作，一个进程的执行与其他并发进程的进展无关</li>
<li>相交并发进程：一组并发进程共享某些变量，一个进程的执行可能影响其他并发进程的结果</li>
<li>Bernstein条件：两个进程使用的变量没有交集，则可并发执行</li>
</ul>
<h3 id="进程互斥临界区临界资源临界区管理的实现方法硬件设施和软件算法">3. 进程互斥、临界区、临界资源、临界区管理的实现方法(硬件设施和软件算法)</h3>
<h4 id="进程互斥">进程互斥</h4>
<p>进程互斥指若干个进程因相互争夺独占型资源时所产生的竞争制约关系，是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调</p>
<h4 id="临界区与临界资源">临界区与临界资源</h4>
<p>并发进程中与共享变量有关的程序段叫“临界区”，共享变量代表的资源叫“临界资源”</p>
<p>临界区调度原则：互斥使用，有空让进；忙则等待、有限等待；择一而入，算法可行</p>
<h4 id="临界区管理的实现方法">临界区管理的实现方法</h4>
<h5 id="硬件设施">硬件设施</h5>
<ol type="1">
<li>关中断：禁止一切中断发生。缺点是代价高，影响并发性；不安全，不适合多CPU</li>
<li>硬件指令：主要使用测试并设置指令与对换指令；缺点是容易产生忙等待和饥饿；优点是使用单处理器和多处理器，方法简单，可以被使用于多重临界段情况</li>
</ol>
<h3 id="进程的竞争和协作">4. 进程的竞争和协作</h3>
<h4 id="竞争关系">竞争关系</h4>
<ul>
<li>竞争关系指原本不存在逻辑关系的各进程因共享资源而产生的交互和制约关系，这是一种间接制约，又称互斥关系。</li>
<li>资源竞争的两个控制问题：死锁问题：进程因争夺资源陷入永久等待状态；饥饿问题：进程对资源的使用被无限期拖延或超过等待时间的上限；资源竞争要求我们既要解决饥饿问题又要解决死锁问题。</li>
</ul>
<h4 id="协作关系">协作关系</h4>
<ul>
<li>协作关系：指某些进程为完成同一任务需要分工协作而产生的关系</li>
<li>进程同步：指为完成共同任务的并发进程基于某个条件来协调它们的活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系。</li>
<li>如果一个进程的执行依赖于协作进程的消息或信号，当该进程没有得到来自于协作进程的消息或信号时需等待，直到消息或信号到达才被唤醒</li>
</ul>
<h3 id="进程同步同步机制用信号量和pv操作解决经典同步问题">5. 进程同步、同步机制、用信号量和PV操作解决经典同步问题</h3>
<h4 id="进程同步与同步机制">进程同步与同步机制</h4>
<p>通过调整并发进程的推进速度来防止并发进程访问缓冲区速度不匹配导致出现不正确结果，这种制约关系定义为进程同步。交互的并发进程可以通过交换信号或信息来达到调整相互速度，保证进程协调运行的目的。操作系统实现进程同步的机制称为同步机制。</p>
<h4 id="用信号量和pv操作解决经典同步问题">用信号量和PV操作解决经典同步问题</h4>
<ul>
<li>信号量：一种软件资源，除初始化外，仅能由两个同步原语对其进行操作的整型变量。</li>
<li>原语：内核中执行时不可被中断的过程：可分为P操作原语与V操作原语</li>
<li>信号量可按其取值分为二元信号量和一般信号量，二元信号量的值仅允许取0或1，主要用于互斥变量。一般信号量取值允许为非负整数，主要用于进程间的一般同步</li>
<li>在一般信号量中，P和V操作原语定义为，P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被置为等待信号量s的状态。V(s):将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程</li>
<li>信号量的物理意义：信号量S的初值表示可用资源数，当S&gt;0时,S的值表示还剩可用资源数。当<span class="math inline">\(s\le 0\)</span>时，表示已无资源可分配，其绝对值表示此时在等待队列中等待分配资源的进程数；wait操作：申请资源，若S&gt;0,意味着有资源可以申请，操作后，S=S-1意味着资源减少；Signal操作：释放资源，执行Signal操作之后，S=S+1,意味着资源数增加</li>
<li>若可用资源数为m,进程数为n,则信号量的变化范围定义为<span class="math inline">\(-(n-m)\le S\le m\)</span></li>
<li>为临界资源设置一个互斥信号量mutex，初值为1，在每个进程中把临界区代码置于P(mutex)和V(mutex)原语之间；必须要成对使用P和V原语，遗漏P原语则不能保证互斥访问，遗漏V原语则不能再使用临界资源之后将其释放给其他等待的进程；P,V原语不能次序错误，重复或遗漏</li>
</ul>
<h3 id="死锁定义引发原因产生条件死锁防止避免检测及解除方法">6. 死锁定义、引发原因、产生条件、死锁防止、避免、检测及解除方法</h3>
<ul>
<li>死锁定义：死锁是指系统中的一组进程，由于进程系统资源或由于彼此通信而永远阻塞，称这些进程处于死锁状态，其产生于资源分配策略和并发进程执行速度有关</li>
<li>死锁产生原因：进程竞争资源而资源不足；进程推进顺序不合适</li>
<li>必要条件
<ul>
<li>互斥条件：一个资源一次只能被一个进程所使用</li>
<li>占有和等待条件：一个进程因请求资源得不到满足而等待时，不释放已占有的资源</li>
<li>不剥夺条件：任一进程不能从另一进程那里抢夺资源，已被占用的资源只能由占用进程自己来释放</li>
<li>循环等待条件：在系统中存在一个由若干个进程形成的循环等待链，其中的每一个进程均占有若干个资源的某一种，同时还要求下一个进程所占有的资源</li>
</ul></li>
<li>处理死锁的三种基本方法：
<ol type="1">
<li>死锁的预防</li>
<li>死锁的避免</li>
<li>死锁的检测和恢复</li>
</ol></li>
<li>死锁的防止：死锁的预防主要通过设置某些限制条件，破坏死锁产生的必要条件，以达到不产生死锁的目的
<ul>
<li>破坏第一个条件(互斥条件)：使资源可同时访问，而不是互斥使用</li>
<li>破坏第二个条件(占有和等待条件)：采用预先静态分配法</li>
<li>破坏第三个条件(不剥夺条件)：采用剥夺式调度方法</li>
<li>破坏第四个条件(循环等待条件)：采用层次分配策略</li>
</ul></li>
<li>死锁的避免：在分配时判断是否会出现死锁，如不会死锁，则分配资源；主要利用银行家算法(单资源或多资源)</li>
<li>死锁的检测：基本思想是通过系统设置检测机构，实际的检测系统中是否存在死锁，并精确的标定出与死锁相关的进程和资源。实现是在操作系统中保存资源的请求和分配信息，利用某种算法对这些信息加以检查，以判断是否存在死锁；检测算法主要是检测是否有循环等待</li>
<li>死锁定理：如果进程资源分配图无环路，则此时系统没有发生死锁。如果有环路且每个资源类仅有一个资源，则系统发生死锁，如果有环路，涉及资源类有多个资源，则环路存在只是产生死锁的必要条件而不是充分条件</li>
<li>死锁的解除：
<ol type="1">
<li>借助于死锁的安全性测试算法来实现</li>
<li>与死锁的检测配套使用，在发现进程死锁时，采用一定策略将系统从死锁状态中恢复，常用的方法是撤销进程并剥夺资源，使用挂起和解除挂起机构</li>
</ol></li>
</ul>
<h2 id="第四章存储管理">第四章：存储管理</h2>
<h3 id="存储器层次逻辑地址空间和物理地址空间及其关系">1. 存储器层次、逻辑地址空间和物理地址空间及其关系</h3>
<h4 id="存储器层次">存储器层次</h4>
<p>存储器层次主要可以分为内存储器和外存储器。内存储器负责处理能直接访问的存储器。用来存放系统和用户的程序和数据，其特点是存取速度快，存储方式是以新换旧，断电信息丢失。外存储器是处理机不能直接访问的存储器。用来存放用户的各种信息，存取速度相对内存而言要慢的多，但它可用来长期保存用户信息，在文件系统中介绍。具体层次可从下图参考 <img src="/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/2024-05-19-18-09-14.png"></p>
<h4 id="逻辑地址空间和物理地址空间及其关系">逻辑地址空间和物理地址空间及其关系</h4>
<ul>
<li>程序地址：用户编程序时所用的地址(或称逻辑地址、虚地址),基本单位可与内存的基本单位相同，也可以不相同</li>
<li>程序地址空间(逻辑地址空间)：用户的程序地址的集合称为逻辑地址空间，它的编址总是从0开始的，可以是一维空间，也可以是多维空间</li>
<li>物理地址空间：物理地址的集合称为物理地址空间(主存地址空间)，它是一个一维的线性空间</li>
<li>为什么程序使用逻辑地址而不是物理地址？
<ul>
<li>用户需要精确计算空间与存放地址</li>
<li>支持多道程序运行十分困难</li>
<li>程序的可移植性差</li>
</ul></li>
</ul>
<h3 id="地址重定位存储保护机制">2. 地址重定位、存储保护机制</h3>
<h4 id="地址重定位">地址重定位</h4>
<ul>
<li>可执行程序逻辑地址转换(绑定)为物理地址的过程称为地址重定位、地址映射或地址转换，基于上述程序装载方式，可分为三种地址重定位
<ul>
<li>静态地址重定位：程序装入内存时由连接装入程序完成从逻辑地址到物理地址的转换</li>
<li>动态地址重定位：在程序执行时由系统硬件完成从逻辑地址到物理地址的转换。</li>
<li>运行时链接地址重定位</li>
</ul></li>
</ul>
<h4 id="存储保护机制">存储保护机制</h4>
<ul>
<li>主要目的是为了防止地址越界和控制正确存取</li>
<li>地址越界保护
<ul>
<li>各道程序只能访问自己的内存区而不能相互干扰，必须对内存中的程序和数据进行保护，以免受到其他程序有意或无意的破坏。</li>
<li>对进程执行时所产生的所有内存访问地址进行检查，确保进程仅访问它自己的内存区，就是地址越界保护</li>
<li>越界保护依赖于硬件设施，常用的有：界地址和存储键</li>
</ul></li>
<li>信息存取保护：进程访问分配给自己的内存区时，要对访问权限进行检查，如运行读、写、执行等，从而确保数据的安全性和完整性，防止有意或无意的误操作而破坏内存信息</li>
</ul>
<h3 id="分区存储管理分区原理分配算法内存不足解决方法移动技术对换技术和覆盖技术">3. 分区存储管理：分区原理、分配算法、内存不足解决方法(移动技术、对换技术和覆盖技术)</h3>
<p>存储管理中，连续存储空间管理技术主要有单用户连续存储管理，固定分区存储管理和可变分区存储管理三种</p>
<h4 id="固定分区存储管理">固定分区存储管理</h4>
<ol type="1">
<li>基本概念：把主存分为若干个固定大小的存储区，每个分区给一个作业使用，直到该作业完成后才将该区归还系统</li>
<li>用户分区划分可分为分区大小相等或不等，大小相等的缺点在于如果程序小于分区大小，则可能出现内部碎片，造成主存浪费。如果程序大于分区，则程序无法在一个分区内装入，导致程序无法运行；分区大小不等则能克服分区大小相等的缺点。</li>
<li>存储分块表(MBT)：当分区大小不等时，系统需要对每个分区的信息进行记录以便管理，MBT就是用来存储分区管理信息的数据基。MBT中一般记录存储块的大小位置和状态</li>
<li>优点：管理简单；硬件支持要求少，一对界地址寄存器；缺点：主存利用率不高，存在内部碎片。分区总数固定，限制了并发执行的程序数目。</li>
</ol>
<h4 id="可变分区存储管理">可变分区存储管理</h4>
<ol type="1">
<li>因为固定分区主存利用率不高，使用不灵活，所以引入可变分区存储管理，其定义为指事先并未将主存划分为一块块分区，而是在作业进入主存时，按作业的大小动态地建立分区，且分区个数也是随机的，实现多个作业对内存的共享，进一步提高内存资源利用率</li>
</ol>
<h4 id="分配算法">分配算法</h4>
<h5 id="最优适应法">最优适应法</h5>
<ul>
<li>定义：按分区的在内存的次序从头查找，找到其大小与要求相差最小的满足要求的空闲分区进行分配。</li>
<li>思想：避免"大材小用"，使分区内未用部分最少</li>
<li>为了便于查找，一般对空闲存储块由小到大顺序排列，这样，第一次找到的满足要求的空闲块就是最佳的空闲块</li>
<li>缺点：孤立地看，此方法似乎是最优的，但从宏观和长远看，其会在主存中留下许多难以利用的小空闲区(外部碎片)</li>
<li>优点：较大的空闲分区可以被保留</li>
</ul>
<h5 id="最先适应法">最先适应法</h5>
<ul>
<li>定义：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配</li>
<li>分析：因为分区序号常从低到高排列，因此该算法倾向于优先利用主存的低地址部分的空闲分区，可保留高端大空闲区，一般会要求对空闲分区按地址递增的次序排列</li>
<li>优点：分配回收时间性能较好，可保留高端大空闲区</li>
<li>缺点：低端易出现很多较小空闲分区，查找时间开销增大</li>
</ul>
<h5 id="最坏适应法">最坏适应法</h5>
<ul>
<li>定义：按分区在内存的先后次序从头查找，找到最大的满足要求的空闲分区进行分配</li>
<li>一般要求对空闲存储块按其大小以递增顺序排列</li>
<li>优点：减少了最佳适应法中出现过多外部碎片的缺点</li>
<li>缺点：不利于大作业分配</li>
</ul>
<h5 id="下次适应法">下次适应法</h5>
<ul>
<li>定义：该算法总是从未分配区的上次扫描结束处顺序查找非分配区表，直到找到第一个满足长度要求的空闲区为止</li>
<li>优点：缩短平均查找时间，使存储空间利用率更加均衡，不会导致小空闲区集中于主存一端</li>
</ul>
<h4 id="内存不足的存储管理技术">内存不足的存储管理技术</h4>
<h5 id="移动技术">移动技术</h5>
<ul>
<li>起因：在可变分区中，会出现大量小的空闲分区，由于地址离散，不能为程序所用，形成外部碎片，造成内存浪费</li>
<li>措施：通过移动程序，将碎片集中起来形成一个大分区</li>
<li>实施时机：
<ol type="1">
<li>在某分区被释放后立即进行紧缩</li>
<li>当请求分配模块找不到足够大的空闲分区时，再进行紧缩</li>
</ol></li>
</ul>
<h5 id="对换技术">对换技术</h5>
<ul>
<li>作用：解决多个程序存在而导致内存区不足</li>
<li>定义：通过选择一个进程，把其暂时移除到磁盘，腾出空间给某个进程使用，同时把磁盘中某个进程再换进内存，让其投入运行，这种互换称对换。</li>
<li>对换进程选择：把时间片耗尽或优先级较低的进程换出，因为短时间内它们不会被投入运行</li>
</ul>
<h5 id="覆盖技术">覆盖技术</h5>
<ul>
<li>作用：解决用户程序长度超出物理内存总和</li>
<li>定义：指一个作业的若干程序段(或数据段)间，或几个作业的某些部分间共享某主存空间。</li>
<li>不足：由用户程序自己控制内外存信息交换，用户负担很重，且程序不宜过长，用于早期的OS</li>
</ul>
<h3 id="分页存储管理基本概念-页面页框逻辑地址页表和地址转换快表页面共享和保护">4. 分页存储管理基本概念-页面、页框、逻辑地址、页表和地址转换、快表、页面共享和保护</h3>
<h4 id="分页存储管理">分页存储管理</h4>
<ul>
<li>基本思想：固定和可变分区有碎片存在，解决碎片除了前面可变分区通过内存紧凑技术消除碎片外，分页存储则采取由连续分配变为离散分配的方法</li>
<li>基本原理：
<ul>
<li>等分内存：把主存划分为相同大小的存储块，称为页架，并按其在内存中的地址顺序对其编号，记为页架号或块号</li>
<li>用户逻辑地址空间分页：将用户程序的逻辑地址空间划分为若干个与页架大小相等的部分，每个部分称为页，同样，按逻辑地址顺序对页进行编号，记为页号</li>
</ul></li>
</ul>
<h4 id="基本概念">基本概念</h4>
<ol type="1">
<li>逻辑地址表示：在分页系统中，每个逻辑地址用一个数对表示(p,d),p:页号；d:页内偏移地址</li>
<li>主存分配原则：主存以页架为单位进行分配，可将作业任意一页放入主存的任意页架，作业所有页一次性装入主存，若主存空间不够，则作业等待</li>
<li>页表：用于管理和维护进程页和页架映射关系的数据结构，称为页表，记为PMT,系统创建进程时，同时会为其产生一个PMT，结束后删除，每个进程页表存放在主存的一个连续地址空间，系统里有一个页表寄存器，用来存放当前正在运行的进程的页表起始地址和页表长度</li>
<li>地址转换：从逻辑地址中求出页号和页偏移，然后以页号为索引查找页表，得到相应的块号；将块号转换为块的物理内存地址，并与也页偏移相加获得对应的物理地址</li>
<li>快表：存放在关联高速缓存中的页表。其表目包含：页号，页架号，所属进程和页面保护权限</li>
</ol>
<h4 id="页面共享和保护">页面共享和保护</h4>
<ul>
<li>页面共享定义为多个进程共享代码和数据，不同的进程可以使用不同页号共享数据项，但必须使用相同页号共享代码页</li>
<li>实现信息共享必须解决共享信息的保护问题，通常做法是在页表中添加标志位，指出此页的信息的权限</li>
</ul>
<h3 id="分段存储管理基本概念实现思想及优点">5. 分段存储管理基本概念、实现思想及优点</h3>
<h4 id="基本概念-1">基本概念</h4>
<ul>
<li>段的定义：一组逻辑信息的组合</li>
<li>分段的引入：主要目的是为了满足用户在编程和内存使用上的要求
<ul>
<li>方便编程：用户希望能够把程序按照逻辑关系分成若干个段，每个段有段名和长度，用户程序在执行时可按段名和段内地址进行访问</li>
<li>共享和保护：在实现程序和数据的共享和保护时，都是以信息逻辑单位为基础的。而在分页系统中，每页都是存放信息的物理单位，本身并没有完整的意义，因而不便于实现信息共享和保护，而段则是信息的逻辑单元</li>
</ul></li>
<li>基本原理：
<ul>
<li>逻辑地址空间划分和表示：每个进程的地址空间被划分为若干段，每段有段名，每段从0开始连续编址，段的长度由相应点逻辑信息组长度决定，段间是可以不连续编址的，采用二维地址空间进行表示：V=(S,W),S为段号，W为段内地址</li>
<li>主存分配：以段为单位进行主存分配，段内连续存放，每段分配一个连续的主存物理空间，段间可以不连续，段和段之间在主存中地址可以离散</li>
<li>段表：用于记录和管理进程分段信息的数据表示，应包含段号，段长，段的主存起始地址。其会在用户创建进程时同时创建，进程结束时，段表删除。和页表一样被存放于连续地址空间，且有段表寄存器管理</li>
</ul></li>
<li>特点：没有内部碎片，便于共享和保护，存在外部碎片，由于段内连续分配，段的长度受内存空闲区大小的限制，但其需要更多硬件支持</li>
</ul>
<h3 id="虚拟存储器程序局部性原理请求分页虚存管理的基本原理硬件支撑页表结构地址转换缺页中断率计算">6. 虚拟存储器、程序局部性原理;请求分页虚存管理的基本原理、硬件支撑、页表结构、地址转换、缺页中断率计算</h3>
<h4 id="虚拟存储器">虚拟存储器</h4>
<ul>
<li>引入原因：实存管理需要把作业一次全部内存方能运行，使作业的大小受到内存的极大限制，解决方法有两种，物理上增加主存和逻辑上扩充主存，逻辑上扩充主存就用到了虚拟存储技术</li>
<li>定义：在具有层次结构存储器的计算机系统中，采用自动实现部分转入和部分对换功能，为用户提供一个比物理内存容量大得多的，可寻址的一种"内存储器"</li>
<li>物质基础：相当容量的辅存与一定容量的主存，地址变换机构</li>
<li>虚拟空间的限制：指令中的地址场长度限制(主要原因)；外部存储器大小的限制</li>
<li>实现要求解决的问题：内存外存统一管理问题；逻辑地址到物理地址的转换问题；部分装入和部分对换问题</li>
</ul>
<h4 id="程序局部性原理">程序局部性原理</h4>
<ul>
<li>指程序在执行过程中一个较短时间内，所执行的指令地址或操作地址分别局限于一定的存储区域中，又可以被细分为时间局部性和空间局部性</li>
<li>时间局部性：程序中某条指令一旦被执行，则较短时间内可能被再次执行，某个数据被访问，则在较短时间内可能被再次访问</li>
<li>空间局部性：一旦程序访问某个存储单元，较短时间内，附近存储单元也可能被访问，程序在一顿短时间内访问的地址可能集中在一定范围内。</li>
</ul>
<h4 id="虚拟存储管理实现技术">虚拟存储管理实现技术</h4>
<h5 id="请求分页虚拟存储管理">请求分页虚拟存储管理</h5>
<ol type="1">
<li>基本原理：只需将部分页装入内存，在执行过程中访问到不在内存页面时，产生缺页中断，再从磁盘动态地装入。当页面不在内存中，采用扩充页表内容，增加驻留标志位等信息以及增加请求调页和页面置换功能</li>
<li>外页表：页面与磁盘物理地址的对应表，由操作系统管理，进程启动运行前系统为其建立外页表，并把进程程序页面装入外存，其按进程页号顺序排列，为节省内存，外页表可存放在磁盘中，当发生缺页中断时需要查用才被调入</li>
<li>硬件支撑：内存管理单元MMU完成逻辑地址到物理地址的转换功能，它接受逻辑地址作为输入，物理地址作为输出，直接送到总线上对内存单元进行寻址</li>
<li>地址转换：
<ol type="1">
<li>直接映像的页地址转换
<ul>
<li>特点：降低CPU执行指令速度，每个进程一个页表，页表全部表项装在一个地址连续内存空间，只适合小进程地址空间</li>
<li>问题：页表可能非常大，地址映射要求非常快 <img src="/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/2024-05-20-08-44-27.png"></li>
</ul></li>
<li>多级页表地址转换：目的是为了减少进程页表对内存的占用，具体实现是通过让系统为每个进程建一个页目录表，每个表项对应一个页表项，页表项每个表项给出页面页框对应关系，页目录表是一级页表，页表项是二级页。其逻辑地址结构由三部分组成：页目录，页表页和位移 <img src="/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/2024-05-20-08-43-34.png"></li>
</ol></li>
<li>多级页表地址映射示意图 <img src="/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/2024-05-20-08-46-05.png"></li>
<li>优缺点分析：
<ul>
<li>优点：作业程序和数据可按页分散存放于内存中，减少移动开销，有效解决碎片问题，即有利于改进内存利用率，又有利于多道程序运行</li>
<li>缺点：要有硬件支持，要进行缺页中断处理，机器成本增加，系统开销加大</li>
</ul></li>
</ol>
<h4 id="缺页中断率计算">缺页中断率计算</h4>
<p>假设作业p共计n页，系统分配给它的内存块只有m块<span class="math inline">\(1\le m \le n\)</span>。如果作业p在运行中成功的访问次数为s，不成功访问次数为F，则总访问次数A=S+F,缺页中断率f=F/A</p>
<p>影响缺页终端率因素有：内存页框数，页面大小，页面替换算法，程序特性</p>
<h3 id="各种页面替换算法">7. 各种页面替换算法</h3>
<h4 id="最近页面替换算法opt">最近页面替换算法OPT</h4>
<ul>
<li>基本思想：选择"将来不再使用的"或"在最远的将来才被访问的"页面被置换</li>
<li>特点：无法实现，因为无法预知未来页面的访问情况，常用作评价其他算法的依据</li>
</ul>
<h4 id="先进先出页面替换算法fifo">先进先出页面替换算法FIFO</h4>
<ul>
<li>基本思想：算法淘汰最先调入内存的页，或者说在内存中驻留时间最长的页</li>
<li>实现技术：设置具有m个元素的页号表，控制换页，最后引入指针链成队列</li>
<li>Beledy现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现增加可用物理页框数量反而会导致缺页率增加的异常现象</li>
<li>Beledy现象的原因：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的</li>
</ul>
<h4 id="最近最少用页面替换算法lru">最近最少用页面替换算法LRU</h4>
<ul>
<li>基本思想：算法淘汰的页面是在最近一段时间内较久未被访问的那页。因为根据程序局部性原理，那些刚被使用过的页面，可能马上还要被使用，而较长时间未被使用的页面，可能不会马上需要被使用</li>
<li>实现技术：
<ol type="1">
<li>页面淘汰队列：队列中存放当前内存中页号，每当访问一页时就调整一次，使队列尾总指向最近访问的页，队列头就是最近最少用的页。发生缺页中断时总淘汰队列头所指示的页，执行一次页面访问后，需要从队列中把该页调整到队列尾</li>
<li>引用法：每页设置一个引用法R,访问某页时，由硬件将页标志位R置1，隔一定时间t将所有页的标志R均清0，发生缺页中断时，从标志位为0的页中挑选一页淘汰。挑选到要淘汰的页后，也将所有页的标志位R清0。又称最近未使用页面替换算法(NRU)</li>
<li>计数法：每个页面设置一个多位计数器，又叫最不常用页面替换算法LFU。每当访问一页时，就使它对应的计数器加1，当发生缺页中断时，可选择计数值最小的对应页面淘汰，并将所有计数器全部清0</li>
<li>计时法：为每个页面设置一个多位计时器，每当页面被访问时，系统的绝对时间记入计时器，比较各页面的计时器的值，选最小值的未使用的页面淘汰，因为他是最老的未使用的页面</li>
<li>老化算法：为每个页设置一个多位寄存器R,当页面被访问时，对应寄存器的最左边置为1，每隔时间t,将R寄存器右移一位，发生缺页中断时，找最小数值的R寄存器对应的页面淘汰</li>
</ol></li>
</ul>
<h4 id="第二次机会页面替换算法scr">第二次机会页面替换算法SCR</h4>
<ul>
<li>基本思想：对FIFO算法进行改进，将FIFO与页表中的"引用位"结合起来使用，最先进入内存的页面，如果最近还在被使用的话，仍然有机会像一个新调入的页面一样留在内存中</li>
<li>实现技术：检查FIFO中的队首页面，如果引用位为0，这个页面既老又没有用，选择该页面淘汰，如果引用位为1，说明它进入内存较早，但最近仍在使用，把他的引用位清0，并把这个页面移到队尾，看为一个新调入的页</li>
</ul>
<h4 id="时钟页面替换算法clock">时钟页面替换算法Clock</h4>
<ul>
<li>基本思想：为了改善二次机会置换算法的算法开销，其实现方式和二次机会置换基本一样，只不过把线性链表构成一个环形链表</li>
<li>实现技术：一个页面首次装入内存，其引用位置1，内存中任何页面被访问时，引用位置1，淘汰页面时，从指针当前指向页面开始扫描循环队列，把遇到的引用位是1的页面的引用位清0，跳过这个页面，把所遇到的引用位是0的页面淘汰掉，指针推进一步，在扫描循环队列时，如果遇到的所有页面的引用位为1，指针就会绕整个循环队列一圈，把遇到的所有页面的引用位清0，指针停在起始位置，并淘汰掉这一页，然后指针推进一步</li>
<li>改进算法：把引用位和修改位结合起来使用，组合成四种情况：最近没被引用和修改(r=0,m=0),最近被引用但没被修改(r=1,m=0),最近没被引用但被修改(r=0,m=1),最近被引用被修改(r=1,m=1)</li>
<li>改进算法工作流程：从指针当前位置开始，扫描循环队列，扫描过程中不改变引用位，把遇到的第一个r=0,m=0的页面作为淘汰页面，如果失败，再从原位置开始，找r=0,m=1的页面，遇到的第一个页面淘汰，把扫描过程中指针扫过的页面的引用位置为0，如果失败，再次从原位置开始，此时所有页面引用位r都为0，再按序重复前面流程，一定可以找出可淘汰的页面</li>
</ul>
<h2 id="第五章设备管理">第五章：设备管理</h2>
<h3 id="io设备分类io控制方式设备控制器及其工作原理">1. I/O设备分类；I/O控制方式；设备控制器及其工作原理</h3>
<h4 id="io设备分类">I/O设备分类</h4>
<ul>
<li>按照I/O操作特性：输入型设备、输出型设备、存储型设备</li>
<li>按照I/O信息交换的单位：字符设备、块设备</li>
<li>其中输入输出型外围设备一般为字符设备，存储型外围设备一般为块设备</li>
</ul>
<h4 id="io控制方式">I/O控制方式</h4>
<p>按照I/O控制器功能的强弱以及和CPU间联系方式的不同，对I/O设备的控制方式可分类为轮询方式、中断方式、DMA方式、通道方式，主要差别在于：中央处理器和外围设备并行工作方式不同，并行工作的程度不同。</p>
<h5 id="轮询方式">轮询方式</h5>
<ul>
<li>也叫程序IO方式或忙等待方式，使用查询指令测试设备控制器的忙闲状态位，决定内存和设备是否能交换数据。</li>
<li>工作流程：几个设备同时要求I/O，可对每个设备都编写I/O数据处理程序，轮流查询这些设备的状态位，当某个设备准备好允许I/O数据后，就调用这个设备的I/O程序处理数据传输，否则依次轮询下个设备是否准备好</li>
<li>特点：在外设进行数据处理时，CPU只能等待，消耗大量处理机时间；处理机和设备串行工作；管理简单</li>
</ul>
<h5 id="中断方式">中断方式</h5>
<ul>
<li>中断方式要求CPU和设备控制器与设备之间有中断请求线，控制器的状态寄存器有相应中断允许位。</li>
<li>工作流程：
<ol type="1">
<li>进程发出启动I/O指令，CPU加载控制信息到设备控制器的寄存器，然后进程继续执行或放弃CPU等待设备操作完成</li>
<li>设备控制器检查状态寄存器，按照I/O指令要求执行相应操作，一旦传输完成，设备控制器通过中断请求线发出I/O中断信号</li>
<li>CPU收到并响应I/O中断后，转向处理该设备的I/O中断例程执行</li>
<li>中断处理例程执行数据读取操作，将I/O缓存寄存器的内容写入内存，操作结束后退出中断处理程序，返回中断前执行状态</li>
<li>进程调度程序在适当时刻恢复得到数据的进程执行</li>
</ol></li>
<li>优点：在外设进行数据处理时，CPU不必等待，可执行该程序或其他程序</li>
<li>缺点：每次I/O都要CPU干预，CPU每次处理的数据量少，只适于数据传输率较低的设备</li>
</ul>
<h5 id="dma方式">DMA方式</h5>
<ul>
<li>工作流程：
<ol type="1">
<li>CPU通过设置DMA控制器实现DMA编程，启动磁盘控制器并测试设备</li>
<li>DMA控制器向磁盘控制器发出读请求，并将内存地址放在地址总线上</li>
<li>磁盘控制器将字节传送到内存指定单元</li>
<li>磁盘控制器向DMA控制器发送应答，DMA控制器将内部地址寄存器加1同时将计数器减1</li>
<li>重复2-4，当计数器为0时，DMA控制器向CPU发出中断信号</li>
</ol></li>
<li>优点：CPU只需干预I/O操作的开始和结束，而其中的一批数据读写无需CPU控制，适于高速设备，相比中断方式，减少了CPU对I/O控制的干预，进一步提高了CPU与I/O设备的并发程度</li>
</ul>
<h5 id="通道方式">通道方式</h5>
<ul>
<li>定义：采用专用的I/O处理器来接受CPU委托，独立执行自己的通道程序来是实现I/O设备与内存之间的信息交换，这就是通道技术</li>
<li>工作流程：
<ol type="1">
<li>用户执行I/O请求时，通过访管指令进入管理程序，由CPU通过管理程序组织一个通道程序并启动通道</li>
<li>通道执行CPU为他组织的通道程序，完成指定的数据输入输出工作，此时CPU可执行其他任务并与通道并行工作</li>
<li>通道程序结束后向CPU发中断请求，CPU响应这个中断请求后，调用管理程序对中断请求进行处理</li>
</ol></li>
<li>通道还可按照信息交换方式把通道分为字节多路通道、数组选择通道、数组多路通道</li>
</ul>
<h4 id="设备控制器及其工作原理">设备控制器及其工作原理</h4>
<ul>
<li>定义：I/O设备的电子部件，又称适配器，是可插入主板扩充槽的印刷电路板</li>
<li>工作原理：设备控制器是CPU和设备之间的接口，负责接收从CPU发来的命令，控制I/O设备操作，实现内存和设备间的数据传输</li>
</ul>
<h3 id="io软件层次io中断处理程序io设备驱动程序独立于设备的io软件和用户层io软件及各层的功能">2. I/O软件层次(I/O中断处理程序、I/O设备驱动程序，独立于设备的I/O软件和用户层I/O软件)及各层的功能</h3>
<p>I/O软件层次组织为四个层次：I/O中断处理程序，I/O设备驱动程序，独立于设备的操作系统I/O软件，用户空间的I/O软件</p>
<h4 id="io中断处理程序">I/O中断处理程序</h4>
<ul>
<li>I/O中断的类型和功能：
<ul>
<li>通知用户程序I/O操作沿链推进程度</li>
<li>通知用户程序I/O操作正常结束</li>
<li>通知用户程序发现的I/O操作异常</li>
<li>通知程序外围设备上的重要异步信号</li>
</ul></li>
<li>I/O中断处理原则：
<ul>
<li>操作正常结束：唤醒等待进程，并置为就绪态</li>
<li>操作发生故障或特殊事件的中断处理</li>
<li>人为要求而产生的中断处理</li>
<li>外围设备的异步信号处理</li>
</ul></li>
</ul>
<h4 id="设备驱动程序">设备驱动程序</h4>
<ol type="1">
<li>定义：I/O系统高层与设备控制器之间的通信程序，是与设备密切相关的代码</li>
<li>主要任务：接收用户提交的逻辑I/O请求并转换为物理I/O操作，发送给设备控制器，启动设备去执行；将设备控制器发来的信号传给上层软件</li>
<li>主要功能：
<ul>
<li>设备初始化：检查并预置设备和控制器以及通道的状态</li>
<li>执行设备驱动例程：启动设备进行数据传输，生成通道指令和通道程序，启动通道工作</li>
<li>执行中断处理例程：响应设备、控制器和通道发出的中断请求，调用相应的中断处理程序进行处理</li>
</ul></li>
<li>特点：
<ul>
<li>是设备无关软件和设备控制器之间通信和转换程序</li>
<li>与设备控制器和I/O设备的硬件特性紧密相关，不同类型的设备应配置不同的设备驱动程序</li>
<li>与I/O设备所采用的I/O控制方式紧密相关</li>
<li>与硬件紧密相关，其中一部分用汇编语言设计</li>
<li>允许可重入，常会在一次调用完成前被再次调用</li>
</ul></li>
</ol>
<h4 id="独立于设备的io软件">独立于设备的I/O软件</h4>
<p>功能：</p>
<ol type="1">
<li>提供设备驱动程序统一接口：方便添加设备驱动程序</li>
<li>设备命名和设备保护：所有设备抽象为文件，用设备文件来表示设备</li>
<li>提供独立于设备的块大小：隐藏不同设备物理数据块大小差异，向高层软件提供大小统一的逻辑数据块</li>
<li>缓冲区管理：建立内核缓冲区，数据复制</li>
<li>块设备的存储分配:实现块设备共享</li>
<li>独占性外围设备分配和回收：由系统进行统一分配和回收处理</li>
<li>错误报告：发现错误，就近逐层处理错误，提示错误</li>
</ol>
<h4 id="用户空间的io软件">用户空间的I/O软件</h4>
<p>主要是库函数(与应用程序链接)和假脱机技术(虚拟设备)</p>
<h3 id="io调度和磁盘驱动调度算法">3. I/O调度和磁盘驱动调度算法</h3>
<p>在介绍调度算法前，需要先介绍I/O系统中数据的组织</p>
<ul>
<li><p>盘片：磁盘最基本组成部分</p></li>
<li><p>磁道：盘片表面以盘片中心为圆心，不同半径的同心圆称为磁道</p></li>
<li><p>扇区：盘片被分为许多扇形区域，称为扇区，硬盘每个扇区存512字节信息</p></li>
<li><p>磁头：每个盘片的每一面都有一个读写头用于读取相应盘面数据</p></li>
<li><p>柱面：不同盘片相同半径的磁道所组成的圆柱称为柱面</p></li>
<li><p>容量磁盘：存储容量=<span class="math inline">\(磁头数*磁道(柱面)*每道扇区数*每扇区字节数\)</span></p></li>
<li><p>驱动调度：系统根据调度策略，按最佳次序执行要求访问的诸多请求，能提高系统效率</p></li>
<li><p>调度算法：</p>
<ul>
<li>先来先服务算法：磁盘臂随机移动，不考虑I/O请求间的相对次序和移动臂当前所处位置，进程等待请求时间会很长，寻道性能较差</li>
<li>最短查找时间优先算法：总是先执行查找时间最短的请求，与FIFO相比有更好的寻道性能。<strong>容易产生饥饿现象</strong></li>
<li>扫描算法：磁盘臂每次沿一个方向移动，扫过所有柱面，遇到最近的请求便处理，直到最后一个柱面后，再向相反方向移动回来。</li>
<li>分布扫描算法：将I/O请求分为长度为N的子队列，按FIFIO依次处理每个子队列，每个子队列采用扫描算法</li>
<li>电梯调度算法：扫描算法的改进，无访问请求时，移动臂不动，有访问请求时，移动臂按电梯规律移动。<strong>电梯调度和扫描算法的区别在于电梯调度不用运行到端点就可以返回</strong></li>
<li>循环扫描算法：移动臂总是从0柱面到最大号柱面顺序扫描，然后直接返回0柱面重复进行，构成循环，缩短处理新来请求的最大延迟</li>
</ul></li>
</ul>
<h3 id="虚拟设备的原理实现要点">4. 虚拟设备的原理、实现要点</h3>
<ul>
<li>SPOOLing技术：是用一类物理设备模拟另一类物理设备的技术，是使独占设备变为共享设备的一种技术</li>
<li>实现要点：独占设备改造为共享设备由于Spooling技术把所有用户进程的输出都送入输出井，然后再由输出进程完成打印工作，而输出井在磁盘上，为共享设备。这样，Spooling技术就把打印机等独占设备改造成立共享设备。实现了虚拟设备功能由于Spooling技术实现了多个用户进程共同使用打印机这种独占设备的情况，从而实现了把一个设备当成多个设备来使用，即虚拟设备的功能。</li>
</ul>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第三章知识小结</title>
    <url>/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-21-27-51.png"></p>
<ol type="1">
<li>连续傅里叶变换(FT)：连续时间,连续频率的傅里叶变换</li>
<li>傅里叶级数(FS)：连续时间,离散频率的傅里叶变换</li>
<li>序列的傅里叶变换(DTFT):离散时间,连续频率的傅里叶变换</li>
<li>离散傅里叶变换(DFT):离散时间,离散频率的傅里叶变换</li>
</ol>
<p><strong>前三种变换总有一个域不是离散的，计算机不能直接计算；希望的变换：不仅在时间域上离散，在频率域上也离散(DFT)</strong></p>
<span id="more"></span>
<h2 id="离散时间信号级数及其性质dfs">离散时间信号级数及其性质(DFS)</h2>
<h3 id="离散傅里叶级数dfs">离散傅里叶级数(DFS)</h3>
<p>周期序列表示</p>
<p><span class="math display">\[
1.\widetilde{x}(n)=\widetilde{x}(n+kN)\\\widetilde{x}(n)=x((n))_N\\\widetilde{x}(n)=\sum_{r=-\infty}^\infty x(n-rN)
\]</span></p>
<p>其中k,r为任意整数，N-周期，其ZT不收敛</p>
<p>在《信号与线性系统》中，用傅里叶级数表示连续时间周期信号。对应地，可用离散傅里叶级数表示离散周期序列，即用周期为N的复指数序列来表示</p>
<p><span class="math display">\[
\widetilde{x}(n)=\frac{1}{N}\sum_{k=0}^{N-1}\widetilde{X}(k)e^{j\frac{2\pi}{N}kn}
\]</span></p>
<p>两边<span class="math inline">\(\times e^{-j\frac{2\pi}{N}nr}\)</span>并从0-N-1求和并交换左右求和次序得：</p>
<p><span class="math display">\[
\sum_{k=0}^{N-1}\widetilde{x}(n)e^{-j\frac{2\pi}{N}nr}=\widetilde{X}(r)
\]</span></p>
<p>用k置换r 得到</p>
<p><span class="math display">\[
\sum_{k=0}^{N-1}\widetilde{x}(n)e^{-j\frac{2\pi}{N}nk}=\widetilde{X}(k)
\]</span></p>
<p>设<span class="math inline">\(W_N=e^{-j\frac{2\pi}{N}}\)</span>(旋转因子)，可得周期序列的傅里叶级数变换对</p>
<p><span class="math display">\[
\widetilde{x}(n)=IDFS[\widetilde{X}(k)]=\frac{1}{N}\sum_{k=0}^{N-1}\widetilde{X}(k)W_N^{-kn},-\infty&lt;n&lt;\infty\\\widetilde{X}(k)=DFS[\widetilde{x}(n)]=\sum_{k=0}^{N-1}\widetilde{x}(n)W_N^{kn},-\infty&lt;k&lt;\infty
\]</span></p>
<p>注：<span class="math inline">\(\widetilde{x}(n),\widetilde{X}(K)\)</span>都是离散和周期性的,且周期为N,DFS只取k次谐波分量中N个谐波分量；n为离散时间变量，理解为nT；k是离散频率变量，理解为<span class="math inline">\(\Delta wk\)</span>,DFS和IDFS具有唯一性</p>
<h3 id="离散傅里叶级数的性质">离散傅里叶级数的性质</h3>
<ol type="1">
<li><p>线性性</p></li>
<li><p>周期序列的移位： <span class="math display">\[
设DFS[\widetilde{x}(n)]=\widetilde{X}(k),则：DFS[\widetilde{x}(n-m)]=W_N^{mk}\widetilde{X}(k)\\IDFS[\widetilde{X}(k-l)]=W_N^{-nl}\widetilde{x}(n)
\]</span></p></li>
<li><p>周期卷积：设<span class="math inline">\(\widetilde{x_1}(n),\widetilde{x_2}(n)\)</span>都为周期为N的周期序列，且 <span class="math display">\[
\widetilde{X_1}(k)=\sum_{m=0}^{N-1}\widetilde{x_1}(m)W_N^{km},\\\widetilde{X_2}(k)=\sum_{r=0}^{N-1}\widetilde{x_1}(m)W_N^{kr},\\\widetilde{Y}(k)=\widetilde{X_1}(k)\widetilde{X_2}(k),\\则\widetilde{y}(n)=IDFS[\widetilde{X_1}(k)\widetilde{X_2}(k)]=\sum_{m=0}^{N-1}\widetilde{x_1}(m)\widetilde{x_2}(n-m)
\]</span></p>
<p><strong>结论：周期卷积的操作步骤与非周期序列的线性卷积相同，不同的是周期卷积仅在一个周期内求和。周期卷积中<span class="math inline">\(\widetilde{x_1}(m),\widetilde{x_2}(n-m)\)</span>对m是周期性的，周期为N,<span class="math inline">\(\widetilde{y}(n)\)</span>周期为N,且周期卷积满足交换律</strong></p>
<p>同理可得：如果<span class="math inline">\(\widetilde{y}(n)=\widetilde{x_1}(n)\widetilde{x_2}(n)\)</span>,则有<span class="math inline">\(\widetilde{Y}(k)=DFS[\widetilde{x_1}(n)\widetilde{x_2}(n)]=\frac{1}{N}\widetilde{X_1}(k)*\widetilde{X_2}(k)\)</span></p></li>
</ol>
<h2 id="离散傅里叶变换及其性质">离散傅里叶变换及其性质</h2>
<p>有限长序列的Fourier变换称为离散Fourier变换(DFT)，定义方法：由DFS导出DFT。</p>
<ol type="1">
<li>将有限长序列<span class="math inline">\(x(n)\)</span>延拓成周期序列<span class="math inline">\(\widetilde{x}(n)\)</span></li>
<li>求周期序列<span class="math inline">\(\widetilde{x}(n)\)</span>的DFS得<span class="math inline">\(\widetilde{X}(k)\)</span></li>
<li>取出<span class="math inline">\(\widetilde{X}(k)\)</span>的一个周期作为<span class="math inline">\(x(n)\)</span>的DFT <span class="math display">\[
X(k)=\widetilde{X}(k)R_N(k)
\]</span></li>
</ol>
<p>经由上诉步骤可由DFS得出有限长序列的DFT为</p>
<p><span class="math display">\[
x(n)=IDFT[X(k)]=\frac{1}{N}\sum_{k=0}^{N-1}X(k)e^{j\frac{2\pi}{N}kn}=\begin{cases}
   \frac{1}{N}\sum_{k=0}^{N-1}X(k)W_N^{-kn},0\le n\le N-1\\
   0,others
\end{cases}\\
X(k)=DFT[x(n)]=\sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn}=\begin{cases}
   \sum_{n=0}^{N-1}x(n)W_N^{kn},0\le k\le N-1\\
   0,others
\end{cases}
\]</span></p>
<p>注：<span class="math inline">\(x(n),X(K)\)</span>都是有限长的，取值范围为<span class="math inline">\(0\sim N-1\)</span>,n为离散时间变量，理解为nT,k是离散频率变量，理解为<span class="math inline">\(\Delta wk\)</span>,DFT与DFS无本质区别，DFT是DFS的主值，且隐含周期性，具有唯一性。</p>
<h3 id="用矩阵计算n点dft">用矩阵计算N点DFT</h3>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-21-22-17-24.png" style="width:50.0%;height:50.0%"></p>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-21-22-17-54.png" style="width:50.0%;height:50.0%"></p>
<h3 id="dft的性质">DFT的性质</h3>
<p><strong>旋转因子的性质</strong></p>
<ol type="1">
<li>对称性：<span class="math inline">\((W_N^k)^*=W_N^{N-k}\)</span></li>
<li>周期性：<span class="math inline">\(W_N^{k+mN}=W_N^k\)</span></li>
<li>换底：<span class="math inline">\(W_N^k=W_{mN}^{mk}\)</span></li>
</ol>
<p><strong><span class="math inline">\(\frac{N}{2}，\frac{N}{4}\)</span>点DFT为</strong></p>
<p><span class="math display">\[
X(k)=\sum_{n=0}^{N/2-1}x(n)W_{N/2}^{kn},k=0,1,...,N/2-1\\X(k)=\sum_{n=0}^{N/4-1}x(n)W_{N/4}^{kn},k=0,1,...,N/4-1
\]</span></p>
<p><strong>DFT与ZT/FT的关系：有限长序列<span class="math inline">\(x(n)\)</span>的DFT系数<span class="math inline">\(X(k)\)</span>可看作其ZT在单位圆上等角距取样的样本值:<span class="math inline">\(X(k)=X(z)|_{z=W_N^{-k}}\)</span>,有限长序列<span class="math inline">\(x(n)\)</span>的DFT系数<span class="math inline">\(X(k)\)</span>可看作其FT在一个周期<span class="math inline">\(2\pi\)</span>中等间距取样的样本值，取样间隔<span class="math inline">\(\Delta w=\frac{2\pi}{N}:X(k)=X(e^{jw})|_{w=\frac{2\pi}{N}k}=X(e^{j\frac{2\pi}{N}k})\)</span></strong></p>
<p>离散傅立叶变换的性质:</p>
<ol type="1">
<li><p>线性</p></li>
<li><p>复共轭序列的DFT <span class="math inline">\(DFT[x^*(n)]=X^*(N-k),0\le k \le N-1\)</span> 由上式可知 <span class="math display">\[\begin{cases}
   Re[X(k)]=Re[X(N-k)]\\
   Im[X(k)]=-Im[X(N-k)]
\end{cases}\]</span> 进一步可以方便的由一个复序列的DFT求得两个实序列的DFT <span class="math display">\[w(n)=x(n)+jy(n)\\W(k)=X(k)+jY(k)=Re[X(k)]-Im[Y(k)]+j(Im[X(k)]+Re[Y(k)])\\\because x(n)=\frac{1}{2}[w(n)+w^*(n)]\qquad y(n)=\frac{1}{2j}[w(n)-w^*(n)]\\\therefore X(k)=\frac{1}{2}[W(k)+W^*(N-k)]\qquad Y(k)=\frac{1}{2j}[W(k)-W^*(N-k)]\]</span></p></li>
<li><p>对称性</p>
<ul>
<li>有限长共轭对称序列<span class="math inline">\(x_{ep}(n)=x_{ep}^*(N-n)\)</span>,也可称为圆周共轭对称序列。</li>
<li>有限长共轭反对称序列<span class="math inline">\(x_{op}(n)=-x_{op}^*(N-n)\)</span></li>
<li>变换区间：<span class="math inline">\(0\le n \le N-1\)</span>，以n=N/2为对称点</li>
<li>频域定义：共轭对称序列：<span class="math inline">\(X_{ep}(k)=X_{ep}^*(N-k)\)</span>，共轭反对称序列：<span class="math inline">\(X_{op}(k)=-X_{op}^*(N-k)\)</span></li>
<li>序列分解：
<ul>
<li><span class="math inline">\(x_{ep}(n)=\frac{1}{2}[x(n)+x^*(N-n)],x_{op}(n)=\frac{1}{2}[x(n)-x^*(N-n)]\)</span></li>
<li><span class="math inline">\(DFT[jx_i(n)]=X_{op}(k) \quad DFT[x_r(n)]=X_{ep}(k)\\DFT[x_{ep}(n)]=X_R(k) \quad DFT[x_{op}(n)]=jX_I(k)\)</span> <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-14-50-38.png" style="width:50.0%;height:50.0%"></li>
</ul></li>
</ul></li>
<li><p>序列的循环移位:一个序列的循环移位定义为:<span class="math inline">\(y(n)=x((n+m)_N)\cdot R_N(n)\)</span>,序列循环移位后DFT为:<span class="math inline">\(Y(k)=DFT[x((n+m)_N)R_N(n)]=W_N^{-km}X(k)\)</span>,由时域频域的对偶关系，<span class="math inline">\(X(k)\)</span>循环移位时，设<span class="math inline">\(Y(k)=X((k+l))_N\cdot R_N(k)\)</span>,则<span class="math inline">\(y(n)=IDFT[X((k+l))_NR_N(k)]=W_N^{nl}x(n)\)</span> <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-14-54-56.png" style="width:40.0%;height:40.0%"></p></li>
<li><p>循环卷积:对于两个长度均为N的序列<span class="math inline">\(x_1(n),x_2(n)\)</span>,其循环卷积定义为<span class="math inline">\(y(n)=\sum_{m=0}^{N-1}x_1(m)x_2((n-m))_NR_N(n)=\)</span><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-15-01-41.png" style="width:20.0%;height:10.0%"> <strong>特点</strong>：</p>
<ul>
<li>循环卷积的过程与周期卷积一样，只取周期卷积的主值</li>
<li>循环卷积隐含周期性</li>
<li>循环卷积在主值区间内进行，参与卷积的两个序列的长度和结果序列的长度均相等</li>
<li>线性卷积与循环卷积计算步骤比较：
<ul>
<li>线性卷积：反折、平移、相乘、积分(或相加)</li>
<li>循环卷积：反折、周期化、平移、相乘、相加 <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-21-22-19-51.png"></li>
</ul></li>
</ul></li>
</ol>
<h2 id="利用循环卷积计算线性卷积">利用循环卷积计算线性卷积</h2>
<p>循环卷积与线性卷积的对比图 <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-15-05-34.png"></p>
<p>由循环卷积求线性卷积</p>
<ol type="1">
<li>当<span class="math inline">\(L&lt;N+M-1\)</span>其循环卷积的结果与线性卷积不相等，但满足一定关系</li>
<li>当<span class="math inline">\(L\ge N+M-1\)</span>两个长度为M，N的序列的线性卷积可用长度均为L的循环卷积来代替</li>
</ol>
<h2 id="频率取样">频率取样</h2>
<h3 id="序列的几种变换之间的关系">序列的几种变换之间的关系</h3>
<ol type="1">
<li>ZT与FT：<span class="math inline">\(X(z)|_{z=e^{jw}}=X(e^{jw})\)</span> 单位圆上的ZT等于序列的FT</li>
<li>LT与ZT：<span class="math inline">\(X(z)|_{z=e^{sT}}=\hat{X}_a(s)\)</span> S平面-&gt;Z平面：S平面上的宽度为<span class="math inline">\(\frac{2\pi}{T}\)</span>的水平带映射为整个平面，左半带映射到单位圆内，右半带映射成单位圆外，虚轴映射为单位圆</li>
<li>DFT与ZT：<span class="math inline">\(X(k)=X(z)|_{z=W_N^{-k}}\)</span> DFT是ZT在单位圆上等角距<span class="math inline">\(\frac{2\pi}{N}\)</span>取样的样本值</li>
<li>DFT与FT：<span class="math inline">\(X(k)=X(e^{jw})|_{w=\frac{2\pi}{N}k}=X(e^{j\frac{2\pi}{N}k})\)</span>,DFT是FT在一个周期等间距取样值，取样间隔<span class="math inline">\(\Delta w=\frac{2\pi}{N}\)</span></li>
</ol>
<h3 id="从n个取样值恢复xn">从N个取样值恢复<span class="math inline">\(x(n)\)</span></h3>
<p><strong>频域取样是指对时域已是离散，频域仍是连续信号。现在频域上进行抽样处理，使其频域也离散化。</strong></p>
<p>在Z平面的单位圆上对序列的ZT进行等角距取样，将导致时间序列的周期延拓 取样后序列主值序列为<span class="math inline">\(x_N(n)=x_p(n)R_N(n)=[\sum_{r=-\infty}^{\infty}x(n+rM)]R_N(n)\)</span></p>
<p><strong>对于长度为N的有限长序列，ZT取样即频率取样不失真的条件是取样点数M应等于或大于原序列的长度N</strong></p>
<h3 id="从n个取样值恢复xzxejw">从N个取样值恢复<span class="math inline">\(X(z),X(e^{jw})\)</span></h3>
<p>长度为N的序列<span class="math inline">\(x(n)\)</span>的FT<span class="math inline">\(x(e^{jw})\)</span>可通过Z平面单位圆上的N个取样值<span class="math inline">\(x(k)\)</span>，即N个频域取样值来恢复,其中用到了和第二章类似的思路通过内插函数<span class="math inline">\(\phi(z)\)</span>与<span class="math inline">\(x(k)\)</span>相乘恢复</p>
<h2 id="快速傅里叶变换">快速傅里叶变换</h2>
<p>直接计算DFT对于计算机来说运算时间和资源占用非常大，因此本节将介绍两种常用的快速傅里叶变换算法(FFT)来用于DFT计算</p>
<h3 id="时间抽取fft算法">时间抽取FFT算法</h3>
<p>基本出发点：利用<span class="math inline">\(W_N^k\)</span>的周期性和对称性，将DFT的计算分解成一些逐次减小的DFT计算；</p>
<p>分解规则：：（1）对时间进行偶奇分（2）对频率进行前后分。</p>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-16-36-54.png" style="width:60.0%;height:60.0%"></p>
<p>上面时间抽选FFT流图具有三个特点： ① 基本计算单元为一碟形； ② 输入为“混序”排列；输出为正序排列； ③ 具有“同址计算”特性。</p>
<ol type="1">
<li>蝶形计算： 对于任意<span class="math inline">\(N=2^M\)</span>，总可以通过M级分解成2点DFT计算，每次由<span class="math inline">\(\frac{N}{2}\)</span>蝶形计算组成，如下图所示 <img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-17-09-25.png" style="width:50.0%;height:50.0%"> 计算方程为 <span class="math display">\[\begin{cases}
   X_{m+1}(p)=X_m(p)+W_N^kX_m(q)\\
   X_{m+1}(q)=X_m(p)-W_N^kX_m(q)
\end{cases}\]</span> 完成一次蝶形运算需要2次复加法和1次复乘法，因为完成<span class="math inline">\(N=2^M\)</span>点的DFT计算需要<span class="math inline">\(log_2N\)</span>级迭代计算，每级<span class="math inline">\(\frac{N}{2}\)</span>个蝶形，蝶形数<span class="math inline">\(\frac{N}{2}log_2N\)</span>，完成N点的时间抽选FFT总计算量为:复乘法次数<span class="math inline">\(\alpha_F=\frac{N}{2}log_2N\)</span>,复加法次数<span class="math inline">\(\beta_F=Nlog_2N\)</span>，直接计算DFT需复乘法次数<span class="math inline">\(\alpha_D=N^2\)</span>,则<span class="math inline">\(\frac{\alpha_F}{\alpha_D}=\frac{log_2N}{2N}\)</span></li>
<li>同址计算： 蝶形计算的好处在于其是一个蝶形计算，输入的运算结果直接送到下一蝶形计算输入保存，中间不需要其他存储器，<strong>节省存储单元，N越大好处越明显</strong></li>
<li>变址计算 从FFT流图可知，输入是混序排列，输出是正序排列，在实际计算中，输入的混序是通过输入正序排列按码位倒置的变址处理得到的，即 <span class="math display">\[x(1)\rightarrow x(001)\Rightarrow x(100)\rightarrow x(4)\]</span> 这样即可实现FFT的同址计算</li>
</ol>
<h3 id="频率抽取fft算法">频率抽取FFT算法</h3>
<p>分解原则：(1)对时间前后分；(2)对频率偶奇分</p>
<p><img src="/2023/11/15/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-16-16-37-26.png" style="width:60.0%;height:60.0%"></p>
<h3 id="n为合数的fft算法">N为合数的FFT算法</h3>
<p>在前面两小节的讨论中，我们只涉及序列长度<span class="math inline">\(N=2^M\)</span>的FFT算法，本节则将着重讨论如果序列长度<span class="math inline">\(N\neq2^M\)</span>时的处理办法。通常有以下两种处理方法</p>
<ol type="1">
<li>用补零的办法将<span class="math inline">\(x(n)\)</span>延长为<span class="math inline">\(2^M\)</span>，再使用基2FFT算法。由于有限长序列补零以后，只是频谱的取样点有所增加。</li>
<li>采用以任意数为基数的FFT算法。设N等于两个整数p和q的乘积，即<span class="math inline">\(N=p\cdot q\)</span>，则可将N点DFT分解成p个q点DFT或q个p点DFT来计算。</li>
</ol>
<h2 id="fft应用">FFT应用</h2>
<h3 id="利用fft对信号进行谱分析">利用FFT对信号进行谱分析</h3>
<p>所谓谱分析就是计算信号的频谱，包括振幅谱、相位谱和功率谱。设离散时间信号<span class="math inline">\(x(n)\)</span>是从连续时间信号<span class="math inline">\(x_a(t)\)</span>取样得到的，定义参数如下:</p>
<ol type="1">
<li>T-取样周期(s)</li>
<li><span class="math inline">\(f_s\)</span>-取样频率(Hz),<span class="math inline">\(f_s=\frac{1}{T}\)</span></li>
<li><span class="math inline">\(f_0\)</span>-连续时间信号的最高频率(Hz)</li>
<li>F-频率分辨率：指频域取样中两相邻点间的频率间隔(Hz)</li>
<li><span class="math inline">\(t_p\)</span>-信号的最小记录长度(s),<span class="math inline">\(t_p=\frac{1}{F}\)</span></li>
<li>N-一个记录长度中的取样数,<span class="math inline">\(t_p=NT\)</span></li>
</ol>
<p>根据取样定理，为了避免混叠失真，要求</p>
<p><span class="math display">\[
f_s\ge2f_0\quad or \quad T\le \frac{1}{2f_0}
\]</span></p>
<p>最小记录长度为：<span class="math inline">\(t_p=NT=\frac{1}{F}\)</span>，则取样点数N须满足条件<span class="math inline">\(N\ge\frac{2f_0}{F}\)</span></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>微波技术基础第三四章知识小结</title>
    <url>/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>因为第四章内容较少，且和第三章关系紧密，故将两章合并</p>
<h2 id="导波系统的一般分析方法">导波系统的一般分析方法</h2>
<h3 id="导波系统的基本概念">导波系统的基本概念</h3>
<p><strong>导波（导行波）</strong>：在微波传输线中按指定方向传播的电磁波</p>
<p><strong>导波系统（波导）</strong>：用来导行电磁波的装置</p>
<span id="more"></span>
<p><strong>规则波导</strong>：沿轴线方向，横截面的形状、尺寸，以及填充介质的分布状态和电参数均不变的无限长的直波导</p>
<p><strong>狭义的波导</strong>：只限于空心的金属矩形和圆形波导等。</p>
<h3 id="不同类型的场">不同类型的场</h3>
<p>波形可划分为三类(根据纵向分量区分):</p>
<ol type="1">
<li><span class="math inline">\(\dot{E_z}=0,\dot{H_z}=0\)</span>:横电磁波：TEM波,<span class="math inline">\(\dot{\overrightarrow{E_t}}=\eta\dot{\overrightarrow{H_t}}\times\dot{\overrightarrow{a_z}}\\\dot{\overrightarrow{H_t}}=\frac{1}{\eta}\dot{\overrightarrow{a_z}}\times\dot{\overrightarrow{E_t}}\)</span></li>
<li><span class="math inline">\(\dot{E_z}=0,\dot{H_z}\neq 0\)</span>:横电波：TE波 H波 电场只有横向分量，纵向分量为零，所以有<span class="math inline">\(\dot{\overrightarrow{E_t}}=\frac{w\mu}{\beta}\dot{\overrightarrow{H_t}}\times\dot{\overrightarrow{a_z}}\)</span></li>
<li><span class="math inline">\(\dot{E_z}\neq 0,\dot{H_z}=0\)</span>:横磁波：TM波 E波 磁场只有横向分量，纵向分量为零，所以有<span class="math inline">\(\dot{\overrightarrow{H_t}}=\frac{w\epsilon}{\beta}\dot{\overrightarrow{a_z}}\times \dot{\overrightarrow{E_t}}\)</span> TE、TM波在横截面内<span class="math inline">\(E_t\)</span>和<span class="math inline">\(H_t\)</span>相互正交，而且与单位矢量z构成一个右手螺旋系</li>
</ol>
<h2 id="波沿导波装置的传输特性">波沿导波装置的传输特性</h2>
<h3 id="传输条件">传输条件</h3>
<p>TE波和TM波在金属波导内传输需满足一定的条件：</p>
<ol type="1">
<li><span class="math inline">\(Z(z)=A^+e^{-j\beta z}\)</span>：无耗波导沿z轴正方向</li>
<li><span class="math inline">\(\beta=\sqrt{K^2-K_c^2}\)</span>：相移常数</li>
<li><span class="math inline">\(K_c=\frac{2\pi}{\lambda_c}=2\pi\sqrt{\mu\epsilon}f_c\)</span>:由横截面尺寸、性质和波型决定</li>
<li><span class="math inline">\(K=w\sqrt{\mu\epsilon}\)</span>:当波导介质一定，就由该波的频率决定</li>
<li><span class="math inline">\(\beta\rightarrow f,\lambda\)</span>,当f变化时，出现以下三种情况：
<ol type="1">
<li><span class="math inline">\(K&gt;K_c,\beta\rightarrow\)</span>实数，波导-传输状态(波向正方向和负方向传播)，此时<span class="math inline">\(\lambda&lt;\lambda_c,f&gt;f_c\)</span>(<span class="math inline">\(\lambda=2\pi/(w\sqrt{\mu\epsilon})\)</span>)-工作波长，f-工作频率，与波导无关</li>
<li><span class="math inline">\(K&lt;K_c,\beta\rightarrow\)</span>虚数，波导-截止状态(波沿指数规律衰减)，此时<span class="math inline">\(\lambda&gt;\lambda_c,f&lt;f_c\)</span></li>
<li><span class="math inline">\(K=K_c,\beta=0\)</span>,波导-临界状态,此时<span class="math inline">\(\lambda=\lambda_c,f=f_c,f_c=\frac{K_c}{2\pi\sqrt{\mu\epsilon}},\lambda_c=\frac{2\pi}{K_c}=\frac{1}{\sqrt{\mu\epsilon}f_c}=\frac{v}{f_c},v:\)</span>波在无界介质中传播速度，可见波导具有高通滤波器特性。(TEM波截止频率为零)</li>
</ol></li>
</ol>
<h3 id="传播常数">传播常数</h3>
<p>传播常数<span class="math inline">\(\gamma=\alpha+j\beta\)</span>,衰减常数<span class="math inline">\(\alpha\)</span>:波导单位长度上波幅值的衰减量 (dB/m),相移常数<span class="math inline">\(\beta\)</span>:波沿波导轴向传播时单位距离内相位的变化量(rad/m),无耗传输线:<span class="math inline">\(\alpha=0\quad\gamma=j\beta\)</span></p>
<h3 id="相速">相速</h3>
<p>相速<span class="math inline">\(v_p\)</span>: 波的等相位面沿波导轴向（z）传播的速度,<span class="math inline">\(v_p=\frac{dz}{dt}=\frac{w}{\beta}=\frac{2\pi f}{\sqrt{(\frac{2\pi}{\lambda})^2-(\frac{2\pi}{\lambda_c})^2}}=\frac{v}{\sqrt{1-(\lambda/\lambda_c)^2}}\)</span>,<strong>TEM波型的相速:<span class="math inline">\(\because \lambda_c\rightarrow\infty\quad v_p=v=\frac{1}{\sqrt{\mu\epsilon}}\)</span></strong>,TE和TM波型相速：<span class="math inline">\(\lambda&lt;\lambda_c,v_p&gt;v\)</span>,可知TEM波的相速与频率无关。具有这种特性的波型称为<strong>无色散波型</strong>，对于传输某一波型的电磁波而言，其相速随频率而变化的(例如TE和TM波型)，具有这种特性的波型称为<strong>色散波型</strong>。</p>
<h3 id="波导波长">波导波长</h3>
<p>波导波长<span class="math inline">\(\lambda_g\)</span>：波导内沿轴向传播的电磁波相邻的两个同相位点之间的距离, 也就是相位相差2π的两点间的距离。<span class="math inline">\(\lambda_g=\frac{v_p}{f}=\frac{\lambda}{\sqrt{1-(\lambda/\lambda_c)^2}},\beta=\frac{2\pi}{\lambda_g}\)</span>,TEM波:<span class="math inline">\(\lambda_g=\lambda\)</span>,TE/TM波：<span class="math inline">\(\lambda&lt;\lambda_c\quad\lambda_g&gt;\lambda\)</span></p>
<h3 id="群速">群速</h3>
<p>群速<span class="math inline">\(v_g\)</span>：多频率成分构成的“波群”的速度（波群－－一群具有相近的ω与相近的β的波），代表能量的传播速度。<span class="math inline">\(v_g=\frac{dw}{d\beta}=v\sqrt{1-(\frac{\lambda}{\lambda_c})^2}(\lambda&lt;\lambda_c),v_g\cdot v_p=v^2\)</span></p>
<h3 id="波型阻抗">波型阻抗</h3>
<p>波型阻抗<span class="math inline">\(Z_w\)</span>：电场的横向分量<span class="math inline">\(E_t\)</span>与磁场的横向分量<span class="math inline">\(H_t\)</span>的幅值之比（行波状态下）,TE波:<span class="math inline">\(Z_{TE}=\frac{w\mu}{\beta}=\sqrt{\frac{\mu}{\epsilon}}\frac{\lambda_g}{\lambda}=\eta\frac{\lambda_g}{\lambda}&gt;\eta\)</span>,TM波:<span class="math inline">\(Z_{TM}=\frac{\beta}{w\mu}=\sqrt{\frac{\mu}{\epsilon}}\frac{\lambda}{\lambda_g}=\eta\frac{\lambda}{\lambda_g}&lt;\eta\)</span>,TEM波：<span class="math inline">\(Z_{TEM}=\sqrt{\frac{\mu}{\epsilon}}=\eta\)</span>(波在无界媒质中的波阻抗)<span class="math inline">\(\approx120\pi\)</span></p>
<h2 id="矩形波导">矩形波导</h2>
<p>矩形波导：通常将由金属材料制成的（一般为铜或铝，内表面镀银或金）、矩形截面的、内充空气的规则金属波导称为矩形波导。它是微波技术中最常用的传输系统之一，其优点在于<strong>微波高频段（厘米波或毫米波）损耗小、功率容量大、频带宽</strong></p>
<h3 id="场解及波型">场解及波型</h3>
<h4 id="te波h波">TE波(H波)</h4>
<ol type="1">
<li><p>场分量表达式：TE波型：<span class="math inline">\(E_Z=0,H_z\neq 0\)</span>,由矩形波导的边界条件:理想导体表面磁场的垂直分量<span class="math inline">\((H_x,H_y)=0\)</span>，结合边界条件得到磁场纵向分量<span class="math inline">\(H_z=H_0cos(\frac{m\pi}{a}x)cos(\frac{n\pi}{b}y)e^{-j\beta z}\)</span>，再进一步推导得到矩形波导其他场分量表达式，其中，最重要的是<span class="math inline">\(K_c=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2}\)</span>,其与波导尺寸和传输波型有关</p>
<ol type="1">
<li>上式的m,n分别代表TE波沿x方向和y方向分布的半波个数,且每一对(m,n)对应一种波型，记为<span class="math inline">\(TE_{mn}(H_{mn})\)</span></li>
<li>对于TE波而言，m、n中任意一个可以为0，但是不能同时为0，故存在<span class="math inline">\(TE_{m0},TE_{0n},TE_{mn}\)</span>,矩形波导中TE波的最低次波型(截止波长最长或截止频率最低)为<span class="math inline">\(TE_{10}(a&gt;b)\)</span>，其余称为高次模</li>
<li>场沿z轴为行波，x,y轴为纯驻波分布，<strong>这意味着在行波状态下，沿矩形波导的纵向（z轴）传输的是有功功率，而在矩形波导的横向（x和y轴）只存在无功功率，即没有功率的传输。</strong></li>
</ol></li>
<li><p>场结构：为了能形象和直观的了解场的分布（场结构），可以利用电力线和磁力线来描绘它。电力线和磁力线遵循的规律：力线上某点的切线方向<span class="math inline">\(\rightarrow\)</span>该点处场的方向,力线的疏密程度<span class="math inline">\(\rightarrow\)</span>场的强弱,当给定了m和n时，根据场分量表达式，就可以绘出电力线和磁力线的图形----场结构图,下面举例<span class="math inline">\(TE_{10}模\)</span></p>
<p><span class="math inline">\(TE_{10}\)</span>波:各个场分量沿x方向有一个半驻波分布，y方向不变为均匀分布。 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-18-53-24.png" style="width:40.0%;height:40.0%"></p></li>
</ol>
<h4 id="tm波e波">TM波（E波）</h4>
<ol type="1">
<li>场分量表达式：TM波型：<span class="math inline">\(H_Z=0,E_z\neq 0\)</span>,由矩形波导的边界条件:理想导体表面切向电场为零,结合边界条件得到磁场纵向分量<span class="math inline">\(E_z=E_0sin(\frac{m\pi}{a}x)sin(\frac{n\pi}{b}y)e^{-j\beta z}\)</span>
<ol type="1">
<li>存在无穷多个波型与m、n对应，其线性组合（叠加）也是场解。每一对（m、n）对应一种波型，记为<span class="math inline">\(TM_{mn}\)</span>。同样<span class="math inline">\(K_c=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2}\)</span></li>
<li>对于TM波，m、n中任意一个不能为0，否则场全为0。(<span class="math inline">\(m,n=0\rightarrow E_z=0\)</span>)所以<span class="math inline">\(TM_{00}、TM_{0n}、TM_{m0}\)</span>不存在。最低波型为<span class="math inline">\(TM_{11}\)</span>。</li>
<li>TM波型的场沿z轴为行波，沿x、y轴为纯驻波分布（正弦、余弦的分布规律）所以行波状态下，沿波导纵向（z轴）传输有功功率、横向（x、y轴）无功功率</li>
</ol></li>
<li>场结构 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-19-02-54.png"></li>
</ol>
<h3 id="矩形波导中电磁波的传播特性">矩形波导中电磁波的传播特性</h3>
<ol type="1">
<li>截止波长和截止频率 <span class="math inline">\(\lambda_c=\frac{2\pi}{K_c}=\frac{2}{\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2}},f_c=\frac{v}{\lambda_c}=\frac{1}{2\sqrt{\mu\epsilon}}\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2}\)</span>,可见<span class="math inline">\(TE_{mn},TM_{mn}\)</span>在m、n相同时具有相同的截止波长与截止频率，但场分布不同</li>
<li>波型简并 由于矩形波导中，对于m及n均不为0的<span class="math inline">\(TE_{mn},TM_{mn}\)</span>模，具有相同的截止波长<span class="math inline">\(\lambda_c\)</span>，故这种场结构（波型）不同的模式截止波长相同的现象。<span class="math inline">\(TE_{0n},TE_{m0}\)</span>是非简并模,存在简并现象的模式称为简并模，简并模在工作频率相同时，其相速、群速、波导波长都是相同的。在工作中要想办法抑制工作模的简并模。</li>
<li>截止波长分布图 因为截止波长与m,n成反比，所以当a,b一定时，m,n越小，截止波长<span class="math inline">\(\lambda_c\)</span>越大,对应的<span class="math inline">\(\beta=\frac{2\pi}{\lambda}\sqrt{1-(\frac{\lambda}{\lambda_c})^2}\)</span>,<strong>所以当工作波长<span class="math inline">\(\lambda&lt;\)</span>某种模式的<span class="math inline">\(\lambda_c\)</span>时，<span class="math inline">\(\beta&gt;0\rightarrow\)</span>传导模，反之则为截止模</strong></li>
<li>主模，高次模,单模波导 截止波长最长的模式称为矩形波导中的主模其余为高次模。矩形波导中的主模为<span class="math inline">\(TE_{10}\)</span>，其<span class="math inline">\(\lambda_c=2a\)</span>，只能传输主模的波导为单模波导</li>
</ol>
<h3 id="矩形波导主模te_10模场分布及工作特性">矩形波导主模<span class="math inline">\(TE_{10}\)</span>模场分布及工作特性</h3>
<p>为何要单模传输？:不同模式的相速不同，他们之间将有模式色散，从而使信号发生畸变。所以微波传输系统无一例外采用单模传输，即只传输主模</p>
<p><span class="math inline">\(TE_{10}\)</span>模可以在相当宽的频带内单模工作，而在此频带内其它模式都截止。这是其得到广泛应用的主要原因</p>
<ol type="1">
<li><span class="math inline">\(TE_{10}\)</span>模的特点:
<ol type="1">
<li>只有<span class="math inline">\(E_y、H_x、H_z\)</span>三个分量</li>
<li>各分量与y无关，即沿y轴均匀分布</li>
<li>横向场量<span class="math inline">\(E_y,H_x\)</span>与纵向场量<span class="math inline">\(H_z\)</span>在x方向上和z方向上相位相差π/2</li>
</ol></li>
<li>传输特性
<ol type="1">
<li><span class="math inline">\(K_c=\frac{\pi}{a}\quad\lambda_c=\frac{2\pi}{K_c}=2a\)</span></li>
<li><span class="math inline">\(\beta=\frac{2\pi}{\lambda}\sqrt{1-(\lambda/\lambda_c)^2}=\frac{2\pi}{\lambda}\sqrt{1-(\lambda/2a)^2}{}\\\lambda_g=\frac{2\pi}{\beta}=\frac{\lambda}{\sqrt{1-(\lambda/2a)^2}}\)</span></li>
<li><span class="math inline">\(v_p=\frac{w}{\beta}=\frac{v}{\sqrt{1-(\lambda/2a)^2}}\\v_g=\frac{dw}{d\beta}=v\sqrt{1-(\lambda/2a)^2}\)</span></li>
<li><span class="math inline">\(Z_{TE_{10}}=\frac{120\pi}{\sqrt{1-(\lambda/2a)^2}}\)</span></li>
<li>传输功率：<span class="math inline">\(P=\frac{abE_0^2}{480\pi}\sqrt{1-(\lambda/2a)^2}\)</span></li>
<li>功率容量：<span class="math inline">\(P_{br}=6\times10^5\sqrt{1-(\lambda/2a)^2}(W),a,b,\lambda\)</span>单位均为cm</li>
</ol></li>
<li>波导横截面尺寸选择原则
<ol type="1">
<li>主要依据是单模传输：<span class="math inline">\(\lambda_{cTE_{20}}&lt;\lambda&lt;\lambda_cTE_{10},\lambda_{cTE_{01}}&lt;\lambda&lt;\lambda_cTE_{10}\\\therefore \frac{\lambda}{2}&lt;a&lt;\lambda,0&lt;b&lt;\frac{\lambda}{2}\)</span></li>
<li>综合考虑传输功率及损耗的要求一般对于工作于<span class="math inline">\(TE_{10}\)</span>模的矩形波导，取<span class="math inline">\(a\approx0.7\lambda,b\approx(0.3-0.35)\lambda\)</span></li>
</ol></li>
<li>管壁电流 管壁电流波在波导内传播，会在波导壁的内表面上（微米数量级）感应出的高频电流，称为管壁电流,其特点为<strong>两个侧壁的表面电流大小相等，方向相同,上下壁上的电流大小相等，方向相反</strong> <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-30-09-45-14.png"> 该图可用于判断外部器件是否切割表面电流</li>
</ol>
<h2 id="圆波导">圆波导</h2>
<p>圆波导－横截面为圆形的空心金属波导管圆波导。圆波导具有加工方便、双极化、低损耗等优点，也是常用的波导管之一，可用于天线馈线、多路通信和卫星电视，可构成微波谐振腔、旋转式移相器、衰减器、旋转关节、天线辐射器等微波器件</p>
<h3 id="场解及波型-1">场解及波型</h3>
<p>圆波导的求解过程与矩形波导的求解类似，区别在于圆波导中，场量沿r方向按贝塞尔函数规律变化，沿圆周按三角函数变化。</p>
<h4 id="tm波型">TM波型</h4>
<p>对于TM波型，<span class="math inline">\(H_z=0\)</span>,经过运算和贝塞尔函数性质可知，其通过边界条件可导出<span class="math inline">\(K_c=\frac{v_{mn}}{R},v_{mn}\)</span>为m阶贝塞尔函数的第n个根的值，则可得其截止波长为<span class="math inline">\(\lambda_c=\frac{2\pi R}{v_{mn}}\)</span>，其特点如下</p>
<ol type="1">
<li>沿圆周和半径方向均呈纯驻波分布</li>
<li><span class="math inline">\(TM_{m0}\)</span>不存在，所以最低的波型为<span class="math inline">\(TM_{01}\)</span>，它的<span class="math inline">\(λ_c\)</span>最长</li>
<li>m：角向波数，表示场量沿圆周分布的整驻波的个数。n：径向波数，表示场量沿半径分布的半驻波分布个数、或最大值个数</li>
</ol>
<h4 id="te波型">TE波型</h4>
<p>对于TE波型，<span class="math inline">\(E_z=0\)</span>,经过运算和贝塞尔函数性质可知，其通过边界条件可导出<span class="math inline">\(K_c=\frac{\mu_{mn}}{R},\mu_{mn}\)</span>为m阶贝塞尔函数导函数的第n个根的值，则可得其截止波长为<span class="math inline">\(\lambda_c=\frac{2\pi R}{\mu_{mn}}\)</span>，其特点如下</p>
<ol type="1">
<li>沿圆周和半径方向均呈纯驻波分布</li>
<li><span class="math inline">\(TE_{m0}\)</span>不存在，所以最低的波型为<span class="math inline">\(TM_{11}\)</span>，它的<span class="math inline">\(λ_c\)</span>最长</li>
<li>m：角向波数，表示场量沿圆周分布的整驻波的个数。n：径向波数，表示场量沿半径分布的半驻波分布个数、或最大值个数</li>
</ol>
<h3 id="截止波长">截止波长</h3>
<p><span class="math inline">\(\lambda_c=\frac{2\pi}{K_c}=\begin{cases}  \frac{2\pi R}{v_{mn}}(TM)\\  \frac{2\pi R}{\mu_{mn}}(TE) \end{cases}\)</span></p>
<ol type="1">
<li>主模及高次模:圆波导中的主模为<span class="math inline">\(TE_{11},λ_c=3.41R\)</span>,其它的模均为高次模</li>
<li>简并现象
<ul>
<li>模式简并：<span class="math inline">\(\because J_0&#39;(x)=-J_1(x),\therefore \mu_{0n}=v_{1n},TE_{0n},TM_{1n}\)</span>模的<span class="math inline">\(\lambda_c\)</span>相同</li>
<li>因为当<span class="math inline">\(m\neq 0\)</span>时，TM波和TE波每一个模的场有两种分布可能（cos/sin），这种同一模式但具有两种极化的场分布，且<span class="math inline">\(λ_c\)</span>相同，称为极化简并现象。</li>
</ul></li>
</ol>
<h3 id="圆波导中常用的三个模式">圆波导中常用的三个模式</h3>
<ol type="1">
<li><span class="math inline">\(TE_{11}\)</span>:
<ol type="1">
<li>是圆波导中的主模，其<span class="math inline">\(λ_c=3.41R\)</span></li>
<li>在横截面上，其场结构与矩形波导的<span class="math inline">\(TE_{10}\)</span>很相似，故常用矩形波导中TE10通过方-圆接头过渡为圆波导中的<span class="math inline">\(TE_{11}\)</span></li>
<li>有极化简并现象，即在<span class="math inline">\(\psi\)</span>方向场分布有<span class="math inline">\(cosm\psi\)</span>及<span class="math inline">\(sinm\psi\)</span>两种分布的可能,故圆波导长距离传输信号一般不用这种波型，而在旋转式移相器、衰减器、谐振腔等，常采用这种波型</li>
</ol></li>
<li><span class="math inline">\(TE_{01}\)</span>：
<ol type="1">
<li><span class="math inline">\(TE_{01}\)</span>也是圆波导中常用的波型之一，它的场分量只有<span class="math inline">\(E_φ,H_r,H_z,E_r＝E_z＝H_φ＝0\)</span></li>
<li>为圆波导中的高次模， <span class="math inline">\(λ_c=1.64R\)</span></li>
<li>m=0，场结构在横截面上是轴对称的（与<span class="math inline">\(\psi\)</span>无关），所以无极化简并。但是与<span class="math inline">\(TM_{11}\)</span>存在模式简并，又称为E－H简并。故在使用时必须设法抑制低次模及简并模。</li>
<li>该波型在波导内壁的切向磁场只有<span class="math inline">\(H_z\)</span>分量，故内壁上只有圆周方向的(<span class="math inline">\(\psi\)</span>方向)的表面电流，导体损耗小</li>
<li>当传输功率一定时，频率越高，则损耗越小。所以该模式适合作为高Q谐振腔的工作模式，以及用来长距离传输功率信号</li>
</ol></li>
<li><span class="math inline">\(TM_{01}\)</span>：
<ol type="1">
<li><span class="math inline">\(TM_{01}\)</span>场分量只有<span class="math inline">\(H_φ,E_r,E_z,H_r＝H_z＝E_φ＝0\)</span></li>
<li>是横磁模中的最低模式,<span class="math inline">\(λ_c=2.61R\)</span></li>
<li>横截面上的场结构具有轴对称性，即沿<span class="math inline">\(\psi\)</span>向无变化,故无极化简并，也无模式简并，因此常作为雷达天线与馈线的旋转关节中的工作模式。</li>
<li>该波型在内壁表面的切向磁场只有<span class="math inline">\(H_\psi\)</span>分量，只有z方向的管壁电流，因此它可以有效地和轴向流动的电子流交换能量，由此将其应用于微波电子管中的谐振腔及直线电子加速器中的工作模式</li>
</ol></li>
</ol>
<h2 id="同轴线">同轴线</h2>
<p>同轴线的优点：主波型（主模）是TEM波，是无色散波，无频率下限、频带宽，场结构稳定，比双绞线损耗小。</p>
<p>同轴线的缺点：随着频率升高，功率容量下降，导体与介质损耗增加。所以一般只能用于分米波和厘米波的低频段</p>
<h3 id="tem波的传输特性">TEM波的传输特性</h3>
<ol type="1">
<li><span class="math inline">\(K_c=0\Rightarrow\lambda_c=\infty,\beta=K=w\sqrt{\mu\epsilon},\lambda_g=\lambda\\v_p=v_g=v=\frac{1}{\sqrt{\mu\epsilon}},Z_{TEM}=\eta=\sqrt{\frac{\mu}{\epsilon}}\)</span></li>
<li>特性阻抗:<span class="math inline">\(Z_0=\frac{\eta}{2\pi}ln\frac{b}{a}=\frac{60}{\sqrt{\epsilon_r}ln\frac{b}{a}}\)</span></li>
<li>传输功率:<span class="math inline">\(P_{br}=\sqrt{\epsilon_r}\frac{a^2E_0^2}{120}ln\frac{b}{a}(w)\)</span></li>
</ol>
<h3 id="高次模及横向尺寸的选择">高次模及横向尺寸的选择</h3>
<p>当工作波长减少到与同轴线的横向尺寸可以相比拟时，同轴线中会出现高次模,一般不用高次波型传输功率，而采用主模TEM来传输功率。为了做到单模传输，就需要抑制高次模。</p>
<p>同轴线中最低的高次模为<span class="math inline">\(TE_{11}\)</span>，截止波长<span class="math inline">\(λc\approx\pi(b+a)\)</span>所以得到横向尺寸选择的依据</p>
<ol type="1">
<li>保证主模单模工作:<span class="math inline">\(\lambda_{min}&gt;\lambda_cTE_{11}=\pi(b+a),\therefore a+b&lt;\frac{\lambda_{min}}{\pi}\)</span></li>
<li>使传输功率容量最大</li>
</ol>
<h2 id="微带传输线">微带传输线</h2>
<p>上一章介绍了规则金属波导传输系统的传输原理及特性, 这类传输系统具有损耗小、结构牢固、功率容量高及电磁波限定在导管内等优点, 其缺点是比较笨重、高频下批量成本高、 频带较窄等。随着航空、航天以及通信发展的需要, 对微波设备提出了体积要小、重量要轻、 可靠性要高、性能要优越、一致性要好、 成本要低等要求, 这就促成了微波技术与半导体器件及集成电路的结合, 产生了微波集成电路。对微波集成传输元件的基本要求之一就是它必须具有平面型结构, 这样可以通过调整单一平面尺寸来控制其传输特性, 从而实现微波电路的集成化。微带线就是一种微波集成电路中应用最广泛的平面传输线。</p>
<h3 id="微带线">微带线</h3>
<p>微带传输线的基本结构有两种形式: 带状线和微带线 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-21-20-50.png"> 带状线由同轴线演化而来，其流程如下，主要传输的还是TEM波 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-21-22-26.png"> 微带线是由沉积在介质基片上的金属导体带和接地板构成的一个特殊传输系统, 它可以看成由双导体传输线演化而来 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-27-21-22-11.png"> 由于这种开放式不对称结构导致微带线是一种不均匀介质填充的传输线，可以证明微带中的电磁场必有纵向分量，即在微带线中不能导行TEM波，但是在工作频率较低时，由于微带线基片厚度h远小于微带波长，其纵向分量很小，可以忽略，此时的场结构与TEM模相似，<strong>此时的传输波型为准TEM模。它是微带线的主模。</strong></p>
<h4 id="微带线的特性阻抗">微带线的特性阻抗</h4>
<p>如果微带线是由<span class="math inline">\(\epsilon_r\)</span>的均匀介质包围，则<span class="math inline">\(Z_0^0=\sqrt{\frac{L}{C}}=\frac{1}{v_pC},v_p=\frac{1}{\sqrt{LC}}=\frac{v_0}{\sqrt{\epsilon_r}},\lambda=\frac{v_p}{f}=\frac{\lambda_0}{\sqrt{\epsilon_r}}\)</span></p>
<p>但是微带线实际上是介质与空气的混合介质系统,所以引入等效相对介电常数的概念: <span class="math inline">\(C_0\)</span>--单一空气介质包围的微带线的分布电容,<span class="math inline">\(C_1\)</span>--实际空气+介质填充微带线的分布电容，等效相对介电常数<span class="math inline">\(\epsilon_{re}=\frac{C_1}{C_0}\)</span></p>
<p>即把实际混合介质系统想象成单一的、均匀的相对介电常数<span class="math inline">\(ε_{re}\)</span>的介质构成的系统,所以<span class="math inline">\(Z_0=\frac{Z_0^0}{\sqrt{\epsilon_{re}}}\quad Z_0^0=\frac{1}{v_pC_0},Z_0^0\)</span>为同样形状尺寸下填充介质全部是空气的微带线的特性阻抗</p>
<p>两组实用的工程计算公式</p>
<ol type="1">
<li>假设导体带厚度为零：<span class="math inline">\(\epsilon_{re}\approx \frac{\epsilon_r+1}{2}+\frac{\epsilon_r-1}{2}(1+\frac{10h}{W})^{-1/2}=1+q(\epsilon_r-1),q=\frac{1}{2}[1+(1+\frac{10h}{W})^{-1/2}]:\)</span>填充系数，表示<span class="math inline">\(\epsilon_r&gt;1\)</span>的介质填充程度</li>
<li>导体带厚度不为零时，这时的解法一般是把边缘电容增加的影响等效为导体带的宽度增加了△ω，即此时的导带宽度为<span class="math inline">\(W_e=w+\Delta w,\Delta w\)</span>的工程近似计算公式为 <span class="math display">\[\frac{w}{h}\le\frac{1}{2\pi}:\Delta w=\frac{t}{\pi}(ln\frac{4\pi w}{t}+1)\\\frac{w}{h}\ge\frac{1}{2\pi}:\Delta w=\frac{t}{\pi}(ln\frac{2h}{t}+1)\]</span></li>
</ol>
<p>其他参量：相速度<span class="math inline">\(v_p=\frac{v_0}{\sqrt{\epsilon_{re}}}\quad\lambda_g=\frac{\lambda_0}{\sqrt{\epsilon_{re}}}\leftrightarrow\beta=k_0\sqrt{\epsilon_{re}}\)</span></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>微波技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title>微波技术基础第五六章知识小结</title>
    <url>/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>因为第六章内容较少，故将两章合并</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<ol type="1">
<li>为什么在微波波段不能使用集总参数LC谐振回路？
<ol type="1">
<li><span class="math inline">\(w_0=1/\sqrt{LC}\)</span>在微波波段，<span class="math inline">\(w_0\)</span>很高，所以L和C很小，元件制造困难</li>
<li>当电路尺寸与微波波长可以相比拟时，就会产生能量的辐射，波长越短辐射越严重，故辐射损耗大。另外，由于此时趋肤效应严重，故欧姆损耗大，而且介质损耗大。因此，在频率较高的微波波段，集总LC谐振回路储能小，损耗大，导致Q值小到不能用</li>
</ol></li>
<li>微波谐振器与LC谐振回路的相同和相异点
<ol type="1">
<li>LC回路为集总参数电路，微波谐振器时属于分布参数电路。所以LC回路能量只分布在L、C上，而微波谐振器的能量分布在整个腔体中</li>
<li>LC回路在L及C一定时，只有一个谐振频率，而微波谐振器有无限多个谐振频率，这称为微波谐振器的多谐性</li>
<li>微波谐振腔储能多，损耗小。故微波谐振器品质因数很高，比LC回路的Q值高很多。</li>
</ol></li>
<li>微波谐振器的分析方法：主要是场解法和场的叠加法，这里主要用的是后者</li>
</ol>
<h2 id="微波谐振器的主要参数">微波谐振器的主要参数</h2>
<ol type="1">
<li>谐振频率：无色散波<span class="math inline">\(\beta=\frac{2\pi}{\lambda_r}=\frac{2\pi}{v}f\)</span>,色散波<span class="math inline">\(\beta=\frac{2\pi}{\lambda_g}=\frac{2\pi}{v}\sqrt{f_r^2-f_c^2}\)</span></li>
<li>品质因数
<ol type="1">
<li>固有品质因数:表征谐振器的损耗的大小、频率选择性的强弱、工作稳定度 <span class="math display">\[Q_0=2\pi\frac{W(腔体总储能)}{W_T(腔体一个周期损耗能量)=PT(P:一周期谐振器平均损耗功率)}\\\therefore Q_0=\frac{2\pi W}{PT}=w_r\frac{W}{P}\]</span> 进一步化简可知<span class="math inline">\(Q_0\)</span>正比于<span class="math inline">\(V/S\)</span>,其与谐振器尺寸成正比，又因谐振器尺寸与工作波长成正比，所以其与工作波长成正比</li>
<li>有载品质因数：谐振器带上负载时腔体的品质因数 <span class="math display">\[Q_L=w_r\frac{W}{P_i+P_c}或\frac{1}{Q_L}=\frac{1}{Q_0}+\frac{1}{Q_c}或Q_L=\frac{Q_0}{1+k}\]</span> <span class="math inline">\(W-总储能，P_i-腔本身损耗功率，P_c-外界负载损耗功率，\\Q_c-耦合品质因数，k-耦合系数(腔体与外界负载之间的耦合程度)\)</span></li>
</ol></li>
</ol>
<h2 id="圆柱谐振腔">圆柱谐振腔</h2>
<p>圆柱谐振腔具有较高的品质因数，调谐方便，结构坚固，易于加工，制作。属于传输线型谐振腔，<strong>可以看作两端短路的一段圆波导</strong></p>
<h3 id="场分量表达式">场分量表达式</h3>
<ol type="1">
<li><span class="math inline">\(TE_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(H_z\)</span>，其形式与圆波导有一定相似性，其在<span class="math inline">\(r,\psi,z\)</span>上均呈驻波状态，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{\mu_{mn}}{R})^2+(\frac{p\pi}{l})^2},m=0,1,2,\dots,n=1,2\dots,p=1,2\dots\)</span></li>
<li><span class="math inline">\(TM_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(E_z\)</span>，其形式与圆波导有一定相似性，其在<span class="math inline">\(r,\psi,z\)</span>上均呈驻波状态，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{v_{mn}}{R})^2+(\frac{p\pi}{l})^2},m=0,1,2,\dots,n=1,2\dots,p=0,1,2\dots\)</span></li>
</ol>
<h3 id="谐振频率和波型图">谐振频率和波型图</h3>
<ol type="1">
<li>谐振频率： <span class="math inline">\(f_r=\frac{Kv}{2\pi}\Rightarrow\lambda_r=\frac{v}{f_r}=\frac{2\pi}{K},\therefore TE_{mnp}:f_r=\frac{1}{2\pi\sqrt{\mu\epsilon}}\sqrt{(\frac{\mu_{mn}}{R})^2+(\frac{p\pi}{l})^2},\lambda_r=\frac{1}{\sqrt{(\frac{\mu_{mn}}{2\pi R})^2+(\frac{p}{2l})^2}},\\\therefore TM_{mnp}:f_r=\frac{1}{2\pi\sqrt{\mu\epsilon}}\sqrt{(\frac{v_{mn}}{R})^2+(\frac{p\pi}{l})^2},\lambda_r=\frac{1}{\sqrt{(\frac{v_{mn}}{2\pi R})^2+(\frac{p}{2l})^2}}\)</span></li>
<li>波形图：如果用<span class="math inline">\(X_{mn}\)</span>来代替上式中的<span class="math inline">\(\mu_{mn}\)</span>和<span class="math inline">\(v_{mn}\)</span>，则圆柱谐振腔中的 谐振波长<span class="math inline">\(\lambda_r\)</span>可以写成一个公式<span class="math inline">\(\lambda_r=\frac{1}{\sqrt{(\frac{X_{mn}}{2\pi R})^2+(\frac{p}{2l})^2}}=\frac{D}{\sqrt{(\frac{X_{mn}}{\pi})^2+(\frac{Dp}{2l})^2}}\rightarrow(f_rD)^2=(\frac{vX_{mn}}{\pi})^2+(\frac{vp}{2})^2(\frac{D}{l})^2\)</span>,从上面关系式可知，对于给定模式，<span class="math inline">\((f_rD)^2与(\frac{D}{l})^2\)</span>在波形图上是一直线,斜率为<span class="math inline">\((\frac{vp}{2})^2\)</span>,截距为<span class="math inline">\((\frac{vX_{mn}}{\pi})^2\)</span> <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-14-42-16.png"> 工作方块：以选定工作波型的调谐曲线为对角线，最小、最大的<span class="math inline">\((f_rD)^2\)</span>值与对应的 <span class="math inline">\((D/l)^2\)</span>确定的矩形区域。利用工作方块保证单模工作，避免干扰波型：
<ul>
<li>自干扰型：相同m、n，不同p-相同截距，不同斜率，与工作波型耦合最强，务必不使其落入工作方块内</li>
<li>一般干扰型：相同p，不同m、n-不同截距，相同斜率，会导致一个以上的谐振频率。</li>
<li>交叉型：m、n、p完全不同-场结构完全不同。</li>
<li>简并型：曲线完全重合，fr完全相同，但场结构完全不同，容易抑制。</li>
</ul></li>
<li>圆柱谐振腔特点：
<ol type="1">
<li>圆柱腔存在多谐性</li>
<li>R、l一定时，谐振波长<span class="math inline">\(λ_r\)</span>最长的模为主模。当l&gt;2.1R时，<span class="math inline">\(TE_{111}\)</span>为主模,当l&lt;2.1R时，<span class="math inline">\(TM_{010}\)</span>为主模</li>
<li><span class="math inline">\(TE_{onp}\)</span>与<span class="math inline">\(TM_{1np}\)</span>模式简并，同时都存在极化简并</li>
</ol></li>
<li>圆柱腔常用的3个振荡模式
<ol type="1">
<li><span class="math inline">\(TE_{011},K_c=\frac{3.832}{R},\lambda_r=1/\sqrt{(\frac{1}{1.64R})^2+(\frac{1}{2l})^2}\)</span>为高次模，磁场分量只有<span class="math inline">\(H_r,H_\psi\)</span>,侧壁和端壁内表面只有<span class="math inline">\(\psi\)</span>方向表面电流，可用不接触式活塞进行调谐，场结构稳定、无极化简并，损耗小，Q值可高达几万以上。故可作成<strong>高精度的频率计</strong></li>
<li><span class="math inline">\(TE_{111},\lambda_r=1/\sqrt{(\frac{1}{3.41R})^2+(\frac{1}{2l})^2},l&gt;2.1R\)</span>时，为圆柱谐振腔的主模，腔体尺寸较小，Q值不高，存在极化简并</li>
<li><span class="math inline">\(TM_{010},K_c=\frac{2.405}{R},\lambda_r=2.61R,l&lt;2.1R\)</span>为主模,既无模式简并，又无极化简并.Q值不高，且<span class="math inline">\(λ_r\)</span>与l无关，故无法用短路活塞来进行调谐,常用的调谐方法从端面中心插入一圆柱体，插入深度可调</li>
</ol></li>
</ol>
<h2 id="矩形谐振腔">矩形谐振腔</h2>
<p>矩形空腔谐振器是由一段长为l、 两端短路的矩形波导组成</p>
<h3 id="场解及振荡模式">场解及振荡模式</h3>
<ol type="1">
<li><span class="math inline">\(TE_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(H_z\)</span>，其形式与矩形波导有一定相似性，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2+(\frac{p\pi}{l})^2},m,n不同时为0,p=1,2\dots\)</span></li>
<li><span class="math inline">\(TM_{mnp}\)</span>振荡模式：先根据边界条件求出<span class="math inline">\(E_z\)</span>，其形式与矩形波导有一定相似性，相位常数<span class="math inline">\(\beta=\frac{p\pi}{l}\)</span>,再进而利用场分量间的关系可以进一步求出其他分量，其中<span class="math inline">\(K=\sqrt{(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2+(\frac{p\pi}{l})^2},m,n\neq0,p=1,2\dots\)</span></li>
</ol>
<h3 id="特性参数">特性参数</h3>
<ol type="1">
<li>谐振频率、谐振波长 <span class="math inline">\(f_r=\frac{Kv}{2\pi}\Rightarrow\lambda_r=\frac{v}{f_r}=\frac{2\pi}{K},\therefore f_r=\frac{1}{2\sqrt{\mu\epsilon}}\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2+(\frac{p}{l})^2},\lambda_r=\frac{2}{\sqrt{(\frac{m}{a})^2+(\frac{n}{b})^2+(\frac{p}{l})^2}}\)</span></li>
<li>固有品质因数(以<span class="math inline">\(TE_{101}\)</span>为例) <span class="math display">\[Q_0=\frac{abl}{\delta}\frac{a^2+l^2}{2b(a^3+l^3)+al(a^2+l^2)}\]</span> <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-03-51.png"></li>
</ol>
<h2 id="同轴线空腔谐振器">同轴线空腔谐振器</h2>
<p>同轴腔由一段长为l的同轴线构成，其振荡模式为TEM模。优点：场结构简单、稳定，无色散，无频率下限，工作频带宽 ,缺点：固有品质因数Q值比较低，损耗大，故工作频率不能太高,适用：米波、分米波、厘米波（小功率）低精度的波长计,主要可分为<span class="math inline">\(\lambda/2\)</span>同轴腔：<span class="math inline">\(\lambda_r=\frac{2l}{p}\)</span>和<span class="math inline">\(\lambda/4\)</span>同轴腔:<span class="math inline">\(\lambda_r=\frac{4l}{2p+1}\)</span>与电容加载同轴谐振腔<span class="math inline">\(l&lt;(2p+1)\frac{\lambda_r}{4}\)</span></p>
<h2 id="微波网络基础">微波网络基础</h2>
<p>微波网络模型由一个通常称之为“黑箱”的N与外部相连接的若干端口构成。 “黑箱”表示不均匀性，端口是它与外界相联系的“窗口”，电信号由端口输入或输出，并可在端口处进行电压、电流、反射系数和衰减等量的测量。<strong>其优点在于不用关心黑盒内部长的具体实现情况，只需要通过测量的方式知道各端口信号量之间的关系，避免了对内部场分布的复杂计算</strong></p>
<h3 id="微波网络与传输矩阵">微波网络与传输矩阵</h3>
<p><img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-12-47.png"> 线性微波网络（Network），输入电压电流<span class="math inline">\(U_1、I_1\)</span>和输出电压电流<span class="math inline">\(U_2、I_2\)</span>可用传输矩阵[A]联系起来 <span class="math display">\[\begin{bmatrix}
U_1\\
I_1\\
\end{bmatrix}=\begin{bmatrix}
A_{11}&amp;A_{12}\\
A_{21}&amp;A_{22}\\
\end{bmatrix}\begin{bmatrix}
U_2\\
-I_2\\
\end{bmatrix}=A\begin{bmatrix}
U_2\\
-I_2\\
\end{bmatrix}\]</span> A称为二端口网络的传输矩阵，其元素<span class="math inline">\(A_{11}、A_{12}、A_{21}和A_{22}\)</span>称为传输参数（A参数）,A参数的定义式可以在端口开路和短路的情况下求得，A参数各参数的物理意义为： <span class="math inline">\(A_{11}\)</span>：端口②开路时，端口①到端口②电压传输系数的倒数； <span class="math inline">\(A_{21}\)</span>：端口②开路时，端口①与端口②之间的转移导纳； <span class="math inline">\(A_{21}\)</span>：端口②短路时，端口①到端口②电流传输系数的倒数； <span class="math inline">\(A_{22}\)</span>：端口②短路时，端口①与端口②之间的转移阻抗。</p>
<p>由于A参数是在网络端口开路和短路的情况下求出的，因此称为混合A参数，并具有明确的物理意义。互易网络:<span class="math inline">\(A_{11}A_{22}-A_{12}A_{21}=1\)</span>对称网络:<span class="math inline">\(A_{11}=A_{22}\)</span></p>
<h3 id="微波网络的散射参数">微波网络的散射参数</h3>
<p><img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-19-43.png"></p>
<p><span class="math display">\[\begin{bmatrix}
b_1\\
b_2\\
\end{bmatrix}=\begin{bmatrix}
S_{11}&amp;S_{12}\\
S_{21}&amp;S_{22}\\
\end{bmatrix}\begin{bmatrix}
a_1\\
a_2\\
\end{bmatrix}\]</span> 简记为b=Sa,b和a分别为由端口的归一化反射波和归一化入射波所构成的列矩阵，S是一个正方矩阵,称为二端口网络的归一化散射矩阵，其元素称为归一化的散射参数，也称为S参数</p>
<p>S参量各参数的物理意义为： <span class="math inline">\(S_{11}\)</span>：端口②接匹配负载时，端口①的反射系数； <span class="math inline">\(S_{21}\)</span>：端口②接匹配负载时，端口①到端口②波的传输系数； <span class="math inline">\(S_{22}\)</span>：端口①接匹配负载时，端口②的反射系数； <span class="math inline">\(S_{12}\)</span>：端口①接匹配负载时，端口②到端口①波的传输系数。 可见, ［S］矩阵的各参数是建立在端口接匹配负载基础上的反射系数或传输系数。 这样利用网络输入输出端口的参考面上接匹配负载即可测得散射矩阵的各个参量。 对于互易网络: <span class="math inline">\(S_{12}=S_{21}\)</span> 对于对称网络: <span class="math inline">\(S_{11}=S_{22}\)</span></p>
<h3 id="二端口网络的工作特性参量">二端口网络的工作特性参量</h3>
<p>二端口元件是微波系统中用的最多的元件,将这些二端口元件接入到传输系统后，相当于在均匀传输线中插入一个二端口网络,此时其输入端的反射系数不仅与网络参量有关，而且还与输出端所接的负载有关 <img src="/2023/11/27/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-28-15-25-42.png"></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>微波技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第二章知识小结</title>
    <url>/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p><strong>本章与信号与系统知识有较多重复，仅记录部分重要的概念</strong></p>
<ol type="1">
<li><p>信号分类</p>
<table>
<thead>
<tr class="header">
<th>时间-幅度</th>
<th>连续</th>
<th>离散</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>连续</td>
<td>模拟</td>
<td>抽样</td>
</tr>
<tr class="even">
<td>离散</td>
<td>量化</td>
<td>数字</td>
</tr>
</tbody>
</table></li>
</ol>
<span id="more"></span>
<h2 id="离散时间信号-序列">离散时间信号-序列</h2>
<h3 id="常见序列">常见序列</h3>
<ol type="1">
<li><p>单位取样序列<span class="math display">\[\delta(n)=\begin{cases}
 1,n=0\\
 0,n\ne0
\end{cases},\delta(n-n_0)=\begin{cases}
 1,n=n_0\\
 0,n\ne n_0
\end{cases}\\
x(n)\delta(n)=x(0)\qquad x(n)\delta(n-n_0)=x(n_0)\\x(n)*\delta(n-n_0)=x(n-n_0)\qquad x(t)\delta(t)=x(0)\delta(t)\]</span></p></li>
<li><p>单位阶跃序列<span class="math display">\[u(n)=\begin{cases}
 1,n\ge0\\
 0,n&lt;0
\end{cases},\delta(n)=u(n)-u(n-1)\\
u(n)=\sum_{k=\infty}^n\delta(k)\quad u(n)=\sum_{k=0}^\infty\delta(n-k)\]</span></p></li>
<li><p>矩形序列<span class="math display">\[R_N(n)=\begin{cases}
 1,0\le n \le N-1\\
 0,others
\end{cases},R_N(n)=u(n)-u(n-N)\]</span></p></li>
<li><p>复指数序列和正弦序列<span class="math display">\[x(n)=e^{(\sigma+jw)n}=e^{\sigma n}cos(wn)+je^{\sigma n}sin(wn),w-数字域频率\\
比较：x_a(t)=Asin(\Omega t+\phi)=Asin(2\pi ft+\phi)\]</span>其中:<span class="math inline">\(\Omega=2\pi f\)</span>模拟域频率，<strong><span class="math inline">\(w=\Omega T(采样周期)\)</span></strong></p></li>
</ol>
<p>当<span class="math inline">\(w=0\)</span>时，<span class="math inline">\(cos(wn)\)</span>变化最慢，当<span class="math inline">\(w=\pi\)</span>时，<span class="math inline">\(cos(wn)\)</span>变化最快，在主值空间<span class="math inline">\([-\pi,\pi]or[0,2\pi]\)</span>上，把<span class="math inline">\(w=0\)</span>附近称为数字低频，<span class="math inline">\(w=\pi\)</span>称为数字高频。<strong>这一特点与模拟正弦信号完全不同，后者<span class="math inline">\(\Omega\)</span>越大，变化越快，因为其连续取值</strong></p>
<h2 id="离散时间系统">离散时间系统</h2>
<h3 id="fir系统和iir系统">FIR系统和IIR系统</h3>
<p>FIR：有限冲激响应，IIR：无限冲激响应 <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-14-21-13-31.png"></p>
<h3 id="离散时间系统的性质">离散时间系统的性质</h3>
<p>在判断离散时间系统性质时，一般用到的都是和信号与系统中已经学到的性质，如线性性，稳定性，因果性这些，主要用到的是因果性，稳定性。因果性和稳定性的判断一般可借助系统函数进行判断，系统函数收敛域包含单位圆即稳定，收敛域到无穷即为因果，在一般判断中，用二者即可，在有些习题中可能不给出时域信号是否是右边信号，只给出<span class="math inline">\(H(z)\)</span>，其判断思路可以参考下面这道例题</p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-22-09-48-20.png" style="width:70.0%;height:70.0%"></p>
<p>在这道例题中，没给出时域信号是否为右边信号，但根据其在无穷远处仍存在，且极点在单位圆外，可判断其为因果不稳定</p>
<h2 id="离散时间信号和系统的频域表示">离散时间信号和系统的频域表示</h2>
<h3 id="连续信号的ft">连续信号的FT</h3>
<p>重要性质1：当<span class="math inline">\(x(n)\)</span>为实序列时，<span class="math inline">\(X(e^{jw})\)</span>的幅值<span class="math inline">\(|X(e^{jw})|\)</span>在区间<span class="math inline">\(0\le w\le2\pi\)</span>内是偶对称函数，相位 <span class="math inline">\(arg[X(e^{jw})]\)</span> 是奇对称函数</p>
<h3 id="离散时间信号的ft的性质">离散时间信号的FT的性质</h3>
<ol type="1">
<li><p>序列的FT的对称性</p>
<p><span class="math inline">\(x_e(n)=x_e^*(-n)\)</span> 共轭对称序列</p>
<p><span class="math inline">\(x_o(n)=-x_o^*(-n)\)</span> 共轭反对称序列</p>
<p><span class="math inline">\(x_e(e^{jw})=x_e^*(e^{-jw})\)</span> 共轭对称函数</p>
<p><span class="math inline">\(x_o(e^{jw})=-x_o^*(e^{-jw})\)</span> 共轭反对称函数</p>
<p>这表明<span class="math inline">\(x_e(n)\)</span>的实部和<span class="math inline">\(x_o(n)\)</span>的虚部为偶序列，<span class="math inline">\(x_e(n)\)</span>的虚部和<span class="math inline">\(x_o(n)\)</span>的实部为奇序列，进一步推导可以得到以下序列分解公式<span class="math display">\[x_e(n)=\frac{1}{2}[x(n)+x^*(-n)] \qquad x_o(n)=\frac{1}{2}[x(n)-x^*(-n)]\\X_e(e^{jw})=\frac{1}{2}[X(e^{jw})+X^*(e^{-jw})] \qquad X_o(e^{jw})=\frac{1}{2}[X(e^{jw})-X^*(e^{-jw})]\]</span></p>
<p>以及FT的共轭对称性<span class="math display">\[FT[x_r(n)]=X_e(e^{jw}),FT[jx_i(n)]=X_o(e^{jw})\\FT[x_e(n)]=X_R(e^{jw}),FT[x_o(n)]=jX_I(e^{jw})\]</span></p>
<p>当<span class="math inline">\(x(n)\)</span>为实序列时<span class="math display">\[若x(n)为实偶序列，则X(e^{jw})为实偶函数\\若x(n)为实奇序列，则X(e^{jw})为纯虚奇函数\]</span></p></li>
</ol>
<h3 id="离散时间系统的频率响应">离散时间系统的频率响应</h3>
<p>与模拟信号处理中正弦信号和复指数信号具有很重要的作用一样，在数字信号处理中，正弦序列和复指数序列也起着很重要的作用。<strong>这是因为线性非移变系统对正弦序列的稳态响应仍然是正弦序列，频率与输入信号频率相同，而幅度和相位取决于系统特性，具体可表述如下</strong></p>
<p>设<span class="math inline">\(x(n)=e^{jw_0n}\)</span>,则<span class="math inline">\(y(n)=e^{jw_0n}H(e^{jw_0})\)</span>,其中<span class="math inline">\(H(e^{jw_0})\)</span>是系统在<span class="math inline">\(w_0\)</span>处的频率响应</p>
<p>设<span class="math inline">\(x(n)=Acos(w_0n+\phi)\)</span>且<span class="math inline">\(h(n)\)</span>为实序列，则<span class="math inline">\(y(n)=A|H(e^{jw_0})|cos(w_0n+\phi+\theta)\)</span>,其中<span class="math inline">\(H(e^{jw_0})\)</span>是系统在<span class="math inline">\(w_0\)</span>处的频率响应,<span class="math inline">\(\theta=arg[H(e^{jw_0})]\)</span>是系统在<span class="math inline">\(w_0\)</span>处的相位响应</p>
<h2 id="连续时间信号的取样">连续时间信号的取样</h2>
<h3 id="取样信号的时域频域表示">取样信号的时域频域表示</h3>
<p>取样信号为<span class="math inline">\(\hat{x_a}(t)=x_a(t)p(t)=\sum_{n=-\infty}^\infty x_a(t)\delta(t-nT),p(t)=\sum_{n=-\infty}^\infty \delta(t-nT)\)</span>,其频谱则为<span class="math inline">\(\\\hat{X_a}(j\Omega)=FT[x_a(t)p(t)]=\frac{1}{2\pi}X_a(j\Omega)*P(j\Omega)=\frac{1}{T}\sum_{r=-\infty}^\infty X_a(j\Omega-jr\Omega_s)\\P(j\Omega)=\frac{2\pi}{T}\sum_{n=-\infty}^\infty\delta(j\Omega-jr\Omega_s)\)</span></p>
<p><strong>这表明取样信号的频谱就是模拟信号频谱的周期延拓，延拓周期的取样角频率为<span class="math inline">\(\Omega_s\)</span></strong></p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-14-21-56-22.png"></p>
<p><strong>若要不产生混叠，则要求<span class="math inline">\(\Omega_s\ge2\Omega_0,\Omega_s：奈奎斯特频率,\Omega_s/2\)</span>：折叠频率</strong></p>
<h3 id="频率归一化">频率归一化</h3>
<p>频率归一化讨论的是离散时间信号<span class="math inline">\(x(n)\)</span>的频谱<span class="math inline">\(X(e^{jw})\)</span>和取样信号<span class="math inline">\(\hat{x_a}(t)\)</span>的频谱<span class="math inline">\(\hat{X_a}(j\Omega)\)</span>之间的关系</p>
<p>取样信号的频谱为：<span class="math display">\[\hat{X_a}(j\Omega)=FT[\hat{x_a}(t)]=FT[x_a(t)p(t)]=FT[\sum_{n=-\infty}^\infty x_a(t)\delta(t-nT)]\\=\sum_{n=-\infty}^\infty x_a(nT)\cdot FT[\delta(t-nT)]=\sum_{n=-\infty}^\infty x_a(nT)e^{-j\Omega nT}\]</span></p>
<p>而离散时间信号的FT变换为： <span class="math display">\[X(e^{jw})=\sum_{n=-\infty}^\infty x(n)e^{-jwn},when \quad w=\Omega T,X(e^{jw})|_{w=\Omega T}=\sum_{n=-\infty}^\infty x(n)e^{-j\Omega Tn}=\hat{X_a}(j\Omega)\]</span></p>
<p>比较可得出<span class="math display">\[X(e^{jw})|_{w=\Omega T}=\hat{X_a}(j\Omega)=\frac{1}{T}\sum_{r=-\infty}^\infty X_a(j\Omega-jr\Omega_s)\\=\frac{1}{T}\sum_{r=-\infty}^\infty X_a(j\frac{w}{T}-jr\frac{2\pi}{T})\]</span></p>
<p><strong>即在<span class="math inline">\(w=\Omega T\)</span>的条件下，离散时间信号的频谱与取样信号的相等，由于<span class="math inline">\(w=\Omega T=\frac{2\pi f}{f_s}(f_s为取样频率)\)</span>是<span class="math inline">\(f\)</span>对<span class="math inline">\(f_s\)</span>归一化的结果，因此可认为离散时间信号频谱是模拟信号频谱的周期延拓且在频率轴上进行归一化的结果</strong></p>
<h3 id="信号重建">信号重建</h3>
<p>如果取样信号频谱不存在混叠，让取样信号通过一理性低通滤波器，其特性为<span class="math inline">\(H(j\Omega)=\begin{cases}  T,|\Omega|\le\Omega_s/2\\  0,|\Omega|&gt;\Omega_s/2 \end{cases}\)</span>,其频谱特性为<span class="math inline">\(H(j\Omega)\hat{X_a}(j\Omega)=X_a(j\Omega),|\Omega|\le\Omega_s/2\)</span>,输出信号则为<span class="math display">\[x_a(t)=\frac{1}{2\pi}\int_{-\frac{\Omega_s}{2}}^{\frac{\Omega_s}{2}} X_a(j\Omega)e^{j\Omega t}\, {\rm d}\Omega=\sum_{n=-\infty}^\infty x(nT)\cdot S_a(t-nT)\\Sa(t-nT)=\frac{sin[\frac{\pi}{T}(t-NT)]}{\frac{\pi}{T}(t-nT)}为内插函数\]</span><strong>此处积分的详细步骤略过，结论：取样信号经过理想LPF后，完全可以把信号还原，而不损失任何信息，由于插值的唯一性，还原的信号也是唯一的</strong></p>
<h3 id="离散时间信号的取样">离散时间信号的取样</h3>
<p>其思路与连续时间信号取样类似</p>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-12-53.png"></p>
<p>其可以看为一个信号调制的过程：<span class="math inline">\(x_p(n)=\sum_{n=-\infty}^\infty x(Nk)\delta(n-kN)\)</span>,频域表示为<span class="math inline">\(X_p(w)=\frac{1}{N}\sum_{n=0}^{N-1}X(w-kw_s),w_s\)</span>为取样频率，且<span class="math inline">\(w_s=\frac{2\pi}{N}\)</span> <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-16-29.png"></p>
<p><strong>为了不发生混叠，取样频率同样需满足<span class="math inline">\(w_s\ge2w_M\)</span></strong></p>
<p>若要恢复序列<span class="math inline">\(x(n)\)</span>，同样可以采用低通滤波器滤波恢复，其频率特性为<span class="math inline">\(H(w)=\begin{cases}  N,|w|\le w_s/2\\  0,|w|&gt; w_s/2 \end{cases}\)</span>,恢复的序列<span class="math inline">\(x_r(n)=\sum_{k=-\infty}^\infty x(kN)\frac{N}{\pi(n-kN)}sin[\frac{w_s}{2}(n-kN)]\)</span></p>
<h3 id="离散时间信号的取样和内插">离散时间信号的取样和内插</h3>
<p><img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-25-46.png"> <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-26-29.png"></p>
<p>离散时间信号的抽取/减取样：</p>
<p><span class="math inline">\(x_d(n)=x(nN)=x_p(nN)\\FT(x_d(n))=X_d(w)=\sum_{n=-\infty}^\infty x_p(n)e^{-jwn/N}\\=X_p(w/N)=\sum_{n=-\infty}^\infty x_p(nN)e^{-jwn}\)</span></p>
<p><strong>取样序列和抽取序列的频谱只是频率尺度不同，注意，只有对原连续时间信号取样率高于奈奎斯特频率，即进行"过采样"，才允许进一步降低采样率，即进行“减采样”</strong></p>
<p>离散时间信号的内插/增采样：是抽取的逆过程，现在每相邻两个序列之间插入N-1个零值，再用低通滤波器得到内插后序列 <img src="/2023/11/11/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-09-28-20.png"></p>
<h2 id="全通系统和最小相位系统">全通系统和最小相位系统</h2>
<ol type="1">
<li>全通系统：全通系统是幅度响应<span class="math inline">\(|H(e^{jw})|\equiv C\)</span>（C为常数）的系统，系统函数:<span class="math inline">\(H_{ap}(z)=\frac{z^{-1}-a^*}{1-az^{-1}}\)</span>（一阶系统）,对于单位取样为实数的多阶系统，有<span class="math inline">\(H_{ap}(z)=A\prod^M_c\frac{z^{-1}-d_k}{1-d_kz^{-1}}\prod^M_r\frac{(z^{-1}-e_k^*)(z^{-1}-e_k)}{(1-e_kz^{-1})(1-e_k^*z^{-1})},|d_k|,|e_k|&lt;1\)</span>,<strong>全通系统的特点是每个极点<span class="math inline">\(z_p\)</span>都有一个与之配对的共轭倒数零点<span class="math inline">\(z_o=\frac{1}{z_p^*}\)</span>,且一阶全通滤波器的相位响应单调递减</strong></li>
<li>最小/大相位系统：系统函数<span class="math inline">\(H_{min}(z)\)</span>所有零极点都在单位圆内/外的系统，对于最小相位系统，存在一个稳定的因果逆系统<span class="math inline">\(H_{min}^{-1}(z)\)</span>,使得<span class="math inline">\(H_{min}(z)H_{min}^{-1}(z)=1\)</span></li>
<li>全通系统与最小相位系统级联：任何系统可表述为一个最小相位系统和一个全通系统级联,<span class="math inline">\(H(z)=H_{min}(z)H_{ap}(z)\)</span></li>
<li>相位延迟与群延迟：数字滤波器的相位延迟：<span class="math inline">\(T_p(w)=-\frac{\phi(w)}{w}\)</span>表示输入是频率为<span class="math inline">\(w\)</span>的单一正弦波的延迟时间，群延迟则定义为<span class="math inline">\(T_g(w)=-\frac{d\phi(w)}{dw}\)</span>表示某一频率<span class="math inline">\(w\)</span>邻域内的延迟性质</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第五章知识小结</title>
    <url>/2023/11/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%94-%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>由于课程对第五章和第七章要求不高，讲述的知识点不多，所以将其整理到一起。（第七章基本没讲，故直接略过）<strong>注意：第五章前四节的知识点和随机过程讲述的知识点高度重合，故不在此赘述</strong></p>
<span id="more"></span>
<h2 id="相关序列和协方差序列的性质">5.5 相关序列和协方差序列的性质</h2>
<p>设<span class="math inline">\(x_n,y_n\)</span>是两个实平稳随机过程，它们的自相关序列，自协方差序列，互相关序列，互协方差序列为:<span class="math display">\[R_{xx}(m)=E[x_nx_{n+m}]\qquad C_{xx}=E[(x_n-m_x)(x_{n+m}-m_x)]\\R_{xy}(m)=E[x_ny_{n+m}]\qquad C_{xx}=E[(x_n-m_x)(y_{n+m}-m_y)]\]</span></p>
<p>性质1：</p>
<p><span class="math inline">\(C_{xx}(m)=R_{xx}(m)-m_x^2\qquad C_{xy}(m)=R_{xy}(m)-m_xm_y\\when \quad m_x=0\quad m_y=0:C_{xx}(m)=R_{xx}(m)\quad C_{xy}(m)=R_{xy}(m)\)</span></p>
<p>性质2：</p>
<p><span class="math inline">\(C_{xx}(0)=\sigma_x^2\qquad R_{xx}(0)=E[x_n^2]\)</span></p>
<p>性质3：</p>
<p><span class="math inline">\(R_{xx}(m)=R_{xx}(-m)\qquad C_{xx}(m)=C_{xx}(-m)\\R_{xy}(m)=R_{yx}(-m)\qquad C_{xy}(m)=C_{yx}(m)\)</span></p>
<p>性质4：</p>
<p><span class="math inline">\(|R_{xy}(m)|\le (R_{xx}(0)R_{yy}(0))^{1/2}\qquad |C_{xy}(m)|\le (C_{xx}(0)C_{yy}(0))^{1/2}\\特例：|R_{xx}(m)|\le R_{xx}(0)\qquad |C_{xx}(m)|\le C_{xx}(0)\)</span></p>
<p>性质5：若<span class="math inline">\(y_n=x_{n-n_0}\)</span>,则有:<span class="math inline">\(R_{yy}(m)=R_{xx}(m)\qquad C_{yy}(m)=C_{xx}(m)\)</span></p>
<p>性质6：在随机过程中，两随机过程中时间间隔越大，它们的相关性越小<span class="math display">\[\lim_{m \to \infty}C_{xx}(m)=0 \qquad \lim_{m \to \infty}C_{xy}(m)=0 \\ \lim_{m \to \infty}R_{xx}(m)=m_x^2 \qquad \lim_{m \to \infty}R_{xy}(m)=m_xm_y\]</span> <img src="/2023/11/18/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E4%BA%94-%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-16-07-13.png"></p>
<h2 id="功率谱">5.6 功率谱</h2>
<h3 id="平稳随机过程的功率谱">平稳随机过程的功率谱</h3>
<p>协方差序列的Z变换称为平稳随机过程的功率谱<span class="math inline">\(S_{xx}(z)\overset{\underset{\mathrm{\Delta}}{}}{=}\sum_{m=-\infty}^\infty C_{xx}(m)z^{-m}\)</span>。在本课程的讨论中，功率谱总是针对于零均值随机信号，则有：<span class="math inline">\(S_{xx}(z)=\sum_{m=-\infty}^\infty R_{xx}(m)z^{-m}\)</span>，功率谱也可以表述为<span class="math inline">\(S_{xx}(e^{jw})=\sum_{m=-\infty}^\infty R_{xx}(m)e^{-jwm}\)</span>。<strong>这两种表述都是等价的</strong>。对于一个实平稳随机过程，<span class="math inline">\(R_{xx}(m)\)</span>的Fourier变换总是存在的,推导可得<span class="math inline">\(E[x_n^2]=\frac{1}{2\pi}\int_{-\pi}^{\pi} S_{xx}(e^{jw})\, {\rm d}w\)</span>。<strong>功率谱在一个周期内的平均值就是随机过程的平均功率</strong>,功率谱的反变换可表述为<span class="math inline">\(R_{xx}(m)=\frac{1}{2\pi j}\oint_{C} S_{xx}(z)z^{m-1}\, \mathrm{d}z=\frac{1}{2\pi}\int_{-\pi}^{\pi} S_{xx}(e^{jw})e^{jmw}\, {\rm d}w\)</span></p>
<h3 id="功率谱的性质">功率谱的性质</h3>
<ol type="1">
<li>实平稳随机过程的功率谱是非负的</li>
<li>实平稳随机过程的功率谱是实函数</li>
<li>实平稳随机过程的功率谱是<span class="math inline">\(w\)</span>的偶函数</li>
</ol>
<h3 id="平稳随机过程的互功率谱">平稳随机过程的互功率谱</h3>
<p>两个平稳随机过程<span class="math inline">\({x_n}\)</span>和<span class="math inline">\({y_n}\)</span>的互功率谱定义为<span class="math display">\[S_{xy}(z)=\sum_{m=-\infty}^\infty R_{xy}(m)z^{-m}\quad S_{xy}(e^{jw})=\sum_{m=-\infty}^\infty R_{xy}(m)e^{-jwm} \]</span>,由上式可得<span class="math inline">\(S_{xy}(e^{jw})=S_{yx}^*(e^{-jw})\)</span></p>
<h2 id="离散随机信号通过线性非移变系统">5.7 离散随机信号通过线性非移变系统</h2>
<p>整个过程可表述为： <span class="math inline">\(y(n)=\sum_{k=-\infty}^\infty h(k)x(n-k)=\sum_{k=-\infty}^\infty h(n-k)x(k)\)</span></p>
<p>其输出的均值可表述为<span class="math inline">\(m_y=m_x \sum_{k=-\infty}^\infty h(k)=m_x H(e^{j0})\)</span></p>
<p>其输出的自相关序列<span class="math inline">\(R_{yy}(m)=\sum_{k=-\infty}^\infty h(k)\sum_{r=-\infty}^\infty h(r)R_{xx}(m-r+k)\)</span>，进一步化简得<span class="math inline">\(R_{yy}(m)=R_{xx}(m)*R_{hh}(m)=R_{xx}(m)*h(m)*h(-m)\)</span>,其中：<span class="math inline">\(R_{hh}(l)=\sum_{k=-\infty}^\infty h(k)h(l+k)=h(l)*h(-l)\)</span>为系统单位冲激响应的自相关序列</p>
<p>其输出的功率谱<span class="math inline">\(S_{yy}(z)=S_{xx}(z)S_{hh}(z)\)</span>,若<span class="math inline">\(h(n)\)</span>为实序列,则<span class="math inline">\(S_{hh}(z)=H(z)H(z^{-1})\)</span>。若<span class="math inline">\(h(n)\)</span>为复序列,则<span class="math inline">\(S_{hh}(z)=H(z)H^*(1/z^*)\)</span></p>
<p>输入输出随机过程的互相关序列<span class="math inline">\(R_{xy}(m)=R_{xx}(m)*h(m)\)</span>,进而可以得到<span class="math inline">\(R_{yy}(m)=R_{xy}(m)*h(-m)\)</span></p>
<p><strong>如果输入是一个零均值的平稳白噪声随机过程，其方差为<span class="math inline">\(\sigma_x^2\)</span>,自相关序列为<span class="math inline">\(R_{xx}(m)=\sigma_x^2\delta(m)\)</span>,功率谱为<span class="math inline">\(S_{xx}(z)=\sigma_x^2\)</span>,根据<span class="math inline">\(R_{yy}(m)=R_{xy}(m)*h(-m)\)</span>有<span class="math inline">\(R_{xy}(m)=\sigma_x^2h(m)\)</span>,对其进行z变换得<span class="math inline">\(S_{xy}(z)=\sigma_x^2H(z)\)</span></strong></p>
<p>输出随机过程的方差:<span class="math inline">\(E[y^2(n)]=R_{yy}(0)=R_{xx}(m)=\\\frac{1}{2\pi j}\oint_{C} S_{yy}(z)z^{-1}\, \mathrm{d}z=\frac{1}{2\pi j}\oint_{C} S_{xx}(z)H(z)H(z^{-1})z^{-1}\, \mathrm{d}z\)</span> 式中的积分围线可选择为单位圆</p>
<p>白噪声<span class="math inline">\(w(n):m_w=0,R_{ww}=\sigma_w^2\delta(m),S_{ww}(z)=\sigma_w^2\qquad S(e^{jw})=\sigma_w^2\)</span></p>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理第四章知识小结</title>
    <url>/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<h3 id="滤波器的分类">滤波器的分类</h3>
<p>经典滤波器从功能上可分为：低通(LP),高通(HP),带通(BP),带阻(BS),且均有AF和DF之分,AF和DF的四种滤波器的理想幅频响应如下图所示： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-50-28.png"> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-50-45.png"></p>
<span id="more"></span>
<h3 id="数字滤波器的技术要求">数字滤波器的技术要求</h3>
<p>数字滤波器的传输函数:<span class="math inline">\(H(e^{jw})=|H(e^{jw})|e^{j\phi(w)}\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-51-38.png"></p>
<p><span class="math inline">\(w_p\)</span>:通带截止频率, <span class="math inline">\(\alpha_p\)</span>:通带允许的最大衰减</p>
<p><span class="math inline">\(w_s\)</span>:阻带截止频率, <span class="math inline">\(\alpha_s\)</span>:阻带允许的最小衰减</p>
<p><span class="math inline">\(w_c\)</span>:3dB通带截止频率，<span class="math inline">\(\delta_1,\delta_2\)</span>：通带、阻带的容限(允许误差)</p>
<p><span class="math inline">\(\alpha_p,\alpha_s\)</span>分别定义为：</p>
<p><span class="math display">\[
\alpha_p=20lg\frac{|H(e^{j0})|}{|H(e^{jw_p})|}\\\alpha_s=20lg\frac{|H(e^{j0})|}{|H(e^{jw_s})|}
\]</span></p>
<h3 id="模拟滤波器的技术要求">模拟滤波器的技术要求</h3>
<p><img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-14-59-33.png"></p>
<p><span class="math inline">\(\Omega_p\)</span>:通带截止频率, <span class="math inline">\(\alpha_p\)</span>:通带中的最大衰减系数</p>
<p><span class="math inline">\(\Omega_s\)</span>:阻带截止频率, <span class="math inline">\(\alpha_s\)</span>:阻带的最小衰减系数</p>
<p><span class="math inline">\(\Omega_c\)</span>:3dB通带截止频率</p>
<p><span class="math inline">\(\alpha_p,\alpha_s\)</span>分别定义为：</p>
<p><span class="math display">\[
\alpha_p=20lg\frac{|H_a(j0)|}{|H_a(j\Omega_p)|}\\\alpha_s=20lg\frac{|H_a(j0)|}{|H_a(j\Omega_s)|}
\]</span></p>
<p>数字滤波器的三种基本运算的框图表示和流程图表示 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-03-39.png"></p>
<h2 id="iir数字滤波器的基本网络结构">IIR数字滤波器的基本网络结构</h2>
<h3 id="直接i型">直接I型</h3>
<p>系统函数：<span class="math inline">\(H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^M b_k\cdot z^{-k}}{1-\sum_{k=1}^N a_k\cdot z^{-k}}=H_1(z)\cdot H_2(z)\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-08-50.png"> 其中<span class="math inline">\(H_1(z)=\sum_{k=0}^M b_k\cdot z^{-k},H_2(z)=1/[1-\sum_{k=1}^N a_k\cdot z^{-k}]\)</span></p>
<p><strong>直接I型,先实现<span class="math inline">\(H_1(z)\)</span>,再实现<span class="math inline">\(H_2(z)\)</span>,特点：先实现系统函数的零点，再实现极点，需要2N个延迟器和2N个乘法器。</strong></p>
<h3 id="直接ii型">直接II型</h3>
<p><strong>直接II型,先实现<span class="math inline">\(H_2(z)\)</span>,再实现<span class="math inline">\(H_1(z)\)</span>,特点：先实现系统函数的极点，再实现零点，需要N个延迟器和2N个乘法器。</strong> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-12-23.png"></p>
<h3 id="级联型">级联型</h3>
<p>系统函数：<span class="math inline">\(H(z)=A\prod_{k=1}^L \frac{\beta_{0k}+\beta_{1k}\cdot z^{-1}+\beta_{2k}\cdot z^{-2}}{1-\alpha_{1k}\cdot z^{-1}-\alpha_{2k}\cdot z^{-2}}=A\prod_{k=1}^L H_k(z)\)</span>,<span class="math inline">\(H_k(z)\)</span>称为滤波器的二阶基本节。 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-22-55.png"> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-22-36.png"></p>
<p><strong>基本结构：二阶基本节，“田字型”结构。特点：1、二阶基本节搭配灵活，可调换次序；2、可直接控制零极点；3、存储器最少；4、误差较大。</strong></p>
<h3 id="并联型">并联型</h3>
<p>系统函数:<span class="math inline">\(H(z)=c_0+\sum_{k=1}^P \frac{A_k}{1-c_k\cdot z^{-1}}+\sum_{k=1}^Q \frac{\gamma_{0k}+\gamma_{1k}\cdot z^{-1}}{1-\alpha_{1k}\cdot z^{-1}-\alpha_{2k}\cdot z^{-2}}\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-15-27-07.png"> <strong>基本结构：一阶基本节和二阶基本节。特点：1、可单独调整极点，不能直接控制零点；2、误差小，各基本节的误差不相互影响；3、速度快。</strong></p>
<h2 id="fir数字滤波器的基本网络结构">FIR数字滤波器的基本网络结构</h2>
<p>FIR数字滤波器是一种非递归结构，其冲激响应<span class="math inline">\(h(n)\)</span>是有限长序列</p>
<p><span class="math display">\[
H(z)=\sum_{n=0}^{N-1} h(n)z^{-n}
\]</span></p>
<p>FIR系统仅在<span class="math inline">\(z=0\)</span>处有N-1阶极点，在其它地方没有极点，有(N-1)个零点分布在有限Z平面内的任何位置上。</p>
<h3 id="直接型">直接型</h3>
<p>系统函数:<span class="math inline">\(H(z)=\sum_{n=0}^{N-1}h(n)z^{-n}=h(0)+h(1)z^{-1}+\dots+h(N-1)z^{-(N-1)}\)</span></p>
<p><img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-20-15-13.png"></p>
<p><strong>特点：只含前向通路</strong></p>
<h3 id="级联型-1">级联型</h3>
<p>系统函数:<span class="math inline">\(H(z)=\sum_{k=0}^{N-1}h(n)z^{-k}=\prod_{k=1}^M(\beta_{0k}+\beta_{1k}\cdot z^{-1}+\beta_{2k}\cdot z^{-2}),h(n)\)</span>为实系数 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-20-20-09.png"></p>
<p>特点：1、每一个基本节控制一对零点；2、乘法器较多；3、遇到高阶时<span class="math inline">\(H(z)\)</span>难分解。</p>
<h3 id="快速卷积型">快速卷积型</h3>
<p>已知两个长度为N的序列的线性卷积，可用2N-1点的循环卷积来代替。 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-17-20-22-02.png"> 特点：能对信号进行高速处理。需要实时处理时采用此结构。</p>
<h3 id="线性相位型">线性相位型</h3>
<ol type="1">
<li>线性相位FIR DF的条件： 单位取样响应<span class="math inline">\(h(n)=\pm h(N-1-n),\)</span>,当N为奇数时，系统的幅度响应和相位响应为<span class="math inline">\(\begin{cases} H(w)=\sum_{n=1}^{N/2}a(n)cos[w(n-\frac{1}{2})]\\ \phi(w)=-w(N-1)/2 \end{cases}\)</span>。<strong>幅度函数<span class="math inline">\(H(w)\)</span>是一个标量函数，可以包括正值和负值;<span class="math inline">\(H(w)\)</span>对<span class="math inline">\(\pi\)</span>呈奇对称。相位特性是严格线性的</strong>。当N为偶数时，系统的幅度响应和相位响应<span class="math inline">\(\begin{cases} H(w)=\sum_{n=1}^{(N-1)/2}b(n)cos[w(n)]\\ \phi(w)=-w(N-1)/2 \end{cases}\)</span>。<strong><span class="math inline">\(H(w)\)</span>对<span class="math inline">\(0,\pi,2\pi\)</span>呈偶对称,相位特性是严格线性的。</strong></li>
<li>线性相位FIR DF系统函数的零点分布 零点分布：两组共轭对<span class="math inline">\(z,\frac{1}{z},z^*,\frac{1}{z^*}\)</span>--要求<span class="math inline">\(h(n)\)</span>为实序列，如果不为实序列，只能确定零点分布为<span class="math inline">\(z,\frac{1}{z}\)</span></li>
<li>线性相位FIR DF系统函数的系数特点 冲激响应为偶对称的线性相位系统函数多项式的系数是镜像对称的,如一个四阶系统<span class="math inline">\(H(z)\)</span>的的形式<span class="math inline">\(a+bz^{-1}+cz^{-2}+bz^{-3}+az^{-4}\)</span></li>
<li>线性相位FIR DF的网络结构 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/当$h(n)=h(N-1-n)$且N为偶数时.png"></li>
</ol>
<h3 id="频率取样型">频率取样型</h3>
<p>上章已证明：长度为N的有限长序列的z变换可用围绕单位圆上的N个等间隔的取样值来表示。即 <span class="math display">\[X(z)=\frac{1-z^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{X(k)}{1-W_N^{-k}\cdot z^{-1}}\]</span> 对FIR系统，其冲激相应<span class="math inline">\(h(n)\)</span>是有限长的（长度为N），根据上述的插值公式，FIR系统的系统函数可表示为： <span class="math display">\[H(z)=\frac{1-z^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{H(k)}{1-W_N^{-k}\cdot z^{-1}}\]</span> 其中<span class="math inline">\(H(k)\)</span>是<span class="math inline">\(h(n)\)</span>的z变换在各点上的取样值，即 <span class="math display">\[H(k)=H(z)|_{z=W_N^{-k}}\]</span> 上式为实现FIR滤波器提供了另一种结构，由两个串联网络组成，即： <span class="math display">\[H(z)=\frac{1}{N}H_1(z)\cdot H_2(z)=\frac{1-z^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{H(k)}{1-W_N^{-k}\cdot z^{-1}}=\frac{1}{N}H_1(z)\cdot \sum_{k=0}^{N-1} H_k(z)\]</span> 其串联网络如下图所示： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-18-57-47.png"> 第一节网络<span class="math inline">\(H_1(z)\)</span>是由N节延迟线组成的梳状滤波器。</p>
<p>相应的差分方程为<span class="math inline">\(y_1(n)=x(n)-x(n-N),H_1(z)\)</span>在单位圆上有N个等分零点，即：<span class="math inline">\(z_k=e^{j\frac{2\pi}{N}k},k=0,1,\dots,N-1\)</span> 其频率响应为：<span class="math inline">\(H_1(e^{jw})=1-e^{-jwN}\)</span>,其流图和幅频特性表示如图： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-19-02-01.png"> 第二个网络<span class="math inline">\(H_2(z)=\sum_{k=0}^{N-1} H_k(z)\)</span>是并联的一阶网络,每个一阶网络<span class="math inline">\(H_k(z)=\frac{H(k)}{1-W_N^{-k}\cdot z^{-1}}\)</span>是一个谐振器,每个一阶网络在单位圆上有一个极点：<span class="math inline">\(z_k=W_N^{-k}\)</span></p>
<p>结论： 1. 由N个谐振器并联的网络有N个极点； 2. 网络对<span class="math inline">\(w=\frac{2\pi}{N},k＝0，1，2，……（N－1）\)</span>的响应为无穷大； 3. 并联谐振器的极点正好各自与梳状滤波器的零点相抵消，从而使这个频率上的响应等于H(k) <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-23-19-05-35.png"> FIR系统频率取样结构的主要特点是：并联谐振器的系数<span class="math inline">\(H(k)\)</span>就是滤波器在<span class="math inline">\(w=\frac{2\pi}{N}k\)</span>处的响应，因此控制其响应是很直接的。</p>
<p>缺点： 1. 所有的相乘系数都是复数，复数乘法比较麻烦； 2. 所有谐振器的极点均在单位圆上，如果滤波器的系数稍有误差，极点就可能移到单位圆外，系统不容易稳定。</p>
<p>改进： 1. 将谐振器的极点从单位圆向内收缩，使极点处在半径为<span class="math inline">\(r&lt;1\)</span>的圆上，<span class="math inline">\(H(z)=\frac{1-r^Nz^{-N}}{N}\cdot \sum_{k=0}^{N-1}\frac{H_r(k)}{1-r\cdot W_N^{-k}\cdot z^{-1}}\)</span> 2. 将复数的复乘法运算变成实数相乘，即复一阶网络用实系数的二阶网络来实现</p>
<h2 id="iir数字滤波器的设计方法">IIR数字滤波器的设计方法</h2>
<p>设计步骤：</p>
<ol type="1">
<li>根据实际需要给定滤波器的技术指标。</li>
<li>由技术指标计算滤波器的系统函数<span class="math inline">\(H(z)\)</span>或单位取样响应<span class="math inline">\(h(n)\)</span>，即用一个稳定的因果系统逼近这些指标；</li>
<li>用有限精度的运算实现<span class="math inline">\(H(z)\)</span>或<span class="math inline">\(h(n)\)</span>，包括选择运算结构、进行误差分析和选择存储单元的字长。</li>
</ol>
<p>IIR常用的设计方法：</p>
<ol type="1">
<li>将IIR模拟滤波器映射成数字滤波器 <span class="math inline">\(H(z)=H_a(s)|_{s=m(z)}\)</span>映射函数<span class="math inline">\(s=m(z)\)</span>应具有下列性质：
<ul>
<li>将<span class="math inline">\(s\)</span>平面的虚轴<span class="math inline">\(j\Omega\)</span>映射成z平面上的单位圆周<span class="math inline">\(|z|=1\)</span>,以保持模拟滤波器的幅度响应在映射后不发生失真。</li>
<li>将s平面左半平面映射成z平面单位圆内的内部，以保证稳定的模拟滤波器能够映射成稳定的数字滤波器</li>
<li><span class="math inline">\(m(z)\)</span>是有理函数，将有理函数<span class="math inline">\(H_a(s)\)</span>映射成有理函数<span class="math inline">\(H(z)\)</span></li>
</ul></li>
<li>计算机辅助设计方法</li>
</ol>
<h3 id="冲激响应不变法">冲激响应不变法</h3>
<ol type="1">
<li>使用冲激响应不变法设计数字滤波器的准则 使数字滤波器的单位取样响应与所参照的模拟滤波器的冲激响应的取样值一样，即<span class="math inline">\(h(n)=h_a(nT)\)</span>，复频域:<span class="math inline">\(H(z)|_{z=e^{sT}}=\frac{1}{T}\sum_{r=-\infty}^{\infty}H_a(s-j\frac{2\pi}{T}r)\)</span>。DF与AF的频率特性<span class="math inline">\(H(e^{jw})|_{w=T\Omega}=\frac{1}{T}\sum_{r=-\infty}^{\infty} H_a(j\frac{w}{T}-j\frac{2\pi}{T}r)\)</span> 数字滤波器的频率响应是模拟滤波器频率响应的周期延拓。在冲激响应不变法中，数字滤波器的频率响应产生混迭失真；数字域频率和模拟域频率之间是线性关系,即<span class="math inline">\(w=T\Omega\)</span>频率之间不产生失真,且T在设计中是一个无关紧要的参量，常为了方便取1.<strong>冲激响应不变法最适合可以用部分分式表示的传递函数</strong></li>
<li>冲激响应不变法设计数字滤波器的设计步骤 <span class="math inline">\(H_a(s)-&gt;h_a(t)-&gt;h(n)=h_a(nT)-&gt;H(z)\)</span>
<ol type="1">
<li>假设模拟滤波器的传递函数<span class="math inline">\(H_a(s)\)</span>具有单阶极点，且分母的阶数高于分子的阶数,将<span class="math inline">\(H_a(s)\)</span>展开为部分分式得<span class="math inline">\(H_a(s)=\sum_{k=1}^N \frac{A_k}{s-s_k}\)</span>,<span class="math inline">\(s_k\)</span>为极点，对<span class="math inline">\(H_a(s)\)</span>求laplace变换得：<span class="math inline">\(h_a(t)=\sum_{k=1}^N A_ke^{s_kt}\cdot u(t)\)</span></li>
<li>使用冲激不变法求数字滤波器的冲激响应<span class="math inline">\(h(n)\)</span> 令<span class="math inline">\(t=nT\)</span>,代入上式得<span class="math inline">\(h(n)=h_a(nT)=h_a(t)=\sum_{k=1}^N A_ke^{s_knT}\cdot u(nT)\)</span></li>
<li>求<span class="math inline">\(h(n)\)</span>的z变换得<span class="math inline">\(H(z)=Z[h(n)]=\sum_{n=0}^\infty[\sum_{k=1}^N A_ke^{s_knT}\cdot ]z^{-n}=\sum_{k=1}^N \frac{A_k}{1-e^{s_kT}z^{-1}}\)</span></li>
</ol></li>
<li>冲激响应不变法的应用范围:能够设计的滤波器：LP、BP；</li>
</ol>
<h3 id="双线性变换法">双线性变换法</h3>
<ol type="1">
<li>双线性变换法设计数字滤波器 双线性变换法是一种s平面到z平面的映射过程，定义为<span class="math inline">\(s=\frac{2}{T}\cdot\frac{1-z^{-1}}{1+z^{-1}}\)</span>,故有<span class="math inline">\(H(z)=H_a(s)|_{s=\frac{2}{T}\cdot\frac{1-z^{-1}}{1+z^{-1}}}=H_a(\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}})\)</span> 将<span class="math inline">\(z=e^{jw}\)</span>和<span class="math inline">\(s=j\Omega\)</span>带入得<span class="math inline">\(s=\frac{2}{T}\cdot \frac{1-z^{-1}}{1+z^{-1}}:j\Omega=\frac{2}{T}\cdot\frac{1-e^{-jw}}{1+e^{jw}}=\frac{2}{T}\cdot jtan(w/2)\)</span>,即<span class="math inline">\(w=2arctan(\frac{T\Omega}{2})\)</span>
<ol type="1">
<li>数字域频率和模拟域频率之间是非线性关系,当<span class="math inline">\(\Omega\)</span>从<span class="math inline">\(0-&gt;+\infty,w:0-&gt;\pi\)</span>。即：AF的全部频率特性，被压缩成等效于DF在频率<span class="math inline">\(0&lt;w&lt;\pi\)</span>之间的特性。</li>
<li>幅度上无混迭失真。双线性变换的频率标度的非线性失真可以通过预畸变的方法来补偿。设所求的数字滤波器的通带和阻带的截止频率分别为<span class="math inline">\(w_p\)</span>和<span class="math inline">\(w_s\)</span>,则</li>
</ol>
<span class="math display">\[
\begin{cases}
   \Omega_p=\frac{2}{T}tg(\frac{w_p}{2})\\
   \Omega_s=\frac{2}{T}tg(\frac{w_s}{2})
\end{cases}\]</span>模拟滤波器就按这两个预畸变了的频率<span class="math inline">\(\Omega_s\)</span>和<span class="math inline">\(\Omega_s\)</span>来设计。双线性变换是一种稳定的变换。令<span class="math inline">\(s=\sigma+j\Omega\)</span>,得<span class="math inline">\(|z|=\sqrt{\frac{(1+\frac{\sigma T}{2})^2+(\frac{\Omega T}{2})^2}{(1-\frac{\sigma T}{2})^2+(\frac{\Omega T}{2})^2}}\)</span>
<ol type="1">
<li>双线性变换是简单映射；</li>
<li>双线性变换是稳定的变换；即模拟滤波器在s平面左半平面的所有极点经映射后均在z平面的单位圆内。</li>
</ol></li>
<li>双线性变换法设计数字滤波器的设计步骤 模拟低通滤波器-&gt;双线性变换映射成数字低通滤波器-&gt;数字低通滤波器的频率响应。</li>
<li>双线性变换法的应用范围：能够设计的滤波器－LP、HP、BP、BS。</li>
<li>冲激响应不变法和双线性变换法比较：
<ul>
<li>相同点：首先设计AF，再将AF转换为DF。</li>
<li>不同点：冲激响应不变法幅频响应有失真 频率之间呈线性 双线性变换法幅频响应无混迭 频率之间非线性</li>
</ul></li>
</ol>
<h3 id="数字butterworth滤波器">数字Butterworth滤波器</h3>
<ol type="1">
<li><p>模拟Butterworth滤波器的幅度平方函数 模拟Butterworth滤波器的幅度平方函数:<span class="math inline">\(|H_a(j\Omega)|^2=\frac{1}{1+(\Omega/\Omega_c)^{2N}}\)</span> <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-10-08-54.png"> 特点：通带内幅度响应最平坦；通带和阻带内幅度特性单调下降；N增大，通带和阻带的近似性越好，过渡带越窄；存在极点，零点在<span class="math inline">\(\infty\)</span> 。</p>
<p>Butterworth滤波器极点分布特点:</p>
<p>令<span class="math inline">\(s=j\Omega\)</span>,则幅度平方函数为<span class="math inline">\(H_a(s)H_a(-s)=\frac{1}{1+(s/{j\Omega_c})^{2N}}\)</span>,令分母为0，则<span class="math inline">\(s_k=\Omega_ce^{j(\frac{\pi}{2N}+\frac{\pi}{2}+\frac{k\pi}{N})},k=0,1,\dots,(2N-1)\)</span></p>
<p>在s平面上共有2N个极点等角距地分布在半径为<span class="math inline">\(\Omega_c\)</span>的圆上；极点对称于虚轴，虚轴上无极点；N为奇数，实轴上两个极点；N为偶数，实轴上无极点；各极点间的角度为<span class="math inline">\(\frac{\pi}{N}\)</span></p></li>
<li><p>根据滤波器的指标求模拟滤波器的系统函数</p>
<p>N为偶数时：模拟Butterworth滤波器的传递函数为 <span class="math display">\[H_a(s)=\frac{\Omega_c^N}{\prod_{k=1}^{N/2}(s-s_k)(s-s_k^*)}\]</span> <span class="math inline">\(s_k\)</span>为左半平面极点，<span class="math inline">\(s_k^*\)</span>为<span class="math inline">\(s_k\)</span>的共轭极点，<span class="math inline">\(s_p\)</span>为实轴上的极点 N为奇数时：<span class="math display">\[H_a(s)=\frac{\Omega_c^N}{(s-s_p)\prod_{k=1}^{N/2-1}(s-s_k)(s-s_k^*)}\]</span></p></li>
<li><p>设计数字Butterworth滤波器的步骤</p>
<ol type="1">
<li>根据实际需要规定滤波器在数字临界频率<span class="math inline">\(w_p\)</span>和<span class="math inline">\(w_T\)</span>处的衰减 (单位为分贝)</li>
<li>确定模拟Butterworth滤波器的阶数N和截止频率<span class="math inline">\(\Omega_c\)</span></li>
<li>求模拟Butterworth滤波器的极点，并由s平面左半平面的极点构成传递函数<span class="math inline">\(H_a(s)\)</span></li>
<li>使用冲激不变法或双线性变换法将<span class="math inline">\(H_a(s)\)</span>转换成数字滤波器的系统函数<span class="math inline">\(H(z)\)</span></li>
</ol></li>
</ol>
<h2 id="iir数字滤波器的频率变换">IIR数字滤波器的频率变换</h2>
<ol type="1">
<li>设<span class="math inline">\(H(v)\)</span>是数字原型低通滤波器的系统函数，<span class="math inline">\(H_d(z)\)</span>是所要求的滤波器（LP、HP、BP、BS）的系统函数。为了将稳定、因果的<span class="math inline">\(H(v)\)</span>变换成稳定、因果的<span class="math inline">\(H_d(z)\)</span>，要求：
<ol type="1">
<li>v平面到z平面的映射<span class="math inline">\(v^{-1}=F(z^{-1})\)</span>是<span class="math inline">\(z^{-1}\)</span>的有理函数；</li>
<li>v平面的单位圆内部映射成z平面的单位圆内部。</li>
</ol></li>
<li>频率变换的设计公式
<ul>
<li>LP-&gt;LP:<span class="math inline">\(w_p\)</span>要求的截止频率 <span class="math display">\[v^{-1}=\frac{z^{-1}-\alpha}{1-\alpha z^{-1}}\qquad\alpha=\frac{sin(\frac{\theta_p-w_p}{2})}{sin(\frac{\theta_p+w_p}{2})}\]</span></li>
<li>LP-&gt;HP:<span class="math inline">\(w_p\)</span>要求的截止频率 <span class="math display">\[v^{-1}=-\frac{z^{-1}+\alpha}{1+\alpha z^{-1}}\qquad\alpha=\frac{cos(\frac{\theta_p+w_p}{2})}{cos(\frac{\theta_p-w_p}{2})}\]</span></li>
<li>LP-&gt;BP：<span class="math inline">\(w_1,w_2\)</span>要求的上、下截止频率 <span class="math display">\[v^{-1}=-\frac{z^{-2}-\frac{2\alpha k}{k+1}z^{-1}+\frac{k-1}{k+1}}{\frac{k-1}{k+1}z^{-2}-\frac{2\alpha k}{k+1}z^{-1}+1}\qquad\alpha=\frac{cos(\frac{w_1+w_2}{2})}{cos(\frac{w_1-w_2}{2})}\qquad k=ctg(\frac{w_2-w_1}{2})tg(\frac{\theta_p}{2})\]</span></li>
<li>LP-&gt;BS：<span class="math inline">\(w_1,w_2\)</span>要求的上、下截止频率 <span class="math display">\[v^{-1}=\frac{z^{-2}-\frac{2\alpha}{k+1}z^{-1}+\frac{1-k}{k+1}}{\frac{1-k}{k+1}z^{-2}-\frac{2\alpha}{k+1}z^{-1}+1}\qquad\alpha=\frac{cos(\frac{w_1+w_2}{2})}{cos(\frac{w_1-w_2}{2})}\qquad k=tg(\frac{w_2-w_1}{2})tg(\frac{\theta_p}{2})\]</span></li>
</ul></li>
</ol>
<h2 id="fir数字滤波器的设计方法">FIR数字滤波器的设计方法</h2>
<p>基本特性: 1. FIR滤波器永远是稳定的（极点均位于原点）； 2. FIR滤波器的冲激响应<span class="math inline">\(h(n)\)</span>是有限长序列； 3. FIR滤波器的系统函数<span class="math inline">\(H(z)\)</span>为多项式； 4. FIR滤波器具有线性相位。 设计的基本方法： 窗函数法，频率抽样法和等波纹逼近法等。</p>
<h3 id="窗函数法">窗函数法</h3>
<ol type="1">
<li><p>窗函数法原理 将理想低通滤波器（LPF）无限长单位取样响应序列<span class="math inline">\(h_d(n)\)</span>截断。（等效于加矩形窗），用得到的有限长序列逼近理想低通滤波器。 特点：理想低通滤波器的冲激响应序列<span class="math inline">\(h_d(n)\)</span>无限长，非因果，不绝对可和。理想LPF是不稳定的，也是不可实现的。可以对理想LPF进行逼近：截断无限长时间冲激响应序列得到一个有限长序列。即：用有限长的冲激响应序列<span class="math inline">\(h(n)\)</span>来逼近无限长的冲激响应序列<span class="math inline">\(h_d(n)\)</span>,<span class="math inline">\(h(n)\)</span>应满足FIR滤波器的基本条件。应为偶对称或奇对称以满足线性相位的条件。应为因果序列。 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-11-14-17.png"> 其中<span class="math inline">\(w_R(n)=\begin{cases}  1,0\le n\le N-1\\  0,else \end{cases}\)</span>--窗函数（矩形窗），其频谱为<span class="math inline">\(H(e^{jw})=\frac{1}{2\pi}H_d(e^{jw})*W(e^{jw})\)</span> 结论：</p>
<ol type="1">
<li>FIR数字滤波器的频谱是理想LPF的频谱与窗函数频谱的卷积；</li>
<li>采用不同的窗函数， <span class="math inline">\(H(e^{jw})\)</span>就有不同的形状 <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-11-18-21.png"> 由理想LPF的时间函数加窗后得到的FIR滤波器的幅度函数是理想LPF的幅度函数与窗函数幅度函数的周期卷积,其具体过程如下： <img src="/2023/11/16/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-18-11-19-15.png"></li>
</ol></li>
<li><p>加窗的影响 理想LPF加窗后：使滤波器的频率响应在不连续点出现了过渡带，它主要是由窗函数频谱的主瓣引起的，其宽度取决于主瓣的宽度。而主瓣的宽度<span class="math inline">\(\Delta w=\frac{4\pi}{N}\)</span>。与滤波器的阶数N成反比。使滤波器在通带和阻带产生了一些起伏振荡的波纹—吉布斯现象，主要由旁瓣造成。</p>
<p>在一般情况下，对窗函数的要求是：(1)尽量减少窗函数频谱的旁瓣高度，使能量集中在主瓣，减少通带/阻带中的波纹。(2)主瓣的宽度尽量窄，获得较陡的过渡带。以上两条标准相矛盾，为了达到上述要求，采取的措施为：采用不同的窗函数。采用窗函数法设计出来的FIR数字低通滤波器的频率响应，它对理想低通滤波器的频率响应的逼近程度，取决于窗函数的频谱的主瓣宽度和旁瓣衰减的大小。</p></li>
<li><p>几种常用的窗函数 Bartlett窗。Hanning窗。Blackman窗。Hamming窗。Kaiser窗</p></li>
<li><p>窗函数的一般性质 窗函数的宽度N越大，窗函数的频谱的主瓣越窄，因而过渡带也越窄。窗函数的频谱的最大旁瓣高度和阻带最小衰减只取决于窗函数的种类，与窗函数的宽度N无关。</p></li>
<li><p>对窗函数的要求 为减小通带和阻带中的波纹幅度，应选择最大旁瓣高度尽可能小的窗函数，这将使更多的能量集中于主瓣内。为获得尽可能窄的过渡带，应选择主瓣宽度尽量窄的窗函数。</p></li>
<li><p>用窗函数法设计FIR数字滤波器的步骤</p>
<ol type="1">
<li>给出希望设计的滤波器的频率响应函数<span class="math inline">\(H_d(e^{jw})\)</span></li>
<li>根据允许的过渡带宽度和阻带衰减，选择窗函数和它的宽度N</li>
<li>计算希望设计的滤波器的单位取样响应<span class="math inline">\(h_d(n)\)</span></li>
<li>计算FIR数字滤波器的单位取样响应<span class="math inline">\(h(n)=h_d(n)w(n)\)</span></li>
<li>计算FIR数字滤波器的频率响应，验证是否达到所要求的指标</li>
<li>计算幅度响应和相位响应</li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模笔记(司守奎)</title>
    <url>/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/</url>
    <content><![CDATA[<hr>
<h1 id="数学建模笔记司守奎">数学建模笔记（司守奎）</h1>
<h2 id="线性规划">线性规划</h2>
<ol type="1">
<li>定义： 在一组线性条件限制下，求一线性目标函数最大或最小的问题</li>
<li>标准的matlab形式：<span class="math inline">\(min f^T x,\)</span> <span class="math inline">\(s.t. \begin{cases} A\cdot x \le b\\ Aeq \cdot x = beq \\ lb \le x \le ub \end{cases}\)</span> 其中<span class="math inline">\(f,x,b,beq,lb,u\)</span>为列向量，<span class="math inline">\(A，Aeq\)</span>为矩阵</li>
<li>matlab相关求解命令为 <span class="math inline">\([x,val]=linprog(f,A,b,Aeq,beq,lb,ub)\)</span></li>
</ol>
<span id="more"></span>
<h2 id="整数规划">整数规划</h2>
<ol type="1">
<li>定义： 数学规划中的变量（部分或全部）限制为整数时，称为整数规划</li>
<li>分类： 根据变量整数是部分还是全部可分为纯整数规划和混合整数规划</li>
<li>求解方法：
<ol type="1">
<li>分支定界法（纯或混）</li>
<li>割平面法（纯或混）</li>
<li>隐枚举法（01规划）
<ul>
<li>过滤隐枚举法</li>
<li>分支隐枚举法</li>
</ul></li>
<li>匈牙利法（指派问题）</li>
<li>蒙特卡洛法（各种类型）</li>
</ol></li>
</ol>
<h3 id="型整数规划">0-1型整数规划</h3>
<ol type="1">
<li>定义：整数规划的一种特殊情况，变量仅取值0或1 应用范围可分为以下几种情况</li>
</ol>
<h4 id="相互排斥的约束条件">相互排斥的约束条件</h4>
<p>也就是说题目中的某一种条件只有一个量，如果给了这个1，同类的都为0，较为典型的问题有运输问题，只用一种方式运输，用火车运了，其他的运输栏都为0，其约束条件可进一步简化为 <span class="math display">\[y_i=\begin{cases}
1,第i个元素起约束作用\\
0,第i个元素不起作用，i=1,2.....,m\\
\end{cases}\]</span> <span class="math display">\[a_{i1}x_1+...+a_{in}x_n\le b_i+(1-y_i)M,i=1,2...,m,\\
y_1+\dots+y_m=1
\]</span> 由约束条件很容易看出，当<span class="math inline">\(y_i\)</span>等于1,就只有这个约束起作用，其他的都是多余的</p>
<h4 id="固定费用的问题">固定费用的问题</h4>
<p>在讨论线性规划时，有些问题要求固定费用，这种问题可以通过改变为混合整数规划来解决，数学模型可表示为 <span class="math inline">\(y_i\epsilon\le x_i\le y_i M\)</span> 其中<span class="math inline">\(\epsilon\)</span>为充分小的正常数；M为充分大的正常数，表明<span class="math inline">\(x_i&gt;0\)</span>时，<span class="math inline">\(y_i\)</span>必须为1，<span class="math inline">\(x_i=0\)</span>时<span class="math inline">\(y_i\)</span>必须为0,<span class="math inline">\([x_i]\)</span>表示采用i方式生产时产量，<span class="math inline">\(y_i\)</span>表示是否用第i种方式生产</p>
<h4 id="指派问题">指派问题</h4>
<p>指派问题描述的是分配n个人去做n件事情，每个人做且仅做一件事情，且分配第i个人去做第j件事情，花费<span class="math inline">\(C_{ij}\)</span>单位时间，求如何分配使总时间最小，这类问题的关键就是要求出分配矩阵，数学形式可表现为 <span class="math display">\[x_{ij}=\begin{cases}
1,第i人做第j项工作\\
0,第i人做第j项工作\\
\end{cases}\]</span> 数学模型为：<span class="math display">\[min \sum_{i=1}^N \sum_{j=1}^N c_{ij}x_{ij}\\
   s.t. \begin{cases}
   \sum_{i=1}^N x_{ij}=1,i=1,2,...,n\\
   \sum_{j=1}^N x_{ij}=1,j=1,2,...,n\\
   x_{ij}=0 or 1,i,j=1,...,n
   \end{cases}\]</span></p>
<h3 id="蒙特卡洛法随机取样法">蒙特卡洛法（随机取样法）</h3>
<ol type="1">
<li>又被称为计算机随机模拟法，它是基于对大量数据的统计结果来实现一些确定性问题的计算</li>
<li>使用该方法必须使用计算机生成相关分布的随机数</li>
</ol>
<h3 id="整数线性规划的计算机求解">整数线性规划的计算机求解</h3>
<ol type="1">
<li>整数规划的求解用Lingo等专用软件比较方便，对于整数线性规划也可以用matlab的intlinprog函数求解，<strong>但其的缺点是必须把所有的决策变量化为一维决策变量，变量替换后，约束条件很难写出</strong>，最好用lingo</li>
<li>matlab求解混合整数线性规划的命令是</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=intlinprog(f,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure>
<p>对应以下数学模型 <span class="math display">\[min_x f^Tx,\\
s.t. \begin{cases}
x(intcon)为整数\\
A \cdot x \le b,\\
Aeq \cdot x =beq,\\
lb \le x \le ub \\
\end{cases}\]</span> 式中：<span class="math inline">\(f,x,intcon,b,beq,lb,ub为列向量；A，Aeq为矩阵\)</span></p>
<h2 id="非线性规划">非线性规划</h2>
<h3 id="非线性规划模型">非线性规划模型</h3>
<ol type="1">
<li><p>定义：如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题</p></li>
<li><p>通过投资决策问题归纳非线性规划数学模型的一般形式 总资金A元，投资第i个项目花<span class="math inline">\(a_i\)</span>元，预计可收益<span class="math inline">\(b_i\)</span>元 选择最佳投资方案 投资决策变量 <span class="math display">\[x_i=\begin{cases}
1,决定投资第i个项目\\
0,决定不投资第i个项目\\
\end{cases}\]</span> 则该模型可用下列数学模型表示 <span class="math display">\[max\, Q = \frac{\sum_{i=1}^n b_i x_i} {\sum_{i=1}^n a_i x_i}\\
s.t. \begin{cases}
0 &lt; \sum_{i=1}^n a_i x_i \le A ,\\
x_i(1-x_i)=0,i=1,...,n\\
\end{cases}\]</span></p></li>
<li><p>根据2中例题，非线性规划问题可进一步概括为： <span class="math inline">\(min\,f(x)\\ s.t. \begin{cases} h_j(x)\le0,j=1,2,...,q\\ g_i(x)=0,i=1,2,...,p\\ \end{cases}\)</span> 其中<span class="math inline">\(x=[x_1,...,x_n]^T\)</span>为模型的决策变量，<span class="math inline">\(f\)</span>为目标函数，<span class="math inline">\(g_i和h_j\)</span>为约束函数，<span class="math inline">\(g_i(x)=0\)</span>为等式约束，<span class="math inline">\(h_j(x)\le0\)</span>为不等式约束</p></li>
<li><p>对一个实际问题，要将其规为非线性规划问题时，一般要注意以下几点</p>
<ol type="1">
<li>确定供选方案</li>
<li>提出追求目标</li>
<li>给出价值标准</li>
<li>寻求限制条件</li>
</ol></li>
<li><p>线性规划与非线性规划的区别：线性规划最优解只能在可行域的边界上达到（特别是顶点），而非线性规划最优解可在可行域任一点达到</p></li>
<li><p>非线性规划的matlab表示 <span class="math display">\[minf(x)\\
s.t. \begin{cases}
A\cdot x \le b,\\
Aeq \cdot x=beq,\\
c(x)\le0\\
ceq(x)=0,\\
lb\le x \le ub
\end{cases}\]</span> 式中的<span class="math inline">\(f(x)\)</span>为标量函数，<span class="math inline">\(A,b,Aeq,beq,lb,ub\)</span>为相应维数的矩阵和向量，<span class="math inline">\(c(x),ceq(x)\)</span>为非线性向量函数 matlab命令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br><span class="line"># x返回决策变量x的取值，fval返回目标函数取值，fun是M文件自定义函数f(x),x0是x的初始值</span><br><span class="line">nonlcon是用M文件定义的c(x)ceq(x)，options定义优化参数</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="无约束问题的matlab解法">无约束问题的Matlab解法</h3>
<ol type="1">
<li>在matlab工具箱中，用于求无约束极小值的函数有fminunc和fminsearch，用法分别为</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminunc(fun,x0,options)</span><br><span class="line">[x,fval]=fminsearch(fun,x0,options) #只能求初始值附近的一个极小值点</span><br></pre></td></tr></table></figure>
<h3 id="约束极值问题">约束极值问题</h3>
<ol type="1">
<li>定义：带有约束条件的极值问题，也叫规划问题</li>
</ol>
<h4 id="二次规划">二次规划</h4>
<ol type="1">
<li>定义：若某非线性规划的目标函数为自变量x的二次函数，约束条件又全为线性的，称这种规划为二次规划</li>
<li>Matlab中二次规划的数学模型可表述为 <span class="math display">\[min\, \frac{1}{2}x^THx+f^Tx,\\
s.t. \begin{cases}
Ax\le b\\
Aeq \cdot x=beq,\\
lb\le x\le ub
\end{cases}
H为实对称矩阵，\\
\]</span> matlab求解二次规划的命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="罚函数法">罚函数法</h4>
<ol type="1">
<li>利用罚函数法可以将非线性规划问题的求解转化为求一系列无约束极值的问题，也把这种方法叫做序列无约束最小化技术</li>
<li>罚函数求解非线性规划问题的思想是利用问题中的约束函数作出适当的罚函数，由此构造出带参数的增广目标函数，把问题转换为无约束非线性规划问题，主要有两种形式，一种叫外罚函数法，另一种叫内罚函数法</li>
<li>外罚函数法： 考虑问题：<span class="math display">\[minf(x)\\
s.t.\begin{cases}
g_i(x) \le 0,i=1,...,r\\
h_j(x) \ge 0,j=1,...,s\\
k_m(x) =0,m=1,...,t
\end{cases}\]</span>取一个充分大的数M&gt;0,构造函数<span class="math inline">\(P(x,M)=f(x)+M\sum_{i=1}^nmax(g_i(x),0)-M\sum_{j=1}^nmin(h_j(x),0)+M\sum_{m=1}^n |k_m(x)|\)</span>,则以增广目标函数<span class="math inline">\(P(x,M)\)</span>为目标函数的无约束极值问题<span class="math inline">\(minP(x,M)\)</span>的最优解也是原问题的最优解</li>
<li><ol type="1">
<li>如果非线性规划问题要求实时算法，可以使用罚函数算法，但计算精度较低</li>
<li>如果不要求实时算法，要求高精度,可以使用lingo或matlab的fmincon命令求解</li>
</ol></li>
</ol>
<h4 id="matlab求约束极值问题">matlab求约束极值问题</h4>
<ol type="1">
<li><p>在matlab工具箱中，用于求解约束最优化问题的函数有fminbnd,fmincon,quadprog,fseminf,fminimax函数</p></li>
<li><p>fminbnd函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminbnd(fun,x1,x2,options) </span><br><span class="line"># 用于求单变量非线性函数在[x1,x2]上极小值</span><br><span class="line"># 返回极小点x和函数的极小值</span><br></pre></td></tr></table></figure></p></li>
<li><p>fseminf函数 用于求下列模型 <span class="math display">\[minf(x),\\
s.t. \begin{cases}
A \cdot x \le b,\\
Aeq \cdot x =beq,\\
lb\le x \le ub\\
c(x)\le0\\
ceq(x)\le0\\
K_i(x,w_i)\le0,1\le i\le n
\end{cases}\\其中c(x),ceq(x)为向量函数，K_i(x,w_i)为标量函数,w_1...为附加变量\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fseminf(fun,x0,ntheta,seminfcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure></p>
<p>fun定义目标函数f(x),x0为x初始值，ntheta是半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>个数，函数seminfcon用于定义非线性不等式约束<span class="math inline">\(c(x)\)</span>,非线性等式约束<span class="math inline">\(ceq(x)\)</span>和半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>的函数，seminfcon有两个输入参量x,s,s是推荐的采样步长 可以不使用</p></li>
<li><p>fminimax函数 用于求下列模型 <span class="math display">\[min_xmax_iF_i(x),\\
s.t. \begin{cases}
A \cdot x \le b,\\
Aeq \cdot x =beq,\\
lb\le x \le ub\\
c(x)\le0\\
ceq(x)=0\\
\end{cases}\]</span> matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminimax(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="图与网络模型及方法">图与网络模型及方法</h2>
<h3 id="图的基本概念与数据结构">图的基本概念与数据结构</h3>
<ul>
<li>基本概念 图可由顶点集V和边集E表示，G=(V,E)，若各边加上方向则为有向图，否则为无向图，另外赋权图是指每条边都有一个(或多个)实数对应的图，该实数称为这条边的权，赋权图在实际情况中非常有用</li>
<li>数据结构 图的数据结构主要有两种方法
<ol type="1">
<li>邻接矩阵表示法</li>
<li>稀疏矩阵表示法</li>
</ol></li>
</ul>
<h3 id="最短路问题">最短路问题</h3>
<h4 id="两个指定顶点之间的最短路径">两个指定顶点之间的最短路径</h4>
<p><strong>问题简述</strong>：给定一个连接若干个城镇的铁路网络，在这个网络的两个指定城镇间，找一条最短铁路线 <strong>模型抽象</strong>：该问题我们可以构建一个赋权图G=(V,E,W),其中顶点集V表示各个小城镇，E为边的集合，邻接矩阵W表示各顶点间的距离，若顶点间无边，则w=∞，则问题可转换为求赋权图G中指定两个顶点<span class="math inline">\(u_0,v_0\)</span>间具有最小权的路，这条路称为<span class="math inline">\(u_0,v_0\)</span>间的最短路，它的权称为二者间的距离，记为<span class="math inline">\(d(u_0,v_0)\)</span> <strong>常用方法</strong>：</p>
<ol type="1">
<li>狄克斯特拉(Dijkstra)算法:基本思想为按距<span class="math inline">\(u_0\)</span>从近到远为顺序，依次求得<span class="math inline">\(u_0\)</span>到G的各顶点的最短路和距离，直至<span class="math inline">\(v_0\)</span>（或直至G所有顶点）</li>
</ol>
<h4 id="两个指定顶点间最短路的数学规划模型">两个指定顶点间最短路的数学规划模型</h4>
<p>假设有向图有n个顶点，现要求从顶点<span class="math inline">\(v_1\rightarrow v_n\)</span>的最短路，仍然用E表示弧的集合，设<span class="math inline">\(W=(w_{ij})_{n×n}\)</span>为邻接矩阵，其分量为：<span class="math display">\[w_{ij}=\begin{cases}
弧v_iv_j的权值，v_iv_j\in E\\
∞，其他，
\end{cases}\]</span> 决策变量为<span class="math inline">\(x_{ij}\)</span>,当<span class="math inline">\(x_{ij}=1\)</span>,说明弧<span class="math inline">\(v_iv_j\)</span>位于顶点<span class="math inline">\(v_1\)</span>到顶点<span class="math inline">\(v_n\)</span>的最短路上，否则<span class="math inline">\(x_{ij}=0\)</span>,其数学规划表达式为<span class="math display">\[min\sum_{v_iv_j\in E}w_{ij}x_{ij},\\
s.t. \begin{cases}
\sum_{j=1,v_iv_j\in E}^n x_{ij}-\sum_{j=1,v_jv_i\in E}^n x_{ji}=\begin{cases}
1,i=1\\
-1,i=n\\
0,i\ne1,n
\end{cases}\\
x_{ij}=0或1
\end{cases}    \]</span></p>
<h4 id="每对顶点之间的最短路径">每对顶点之间的最短路径</h4>
<p>计算赋权图各队顶点之间的最短路径，调用方法有两种</p>
<ol type="1">
<li>Dijkstra算法 每次以不同的顶点作为起点，用Dijkstra算法算出该起点到其余顶点的最短路径，反复执行n-1次操作，就可得到从每一个顶点到其他顶点的最短路径，时间复杂度为<span class="math inline">\(O(n^3)\)</span></li>
<li>Floyd算法 递推产生一个矩阵序列<span class="math inline">\(A_1,...,A_k,...,A_n\)</span>,其中矩阵<span class="math inline">\(A_k\)</span>的第i行第j列元素<span class="math inline">\(A_k(i,j)\)</span>表示从顶点<span class="math inline">\(v_i\)</span>到顶点<span class="math inline">\(v_j\)</span>的路径经过顶点序号不大于k的最短路径长度，计算时用迭代公式<span class="math inline">\(A_k(i,j)=min(A_{k-1}(i,j),A_{k-1}(i,k)+A_{k-1}(k,j))\)</span>,k是迭代次数，i,j,k=1,2,...n,最后当k=n时，<span class="math inline">\(A_n\)</span>即是各顶点间的最短通路值</li>
</ol>
<h3 id="最小生成树问题">最小生成树问题</h3>
<h4 id="基本概念">基本概念</h4>
<p>连通的无圈图叫做树，记为T，其度为1的顶点称为叶子节点，显然有边的树至少有两个叶子顶点 若图G=(V(G),E(G))和树T=(V(T),E(T))满足<span class="math inline">\(V(G)=V(T),E(T)\subset E(G)\)</span>，则称T是G的生成树，图G连通的充要条件是G有生成树</p>
<h4 id="最小生成树">最小生成树</h4>
<p>欲修筑连接n个城市的铁路，已知i城与j城之间的铁路造价为<span class="math inline">\(c_{ij}\)</span>,设计一个线路图使总造价最低，这个问题的数学模型是在连通赋权图上求权最小的生成树，赋权图具有最小权的生成树叫做最小生成树 <strong>常用算法</strong>： 构造连通赋权图G=(V,E,W)的最小生成树，设置两个集合P和Q,其中P用于存放G的最小生成树的顶点，集合Q存放G的最小生成树的边。令集合P的初值为<span class="math inline">\(P={V_1}\)</span>(假设构造最小生成树时，从顶点<span class="math inline">\(v_1\)</span>)出发，集合Q的初值为<span class="math inline">\(Q=\varnothing\)</span></p>
<ol type="1">
<li>prim算法 从所有<span class="math inline">\(p\in P,v\in V-P\)</span>的边中，选取具有最小权值的边pv，将顶点v加入集合P中,将边pv加入集合Q中，如此重复，直到P=V时，最小生成树构造完毕，这是集合Q包含了最小生成树的所有边。</li>
<li>Kruskal算法 选<span class="math inline">\(e_1\in E(G)\)</span>，使得<span class="math inline">\(e_1\)</span>是权值最小的边, 若<span class="math inline">\(e_1,e_2,...,e_i,e_{i+1}\)</span>已选好，则从E(G)-{<span class="math inline">\(e_1,e_2,...,e_i\)</span>}中选取<span class="math inline">\(e_{i+1}\)</span>,使得<span class="math inline">\({e_1,e_2,...,e_i,e_{i+1}}\)</span>中无圈，<span class="math inline">\(e_{i+1}\)</span>是E(G)-<span class="math inline">\({e_1,e_2,...,e_i}\)</span>中权值最小的边，直到选得<span class="math inline">\(e_{|V|-1}\)</span>为止</li>
</ol>
<h3 id="网络最大流问题">网络最大流问题</h3>
<h4 id="基本概念-1">基本概念</h4>
<ol type="1">
<li>网络：给一个有向图D=(V,A),其中A为弧集，在V中指定一点，称为发点(记为<span class="math inline">\(v_s\)</span>),另一点称为收点(记为<span class="math inline">\(v_t\)</span>)，其余点为中间点，对于每一条弧<span class="math inline">\((v_i,v_j)\in A\)</span>，对应有一个<span class="math inline">\(c(v_i,v_j)\ge 0(或简写为c_{ij})\)</span>,称为弧的容量，通常把这样的有向图叫做一个网络，记为D=(V,A,C),其中C={<span class="math inline">\(c_{ij}\)</span>}</li>
<li>流：定义在弧集合A的一个函数<span class="math inline">\(f={f_{ij}={f(v_i,v_j)}}\)</span>，并称<span class="math inline">\(f_{ij}\)</span>为弧<span class="math inline">\((v_i,v_j)\)</span>上的流量</li>
<li><div id="hei">
最大流问题的线性规划表示
</div></li>
</ol>
<p><span class="math display">\[max\quad v(f),\\
s.t.\begin{cases}
\sum_{j:(v_i,v_j)\in A}f_{ij}-\sum_{j:(v_j,v_i\in A)}f_{ji}=\begin{cases}
v(f),i=s\\
-v(f),i=t\\
0,i\ne s,t,
\end{cases}\\
0\le f_{ij} \le c_{ij},\forall(v_i,v_j)\in A
\end{cases}\]</span></p>
<h3 id="最小费用最大流问题">最小费用最大流问题</h3>
<h4 id="最小费用最大流">最小费用最大流</h4>
<p>给定网络D=(V,A,C),每一弧<span class="math inline">\((v_i,v_j)\in A\)</span>上，除了已给容量<span class="math inline">\(c_{ij}\)</span>外，还给了一个单位流量的费用<span class="math inline">\(b(v_i,v_j)\ge 0(b_{ij})\)</span>，所谓最小费用最大流问题就是求一个发点<span class="math inline">\(v_s\)</span>到收点<span class="math inline">\(v_t\)</span>的最大流，使流的总输送费用<span class="math inline">\(\sum_{(v_i,v_j)\in A}b_{ij}f_{ij}\)</span>取最小值，最小费用最大值问题可以归结为两个线性规划问题，首先用一个线性规划模型求出最大流量<span class="math inline">\(v(f_{max})\)</span>，再用一个线性规划模型求出最大流对应最小费用 <span class="math display">\[min \sum_{(v_i,v_j)\in A}b_{ij}f_{ij}\\
s.t. \begin{cases}
0\le f_{ij} \le c_{ij},\forall(v_i,v_j)\in A\\
\sum_{j:(v_i,v_j)\in A}f_{ij}-\sum_{j:(v_j,v_i\in A)}f_{ji}=d_i\\
d_i=\begin{cases}
v(f_{max}),i=s\\
-v(f_{max}),i=t\\
0,i\ne s,t,\\
\end{cases}\\
\end{cases}
\]</span> <span class="math inline">\(v_{f_{max}}\)</span><a href="#网络最大流问题">上节</a>求得最大流流量</p>
<h3 id="matlab的图论工具箱">Matlab的图论工具箱</h3>
<p><img src="/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/2024-01-15-16-35-48.png"></p>
<h3 id="旅行商tsp问题">旅行商(TSP)问题</h3>
<ol type="1">
<li>问题描述：一推销员准备前往若干城市推销商品，然后回到驻地，如何为他设计一条最短的旅行路线(从驻地出发，经过每个城市恰好一次，最后返回驻地)，这个问题就被称为旅行商问题</li>
<li>数学抽象：用图论术语表示，就是在一个赋权完全图中，找出一个有最小权的Hamilton圈，这个圈就叫最优圈</li>
<li>数学模型：设城市的个数为n，<span class="math inline">\(d_{ij}\)</span>是两个城市i与j之间的距离，<span class="math inline">\(x_{ij}=0 or 1\)</span>(1表示走过城市i到城市j的路，0表示没有选择走这条路)，则有 <span class="math display">\[min \sum_{i\ne j}d_{ij}x_{ij}\\
s.t. \begin{cases}
\sum_{j=1}^n x_{ij}=1,i=1,2,\dots,n,(每个点只有一条边出去)\\
\sum_{i=1}^n x_{ij}=1,i=1,2,\dots,n,(每个点只有一条边进去)\\
\sum_{i,j\in s}x_{ij}\le|s|-1,2\le|s|\le n-1,s\subset{1,2,\dots,n},即s为{1,2,\dots,n}的真子集\\
x_{ij}\in {0,1},i,j=1,2,\dots,n,i\ne j
\end{cases}
\]</span></li>
</ol>
<h3 id="计划评审方法和关键路线法">计划评审方法和关键路线法</h3>
<p>这两个方法是网络分析的重要组成部分，已经合并为一种方法，国外称PERT/CPM，国内称为统筹方法</p>
<h4 id="计划网络图">计划网络图</h4>
<p>计划网络图中通常用圆圈表示事件，用箭线表示工作，用这种方法画出的网络图为计划网络图 <img src="/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/2024-01-15-16-35-14.png"> 虚作业用虚箭线表示，表示工时为0，不消耗任何资源的虚构作业，作用只是为了正确表述工作的前向后继关系 <strong>关键路线</strong>: 在计划网络图中，称从初始事件到最终事件的由各项工作连贯组成的一条路为路线，具有累计作业时间最长的路线称为关键路线</p>
<h4 id="时间参数">时间参数</h4>
<ol type="1">
<li>事件时间参数
<ol type="1">
<li>事件的最早时间</li>
<li>事件的最迟时间</li>
</ol></li>
<li>工作时间参数
<ol type="1">
<li>工作的最早可能开工时间与最早可能完工时间</li>
<li>最迟必须开工时间和最迟必须完工时间</li>
</ol></li>
<li>时差
<ol type="1">
<li>工作总时差</li>
<li>工作单时差</li>
</ol></li>
</ol>
<h4 id="计划网络图的计算">计划网络图的计算</h4>
<ol type="1">
<li>建立计划网络图 <img src="/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0-%E5%8F%B8%E5%AE%88%E5%A5%8E/2024-01-15-16-34-48.png"></li>
<li>写出相应的规划问题 <span class="math display">\[min\sum_{i\in V}x_i\\
s.t\begin{cases}
x_j\ge x_i+t_{ij},(i,j)\in A,i,j\in V\\
x_i\ge 0,i\in V\\
\end{cases}\]</span> V为所有时间集合，A为所有作业集合，<span class="math inline">\(x_i\)</span>为事件i的开始时间，<span class="math inline">\(t_{ij}\)</span>为作业(i,j)的计划时间</li>
<li>问题求解</li>
<li>将关键路线看为最长路 如果将关键路线看成最长路,则可以按照求最短路的方法(将求极小改为求极大)求出关键路线 设<span class="math inline">\(x_{ij}\)</span>为0-1变量，当作业(i,j)位于关键路线上取1，否则取0，数学规划问题写成 <span class="math display">\[max\sum_{(i,j)\in A}t_{ij}x_{ij}\\
s.t.\begin{cases}
\sum_{j:(i,j)\in A}x_{ij}-\sum_{j:(j,i)\in A}x_{ji}=\begin{cases}
1,i=1,\\
-1,i=n,\\
0,i\ne1,n,\\
\end{cases}\\
x_{ij}=0 or 1,(i,j)\in A
\end{cases}\]</span></li>
</ol>
<h2 id="插值与拟合">插值与拟合</h2>
<p>若仅已知函数<span class="math inline">\(f(x)\)</span>在某区间<span class="math inline">\([a,b]\)</span>上一系列点上的值<span class="math inline">\(y_i=f(x_i),i=0,1,\dots,n\)</span>，当需要在这些节点间的x上的函数值时，有两种方法：插值法，拟合法，二者都是根据一组数据构造一个函数作为近似，由于近似的要求不同，二者在数学方法上完全不同，需要我们根据实际情况考虑</p>
<h3 id="插值方法">插值方法</h3>
<p>在工程和数学应用中，若在平面上给定一组离散点列，要求一条曲线，把这些点按次序连接起来，称为插值，若已知n+1点<span class="math inline">\((x_i,y_i)(i=0,1,...,n)\)</span>,下面详细介绍各种插值函数</p>
<h4 id="分段线性插值">分段线性插值</h4>
<p>简单来说，将每两个相邻的节点用直线连起来，如此形成的一条折线就是分段线性插值函数，记住<span class="math inline">\(I_n(x_i)=y_i\)</span>,且<span class="math inline">\(I_n(x)\)</span>在每个小区间<span class="math inline">\([x_i,x_{i+1}]\)</span>是线性函数<span class="math inline">\((i=0,1,...,n-1)\)</span> <span class="math inline">\(I_n(x)\)</span>可以表示<span class="math inline">\(I_n(x)=\sum_{i=0}^ny_il_i(x)\)</span>,其中 <span class="math display">\[l_i(x)=\begin{cases}
\frac{x-x_{i-1}}{x_i-x_{i-1}},x\in[x_{i-1},x_i],i\ne 0,\\
\frac{x-x_{i+1}}{x_i-x_{i+1}},x\in[x_i,x_{i+1}],i\ne n,\\
0,else\\
\end{cases}\]</span> <span class="math inline">\(l_n(x)\)</span>有良好的收敛性，即对于<span class="math inline">\(x\in[a,b]\)</span>,有<span class="math inline">\(\lim_{n \to \infty}I_n(x)=f(x)\)</span>,用<span class="math inline">\(I_n(x)\)</span>计算x点的插值时，只用到x左右的两个节点，计算量与节点个数n无关，但n越大，分段越多，插值误差越小</p>
<h4 id="拉格朗日插值多项式">拉格朗日插值多项式</h4>
<p>拉格朗日(Lagrange)插值的基函数为<span class="math display">\[l_i(x)=\frac{(x-x_0)...(x-x_{i-1})(x-x_{i+1})...(x-x_n)}{(x_i-x_0)...(x_i-x_{i-1})(x_i-x_{i+1})...(x_i-x_n)}\\
=\prod_{j=0,j\ne i}^n \frac{x-x_j}{x_i-x_j},i=0,1,...,n\\
l_i(x)是n次多项式，满足l_i(x_j)=\begin{cases}
0,j\ne i\\
1,j=i
\end{cases}\]</span> 综上，拉格朗日插值函数<span class="math display">\[L_n(x)=\sum_{i=0}^ny_il_i(x)=\sum_{i=0}^ny_i(\prod_{j=0,j\ne i}^n\frac{x-x_j}{x_i-x_j})\]</span></p>
<h4 id="样条插值">样条插值</h4>
<p>对于一些要求插值曲线具有较高的光滑程度，有连续曲率的数学物理问题，这时需要用样条插值</p>
<ol type="1">
<li>样条函数的概念 数学上将具有一定光滑性的分段多项式称为样条函数，具体地说，给定区间[a,b]的一个分划：<span class="math inline">\(\delta:a=x_0&lt;x_1&lt;\dots&lt;x_{n-1}&lt;x_n=b\)</span> 如果函数S(x)满足
<ol type="1">
<li>在每个小区间<span class="math inline">\([x_i,x_{i+1}](i=0,1,...,n-1)\)</span>上S(x)是m次多项式</li>
<li>S(x)在[a,b]上具有m-1阶连续导数 则称S(x)为关于分划<span class="math inline">\(\delta\)</span>的m次样条函数，其图形为m次样条曲线</li>
</ol></li>
<li>三次样条插值 利用样条函数进行插值，称为样条插值，三次样条插值函数就是把上面S(x)中的m=3,但是仅有这些条件是不足与确定所有待定参数，还需要额外的边界条件 常用的三次样条函数的边界条件有三种类型：
<ol type="1">
<li><span class="math inline">\(S&#39;(a)=y_0&#39;,S&#39;(b)=y_n&#39;\)</span>,有这种边界条件建立的样条插值函数称为<span class="math inline">\(f(x)\)</span>的完备三次样条插值函数，若<span class="math inline">\(f&#39;(x)\)</span>不知道，我们可以要求S'(x)与f'(x)在端点处近似相等，这时以<span class="math inline">\(x_0,x_1,x_2,x_3\)</span>为节点做一个三次Newton插值多项式,有这种边界条件建立的三次样条称为f(x)的Lagrange三次样条插值函数</li>
<li><span class="math inline">\(S&quot;(a)=y_0&quot;,S&quot;(b)=y_n&quot;,when y_0&quot;=y_n&quot;=0\)</span>,称为自然边界条件</li>
<li><span class="math inline">\(S&#39;(a+0)=S&#39;(b-0),S&quot;(a+0)=S&quot;(b-0)\)</span>,称为周期条件</li>
</ol></li>
</ol>
<h4 id="matlab插值工具箱">Matlab插值工具箱</h4>
<ol type="1">
<li>一维插值函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y=interp1(x0,y0,x,&#x27;method&#x27;)</span><br><span class="line">method 指定插值方法，默认为线性插值，其值可为</span><br><span class="line">&#x27;nearest&#x27; 最近项插值</span><br><span class="line">&#x27;linear&#x27; 线性插值</span><br><span class="line">&#x27;spline&#x27; 立方线条插值</span><br><span class="line">&#x27;cubic&#x27; 立方插值</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>三次样条插值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pp=csape(x0,y0,conds,valconds);y=fnval(pp,x);</span><br><span class="line">csape的返回值是pp形式，要求插值点函数值必须调用fnval，conds指定插值边界条件，valconds指定边界导数值</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p>二维插值 若节点是二维的，插值函数就是二元函数，即曲面</p>
<ol type="1">
<li>插值节点为网格节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z=interp2(x0,y0,z0,x,y,&#x27;method&#x27;)</span><br><span class="line">x0,y0分别为m,n维向量,表示节点,z0为n×m矩阵，表示节点值,x,y为一维数组，表示插值点，z表示得到的插值</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>插值节点为散乱节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZI=griddata(x,y,z,XI,YI)</span><br><span class="line">x,y,z指数据点横纵竖坐标,XI,YI给定的插值点横纵坐标,ZI网格(XI,YI)的函数值</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="曲线拟合的线性最小二乘法">曲线拟合的线性最小二乘法</h3>
<h4 id="线性最小二乘法">线性最小二乘法</h4>
<p>曲线拟合：已知一组(二维)数据，即平面上n个点<span class="math inline">\((x_i,y_i),i=1,2,...,n,x_i\)</span>互不相同，寻求一个函数(曲线)<span class="math inline">\(y=f(x)\)</span>,使<span class="math inline">\(f(x)\)</span>在某种准则下雨所有数据点最为接近，即曲线拟合的最好。</p>
<p>线性最小二乘法是解决曲线拟合最常用的方法，基本思路是，令<span class="math inline">\(f(x)=a_1r_1(x)+a_2r_2(x)+\dots+a_mr_m(x)\)</span>,式中:<span class="math inline">\(r_k(x)\)</span>为事先选定好的一组线性无关的函数，<span class="math inline">\(a_k\)</span>为待定系数<span class="math inline">\((k=1,2,...,m&lt;n)\)</span></p>
<p>拟合准则是使<span class="math inline">\(y_i(i=1,2,...,n)\)</span>与<span class="math inline">\(f(x_i)\)</span>的距离<span class="math inline">\(\delta_i\)</span>的平方和最小，称为最小二乘准则</p>
<h4 id="最小二乘法的matlab实现">最小二乘法的Matlab实现</h4>
<ol type="1">
<li>解方程组方法</li>
<li>多项式拟合法</li>
</ol>
<h3 id="最小二乘优化">最小二乘优化</h3>
<p>在无约束优化问题中，有些重要的特殊情形，比如目标函数有若干个函数的平方和构成，这类函数可以写成<span class="math inline">\(F(x)=\sum_{i=1}^mf_i^2(x),x\in R^n,x=[x_1,...,x_n]^T,m\ge n\)</span> 把极小化这类函数的问题<span class="math inline">\(min F(x)=\sum_{i=1}^mf_i^2(x)\)</span>称为最小二乘优化问题 matlab也提供一些函数优化此问题,有lsqlin,leqcurvefit,leqnonlin,lsqnonneg,也可以直接调用工具箱里命令cftool,该命令给出一维数据拟合的交互式环境</p>
<h3 id="曲线拟合和函数逼近">曲线拟合和函数逼近</h3>
<p>曲线拟合是指已知一组离散数据<span class="math inline">\({(x_i,y_i),i=1,...,n}\)</span>，选择一个较简单的函数<span class="math inline">\(f(x)\)</span>(如多项式),在一定准则(如最小二乘准则)下，最接近这些数据 如果已知一个较为复杂的连续函数<span class="math inline">\(y(x),x\in[a,b]\)</span>,要求选择一个较简单的函数<span class="math inline">\(f(x)\)</span>,在一定准则下最接近<span class="math inline">\(y(x)\)</span>，就是函数逼近 与曲线拟合的最小二乘准则对应，函数逼近常用的一种准则是最小平方逼近，即<span class="math inline">\(J=\int_{a}^{b} [f(x)-y(x)]^2\, {\rm d}x\)</span>达到最小，与曲线拟合一样，选一组函数构造<span class="math inline">\(f(x)\)</span>,代入使J达到最小</p>
<h2 id="微分方程建模感觉不太重要">微分方程建模(感觉不太重要)</h2>
<p>对于生活中的实际问题，我们往往需要将其化为微分方程的定解问题来求解，大致可分为以下几步：</p>
<ol type="1">
<li>根据实际要求要求确定要研究的量(自变量，未知函数，必要的参数)并确定坐标系</li>
<li>找出这些量所满足的基本规律(物理的，几何的，化学的或生物的等)</li>
<li>运用这些规律列出方程和定解条件 列方程常见方法：
<ul>
<li>按规律直接列方程</li>
<li>微元分析法与任意区域取积分方法</li>
<li>模拟近似法</li>
</ul></li>
</ol>
<h3 id="matlab求微分方程的符号解">Matlab求微分方程的符号解</h3>
<p>用matlab求解常微分方程的符号解，首先定义符号向量，然后调用命令dsolve，dsolve调用格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y1,...,yN]=dsolve(eqns,conds,Name,Value)</span><br><span class="line">eqns符号微分方程(组)，conds，初值条件或边值条件，Name,Value可选的成对参数</span><br></pre></td></tr></table></figure>
<h2 id="数理统计感觉不太重要">数理统计(感觉不太重要)</h2>
<p>数理统计研究对象主要是受随机因素影响的数据，面对一批数据进行分析建模，首先要掌握参数估计和假设检验这两个数理统计中最基本方法，给定数据符合一定分布要求后，才能建立回归分析和方差分析等数学模型</p>
<h2 id="时间序列">时间序列</h2>
<h3 id="简介">简介</h3>
<p>将预测对象按照时间顺序排列起来，构成一个所谓的时间序列，从所构成的这一组时间序列过去的变化规律，推断今后变化的可能性及变化趋势，变化规律，就是时间序列预测法</p>
<p>时间序列法其实也是一种回归模型，其基于原理是：一方面承认事物发展的延续性，运用过去时间序列的数据进行统计分析就能推测事物发展趋势，另一方面又充分考虑到偶然因素影响产生的随机性</p>
<p>其<strong>优点</strong>是简单易行，便于掌握，能充分运用原时间序列的各项数据，计算速度快，对模型参数有动态确定能力，精度较好，采用组合的时间序列或将时间序列和其他模型组合效果更好</p>
<p>其<strong>缺点</strong>是不能反映事物内在联系，不能分析两个因素间相关关系，只适用于短期预测</p>
<h3 id="确定性时间序列分析方法">确定性时间序列分析方法</h3>
<p>时间序列预测技术就是通过对预测目标自身时间序列的处理，来研究其变化趋势，一个时间序列往往是一下几类变化形式的叠加或耦合</p>
<ol type="1">
<li>长期趋势变动，他指时间序列朝着一定的方向持续上升或下降，或停留在某一水平上的倾向，反映了客观事物的主要变化趋势。</li>
<li>季节变动</li>
<li>循环变动，通常是周期为一年以上，由非季节因素引起的涨落起伏波形相似的波动</li>
<li>不规则变动，通常分为突然变动和随机变动</li>
</ol>
<p>通常用<span class="math inline">\(T_t\)</span>表示长期趋势项，<span class="math inline">\(S_t\)</span>表示季节变动趋势项，<span class="math inline">\(C_t\)</span>表示循环变动趋势项，<span class="math inline">\(R_t\)</span>表示随机干扰项，常见确定性时间序列模型类型如下 1. 加法模型： <span class="math inline">\(y_t=T_t+S_t+C_t+R_t\)</span> 2. 乘法模型： <span class="math inline">\(y_t=T_t\cdot S_t\cdot C_t\cdot R_t\)</span> 3. 混合模型： <span class="math display">\[y_t=T_t\cdot S_t+R_t\\
   y_t=S_t+T_t\cdot R_t\]</span> <span class="math inline">\(y_t\)</span>为观测目标的观测记录，均值<span class="math inline">\(E(R_t)=0\)</span>,方差<span class="math inline">\(Var(R_t)=\sigma^2\)</span> 如果在预测时间范围以内，无突然变动且随机变动的方差较小，且有理由认为过去和现在的演变趋势将继续发展到未来时，可用一些经验方法进行预测</p>
<h4 id="移动平均法">移动平均法</h4>
<p>设观测序列为<span class="math inline">\(y_1,...,y_T\)</span>,取移动平均的项数N&lt;T,一次移动平均值计算公式为： <span class="math display">\[M_t^{(1)}=\frac{1}{N}(y_t+y_{t-1}+\dots+y_{t-N+1})\\=\frac{1}{N}(y_{t-1}+\dots+y_{t_N})+\frac{1}{N}(y_t-y_{t-N})=M_{t-1}^{(1)}+\frac{1}{N}(y_t-y_{t-N})\]</span></p>
<p>二次移动平均值计算公式为 <span class="math display">\[M_t^{(2)}=\frac{1}{N}(M_t^{(1)}+\dots+M_{t-N+1}^{(1)})=M_{t-1}^{(2)}+\frac{1}{N}(M_t^{(1)}-M_{t-N}^{(1)})\]</span> 当预测目标的基本趋势是在某一水平上下波动时，可用一次移动平均方法建立预测模型,即 <span class="math display">\[\hat{y_{t+1} }=M_t^{(1)}=\frac{1}{N}(y_t+\dots+y_{t-N+1}),t=N,N+1,\dots,T\]</span> 其预测标准误差为<span class="math display">\[S=\sqrt{\frac{\sum_{t=N+1}^T(\hat{y_t}-y_t)^2}{T-N}}\]</span></p>
<p>最近N期序列值的平均值作为未来各期的预测结果，一般N取值为:<span class="math inline">\(5\le N\le 200\)</span>,当历史序列的基本趋势变化不大且序列中随机变动成分较多时，N的取值应较大一些,否则N的取值应小一些，在有确定的季节变动周期资料中，移动平均的项数应取周期长度，选择最佳N值的一个有效方法是编辑若干模型的预测误差，预测误差最小值为好</p>
<p>当预测目标基本趋势和某一线性模型吻合时，常用二次移动平均法，但序列同时存在线性趋势和周期波动时，可用趋势移动平均法建立预测模型： <span class="math inline">\(\hat{y_{T+m}}=a_T+b_Tm,m=1,2,\dots\)</span>,式中 <span class="math inline">\(a_T=2M_T^{(1)}-M_T^{(2)};b_T=\frac{2}{N-1}(M_T^{(1)}-M_T^{(2)})\)</span></p>
<h4 id="指数平滑法">指数平滑法</h4>
<p>一般来说历史数据对未来值的影响是随时间间隔增长而递减的，而上述移动平均法的权数都是两端项权数小，中间项权数大，不符合上诉规律，更好的方法是对各期观测值依时间顺序进行加权平均作为预测值，<strong>指数平滑法</strong>就满足这一要求，且具有简单递推形式</p>
<p>指数平滑法根据平滑次数的的不同，又分为一次指数平滑法，二次指数平滑法，和三次指数平滑法等</p>
<p><strong>一次指数平滑法</strong> 1. 预测模型</p>
<p>设时间序列为<span class="math inline">\(y_1,y_2,...,y_t,...,\alpha\)</span>为加权系数,<span class="math inline">\(0&lt;\alpha&lt;1\)</span>,一次指数平滑公式为: <span class="math inline">\(S_t^{(1)}=\alpha y_t+(1-\alpha)S_{t-1}^{(1)}=S_{t-1}^{(1)}+\alpha(y_t-S_{t-1}^{(1)})\)</span> 以这种平滑值进行预测，就是一次指数平滑法，预测模型为<span class="math inline">\(\hat{y_{t+1}}=S_t^{(1)}=\alpha y_t+(1-\alpha)\hat{y_t}\)</span></p>
<ol start="2" type="1">
<li><p>加权系数的选择</p>
<p>加权系数<span class="math inline">\(\alpha\)</span>的大小决定了在新预测值中新数据和原预测值所占的比重，<span class="math inline">\(\alpha\)</span>越大，新数据所占比重越大，原预测值所占比重越小，也可将上式改为<span class="math inline">\(\hat{t_{t+1}}=\hat{y_t}+\alpha(y_t-\hat{y_t})\)</span></p>
<p>这可看出新预测值是根据预测误差对原预测值进行修正得到的，<span class="math inline">\(\alpha\)</span>越大，修正幅度越大 其选取规则如下：</p>
<ul>
<li>如果时间序列波动不大，比较平稳，则α可取小一点以减少修正幅度，使预测模型能包含较长时间序列的信息</li>
<li>如果时间序列具有迅速且明显的变动倾向，则α应取大一点，使预测模型灵敏度高一些，以便迅速跟上数据的变化</li>
</ul></li>
<li><p>初始值的确定</p>
<p>用一次平滑法预测，除了选择合适的<span class="math inline">\(\alpha\)</span>，还要确定初始值<span class="math inline">\(s_0^{(1)}\)</span>,初始值是预测者估计指定的</p></li>
</ol>
<p><strong>二次指数平滑法</strong> 一次指数平滑法虽然克服了移动平均法的缺点，但当时间序列变动出现直线趋势时，用该方法预测由明显滞后偏差，应用二次指数平滑，用滞后偏差的规律建立直线趋势模型，计算公式如下 <span class="math inline">\(\begin{cases} S_t^{(1)}=\alpha y_t+(1-\alpha)S_{t-1}^{(1)}\\ S_t^{(2)}=\alpha S_t^{(1)}+(1-\alpha)S_{t-1}^{(2)} \end{cases}\)</span> 式中：<span class="math inline">\(S_t^{(1)}\)</span>为一次指数的平滑值，<span class="math inline">\(S_t^{(2)}\)</span>为二次平滑函数的平滑值</p>
<p>当时间序列<span class="math inline">\({y_t}\)</span>从某时期开始具有直线趋势，可用直线趋势模型 <span class="math inline">\(\hat{y_{t+m}}=a_t+b_tm,m=1,2,\dots,\)</span> <span class="math inline">\(\begin{cases}  a_t=2S_t^{(1)}-S_t^{(2)},\\  b_t=\frac{\alpha}{1-\alpha}(S_t^{(1)}-S_t^{(2)}) \end{cases}\)</span>进行预测</p>
<p><strong>三次指数平滑法</strong> 当时间序列的变动表现为二次曲线趋势，需要用三次指数平滑法，其在二次指数平滑基础上，再进行一次平滑，计算公式为 <span class="math inline">\(\begin{cases}  S_t^{(1)}=\alpha y_t+(1-\alpha)S_{t-1}^{(1)}\\  S_t^{(2)}=\alpha S_t^{(1)}+(1-\alpha)S_{t-1}^{(2)}\\  S_t^{(3)}=\alpha S_t^{(2)}+(1-\alpha)S_{t-1}^{(3)} \end{cases}\)</span> <span class="math inline">\(S_t^{(3)}\)</span>为三次指数平滑值</p>
<p>其预测模型为: <span class="math inline">\(\hat{y_{t+m}}=a_t+b_tm+C_tm^2,m=1,2,\dots,\)</span> <span class="math inline">\(\begin{cases}  a_t=3S_t^{(1)}-3S_t^{(2)}+S_t^{(3)},\\  b_t=\frac{\alpha}{2(1-\alpha)^2}((6-5\alpha)S_t^{(1)}-2(5-4\alpha)S_t^{(2)}+(4-3\alpha)S_t^{(3)})\\  c_t=\frac{\alpha^2}{2(1-\alpha)^2}(S_t^{(1)}-2S_t^{(2)}+S_t^{(3)}) \end{cases}\)</span></p>
<h4 id="差分指数平滑法">差分指数平滑法</h4>
<p>我们也可以从数据变换角度解决一次指数平滑法的滞后偏差问题，差分方法就是改变数据变动趋势的简易方法</p>
<p>下面以一阶差分指数平滑法为例，其公式如下 <span class="math inline">\(\nabla y_t=y_t-y_{t-1} \\ \nabla \hat{y_{t+1}}=\alpha \nabla y_t+(1-\alpha)\nabla\hat{y_t} \\\hat{y_{t+1}}=\nabla\hat{y_{t+1}}+y_t,\nabla\)</span>为差分记号</p>
<h4 id="具有季节性特点的时间序列的预测">具有季节性特点的时间序列的预测</h4>
<p>对于季节性时间序列的预测，要在数学上完全拟合其变化曲线是非常困难的，但预测的目的是为了找到时间序列的变化趋势，尽可能的做到精确，下面介绍季节系数法，计算步骤如下 1. 收集m年的每年各季度或各月份的时间序列样本数据<span class="math inline">\(a_{ij}\)</span>,i表示年份序号，j表示季度(月份)序号 2. 计算每年所有季度或月份算术平均值<span class="math inline">\(\bar{a}=\frac{1}{k}\sum_{i=1}^m\sum_{j=1}^n a_{ij},k=mn\)</span> 3. 计算同季度或同月份数据的算术平均值<span class="math inline">\(\bar{a_{.j}}=\frac{1}{m}\sum_{i=1}^ma_{ij}\)</span> 4. 计算季度(月份)系数<span class="math inline">\(b_j=\frac{\bar{a_{.j}}}{\bar{a}}\)</span> 5. 预测计算，当时间序列按季度列出，先求出预测年份(下一年)的年加权平均<span class="math inline">\(y_{m+1}=\frac{\sum_{i=1}^mw_iy_j}{\sum_{i=1}^mw_i}  \\y_i=\sum_{j=1}^na_{ij}\)</span>为第i年年合计数，<span class="math inline">\(w_i\)</span>为第i年权数,<span class="math inline">\(w_i=i\)</span>,再计算预测年份的季度平均值<span class="math inline">\(\bar{y_{m+1}}=y_{m+1}/n\)</span>,最后预测年份第j季度的预测值为<span class="math inline">\(y_{m+1,j}=b_j\bar{y_{m+1}}\)</span></p>
<h3 id="平稳时间序列模型">平稳时间序列模型</h3>
<p>这里的平稳指的是宽平稳，其特性是序列的统计特性不随时间Pinyin而变化，即均值和协方差不随时间平移而变化</p>
<h4 id="时间序列的基本概念">时间序列的基本概念</h4>
<p><em>平稳序列</em>:设随机序列<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>满足 - <span class="math inline">\(E(X_t)=\mu\)</span>=常数 - <span class="math inline">\(\gamma_{t+k,t}=\gamma_k(k=0,\pm1,\pm2,...)\)</span>与t无关，则称<span class="math inline">\(X_t\)</span>为平稳随机序列,坚持平稳序列</p>
<p><em>平稳白噪声序列</em>:设平稳序列<span class="math inline">\({\epsilon_t,t=0,\pm1,\pm2,...}\)</span>的自协方差函数为<span class="math inline">\(\gamma_k=\sigma^2\delta_{k,0}=\begin{cases}  0,k\ne0\\  \sigma^2,k=0 \end{cases}\)</span> 则称该序列为平稳白噪声序列</p>
<p><em>偏相关函数</em>:考虑由<span class="math inline">\({X_{t-1},X_{t-2},...,X_{t-k}}\)</span>对<span class="math inline">\(X_t\)</span>的线性最小均方估计，即选择系数<span class="math inline">\(\psi_{k,1},\psi_{k,2},...,\psi_{k,k}\)</span>,使得<span class="math inline">\(min\quad\delta=E[(X_t-\sum_{j=1}^k\psi_{k,j}X_{t-j})^2]\)</span>,<span class="math inline">\({\psi_{k,k},k=1,2,\dots}\)</span>称为<span class="math inline">\(X_t\)</span>的偏相关函数</p>
<p><em>ARMA时间序列</em>:ARMA时间序列可以分为三种类型 1. AR序列，即自回归序列(Auto Regressive Model) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为零均值平稳序列，满足下列模型 <span class="math inline">\(X_t=\psi_1 X_{t-1}+\psi_2 X_{t-2}+\dots+\psi_p X_{t-p}+\epsilon_t\)</span> <span class="math inline">\(\epsilon_t\)</span>为零均值，方差为<span class="math inline">\(\delta_\epsilon^2\)</span>的平稳白噪声，<span class="math inline">\(X_t\)</span>为阶数为p的自回归序列，简称AR(p)序列，<span class="math inline">\(\psi=[\psi_1,\psi_2,...,\psi_p]^T\)</span>为自回归参数向量,其分量为自回归系数 引入后移算子B辅助定义，算子B定义<span class="math inline">\(BX_t\equiv X_{t-1},B^kX_t\equiv X_{t-k}\)</span> 记算子多项式<span class="math inline">\(\psi(B)=1-\psi_1B-\psi_2B^2-...-\psi_pB^p\)</span> 则AR序列可改写为<span class="math inline">\(\psi(B)X_t=\epsilon_t\)</span></p>
<ol start="2" type="1">
<li><p>MA序列，即移动平均序列(Moving Average Model) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为零均值平稳序列，满足下列模型 <span class="math inline">\(X_t=\epsilon_t-\theta_1 \epsilon_{t-1}-\dots-\theta_q \epsilon_{t-q}\)</span> <span class="math inline">\(\epsilon_t\)</span>为零均值，方差为<span class="math inline">\(\delta_\epsilon^2\)</span>的平稳白噪声，<span class="math inline">\(X_t\)</span>为阶数为q的移动平均序列，简称MA(q)序列，<span class="math inline">\(\theta=[\theta_1,\theta_2,...,\theta_p]^T\)</span>为移动平均参数向量,其分量为移动平均系数，引入线性后移算子B，再定义一个和上面类似多项式,则可MA序列改写为<span class="math inline">\(X_t=\theta(B)\epsilon_t\)</span></p></li>
<li><p>ARMA序列，即自回归移动平均序列(Auto Regressive Moving Model) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为零均值平稳序列，满足下列模型 <span class="math inline">\(X_t-\psi_1 X_{t-1}-\psi_2 X_{t-2}-\dots-\psi_p X_{t-p}=\epsilon_t-\theta_1 \epsilon_{t-1}-\dots-\theta_q \epsilon_{t-q}\)</span> <span class="math inline">\(\epsilon_t\)</span>为零均值，方差为<span class="math inline">\(\delta_\epsilon^2\)</span>的平稳白噪声，<span class="math inline">\(X_t\)</span>为阶数为p,q的移动平均序列，简称ARMA(p,q)序列,利用后移算子可表为<span class="math inline">\(\psi(B)(X_t-\mu)-\theta(B)\epsilon_t\)</span></p>
<p>对于算子多项式<span class="math inline">\(\psi(B),\theta(B)\)</span>通常还要做下列假定</p>
<ol type="1">
<li>二者无公共因子，且<span class="math inline">\(\psi_p\ne0,\theta_q\ne0\)</span></li>
<li><span class="math inline">\(\psi(B)=0\)</span>的根全在单位圆外，称为模型平稳性条件</li>
<li><span class="math inline">\(\theta(B)=0\)</span>的根全在单位圆外，称为模型可逆性条件</li>
</ol></li>
</ol>
<h4 id="arma模型的构建和预报">ARMA模型的构建和预报</h4>
<p>在实际问题建模中，首先要进行模型的识别和定阶，即要判断AR(p),MA(q),ARMA(p,q)模型的类别，并估计阶数p,q，其实都归结到模型的定阶问题，当模型定阶后，就要对模型参数<span class="math inline">\(\psi,\theta\)</span>进行估计，完成后还需要对模型进行检验，检验<span class="math inline">\(\epsilon_t\)</span>是否为平稳白噪声</p>
<ol type="1">
<li>ARMA模型的构建
<ul>
<li>ARMA模型定阶的AIC准则：选p,q使<span class="math inline">\(min \quad AIC-nln\hat{\delta_\epsilon^2}+2(p+q+1)\)</span>,若序列含未知均值参数，修正为2(p+q+2)</li>
<li>ARMA模型的参数估计：直接用Matalb工具箱即可</li>
<li>ARMA模型检验的<span class="math inline">\(\chi^2\)</span>检验：给定显著性水平<span class="math inline">\(\alpha\)</span>，查表得上<span class="math inline">\(\alpha\)</span>分位数<span class="math inline">\(\chi_{\alpha}^2(L-r)\)</span>,当<span class="math inline">\(\chi^2&gt;chi_{\alpha}^2(L)\)</span>认为模型检验未通过</li>
</ul></li>
<li>ARMA序列的预报 时间序列的m步预报，是根据<span class="math inline">\({X_k,X_{k-1},...}\)</span>的取值对未来k+m时刻的随机变量<span class="math inline">\(X_{k+m}(m&gt;0)\)</span>做出估计，估计量记作<span class="math inline">\(\hat{X_k}(m)\)</span>，是<span class="math inline">\({X_k,X_{k-1},...}\)</span>的线性组合
<ul>
<li>AR(p)序列的预报:<span class="math inline">\(\begin{cases}  \hat{X_k(1)}=\psi_1X_k+\psi_2X_{k-1}+\dots+\psi_pX_{k-p+1}\\  \hat{X_k(2)}=\psi_1X_k(1)+\psi_2X_{k}+\dots+\psi_pX_{k-p+2}\\  ...\\  \hat{X_k(p)}=\psi_1X_k(p-1)+\psi_2X_{k}(p-2)+\dots+\psi_pX_{k}\\  \hat{X_k(m)}=\psi_1X_k(m-1)+\psi_2X_{k}(m-2)+\dots+\psi_p\hat{X_k(m-p)},m&gt;p\\ \end{cases}\)</span> 由此可见<span class="math inline">\(\hat{X_K}(m)(m\ge1)\)</span>仅依赖于<span class="math inline">\(X_t\)</span>的k时刻以前的p个时刻的值<span class="math inline">\(X_K,X_{k-1},\dots,X_{k-p+1}\)</span>,这是AR(p)序列预报的特点</li>
<li>MA(q)和ARMA(p,q)序列的预报 MA(q)序列 <span class="math inline">\(\hat{X_{k+1}^{(q)}}=\begin{bmatrix}  \theta_1 &amp;1&amp;0&amp;\cdots&amp;0\\  \theta_2 &amp;0&amp;1&amp;\cdots&amp;0\\  \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\  \theta_{q-1} &amp;0&amp;0&amp;\cdots&amp;1\\  \theta_q &amp;0&amp;0&amp;\cdots&amp;0\\ \end{bmatrix}\hat{X_{k}^{(q)}}-\begin{bmatrix} \theta_1\\ \theta_2\\ \vdots\\ \theta_1 \end{bmatrix}X_{k+1}\)</span> 递推初值可取<span class="math inline">\(\hat{X_{k_0}^{(q)}}=0(k_0)\)</span>较小，因为模型可逆性保证递推式渐进稳定，即当n充分大后，初始误差影响可以逐渐消失 ARMA(p,q)序列 <span class="math display">\[\hat{X_{k+1}^{(q)}}=\begin{bmatrix}
 -G_1 &amp;1&amp;0&amp;\cdots&amp;0\\
 -G_2 &amp;0&amp;1&amp;\cdots&amp;0\\
 \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
 -G_{q-1} &amp;0&amp;0&amp;\cdots&amp;1\\
 -G_q+\psi_q^* &amp;\psi_{q-1}^* &amp;\psi_{q-2}^*&amp;\cdots&amp;\psi_1^*\\
\end{bmatrix}\hat{X_{k}^{(q)}}\\+\begin{bmatrix}
G_1\\
G_2\\
\vdots\\
G_q\\
\end{bmatrix}X_{k+1}+\begin{bmatrix}
0\\
0\\
\vdots\\
0\\
\sum_{j=q+1}^p\psi_j^*X_{k+q+1-j}\\
\end{bmatrix},G_j:X_t=\sum_{j=0}^∞G_j\epsilon_{t-j}\]</span> 实际中，模型参数是未知的，若已建立了时间序列的模型，则理论模型的未知参数可用其估计替代，再用上面介绍的方法预报</li>
</ul></li>
</ol>
<h3 id="时间序列的matlab相关工具箱及命令">时间序列的Matlab相关工具箱及命令</h3>
<p>Matlab时间序列的相关指令在系统辨识，计量经济学，金融工具箱内</p>
<h3 id="arima序列与季节性序列">ARIMA序列与季节性序列</h3>
<p>在实践中遇到的时间序列往往有三个特性，趋势性，季节性，非平稳性，一般采用差分方法或其他时间序列变化方法消除趋势性季节性，使变换后序列为平稳序列，并假设为ARMA序列，再用上面介绍方法研究。</p>
<h4 id="arima序列及其预报">ARIMA序列及其预报</h4>
<p>对于非平稳序列，可借助差分运算使其平稳化，若<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>为非平稳序列，若存在正整数d，使<span class="math inline">\(\nabla^dX_t=W_t\)</span>，且<span class="math inline">\({W_t,t=0,\pm1,\pm2,...}\)</span>是ARMA(p,q)序列，称<span class="math inline">\(X_t\)</span>为ARIMA(p,d,q)序列</p>
<p>ARIMA序列的预报(d=1,d=2) 设<span class="math inline">\({X_t,t=0,\pm1,\pm2,...}\)</span>是ARIMA(p,d,q)序列 1. <span class="math inline">\(d=1,\nabla X_t=W_t \to\hat{X_k(m)}=\hat{X_k}(m-1)+\hat{W_k}(m)=X_k+\sum_{j=1}^m\hat{W_k}(j)\)</span> 2. <span class="math inline">\(d=2,\nabla^2 X_t=\hat{W_k}(m) \to\hat{X_k(m)}=X_k+\sum_{j=1}^m\hat{W_k}(j)(m+1-j)+m(X_k-X_{k-1})\)</span></p>
<h4 id="季节性序列及其预报">季节性序列及其预报</h4>
<p>由季节性因素或其他周期因素引起的周期性变化的时间序列，称为季节性时间序列，相应的模型为季节性模型，一般的，对周期为s的序列，先进行差分运算<span class="math inline">\(\nabla_sX_t=(1-B^s)X_t,\\\nabla_s^d=(1-B^s)^dX_t\)</span>,然后再进行ARIMA建模</p>
<h2 id="支持向量机">支持向量机</h2>
<p>支持向量机是数据挖掘中一项新技术，借助最优化方法解决机器学习问题的新工具，在模式识别等领域获得了广泛应用，其主要思想是找到一个超平面，使得它能够尽可能多地将两类数据点正确分开，同时使分开的两类数据点距离分类面最远</p>
<h3 id="支持向量分类机的基本原理">支持向量分类机的基本原理</h3>
<p>根据给定的训练集，<span class="math inline">\(T={[a_1,y_1],[a_2,y_2],\dots,[a_t,y_t]}\in(\Omega\times Y)^l\)</span>,<span class="math inline">\(a_i\in\Omega=R^n,\Omega\)</span>为输入空间，输入空间的每一个点<span class="math inline">\(a_i\)</span>由n个属性特征组成，<span class="math inline">\(y_i\in Y={-1,1},i=1,\dots,l\)</span> 寻找<span class="math inline">\(R^n\)</span>上的一个实值函数<span class="math inline">\(g(x)\)</span>,以便用分类函数<span class="math inline">\(f(x)=sgn(g(x))\)</span>推断任意一个模式x所对应的y值的问题为分类问题</p>
<h4 id="线性可分支持向量分类机">线性可分支持向量分类机</h4>
<p>考虑训练集T,若<span class="math inline">\(\exists \omega\in R^n,b\in R,\epsilon(&gt;0)\)</span>，使得对所有使<span class="math inline">\(y_i=1\)</span>的<span class="math inline">\(a_i\)</span>有<span class="math inline">\((\omega\cdots a_i)+b\ge\epsilon\)</span>,这里<span class="math inline">\((\omega\cdots a_i)\)</span>表示向量<span class="math inline">\(\omega,a_i\)</span>的内积，而对所有使<span class="math inline">\(y_i=-1\)</span>的<span class="math inline">\(a_i\)</span>有<span class="math inline">\((\omega\cdots a_i)+b\le-\epsilon\)</span>,则称训练集T线性可分，称相应的分类问题是线性可分的</p>
<p><em>规范超平面</em>：空间<span class="math inline">\(R^n\)</span>中超平面都可以写为<span class="math inline">\((\omega\cdot x)+b=0\)</span>的形式，参数<span class="math inline">\((w,b)\)</span>乘以任何一个非零参数后得到的是同一个超平面，定义满足条件<span class="math inline">\(\begin{cases}y_i[(\omega\cdot a_i+b)]\ge 0,\\min_{i=1,...,l}|(\omega\cdot a_i)+b|=1,i=1,...,l\\\end{cases}\)</span>的超平面为训练集T的规范超平面，</p>
<p><strong>当训练集T为线性可分时，存在唯一的规范超平面<span class="math inline">\((\omega\cdot x)+b=0\)</span>,使得<span class="math inline">\(\begin{cases}(\omega\cdot a_i)+b\ge 1,y_i=1\\(\omega\cdot a_i)+b\le -1,y_i=-1 \end{cases}\)</span>，其中=正负1的被称为普通支持向量</strong></p>
<p>支持向量机一般又可分为以下几类 - 线性支持向量机：除了普通支持向量分布在两个边界，其余的所有样本点分布在分类边界以外，这是构造的超平面是<strong>硬间隔超平面</strong>，若存在样本点在边界之间，需要进行软化处理，这是获得的就是<strong>软间隔超平面</strong>，软化方法就是加入一个调节因子</p>
<ul>
<li><p>非线性可分支持向量机：当两个凸包重合太大了，也就是软化的方法不适用的时候，采用映射的方法，换到另外一个高维空间域里进行分类。通过引进从输入空间 X 到另一个高维的 Hilbert 空间 H 的变换，空间H叫做特征空间。</p></li>
<li><p>C-支持向量机（非线性不可分）：映射到高维H空间之后还是不能直接可分，在H空间进行软化再分类。</p></li>
</ul>
<p>该模型主要是利用图像学原理，通过对凸包的研究把求超平面的问题转化成求约束下的优化问题，从而利用拉格朗日算子和KTT条件来求解。</p>
<h3 id="支持向量机的matlab命令">支持向量机的Matlab命令</h3>
<p>Matlab支持向量机的命令有，训练支持向量机分类器的函数svmtrain,使用支持向量机分类的函数svmclassify,指定支持向量机函数使用的序列最小化参数函数svmsmoset</p>
<h2 id="多元分析">多元分析</h2>
<p>多元分析是多变量的统计分析方法，是数理统计中应用广泛的一个重要分支</p>
<h3 id="聚类分析">聚类分析</h3>
<p>将认识对象进行分类是人类认识世界的一种重要方法，聚类分析作为一种定量方法，可以从数据分析的角度，给出一个更精确，细致的分类工具，聚类分析又被称为群分析，是对多个样本(或指标)进行定量分类的一种多元统计分析方法，对样本进行分类称为<strong>Q型聚类分析</strong>，对指标进行分类称为<strong>R型聚类分析</strong></p>
<h4 id="q型聚类分析">Q型聚类分析</h4>
<ol type="1">
<li><p>样本的相似性度量 要用数量化方法对事物进行分类，就必须用数量化方法描述事物之间的相似程度，对每个样本点的相似程度，一般利用距离来衡量，在这里距离的选择有很多种，最常用的是<strong>闵氏距离</strong>，绝对值距离，欧几里得距离，切比雪夫距离都是其的一些特例，其中最常用的还是<strong>欧几里得距离</strong>，其主要优点是当坐标轴进行正交旋转时，欧氏距离是保持不变的，因此，若对原坐标系进行平移和旋转变换，则变换后样本点的距离和变换前完全相同，闵氏距离也有一些缺点，<strong>需要量纲一致，需要避免变量的多重相关性</strong> 针对其缺点，马氏距离做出了相应的改进</p></li>
<li><p>类与类间的相似性度量 度量方法如下：</p>
<ul>
<li>最短距离法</li>
<li>最长距离法</li>
<li>重心法</li>
<li>类平均法</li>
<li>离差平方和法</li>
</ul></li>
<li><p>聚类图 Q型聚类结果可由一个聚类图表示出来，生成步骤如下</p>
<ol type="1">
<li>计算n个样本点两两之间的距离<span class="math inline">\({d_{ij}}\)</span>,记为矩阵<span class="math inline">\(D=(d_{ij})_{n\times n}\)</span></li>
<li>首先构造n个类，每一个类只包含一个样本点，每一类的平台高度均为0</li>
<li>合并距离最近的两类为新类，并且以这两类的距离值作为聚类图的平台高度</li>
<li>计算新类与当前各类的距离，若类的个数已经等于1，转入步骤5，否则回到步骤3</li>
<li>画聚类图</li>
<li>决定类的个数和类</li>
</ol></li>
<li><p>Matlab聚类分析的相关指令 pdist,linkage,cluster,zsore,dendrogram,clusterdata</p></li>
</ol>
<h4 id="r型聚类法">R型聚类法</h4>
<p>在实际工作中，变量聚类法的应用非常重要，人们希望能研究变量间的相似关系，按照变量的相似关系把它们聚合成若干个类，进而找出影响系统的主要因素 1. 变量相似性度量 在对变量进行聚类分析时，首先要确定变量的相似性度量，常用的变量相似性度量有<strong>相关系数</strong>和<strong>夹角余弦</strong> 各种定义的相似度量均需具有以下两个性质 1. <span class="math inline">\(|r_{jk}\le 1|,r_{jk}=r_{kj}\)</span>，越接近1，二者越相关，越接近0，相似性越弱 2. 变量聚类法 类似系统聚类法，在变量聚类中常用的是最长距离法和最短距离法</p>
<h3 id="主成分分析">主成分分析</h3>
<p>主成分分析的主要目的是希望用较少的变量去解释原来资料中大部分变异，通常是选出比元素变量个数少，能解释大部分资料中变异的几个新变量，即所谓的主成分，并用以解释资料的综合性指标，本质上是一种<strong>降维方法</strong></p>
<h4 id="分析步骤">分析步骤</h4>
<ol type="1">
<li>构建初始数据矩阵：矩阵的每一行表示一个样本，每一列表示一个原始指标，矩阵中每一个元素表示某一个样本在某一个指标下的得分</li>
<li>计算相关系数矩阵：对初始数据矩阵中的各个指标，求出相关系数矩阵</li>
<li>计算特征值和特征向量：计算样本相关系数矩阵的特征值和特征向量，计算完成和对特征值进行从大到小的排序</li>
<li>计算主成分贡献率和累积贡献率：每一个特征值对应一个主成分和贡献率，某特征值的贡献率=该特征值/所有特征值的和，该特征值对应的主成分即为对应的特征向量</li>
<li>选择保留的主成分：一般取累积贡献率超过80%的那些主成分作为最终结果，特征值对应的特征向量即为主成分的系数</li>
<li>利用系数分析主成分代表的含义</li>
<li>利用主成分进行后续的分析过程</li>
</ol>
<h4 id="不足与注意事项">不足与注意事项</h4>
<p><strong>不足</strong>：主成分的含义解释一般都带有一些模糊性，不像原始变量那样清楚确切，这是变量降维过程中必须付出的代价，只有当主成分个数远小于原始变量的个数才使用主成分分析</p>
<p><strong>注意事项</strong>： 在评价类模型中，不能先用主成分分析后再对主成分进行评价。</p>
<p>主成分分析可以用于聚类。因为聚类结果的维度往往很高，这时可以通过主成分分析法对聚类结果降维，从而在二维或三维空间中作出聚类结果图</p>
<h3 id="因子分析">因子分析</h3>
<p>因子分析可以看为主成分分析的推广，也是多元统计分析中常用的一种降维方式，他们的差别体现在： 1. 主成分分析将方差划分为不同的正交成分，而因子分析把方差划分为不同的起因因子 2. 主成分分析只是变量变换，因子分析需要构造因子模型 3. 主成分分析原始变量的线性组合表示新的综合变量，即主成分。因子分析潜在的假想变量和随机影响变量的线性组合表示原始变量</p>
<h4 id="因子分析模型">因子分析模型</h4>
<p>数学模型：<span class="math inline">\(\mathbf{X-\mu=\Lambda F+\epsilon}\\\mathbf{X,\mu,\Lambda,F,\epsilon}=\begin{bmatrix}X_1\\X_2\\\vdots\\X_p\end{bmatrix},\begin{bmatrix}\mu_1\\\mu_2\\\vdots\\\mu_p\end{bmatrix},\begin{bmatrix}\alpha_{11}\quad\alpha_{12}\quad\cdots\quad\alpha_{1m}\\\alpha_{21}\quad\alpha_{22}\quad\cdots\quad\alpha_{2m}\\\vdots\qquad\vdots\quad\ddots\quad\vdots\\\alpha_{p1}\quad\alpha_{p2}\quad\cdots\quad\alpha_{pm}\end{bmatrix},\begin{bmatrix}F_1\\F_2\\\vdots\\F_p\end{bmatrix},\begin{bmatrix}\epsilon_1\\\epsilon_2\\\vdots\\\epsilon_p\end{bmatrix}\)</span>,在上式中 称<span class="math inline">\(F_1,F_2,...,F_p\)</span>为公共因子，是不可观测的变量，其系数称为载荷因子，<span class="math inline">\(\epsilon_i\)</span>是特殊因子，不能被前m个公共因子包含的部分</p>
<h4 id="因子载荷矩阵的估计方法">因子载荷矩阵的估计方法</h4>
<p>用于估计<span class="math inline">\(\mathbf{\Lambda}\)</span> 1. 主成分分析法 2. 主因子法 3. 最大似然估计法</p>
<h4 id="因子旋转正交变换">因子旋转(正交变换)</h4>
<p>对因子载荷矩阵进行旋转的目的是使因子载荷矩阵结构简化，使载荷矩阵每列或行的元素平方值向0和1两极分化，主要正交旋转法有：方差最大法，四次方最大法，等量最大法</p>
<h4 id="因子得分">因子得分</h4>
<p>上述小节解决了用公共因子的线性组合表示一组观测变量的问题，如果利用因子做其他研究，比如作为自变量来做回归分析，对样本分类或平均，需要对公共因子测度，给出公共因子的值，其数学模型就是将上述数学模型的<span class="math inline">\(\mathbf{\mu}\)</span>移到等式右边 常用方法有: 巴斯莱特因子得分(加权最小二乘法),回归方法</p>
<p><strong>因子分析的步骤</strong>： 1. 选择分析的变量 2. 计算所选的原始变量的相关系数矩阵 3. 提出公共因子 4. 因子旋转 5. 计算因子得分</p>
<h3 id="判别分析">判别分析</h3>
<p>判别分析是根据所研究的个体的观测指标来推断该个体所属类型的一种统计方法，用统计方法表述，就是已有q个总体<span class="math inline">\(X_1,X_2,...,X_q\)</span>,他们的分布函数为<span class="math inline">\(F_1(x),F_2(x),...,F_q(x)\)</span>，对于给定样本X,要判断它来自哪个总体</p>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理知识小结</title>
    <url>/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>参考彭勤牧老师的课件和冈萨雷斯第三版课本整理</p>
<span id="more"></span>
<p><img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-31-10-00-32.png"></p>
<h2 id="第二章数字图像基础">第二章：数字图像基础</h2>
<h3 id="数字图像基础">数字图像基础</h3>
<ol type="1">
<li>采样与量化：空间坐标的离散化定义为空间采样，幅度的离散化定义为幅度量化</li>
<li>空间分辨率：空间分辨率是图像中可辨别的最小细节的度量。也就是数字图像的采样分辨率</li>
<li>灰度分辨率：灰度分辨率是指在灰度级中可分辨的最小变化。也就是数字图像的量化分辨率</li>
<li>距离量度函数：<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-01-23-50-37.png"></li>
</ol>
<h2 id="第三章空间域图像增强">第三章：空间域图像增强</h2>
<h3 id="本章概述">本章概述</h3>
<ul>
<li>图像增强的目标是改善图像质量/改善视觉效果，其标准相当主观，因人而异，没有完全通用的标准，其是否好要看具体应用的结果来评价</li>
<li>技术分类：根据其处理所涉及的空间不同，可分为图像域(空域)方法，变换域(频域)方法；根据其处理策略的不同可分为全局的方法(整图)，局部的方法(子图)；根据其处理对象不同可分为灰度图像(单性质)，彩色图像(多性质)</li>
</ul>
<h3 id="直接灰度变换">直接灰度变换</h3>
<ol type="1">
<li>修改灰度：假设原图为<span class="math inline">\(f(x,y)\)</span>,改变后的图为<span class="math inline">\(g(x,y)\)</span>。修改灰度是用一种变换关系曲线或查表来进行<span class="math inline">\(f(x,y),g(x,y)\)</span>的灰度变换，以实现动态范围和对比度的改变，记为<span class="math inline">\(g=T(f)\)</span>,目的是找变换关系T</li>
<li>简单变换
<ul>
<li>反转图：求反转图相当于在照相底片和印像之间变换，变换曲线是一条直线</li>
<li>规范化：规范化是将原动态范围从<span class="math inline">\(f_{min}-f_{max}\)</span>改变为0-255，也即进行线性变换，将动态范围扩大，公式如下<span class="math inline">\(g(x,y)=\frac{f(x,y)-f_{min}}{f_{max}-f_{min}}\times 255\)</span></li>
<li>非线性调整动态范围(对数、指数):一般采用对数方式来压缩，<span class="math inline">\(g=clog(1+f)\)</span>,其中c为常数，使得g的范围为0-255</li>
<li>灰度级分割(分段线性):对感兴趣的区域进行灰度增强，其他像素灰度不变或灰度取低值</li>
</ul></li>
</ol>
<h3 id="直方图处理">直方图处理</h3>
<ol type="1">
<li>直方图定义：直方图具体来说是表示的灰度统计直方图，其提供了图像象素的灰度值分布情况</li>
<li>直方图意义：
<ul>
<li>反映出图象的灰度分布情况：低端分布的直方图，图象较暗，高端分布的直方图，图像太亮，直方图分布狭窄，图象的对比度不够，直方图的多个峰值，一般对应多类目标；</li>
<li>指出图象增强处理的方向：直方图的均衡化：均匀分布的直方图，可扩大动态范围，增大图象对比度；直方图的规定化：符合特定分布的直方图，有目的的增强感兴趣目标</li>
</ul></li>
<li>直方图均衡化：
<ul>
<li>其目的是借助直方图变换实现(归一的)灰度映射</li>
<li>均衡化(线性化)基本思想：变化原始图象的直方图为均匀分布--大动态范围；使象素灰度值的动态范围最大--增强图象的整体对比度(反差)</li>
<li>变换方法：根据图象直方图得到累积直方图，通过累积直方图进行均匀化灰度重分配，根据确定的灰度变换关系，对全图进行灰度变换(L元素数量)</li>
<li><img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-27-09-26-31.png"></li>
</ul></li>
<li>直方图规定化：
<ul>
<li>借助直方图变换实现规定/特定的灰度映射</li>
<li>处理方法：对原始直方图计算灰度累积直方图，对规定化直方图计算灰度累计直方图，通过累积直方图对应关系，得到灰度映射关系</li>
<li><img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-27-09-28-46.png"></li>
</ul></li>
<li>直方图规定化与直方图均衡化的对比：
<ul>
<li>直方图均衡化是一种自动增强，效果不易控制，总得到全图增强的结果，适合增强直方图成尖峰分布的图像</li>
<li>直方图规定化则是一种有选择性的增强，需给定需要的直方图，可特定增强的效果</li>
</ul></li>
</ol>
<h3 id="图像间运算">图像间运算</h3>
<ol type="1">
<li>去除噪声-利用多幅图像相加,其假设是噪声在空间位置上互不相关</li>
<li>差异检测-利用多幅图像相减,其要求多幅图像之间位置准确对应</li>
<li>区域选择-利用多幅图像相乘,通过逻辑运算，制作感兴趣区域为1的掩膜图像</li>
</ol>
<h3 id="空域滤波增强">空域滤波增强</h3>
<ol type="1">
<li>以平滑滤波为例，平滑的主要目标是去除噪声，其附加要求是保护图像信息的细节，对于保边缘的平滑滤波算法，主要有邻域平均和邻域中值</li>
<li>滤波器实现方法--邻域加权运算，可以用图像掩膜来对图象进行空间滤波，处理图象的高频低频和特殊频段分量，掩膜在这里是一个窗口，作为象素变换的模板，并表示了变换关系，其本身就是空间滤波器，掩膜的计算过程实际上就是数学上离散卷积的过程</li>
<li>空间滤波概述：主要用于处理图象中不同频率的分量，图象中的高频分量对应图中灰度急剧变化的区域，低频分量对应灰度变化平缓的区域，低通滤波器的作用是减弱噪声，使图更平滑，但同时降低了图象的清晰度。高通滤波器使得图象的边缘和细节更清晰，但噪声也随之被强化</li>
</ol>
<h3 id="平滑滤波器">平滑滤波器</h3>
<p>原理：减弱或消除高频分量，保留低频分量，平滑处理往往用于图象分割之前，因为它可以去除噪声也可以填补图象边缘中的间隙，有利于从图象中找出目标</p>
<ol type="1">
<li>线性平滑滤波器：其系数都为正，中间系数大，周围系数小，保存灰度值范围(所以系数之和为1)
<ul>
<li>带门限的邻域平均：思想是有噪声就进行邻域平均去噪，无噪声则不处理。如果被处理像素的灰度与邻域均值的差别不大，则可认为噪声不存在，反之则用邻域均值取代原像素灰度</li>
<li>半邻域平均：思想是判断邻域中有无边缘，没有边缘可以不担心细节信息被平滑，被处理像素灰度采用全邻域均值，否则，根据邻域中的目标信息为被处理像素赋值</li>
</ul></li>
<li>非线性平滑滤波器--统计排序滤波：邻点平均滤波有损于图的清晰度，中值滤波器可做到只去除噪声而不使原图清晰度变坏。其原理是将一个窗置于感兴趣点之上，把窗中所有邻点灰度值排序，变换后在该感兴趣点上的灰度值将由邻点排序后的中值代替</li>
</ol>
<h3 id="锐化滤波器">锐化滤波器</h3>
<p>原理：减弱或消除低频分量，保留高频分量，又称高通滤波器，其把低通滤波器的概念用到高通中来，如果从图象中除去低频分量剩下的就是高频分量了</p>
<ol type="1">
<li>线性锐化滤波器：中心系数为正，周围系数为负，输出平均值为0，灰度变换到<span class="math inline">\([0,L-1]\)</span>便于显示，最简单的锐化滤波模板</li>
<li>高频提升：如果把高通滤波的结果加到原图乘以一个系数后的图中去，其结果是原图中的低频信号没有完全除去，高频信号有了一定程度的增加。因而称为高频提升</li>
<li>非线性锐化滤波器：邻点平均的滤波效果使图象模糊。它是邻点灰度值相加的结果，可类比为积分，那么可以期待求邻点差分－微分将产生正好相反的效果。最常见的微分方法是求梯度，因而微商滤波器也经常就是梯度滤波器。</li>
<li>梯度运算模板：<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-01-23-31-23.png"></li>
<li>几种典型的梯度算子：<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-01-23-32-30.png"></li>
</ol>
<h2 id="第四章频率域图像增强">第四章：频率域图像增强</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>频域增强是通过在频域的滤波处理来达到增强图象的目的；其把图象用FFT变化到频域，将结果乘一个滤波函数再变回到空域，就实现了频域滤波。低通滤波就是在频域中去掉了一些高频分量，高通滤波正好相反。在概念上来说在频域上设计滤波器比较直接了当，但由于要经过正反两次傅里叶变换，计算量较大，还是直接的空间滤波使用广泛</li>
<li>空域滤波到频域滤波：空域的锐化、平滑模板处理，其实就是频域的高通、低通处理；空域的处理模板，映射到频域可以看到，它们并非都是无相移系统，将造成处理后图象，目标会有位置变化，而这种不利影响在频域处理中可以避免</li>
</ul>
<h3 id="低通滤波">低通滤波</h3>
<ol type="1">
<li>基本概念：在频域中将高频分量除去或衰减就构成了低通滤波。设图像为<span class="math inline">\(F(u,v)\)</span>,变化后的图象为<span class="math inline">\(G(u,v)\)</span>，则问题就是如何选择滤波器<span class="math inline">\(H(u,v)\)</span>，使得变换后高频分量得以衰减。一般我们只考虑<span class="math inline">\(H(u,v)\)</span>为实数的滤波器，它不影响变化前后的相位特性，称为0相位漂移滤波器。</li>
<li>滤波器分类：一般常讨论和使用的低通滤波器有理想低通滤波器，Butterworth低通滤波器--减少振铃效应，高低频率间过度比较平滑，Gaussian低通滤波器</li>
<li>振铃效应：振铃效应是指在图像的灰度剧烈变化处，如边缘附近，出现的不期望的震荡或波动。这种现象通常发生在图像的恢复或重建过程中，当使用理想低通滤波器或其他具有陡峭截止频率的滤波器时，由于滤波器的频率响应在截止频率处的不连续性，导致在图像的空间域中产生类似钟声的震荡波形</li>
</ol>
<h3 id="高通滤波">高通滤波</h3>
<ol type="1">
<li>基本概念：高通滤波是想保留图象中灰度急剧变化的部分，一般只讨论零相移高通滤波器，常用的滤波器有理想/Butterworth/Gaussian高通滤波器</li>
</ol>
<h3 id="带通带阻滤波">带通带阻滤波</h3>
<ol type="1">
<li>基本概念：和之前学习的课程的知识并无区别，不详细介绍</li>
</ol>
<h3 id="同态滤波">同态滤波</h3>
<ol type="1">
<li>基本概念：同态滤波是在频域中同时压缩动态范围并增强局部对比度，来实现图像增强的方法</li>
<li>设计思想：先进行对数运算，然后再进行线性运算，最后以指数运算结束，称之为乘法同态系统，用这类系统进行滤波加同态滤波。其中取对数的目的是使信号满足线性系统的要求，取指数使其变回来。</li>
</ol>
<h3 id="局部增强">局部增强</h3>
<ol type="1">
<li>基本概念：实际应用中常常需要对图象某些局部区域的细节进行增强，局部增强方法比全局增强方法在具体进行增强操作前多了一个选择/确定局部区域的步骤</li>
</ol>
<h2 id="第五章图象复原">第五章：图象复原</h2>
<h3 id="概述与技术分类">概述与技术分类</h3>
<ol type="1">
<li>概述：图象复原是图象处理中的一大类技术，其与图象增强相比，相同之处在于用于改进输入图象的视觉质量，不同之处在于图象增强借助人的视觉系统特性，以取得较好的视觉结果(不考虑退化原因)，图象恢复根据相应的退化模型和知识重建或恢复原始的图象(考虑退化原因)</li>
<li>技术分类：技术分为单纯噪声引起的退化恢复和失真的成像系统引起的退化恢复(无约束和有约束)，策略分为自动和交互，处理所在域分为频域和空域，从广义的角度上来看有可以分为几何失真(退化)校正(恢复)，投影(退化)重建(恢复)</li>
</ol>
<h3 id="退化模型">退化模型</h3>
<ol type="1">
<li>几种典型的退化形式
<ul>
<li>光学系统孔径衍射造成的退化</li>
<li>目标运动造成的退化</li>
<li>成像过程的非线性造成的退化</li>
<li>噪声引入造成的退化</li>
</ul></li>
<li>退化的数学描述：退化过程采用系统函数H表示，还叠加有统计特性已知的加性噪声<span class="math inline">\(n(x,y)\)</span>,退化模型数学表述为<span class="math inline">\(g(x,y)=H[f(x,y)]+n(x,y)\)</span>,恢复图象则是在给定<span class="math inline">\(g(x,y)\)</span>和代表退化的H的基础上得到的对<span class="math inline">\(f(x,y)\)</span>的某个近似</li>
<li>退化模型：
<ul>
<li>空域模型：<span class="math inline">\(g(x,y)=H[f(x,y)]+n(x,y)=f(x,y)*h(x,y)+n(x,y)\)</span></li>
<li>频域模型：<span class="math inline">\(G(u,v)=H(u,v)F(u,v)+N(u,v)\)</span></li>
</ul></li>
</ol>
<h3 id="图像恢复的噪声问题">图像恢复的噪声问题</h3>
<ol type="1">
<li>噪声的种类可分为：高斯噪声，均匀噪声，椒盐噪声，周期性噪声等</li>
<li>噪声参数的估计一般是选取图像中被噪声影响的均匀区域，由直方图估计噪声类型，计算区域S的统计参数，然后根据噪声类型计算噪声参数</li>
</ol>
<h3 id="空域滤波去噪">空域滤波去噪</h3>
<ol type="1">
<li>均值滤波：
<ul>
<li>算术均值：简单平滑局部变化，达到去噪效果</li>
<li>几何均值：滤波效果类似算术均值，更少丢失图像细节</li>
<li>谐波均值：善于处理高斯噪声，适合处理"盐噪声"，不适合处理"胡椒"噪声</li>
<li>逆谐波均值：Q为滤波器阶数，为正适合处理"胡椒噪声"，为负适合处理"盐噪声"，为0等同算术均值滤波，为-1等同谐波均值滤波器</li>
</ul></li>
<li>统计排序滤波(中值滤波)
<ul>
<li>中值滤波</li>
<li>最大最小值滤波器：最大值滤波适合处理盐噪声，最小值滤波适合处理胡椒噪声</li>
<li>中点滤波器：综合统计排序和求平均的优势，适合高斯，均匀分布噪声的处理</li>
<li>修正后阿尔法均值滤波器：适合多种情况下的滤波</li>
</ul></li>
<li>自适应滤波：主要分为自适应局部噪声消除和自适应中值滤波器</li>
</ol>
<h3 id="频域滤波消除周期噪声">频域滤波消除周期噪声</h3>
<ol type="1">
<li>带(阻)通滤波：对位于一定频带内的噪声进行滤除</li>
<li>陷波滤波：阻止(通过)对事先定义的中心频率邻域的信息</li>
</ol>
<h3 id="图像恢复的频域滤波方法">图像恢复的频域滤波方法</h3>
<ol type="1">
<li>频域滤波思想：失真的现象可以通过传输函数H数学表示为<span class="math inline">\(F(u,v)=\frac{G(u,v)}{H(u,v)}-\frac{N(u,v)}{H(u,v)}\)</span>,不考虑噪声影响则是<span class="math inline">\(F(u,v)=\frac{G(u,v)}{H(u,v)}\)</span>,恢复失真的图像，可以经过频域滤波实现，也就是频域除以传输函数H可得，这就是简单逆滤波</li>
<li>简单逆滤波：滤波器数学表达：<span class="math inline">\(M(u,v)=1/H(u,v)\)</span>，在此基础上有两种改进，一个是避免噪声的影响， 除去H(u,v)为0的点，另一个是为了减少振铃效应，避免传输函数低值影响</li>
<li>退化和滤波的综合模型 <img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-28-15-45-41.png"></li>
<li>有约束滤波-维纳滤波(最小均方滤波)：维纳滤波是一种在恢复过程中考虑噪声影响的最经典的滤波恢复方式之一，有约束滤波，其复原过程如下，首先计算退化图像<span class="math inline">\(g(x,y)\)</span>的二维Fourier变换<span class="math inline">\(G(u,v)\)</span>，然后再计算点扩展函数<span class="math inline">\(h(x,y)\)</span>的二维Fourier变换<span class="math inline">\(H(u,v)\)</span>,计算退化图像和噪声的功率谱<span class="math inline">\(S_f(u,v),S_n(u,v)\)</span>，然后在计算滤波器<span class="math inline">\(H_w(u,v)\)</span>，最后计算理想图像的频谱估计<span class="math inline">\(\hat{F}(u,v)=H_w(u,v)G(u,v)\)</span>后求反Fourier变换</li>
<li>系统传输函数的估计：图像恢复公式中都用到了公式<span class="math inline">\(g=hf或g=hf+n\)</span>,或者它们相应的频域表示，求解这些方程的必要条件是点源传输函数或其频域表示已知，当不知道点源传输函数<span class="math inline">\(h(x,y)\)</span>时，由模糊图<span class="math inline">\(g(x,y)\)</span>估计清楚图<span class="math inline">\(f(x,y)\)</span>的问题就叫盲反卷积问题。估计方法可分为图像观察和试验估计，模型估计三类</li>
</ol>
<h3 id="交互式恢复">交互式恢复</h3>
<ol type="1">
<li>方法概述：人机结合控制恢复过程以达到一些特殊的效果</li>
<li>工作流程：依靠视觉观察在频率域确定出脉冲分量的位置并在该位置利用带阻滤波器消除，在频率域里对应每个亮点的位置放一个带通滤波器<span class="math inline">\(H(u,v)\)</span>，得到干扰模式的傅里叶变换后进行反变换，从退化图像减去干扰图像，也能达到恢复的目的</li>
</ol>
<h3 id="几何失真的校正">几何失真的校正</h3>
<ol type="1">
<li>概述：主要用在对几何畸变的校正和图像的匹配上，处理步骤是先进行空间变换，即对图像坐标位置进行校正，然后灰度插值，即对象素灰度级进行估算。</li>
<li>空间变换：
<ul>
<li>模型：图像<span class="math inline">\(f(x,y)\)</span>受几何形变的影响变成失真图像<span class="math inline">\(g(x&#39;,y&#39;)\)</span></li>
<li>模型的系数确定：采用约束对应点方法(控制点方法)，在输入图(失真图)和输出图(校正图)上找一些其位置确切知道的点，然后利用这些点建立两幅图间其他象素空间位置的对应关系</li>
</ul></li>
<li>灰度插值：
<ul>
<li>定义：坐标变换后的结果不是整数，不在数字图像的像素位置上，需要用整数处的象素值来计算在非整数处的象素值，这就是灰度插值</li>
<li>变换的策略：从校正后图像的坐标空间反变换到退化图像的坐标空间，非整数位置处的图像灰度，通过周边相邻像素的灰度值计算而得。</li>
<li>最近邻插值：也称为零阶插值，将离<span class="math inline">\((x&#39;,y&#39;)\)</span>点最近的象素的灰度值作为<span class="math inline">\((x&#39;,y&#39;)\)</span>点的灰度值赋给原图<span class="math inline">\((x,y)\)</span>处象素</li>
<li>双线性插值：利用<span class="math inline">\((x&#39;,y&#39;)\)</span>点的四个最近邻象素A,B,C,D,灰度值分别为<span class="math inline">\(g(A),g(B),g(C),g(D)\)</span>,得到<span class="math inline">\(g(E)=(x&#39;-i)[g(B)-g(A)]+g(A),g(F)=(x&#39;-i)[g(D)-g(C)]+g(C)\)</span>,最后可得<span class="math inline">\(g(x&#39;,y&#39;)=(y&#39;-j)[g(F)-g(E)]+g(E)\)</span></li>
</ul></li>
<li>应用情况：遥感图像的校正，目标的匹配</li>
</ol>
<h3 id="图象的投影重建">图象的投影重建</h3>
<ol type="1">
<li>概念：二维图像在某方向上的一维投影，可以反映二维图象的部分信息，多方向的一维投影数据，可以重建二维图像</li>
<li>分类：投射断层成像，发射断层成像，反射断层成像，其他断层成像，傅里叶反变换重建图像</li>
<li>投影定理：<span class="math inline">\(f(x,y)\)</span>以<span class="math inline">\(\theta\)</span>角进行投影的傅立叶变换等于<span class="math inline">\(f(x,y)\)</span>的傅里叶变换在傅立叶空间<span class="math inline">\((R ,\theta)\)</span>处的值</li>
<li>傅里叶反变换进行投影重建的步骤：对以角<span class="math inline">\(\theta_n(n=1,2,...,N)\)</span>的投影进行1D傅里叶变换，在傅里叶空间从极坐标向直角坐标插值，进行2D傅里叶反变换得到重建图像。</li>
</ol>
<h2 id="第六章彩色图象处理">第六章：彩色图象处理</h2>
<h3 id="彩色基础">彩色基础</h3>
<ol type="1">
<li>彩色图像处理可分为两个主要领域：全彩色处理(图像用全彩色传感器获取),伪彩色处理(对特定的单一亮度或亮度范围赋予一种颜色)</li>
</ol>
<h3 id="彩色模型">彩色模型</h3>
<ol type="1">
<li>RGB模型-彩色立方体：基于笛卡尔坐标系统，RGB为三个分量，是一个物理可实现的彩色模型</li>
<li>CMY模型：颜色的三原色CMY(青、品红、黄),对应的是白光中减去RGB(红、绿、蓝),RGB模型与CMY之间的转换<span class="math display">\[\begin{bmatrix}
C \\
M \\
Y
\end{bmatrix}=\begin{bmatrix}
1\\
1\\
1
\end{bmatrix}-\begin{bmatrix}
R\\
G\\
B
\end{bmatrix}\]</span></li>
<li>HSI模型：就人眼的感觉来说，色彩感受可分为色调：反映颜色的类别；色饱和度：反映颜色的纯度；亮度：彩色光的强度；色调和色饱和度合称为色度表示颜色的类别和深浅；色环可采用极坐标方式表示色度，色调H对应<span class="math inline">\(\theta\)</span>,色饱和度对应p</li>
<li>HSI与RGB之间的转换
<ul>
<li>RGB到HSI:<span class="math display">\[H=\begin{cases}
 \theta \qquad G\ge B\\
 2\pi-\theta\qquad G&lt;B
\end{cases}\\I=\frac{1}{3}(R+G+B)\\S=1-\frac{3min(R,G,B)}{R+G+B}\\\theta=cos^{-1}[\frac{\frac{1}{2}[(R-G)+(R-B)]}{\sqrt{(R-G)^2+(R-B)(G-B)}}]\]</span></li>
<li>HSI到RGB:<span class="math display">\[0°\le H\le 120° \begin{cases}
 B=I(1-S)\\
 R=I[1+\frac{Scos(H)}{cos(60°-H)}]\\
 G=3I-(R+B)\\
\end{cases}\\120°\le H\le 240° \begin{cases}
 H=H-120°\\
 R=I(1-S)\\
 G=I[1+\frac{Scos(H)}{cos(60°-H)}]\\
 B=3I-(R+G)\\
\end{cases}\\240°\le H\le 360° \begin{cases}
 H=H-240°\\
 G=I(1-S)\\
 B=I[1+\frac{Scos(H)}{cos(60°-H)}]\\
 R=3I-(G+B)\\
\end{cases}\]</span></li>
</ul></li>
<li>HSI模型更适合对彩色的描述，因为其色彩的变换只在一个分量中确定，另外，其适合满足视觉效果的处理，这样人眼对彩色和亮度的空间分辨率差异可以得到利用</li>
<li>XYZ色度图：其相较于RGB的优点是系数没有负数，Y可以确定彩色光的亮度，彩色光的色度也可以有XYZ比值确定，X=Y=Z对应R=G=B，代表等能白光</li>
</ol>
<h3 id="彩色增强">彩色增强</h3>
<ol type="1">
<li>原理：人眼对颜色的区分能力比对灰度的区分能力要强很多，彩色增强的方法包括伪彩色增强和真彩色增强</li>
<li>伪彩色增强：
<ul>
<li>特点是对原来灰度图像中不同灰度值区域赋予不同的颜色用以更明显的区分它们，典型方法有亮度切割，利用变换函数和频域滤波</li>
</ul></li>
<li>真彩色增强:
<ul>
<li>对彩色分量进行增强，首先将RGB分量图转化为HSI分量图，然后利用对灰度图增强的方法增强其中某个分量图，再将结果转换为RGB分量图</li>
<li>对S分量增强时，增强饱和度能使彩色更浓，反差增加，边缘清晰；减小饱和度能使部分区域变为灰色，整体比较平淡；增强H分量当色调加减小常数时，图像会变暖或变冷，加减大常数时对图象感受发生比较激烈的变化</li>
</ul></li>
</ol>
<h3 id="彩色变换应用">彩色变换应用</h3>
<ol type="1">
<li>补色的概念：彩色环上面的对立色互为补色，补色能突出感兴趣的目标</li>
<li>直方图处理：彩色图象的直方图处理一般不针对RGB模型，因为可能产生不可控制的色调变化，一般在HSI模型下进行处理，其处理亮度分量，然后根据需要处理饱和度分量。</li>
</ol>
<h3 id="插值与外推">插值与外推</h3>
<ol type="1">
<li>基本概念：两幅图象之间的插值或外推提供了一种简单易行的图象增强手段。它在增强亮度、对比度、饱和度，改变色彩，尖锐化等方面均有重要应用。插值：两个图像之间的线性过渡；外推：保持线性关系，跨越两个图像本身的线性外推，得到图像属性的针对性变化。</li>
<li>插值公式：<span class="math inline">\(out=(1-a)V_1+aV_2\)</span>，其中<span class="math inline">\(V_1,V_2\)</span>分别为两图或图像中对应点的灰度值，out为插值结果，当a在0-1范围内时为一般意义的插值，否则为外推</li>
<li>插值改变亮度：以全黑的图和适中的图来运算。插值时图变黑，外推时图变亮。运算时较亮的象素受影响较大。</li>
<li>插值改变对比度：可用常值(例如平均灰度)图来控制对比度。插值时对比度降低，外推时增高。负值时变成反转图。离常值越远的值改变越大。</li>
<li>尖锐化：如果以一幅模糊图(原图经过低通滤波或平均)为参考图和原图内插就会减少高频分量，外推就会使图象尖锐。</li>
<li>插值改变饱和度：可用灰图作参考图来调节色彩的饱和度。插值降低饱和度，外推使其升高。 a&lt; 0 则保留照度而改变色调。用这种方法可以避免向HSV空间变来变去和复杂的计算。</li>
</ol>
<h3 id="彩色图象处理的应用">彩色图象处理的应用</h3>
<ol type="1">
<li>去红眼：首先确定眼部区域，对眼部区域的每一象素从RGB模型转换到HSI模型，然后将满足公式的象素饱和度s置为0，变成灰色，重复执行，直到处理完眼部区域所有象素</li>
<li>肤色检测：根据肤色模型，将一幅彩色图像转变为灰度图像，像素的灰度值对应于该点属于皮肤区域的概率；选取合适的阈值，将灰度图像转换为二值图像，其中0、 1分别表示非皮肤区域和皮肤区域；以该二值图像作模板，在原图像中检测肤色区域。</li>
</ol>
<h2 id="第七章小波变换和多分辨处理">第七章：小波变换和多分辨处理</h2>
<h3 id="多分辨率概念">多分辨率概念</h3>
<ol type="1">
<li>多分辨率意义：目标具有特定的形状，形状具有不同的大小，大目标可以在低分辨率下观察，小目标需要在高分辨率下观察，具有多分辨率的识别系统才能最有效的识别目标，人眼视觉对目标的感知也具有多分辨率能力</li>
<li>图像金字塔：逐级建立近似图像，不同级别图像可识别不同尺寸目标</li>
<li>子带编码：金字塔分解的两个方面：近似和残差，信息在频域上与此对应的两个部分：低频和高频</li>
<li>图像的二维子分解：是水平、垂直可分离的分解，首先沿垂直方向逐行分解，然后在水平方向逐列分解，生成了四个分量，近似值，垂直细节分量，水平细节分量，对角细节分量。</li>
</ol>
<h3 id="小波变换概念">小波变换概念</h3>
<ol type="1">
<li>小波概念：有限间隔内且平均值为0的一种函数，相对于正弦波而言，称其为"小波",</li>
<li>小波变换：主要包括连续变换，离散变换，离散小波变换和子带编码，小波分解树，小波重构</li>
</ol>
<h3 id="小波变换的应用">小波变换的应用</h3>
<ol type="1">
<li>小波变换在图像处理中的应用</li>
<li>边界提取：
<ul>
<li>处理原理:边界属于细节信息，对变换以后的数据，丢弃近似数据，保留细节数据，可以达到提取边界的目的</li>
<li>算法推广：若只保留某一方向的细节数据，则可以提取方向性边界</li>
</ul></li>
<li>图像去噪：
<ul>
<li>处理原理:噪声具有细节特征，存在于变换后的细节分量中，选择合适的尺度的细节分量进行门限化处理，可以达到去噪目的</li>
</ul></li>
<li>图像编码：
<ul>
<li>处理原理：小波变换后，大量数据反映细节内容，舍弃一定的细节信息不影响反变换的观察效果，细节信息数据动态范围小，适合采用短码字的量化压缩</li>
</ul></li>
<li>图像融合：
<ul>
<li>处理原理：同一目标，不同方式获得的图像，可反映多维度信息，融合处理能在一幅图像上反映更丰富的信息，融合的步骤一般包括预处理，去除噪声；配准，位置校正；在变换域进行信息取舍，反变换得到融合结果。</li>
</ul></li>
</ol>
<h2 id="第八章图象压缩">第八章：图象压缩</h2>
<h3 id="引言">引言</h3>
<ol type="1">
<li>编码的动机：数字图象数据量很大，需要缩减数据量，便于保存和交流</li>
<li>图象编码定义为采用对图象的新的表达方法以减小所需的数据量</li>
<li>图象编码整个过程包括：图象压缩(编码)和图象解压缩(解码)，整个方法可分为无损压缩和有损压缩</li>
</ol>
<h3 id="编码基本概念和理论基础">编码基本概念和理论基础</h3>
<ol type="1">
<li>数据冗余的概念：冗余有两方面，数据表达了无用的信息或数据表达了已表达的信息；相对数据冗余：<span class="math inline">\(n_1,n_2\)</span>代表表达同一信息，2个数据集合中各自信息载体的个数，<span class="math inline">\(n_1\)</span>相对<span class="math inline">\(n_2\)</span>数据冗余的定量描述：<span class="math inline">\(R_D=(n_1-n_2)/n_1=1-1/C_R\)</span><img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-30-16-03-26.png"></li>
<li>数据冗余的类别：
<ul>
<li>编码冗余：与灰度分布概率特性有关</li>
<li>象素相关冗余：空间冗余，时间冗余，几何冗余</li>
<li>心理视觉冗余：与主观感觉有关</li>
</ul></li>
<li>图象保真度和质量：有损压缩造成的损失的独立方式可分为主观保真度准则和客观保真度准则，客观保真度准则用编码输入图和解码输出图的某个确定函数来表示损失的信息量，便于计算或测量</li>
<li>图像编码模型 <img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-30-16-06-48.png"></li>
</ol>
<h3 id="简单编码方法">简单编码方法</h3>
<ol type="1">
<li>变长编码：采用自然码会产生编码冗余，解决的方法是用短码表示出现多的灰度级，长码表示出现少的灰度级</li>
<li>哈夫曼编码：
<ul>
<li>其基本步骤是将符号按照概率大小排列，对概率最小两符号合并，计算合并后新符号概率并排序，重复直到剩余符号不多于两个，然后对各信源符号逆向赋值</li>
<li>其变形有截断哈夫曼码和平移哈夫曼码，截断哈夫曼码支队最可能出现的M个符号进行哈夫曼编码，其他符号用合适的定长编码加前缀进行综合编码，平移哈夫曼码则将符号总数分成相同大小的符号块，所有块中各个元素采用同样方法编码，每个块再加上专门的平移符号进行区分。</li>
<li>特点：非等长码，解码唯一，所有码字不是前缀码，且都在编码树叶节点，但抗干扰能力不强</li>
</ul></li>
<li>算术编码：
<ul>
<li>简介：从整个符号序列出发进行编码，不是对每个符号的编码，没有源符号和码字的一一对应关系，其需要每个符号的出现概率和整个符号的排列顺序，编码过程按照符号序列顺序递推进行，随符号序列中符号数量增加，其是对符号串整体的编码，理论上可以达到无失真编码定理给出的编码极限。</li>
<li>编码过程示例：<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-30-16-22-16.png">,简要总结，就是第一个符号将概率区间缩减到其符号概率区间，后面的符号一个个依次缩小符号区间</li>
<li>解码过程示例：其实就是编码过程的逆过程 一个个判断范围就好</li>
<li>编码结果分析：只用到加法和移位运算，源符号和码字的一一关系并不存在，从整个符号序列出发采用递推方式连续编码</li>
</ul></li>
<li>LZW编码：用于消除图像中像素间冗余，是Unix操作系统文件压缩标准方法，特点是码字长度固定，无需信源信号出现概率，采用字典编码定义符号出现顺序</li>
<li>位平面编码：将多灰度指图像分解为一系列二值图像，然后对每一幅二值图像进行二元压缩，既能够减少编码冗余还能减少像素间冗余</li>
<li>编码评价：
<ul>
<li>编码的平均长度=概率*长度之和</li>
<li>信元的熵：按定义正常求即可</li>
<li>编码效率=<span class="math inline">\(\eta=\frac{H(u)}{L_{avg}}\)</span></li>
</ul></li>
</ol>
<h3 id="预测编码方法">预测编码方法</h3>
<ol type="1">
<li>思路：图像信息存在像素间冗余，像素间相关性使得预测成为可能，根据预测过程是否造成信息丢失可分为无损/有损预测编码</li>
</ol>
<h3 id="变换编码方法">变换编码方法</h3>
<ol type="1">
<li>概念：基于空间冗余压缩思想的方法，编码过程综合使用其他信息冗余压缩方法，需要解决变换的选择，基于运算效率和数据相关性考虑的子图选择，变换域中有用信息的选取原则，信息的量化编码</li>
</ol>
<h2 id="第九章形态学图像处理">第九章：形态学图像处理</h2>
<h3 id="形态学理论基础">形态学理论基础</h3>
<ol type="1">
<li>基本概念：用具有一定形态的结构元素去量度和提取图像中的对应形状，达到对图像分析和识别的目的
<ul>
<li>数学基础是集合论</li>
<li>基本运算包括膨胀，腐蚀、开启、闭合、击中、击不中</li>
<li>处理对象主要是二值图像和灰度图像</li>
<li>位移：A用<span class="math inline">\(b=(b_1,b_2)\)</span>位移，记为<span class="math inline">\((A)_z={y|y=a+b,a\in A}\)</span></li>
<li>映像：A的映像记为<span class="math inline">\(\hat{A}={w|w=-a,a\in A}\)</span></li>
</ul></li>
</ol>
<h3 id="膨胀与腐蚀">膨胀与腐蚀</h3>
<p>二值形态学的运算对象是集合，设A为图像集合，B是结构元素，数学形态学运算是用B对A进行操作，二值形态学中最基本的两个运算就是腐蚀和膨胀</p>
<h4 id="膨胀">膨胀</h4>
<ol type="1">
<li>定义：A用结构元素B进行膨胀运算为$AB={x|[()_xA]} orAB={x|[()_xA]A} $<br>
<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-30-19-16-21.png"></li>
<li>理解：可以理解为将B这个结构元素的原点在整个图像上平移 如果B有与A的交集，那么当前B的所有区域位置的元素都置为1</li>
</ol>
<h4 id="腐蚀">腐蚀</h4>
<p><img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-30-19-16-53.png"> 腐蚀的应用主要在去除图像中不需要部分(噪声，毛刺) 2. 理解：可以理解为将B这个结构元素的原点在整个图像上平移 如果B所有点都在A内，那么当前B的原点对应位置保留</p>
<h4 id="灰度形态学的膨胀与腐蚀">灰度形态学的膨胀与腐蚀</h4>
<ol type="1">
<li>膨胀：类似卷积的一种操作，用P加上B，然后取这个区域中的最大值赋值给结构元素B的原点所对应的位置。</li>
<li>腐蚀：类似卷积的一种操作，用P减去结构元素B形成的小矩形，取其中最小值赋到对应原点的位置即可。</li>
</ol>
<h3 id="开操作和闭操作">开操作和闭操作</h3>
<ol type="1">
<li>思路：腐蚀使目标变小，膨胀使目标变大，那么腐蚀后再膨胀就能去掉毛刺，恢复目标尺寸，先膨胀再腐蚀就能填充空洞，恢复目标尺寸</li>
<li>开操作就定义为采用结构元素B对A先腐蚀再膨胀，通过去除细小突出物，断开狭窄的间断来平滑目标</li>
<li>闭操作定义为采用结构元素B对A先膨胀再腐蚀，通过填充小孔洞，消弥狭窄简短和细长鸿沟来平滑目标</li>
<li>几何解释：
<ul>
<li>开操作：结构元素沿目标的内边界滚动，B中的点所能达到的A的边界的最近点</li>
<li>闭操作：结构元素沿目标的外边界滚动，B中的点所能达到的A的边界的最近点</li>
</ul></li>
</ol>
<h3 id="击中或击不中变换">击中或击不中变换</h3>
<p>击中/击不中变换主要用于判断、检测物体内部的成分以确定图像的结构 <img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-30-19-30-26.png"></p>
<ol type="1">
<li>思路：对于多个目标构成的图像，以某一目标为结构元素进行腐蚀操作，能保留比该目标大的对象</li>
<li>定义：检测对象为X，X包围在小窗口W中，(W-X)为背景，图像A经X腐蚀，可以检测比X大的目标，图像A的补集经(W-X)腐蚀，能检测比(W-X)小的目标，综合就可以检测目标X</li>
</ol>
<h3 id="一些形态学算法">一些形态学算法</h3>
<h4 id="边界提取">边界提取</h4>
<p>集合A的边界表示为<span class="math inline">\(\beta(A)\)</span>,可通过以下运算得到<span class="math inline">\(\beta(A)=A-(A\circleddash B)\)</span>,其中B为一个适当的结构元素</p>
<h4 id="区域填充">区域填充</h4>
<p><img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-30-19-35-13.png"></p>
<h4 id="top-hat变换">TOP-hat变换</h4>
<p>应用于灰度图像，实际上就是原图与开运算结果图之差，常用来分离比临近点亮一些的斑块。</p>
<h2 id="第十章图像分割">第十章：图像分割</h2>
<h3 id="图像分割概述">图像分割概述</h3>
<ol type="1">
<li>目的：区分图像中的前景(感兴趣的目标)和背景，在图像中将不同区域分离出来，提取目标，分割的依据就是图像的区域特性:灰度、颜色、纹理等</li>
<li>定义：<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-31-10-50-21.png"></li>
<li>分类：<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-31-10-51-08.png"></li>
</ol>
<h3 id="并行边界技术">并行边界技术</h3>
<ol type="1">
<li>主要内容：边缘检测，微分算子，边缘连续性，边缘检测的变换检测法</li>
<li>边缘检测：
<ul>
<li>边缘：(相邻象素)灰度值不连续的结果可利用计算导数方法进行检测，边缘常出现在一阶导数具有较大值的位置，要检测边缘，就需要采用对图像的微分运算，引入微分算子</li>
</ul></li>
<li>微分算子：
<ul>
<li>梯度算子：常被用于进行图像的锐化处理，主要有以下几种<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-31-10-55-30.png"></li>
<li>拉普拉斯算子：二阶导数算子，特点是中心为正，临近为负，模板和为0，对噪声敏感，产生双象素宽边缘，没有方向信息，常用于在边缘已知情况下，确定象素在明区或暗区</li>
<li>马尔(Marr)算子(LoG算子)：根据人眼成像机理产生，具有去噪和检测边界作用，其算法为首先用2D高斯平滑模板与图像卷积，然后计算卷积后的拉普拉斯结果，检测结果图中的过零点作为边界</li>
<li>Canny边缘检测：和Log类似，也属于先平滑后求导数，其步骤是先对原始图像进行灰度化，然后高斯滤波，再用一阶偏导的有限差分来计算梯度的幅值和方向，再对梯度幅值进行非极大值抑制，最后用双阈值算法检测和连接边缘</li>
</ul></li>
<li>边界闭合：
<ul>
<li>原因：有噪声时：边缘象素常孤立或分小段连续，在同一目标，边界应该是封闭的，需要进行边缘象素连接</li>
</ul></li>
<li>边界细化：
<ul>
<li>思路：理想边界只有一个象素宽度，实际中边界很宽，需在边界垂直方向判断最近边界点，去除其他点，最佳点应该具有最大梯度</li>
<li>算法思路主要有采用模板进行非最大梯度消除和插值方法</li>
</ul></li>
<li>Hough变换检测法：主要是将图像空间中直线检测问题转换到参数空间中，通过在参数空间进行简单的累加统计完成检测任务</li>
</ol>
<h3 id="串行边界技术">串行边界技术</h3>
<ol type="1">
<li>目标：并行处理受噪声影响效果变差，串行方法将检测边缘和连接边缘结合起来完成</li>
<li>图搜索方法：边界点和边界段采用图结构表示，选定一边界段定理描述代价，组成完成边界的边界段集合计算总代价，最小代价的边界段集合就是结果</li>
</ol>
<h3 id="并行区域技术">并行区域技术</h3>
<ol type="1">
<li>原理与分类
<ul>
<li>区域分割：不同区域有不同的灰度特征，根据灰度特征进行区域划分，最简单的是灰度阈值法，也被叫做二值化分割方法，其根据灰度阈值将区域划分为灰度极大值和极小值</li>
<li>取阈值分割步骤:确定阈值，根据阈值对象素进行分类</li>
<li>阈值分割方法分类：全局/局部/动态阈值方法</li>
</ul></li>
<li>依赖象素的阈值选择
<ul>
<li>最小值点阈值：将直方图包络看为一条曲线，求曲线极小值</li>
<li>最优阈值：主要是最小误差阈值</li>
</ul></li>
<li>依赖区域的阈值选择：主要根据直方图来选择，低梯度象素直方图没有边界象素干扰，只有目标背景两个区域，高梯度象素直方图只有边界像素，峰就是边界所在</li>
<li>依赖坐标的阈值选取：主要使用与坐标相关的一系列阈值对图像分割，基本思路是把图像分解为一系列子图像，然后对每个子图像计算一个阈值，对这些子图像阈值插值，用插值结果分割</li>
<li>ostu法：大津法（OTSU）是图像分割中阈值选取的最佳算法，它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量,背景和前景之间的类间方差越大,说明构成图像的两部分的差别越大,当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。优点为计算简单快速，不受图像亮度对比度影响，缺点是对图像噪声敏感，只能针对单一目标分割，当目标和背景大小比例悬殊时效果不好。</li>
</ol>
<h3 id="串行区域技术">串行区域技术</h3>
<ol type="1">
<li>特点：从区域着手顺序进行分析，当前处理借助早期结果，优点是抗噪声抗干扰，缺点是复杂耗时，主要技术包括区域生长和分裂合并</li>
<li>区域生长：
<ul>
<li>思路：将相似象素结合起来构成区域</li>
<li>基本步骤：选择区域的种子象素，确定将相邻象素包括进来的准则，制定生长停止的规则</li>
</ul></li>
<li>分裂合并：
<ul>
<li>思路：首先将图像分割为初始区域，然后分类合并这些区域直到获得均匀区域为止</li>
<li>基本步骤：初始分割，计算区域方差，将方差大的区域继续划分，方差小的区域和邻域比较考虑合并</li>
</ul></li>
</ol>
<h3 id="基于形态学分水岭的分割">基于形态学分水岭的分割</h3>
<ol type="1">
<li>基本概念：用地形学理解图像中目标，汇水盆地类比目标(均匀低灰度区)，分水岭类比分割线(突变的高灰度区)</li>
<li>操作步骤：彩色图像灰度化，然后再求梯度图，最后在梯度图的基础上进行分水岭 算法，求得分段图像的边缘线</li>
<li>思想：在梯度图像上分析，梯度值低的位置为中心，逐步向周边高梯度位置扩散，遇到多区域交汇的位置就形成分割边界</li>
<li>问题：对噪声敏感，易过分割，太多分割区域导致结果没使用价值</li>
<li>解决方法：对梯度图像先滤波，应用标记方法</li>
</ol>
<h2 id="第十一章表示和描述">第十一章：表示和描述</h2>
<h3 id="边界的表达">边界的表达</h3>
<ol type="1">
<li>边界的链码：
<ul>
<li>本质：是对轮廓点的一种编码</li>
<li>特点：由一系列直线段构成，边界走向和采用的连接表达方式有关--4-连接，8-连接</li>
<li>表达方法：编码顺序采用顺时针方向，起点采用(绝对)坐标表示，其余点采用接续方向代表，</li>
<li>示例：<img src="/2024/05/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-05-31-11-27-25.png"></li>
</ul></li>
<li>链码归一化：原因是不进行归一化，同一个目标因为起点不同，链码不同，对目标表达一致性受到影响，归一化手段：链码看作一个循环序列，依次取各个边界作为起点，从所有链码中选取构成自然数值最小的码，作为归一化结果</li>
<li>差分码：采用一阶差分表示，注意第一个差分码是相对于最后一个码的差分，结果都按方向数取模，其可以保证不随轮廓的选择而变化</li>
</ol>
<h3 id="区域的表达">区域的表达</h3>
<ol type="1">
<li>空间占有数组：就是目标的二值化表达，属于区域象素为1，否则为0</li>
<li>四叉树表达：采用四叉树对空间占有数组有效编码，背景为白节点，目标黑节点，混合灰节点</li>
<li>骨架：对于区域中的点在区域中有多于一个的最短距离，该点就是骨架点</li>
</ol>
<h3 id="边界的描述">边界的描述</h3>
<ol type="1">
<li>形状数：基于链码的一种边界形状表达，为链码差分码中取值最小的序列</li>
</ol>
<h3 id="区域的描述">区域的描述</h3>
<ol type="1">
<li>拓扑描述：可以描述区域全局情况，不受畸变影响，描述参数：欧拉数E=区域内连通组元C-区域孔数H</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2022/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>首先堆又被称为完全二叉堆，因为它是一种逻辑上基于完全二叉树，物理上基于线性数据结构(如数组，链表等)的数据结构，堆根据其有序性可以被分为两种：大根堆(最大堆)-大根堆在逻辑上二叉树结构中满足根节点&gt;子节点，小根堆(最小堆)-小根堆在逻辑上二叉树结构满足根节点&lt;子节点</p>
<span id="more"></span>
<h1 id="常见应用">常见应用</h1>
<ol type="1">
<li>利用堆的性质找出一个序列中最大最小的元素</li>
<li>堆排序</li>
<li>建立优先级队列，快速获取队列中优先级最高</li>
<li>在n个元素中排出前k大元素的问题，可以建立一个小根堆，依次读入n个元素并调整，当堆的规模达到k+1时，剔除第一个元素，剩下k个较大元素，保持堆的规模不超过k，然后一直循环</li>
</ol>
<h1 id="具体操作">具体操作</h1>
<p>下面介绍的操作以大根堆为例</p>
<h2 id="堆的插入">堆的插入</h2>
<p>每次插入都先将新数据放在数组最后，由于从这个新数据的父节点到根节点必然为一个有序的序列，在插入后，我们需要从下而上依次比较使堆整体有序，比如我们有这样一个堆数组[10,7,2,5,1]，下面我们往这个堆插入16，具体流程图如下 <img src="https://s2.loli.net/2022/04/10/p2vDjPuXJs3iS6M.png" alt="堆示意图.png"></p>
<h2 id="堆的删除">堆的删除</h2>
<p>堆中删除需要把最后一个数据的值赋给根节点，然后再从根节点开始开始从上而下的调整，再从根节点开始进行一次从上向下调整，不断将根节点与其子节点比较调整直到堆恢复有序，下面，我们还是以堆数组[10,7,2,5,1]为例，下面我们删除10，具体流程图如下 <img src="https://s2.loli.net/2022/04/10/AkqT9yxutWCc2LM.png" alt="堆示意图2.png"></p>
<h1 id="堆的实现代码">堆的实现代码</h1>
<p>由于最近在学python，所以使用python代码实现，其他版本请百度,同时，因为最大堆和最小堆实现方式类似，下面我们只给出最大堆代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Array(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Achieve an Array by Python list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, size = 32):</span><br><span class="line">        self._size = size</span><br><span class="line">        self._items = [None] * size</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get items</span><br><span class="line">        :param index: get a value by index</span><br><span class="line">        :return: value</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._items[index]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, index, value):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        set item</span><br><span class="line">        :param index: giving a index you want to teset</span><br><span class="line">        :param value: the value you want to set</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._items[index] = value</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :return: the length of array</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._size</span><br><span class="line"></span><br><span class="line">    def clear(self, value=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        clear the Array</span><br><span class="line">        :param value: set all value to None</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for i in range(self._size):</span><br><span class="line">            self._items[i] = value</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        for item in self._items:</span><br><span class="line">            yield item</span><br><span class="line">          </span><br><span class="line">class MaxHeap(object):</span><br><span class="line">    def __init__(self, maxsize=None):</span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self._elements = Array(maxsize)</span><br><span class="line">        self._count = 0</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return self._count</span><br><span class="line"></span><br><span class="line">    def add(self, value):</span><br><span class="line">        if self._count &gt;= self.maxsize:</span><br><span class="line">            raise Exception(&#x27;full&#x27;)</span><br><span class="line">        self._elements[self._count] = value</span><br><span class="line">        self._count += 1</span><br><span class="line">        self._siftup(self._count-1)  # 维持堆的特性</span><br><span class="line"></span><br><span class="line">    def _siftup(self, ndx):</span><br><span class="line">        if ndx &gt; 0:</span><br><span class="line">            parent = int((ndx-1)/2)</span><br><span class="line">            if self._elements[ndx] &gt; self._elements[parent]:    # 如果插入的值大于 parent，一直交换</span><br><span class="line">                self._elements[ndx], self._elements[parent] = self._elements[parent], self._elements[ndx]</span><br><span class="line">                self._siftup(parent)    # 递归</span><br><span class="line"></span><br><span class="line">    def extract(self):</span><br><span class="line">        if self._count &lt;= 0:</span><br><span class="line">            raise Exception(&#x27;empty&#x27;)</span><br><span class="line">        value = self._elements[0]    # 保存 root 值</span><br><span class="line">        self._count -= 1</span><br><span class="line">        self._elements[0] = self._elements[self._count]    # 最右下的节点放到root后siftDown</span><br><span class="line">        self._siftdown(0)    # 维持堆特性</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def _siftdown(self, ndx):</span><br><span class="line">        left = 2 * ndx + 1</span><br><span class="line">        right = 2 * ndx + 2</span><br><span class="line">        # determine which node contains the larger value</span><br><span class="line">        largest = ndx</span><br><span class="line">        if (left &lt; self._count and     # 有左孩子</span><br><span class="line">                self._elements[left] &gt;= self._elements[largest] and</span><br><span class="line">                self._elements[left] &gt;= self._elements[right]):  # 原书这个地方没写实际上找的未必是largest</span><br><span class="line">            largest = left</span><br><span class="line">        elif right &lt; self._count and self._elements[right] &gt;= self._elements[largest]:</span><br><span class="line">            largest = right</span><br><span class="line">        if largest != ndx:</span><br><span class="line">            self._elements[ndx], self._elements[largest] = self._elements[largest], self._elements[ndx]</span><br><span class="line">            self._siftdown(largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_maxheap():</span><br><span class="line">    import random</span><br><span class="line">    n = 5</span><br><span class="line">    h = MaxHeap(n)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        h.add(i)</span><br><span class="line">    for i in reversed(range(n)):</span><br><span class="line">        assert i == h.extract()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="python中heapq模板">Python中heapq模板</h1>
<p>Python中创建一个堆可以直接使用list的创建方式H = [], 或者使用heapify()函数将一个存在的列表转为堆。</p>
<p>这个模块提供了下面几种堆的操作： heapq.heappush(heap, item) 往堆中插入一个值，同时要保持为最小堆。</p>
<p>heapq.heappop(heap) 返回堆中的最小值，并把它从堆中删除，同时保持为最小堆；如果堆为空，发生 IndexError。直接通过heap[0]可以获取最小值并不从堆中把它删除。</p>
<p>heapq.heappushpop(heap, item) 向堆中插入值后再弹出堆中的最小值，这个函数的速度比直接使用heappush() 和heappop()的效率更加高。</p>
<p>heapq.heapreplace(heap, item) 弹出和返回堆中的最小值再插入一个新的值。堆的大小没有改变。如果堆为空，产生 IndexError。 这一个操作也比直接使用heappush() 和heappop()的效率更加高，尤其适合使用在固定堆大小不变的情况。 与上一个函数相比，这个函数返回的值可能要比将要插入到堆的值大。</p>
<p>heapq.heapify(x) 将一个list转为最小堆，线性时间复杂度，O(n).</p>
<h1 id="重要应用-堆排序">重要应用-堆排序</h1>
<h2 id="简述-1">简述</h2>
<p>堆排序主要分为两个步骤</p>
<ol type="1">
<li>建堆
<ul>
<li>升序：建大堆</li>
<li>降序：建小堆</li>
</ul></li>
<li>利用堆删除的思想来排序，建堆和堆删除中都用到了向下调整，所以关键是要掌握向下调整 下面以升序为例简述下堆排序的流程：</li>
</ol>
<ul>
<li>首先应该建一个大堆，不能直接使用堆来实现，可以将需要排序的数组看作是一个堆，但需要把数组结构变为堆</li>
<li>从堆倒数第二行最右边开始依次往下调整直到调整到堆顶，这样就可以把数组调整成一个堆</li>
<li>然后按照堆删的思想将堆顶域堆底的数据交换，不同的是这里不删除最后一个元素</li>
<li>这样一来最大元素就在最后一个位置，然后从堆顶向下调整到倒数第二个元素，这样次大元素在堆顶，重复到只剩堆顶为止 流程图如下： <img src="https://s2.loli.net/2022/05/18/EewJOgZ5jr32a7p.gif" alt="堆排序示例.gif"></li>
</ul>
<h2 id="实现代码">实现代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 堆排序</span><br><span class="line">void AdjustDown(int* a, int n, int root)//向下调整</span><br><span class="line">&#123;</span><br><span class="line">	assert(a);</span><br><span class="line">	int parent = root;</span><br><span class="line">	int child = parent * 2 + 1;</span><br><span class="line">	while (child &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child])</span><br><span class="line">		&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[child] &gt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			Swap(&amp;a[child], &amp;a[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * 2 + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void HeapSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	assert(a);</span><br><span class="line"> </span><br><span class="line">    //建堆</span><br><span class="line">	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		AdjustDown(a, n, i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //交换</span><br><span class="line">	for (int i = n - 1; i &gt; 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		Swap(&amp;a[i], &amp;a[0]);</span><br><span class="line">		AdjustDown(a, i, 0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体应用">具体应用</h2>
<p>给定数组{33,44,21,8,19,123,46,78,11}如何求解其第一趟堆排序后的结果？ <img src="https://s2.loli.net/2022/05/18/Fad4QHSLjnrvOUE.png" alt="堆排序.png"></p>
<h2 id="总结">总结</h2>
<p>从上面的例子，我们可以看出，其实堆排序就是在树形结构下对父子节点不断进行交换，选出最大的放在堆顶，然后将对堆顶元素与堆底倒数第x个元素交换(x为当前循环趟数)，这样就起到了一趟选出一个剩余数组中最大值并放于剩余数组末尾的目的。它的特点是，一趟排序就能确定一个元素的最终位置，因为用了二叉树结构进行辅助排序，其时间复杂度显然为O(logn)</p>
<h1 id="leetcode例题">leetcode例题</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-product-after-k-increments/">6039-K次增加后的最大乘积</a></p>
<p>参考资料： <a href="https://blog.csdn.net/xiaomucgwlmx/article/details/103522410">OH,CGWLMXUP的博客</a> <a href="https://blog.csdn.net/qq_23869697/article/details/82735088">西檬饭的博客</a> <a href="https://blog.csdn.net/Edward_Asia/article/details/121419975">风继续吹TT的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模笔记</title>
    <url>/2022/12/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数学建模笔记姜启源">数学建模笔记（姜启源）</h1>
<h2 id="线性规划">线性规划</h2>
<ol type="1">
<li>定义： 在一组线性条件限制下，求一线性目标函数最大或最小的问题</li>
<li>标准的matlab形式：<span class="math inline">\(min f^T x,\)</span> <span class="math inline">\(s.t. \begin{cases} A\cdot x \le b\\ Aeq \cdot x = beq \\ lb \le x \le ub \end{cases}\)</span> 其中<span class="math inline">\(f,x,b,beq,lb,u\)</span>为列向量，<span class="math inline">\(A，Aeq\)</span>为矩阵</li>
<li>matlab相关求解命令为 <span class="math inline">\([x,val]=linprog(f,A,b,Aeq,beq,lb,ub)\)</span></li>
</ol>
<span id="more"></span>
<h2 id="整数规划">整数规划</h2>
<ol type="1">
<li>定义： 数学规划中的变量（部分或全部）限制为整数时，称为整数规划</li>
<li>分类： 根据变量整数是部分还是全部可分为纯整数规划和混合整数规划</li>
<li>求解方法：
<ol type="1">
<li>分支定界法（纯或混）</li>
<li>割平面法（纯或混）</li>
<li>隐枚举法（01规划）
<ul>
<li>过滤隐枚举法</li>
<li>分支隐枚举法</li>
</ul></li>
<li>匈牙利法（指派问题）</li>
<li>蒙特卡洛法（各种类型）</li>
</ol></li>
</ol>
<h3 id="型整数规划">0-1型整数规划</h3>
<ol type="1">
<li>定义：整数规划的一种特殊情况，变量仅取值0或1 应用范围可分为以下几种情况</li>
</ol>
<h4 id="相互排斥的约束条件">相互排斥的约束条件</h4>
<p>也就是说题目中的某一种条件只有一个量，如果给了这个1，同类的都为0，较为典型的问题有运输问题，只用一种方式运输，用火车运了，其他的运输栏都为0，其约束条件可进一步简化为 <span class="math inline">\(y_i=\begin{cases} 1,第i个元素起约束作用\\ 0,第i个元素不起作用，i=1,2.....,m\\ \end{cases}\)</span> $a_{i1}x_1+...a_{in}x_nb_i+(1-y_i)M,i=1,2...,m,\ y_1++y_m=1 $ 由约束条件很容易看出，当<span class="math inline">\(y_i\)</span>等于1,就只有这个约束起作用，其他的都是多余的</p>
<h4 id="固定费用的问题">固定费用的问题</h4>
<p>在讨论线性规划时，有些问题要求固定费用，这种问题可以通过改变为混合整数规划来解决，数学模型可表示为 <span class="math inline">\(y_i\epsilon\le x_i\le y_i M\)</span> 其中<span class="math inline">\(\epsilon\)</span>为充分小的正常数；M为充分大的正常数，表明<span class="math inline">\(x_i&gt;0\)</span>时，<span class="math inline">\(y_i\)</span>必须为1，<span class="math inline">\(x_i=0\)</span>时<span class="math inline">\(y_i\)</span>必须为0 <span class="math inline">\(【x_i】\)</span>表示采用i方式生产时产量，<span class="math inline">\(y_i\)</span>表示是否用第i种方式生产</p>
<h4 id="指派问题">指派问题</h4>
<p>指派问题描述的是分配n个人去做n件事情，每个人做且仅做一件事情，且分配第i个人去做第j件事情，花费<span class="math inline">\(C_{ij}\)</span>单位时间，求如何分配使总时间最小，这类问题的关键就是要求出分配矩阵，数学形式可表现为 <span class="math inline">\(x_{ij}=\begin{cases} 1,第i人做第j项工作\\ 0,第i人做第j项工作\\ \end{cases}\)</span> 数学模型为：<span class="math inline">\(min \sum_{i=1}^N \sum_{j=1}^N c_{ij}x_{ij}\)</span> <span class="math inline">\(s.t. \begin{cases}  \sum_{i=1}^N x_{ij}=1,i=1,2,...,n\\  \sum_{j=1}^N x_{ij}=1,j=1,2,...,n\\  x_{ij}=0 or 1,i,j=1,...,n  \end{cases}\)</span></p>
<h3 id="蒙特卡洛法随机取样法">蒙特卡洛法（随机取样法）</h3>
<ol type="1">
<li>又被称为计算机随机模拟法，它是基于对大量数据的统计结果来实现一些确定性问题的计算</li>
<li>使用该方法必须使用计算机生成相关分布的随机数</li>
</ol>
<h3 id="整数线性规划的计算机求解">整数线性规划的计算机求解</h3>
<ol type="1">
<li>整数规划的求解用Lingo等专用软件比较方便，对于整数线性规划也可以用matlab的intlinprog函数求解，<strong>但其的缺点是必须把所有的决策变量化为一维决策变量，变量替换后，约束条件很难写出</strong>，最好用lingo</li>
<li>matlab求解混合整数线性规划的命令是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【x,fval】=intlinprog(f,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> 对应以下数学模型 <span class="math inline">\(min_x f^Tx,\)</span> <span class="math inline">\(s.t. \begin{cases} x(intcon)为整数\\ A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb \le x \le ub \\ \end{cases}\)</span> 式中：<span class="math inline">\(f,x,intcon,b,beq,lb,ub为列向量；A，Aeq为矩阵\)</span></li>
</ol>
<h2 id="非线性规划">非线性规划</h2>
<h3 id="非线性规划模型">非线性规划模型</h3>
<ol type="1">
<li>定义：如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题</li>
<li>通过投资决策问题归纳非线性规划数学模型的一般形式 总资金A元，投资第i个项目花<span class="math inline">\(a_i\)</span>元，预计可收益<span class="math inline">\(b_i\)</span>元 选择最佳投资方案 投资决策变量 <span class="math inline">\(x_i=\begin{cases} 1,决定投资第i个项目\\ 0,决定不投资第i个项目\\ \end{cases}\)</span> 则该模型可用下列数学模型表示 <span class="math inline">\(max\, Q = \frac{\sum_{i=1}^n b_i x_i} {\sum_{i=1}^n a_i x_i} s.t. \begin{cases} 0 &lt; \sum_{i=1}^n a_i x_i \le A ,\\ x_i(1-x_i)=0,i=1,...,n\\ \end{cases}\)</span></li>
<li>根据2中例题，非线性规划问题可进一步概括为： <span class="math inline">\(min\,f(x)\\ s.t. \begin{cases} h_j(x)\le0,j=1,2,...,q\\ g_i(x)=0,i=1,2,...,p\\ \end{cases}\)</span> 其中<span class="math inline">\(x=[x_1,...,x_n]^T\)</span>为模型的决策变量，<span class="math inline">\(f\)</span>为目标函数，<span class="math inline">\(g_i和h_j\)</span>为约束函数，<span class="math inline">\(g_i(x)=0\)</span>为等式约束，<span class="math inline">\(h_j(x)\le0\)</span>为不等式约束</li>
<li>对一个实际问题，要将其规为非线性规划问题时，一般要注意以下几点
<ol type="1">
<li>确定供选方案</li>
<li>提出追求目标</li>
<li>给出价值标准</li>
<li>寻求限制条件</li>
</ol></li>
<li>线性规划与非线性规划的区别：线性规划最优解只能在可行域的边界上达到（特别是顶点），而非线性规划最优解可在可行域任一点达到</li>
<li>非线性规划的matlab表示 <span class="math inline">\(minf(x)\\ s.t. \begin{cases} A\cdot x \le b,\\ Aeq \cdot x=beq,\\ c(x)\le0\\ ceq(x)=0,\\ lb\le x \le ub \end{cases}\)</span> 式中的<span class="math inline">\(f(x)\)</span>为标量函数，<span class="math inline">\(A,b,Aeq,beq,lb,ub\)</span>为相应维数的矩阵和向量，<span class="math inline">\(c(x),ceq(x)\)</span>为非线性向量函数 matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br><span class="line"># x返回决策变量x的取值，fval返回目标函数取值，fun是M文件自定义函数f(x),x0是x的初始值</span><br><span class="line">nonlcon是用M文件定义的c(x)ceq(x)，options定义优化参数</span><br></pre></td></tr></table></figure> ### 无约束问题的Matlab解法</li>
<li>在matlab工具箱中，用于求无约束极小值的函数有fminunc和fminsearch，用法分别为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminunc(fun,x0,options)</span><br><span class="line">[x,fval]=fminsearch(fun,x0,options) #只能求初始值附近的一个极小值点</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="约束极值问题">约束极值问题</h3>
<ol type="1">
<li>定义：带有约束条件的极值问题，也叫规划问题</li>
</ol>
<h4 id="二次规划">二次规划</h4>
<ol type="1">
<li>定义：若某非线性规划的目标函数为自变量x的二次函数，约束条件又全为线性的，称这种规划为二次规划</li>
<li>Matlab中二次规划的数学模型可表述为 $min, x<sup>THx+f</sup>Tx,\ s.t.
<span class="math display">\[\begin{cases}
Ax\le b\\
Aeq \cdot x=beq,\\
lb\le x\le ub
\end{cases}\]</span>
H为实对称矩阵，\ $ matlab求解二次规划的命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="罚函数法">罚函数法</h4>
<ol type="1">
<li>利用罚函数法可以将非线性规划问题的求解转化为求一系列无约束极值的问题，也把这种方法叫做序列无约束最小化技术</li>
<li>罚函数求解非线性规划问题的思想是利用问题中的约束函数作出适当的罚函数，由此构造出带参数的增广目标函数，把问题转换为无约束非线性规划问题，主要有两种形式，一种叫外罚函数法，另一种叫内罚函数法</li>
<li>外罚函数法： 考虑问题：<span class="math inline">\(minf(x)\\ s.t.\begin{cases} g_i(x) \le 0,i=1,...,r\\ h_j(x) \ge 0,j=1,...,s\\ k_m(x) =0,m=1,...,t \end{cases}\)</span>取一个充分大的数M&gt;0,构造函数<span class="math inline">\(P(x,M)=f(x)+M\sum_{i=1}^nmax(g_i(x),0)-M\sum_{j=1}^nmin(h_j(x),0)+M\sum_{m=1}^n |k_m(x)|\)</span>,则以增广目标函数<span class="math inline">\(P(x,M)\)</span>为目标函数的无约束极值问题<span class="math inline">\(minP(x,M)\)</span>的最优解也是原问题的最优解</li>
<li><ol type="1">
<li>如果非线性规划问题要求实时算法，可以使用罚函数算法，但计算精度较低</li>
<li>如果不要求实时算法，要求高精度,可以使用lingo或matlab的fmincon命令求解</li>
</ol></li>
</ol>
<h4 id="matlab求约束极值问题">matlab求约束极值问题</h4>
<ol type="1">
<li>在matlab工具箱中，用于求解约束最优化问题的函数有fminbnd,fmincon,quadprog,fseminf,fminimax函数</li>
<li>fminbnd函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminbnd(fun,x1,x2,options) </span><br><span class="line"># 用于求单变量非线性函数在[x1,x2]上极小值</span><br><span class="line"># 返回极小点x和函数的极小值</span><br></pre></td></tr></table></figure></li>
<li>fseminf函数 用于求下列模型 <span class="math inline">\(minf(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)\le0\\ K_i(x,w_i)\le0,1\le i\le n \end{cases}其中c(x),ceq(x)为向量函数，K_i(x,w_i)为标量函数,w_1...为附加变量\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fseminf(fun,x0,ntheta,seminfcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure> fun定义目标函数f(x),x0为x初始值，ntheta是半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>个数，函数seminfcon用于定义非线性不等式约束<span class="math inline">\(c(x)\)</span>,非线性等式约束<span class="math inline">\(ceq(x)\)</span>和半无穷约束<span class="math inline">\(K_i(x,w_i)\)</span>的函数，seminfcon有两个输入参量x,s,s是推荐的采样步长 可以不使用</li>
<li>fminimax函数 用于求下列模型 <span class="math inline">\(min_xmax_iF_i(x),\\ s.t. \begin{cases} A \cdot x \le b,\\ Aeq \cdot x =beq,\\ lb\le x \le ub\\ c(x)\le0\\ ceq(x)=0\\ \end{cases}\)</span> matlab命令为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x,fval]=fminimax(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>次优查找树</title>
    <url>/2022/05/03/%E6%AC%A1%E4%BC%98%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="次优查找树">次优查找树</h1>
<h2 id="前言">前言</h2>
<p>关于静态查找表中对特定关键字进行顺序查找，折半查找或者分块查找，都是在查找表中各关键词被查找概率相同的前提下进行的，然而在查找表中各关键字查找概率不同的情况下，折半查找的效果其实是不好的。在查找成功的情况下，描述查找过程的判定树其带权路径长度之和（用PH表示）最小时，查找性能最优，称该二叉树为静态最优查找树 其中: PH = 所有节点所在的层次数*每个节点对应的概率值 由于构造最优查找树花费的时间代价较高，而且有一种构造方式创建的判定树的查找性能同最优查找树只差1%-2%，称这种极度接近于最优查找树的二叉树为次优查找树</p>
<span id="more"></span>
<h2 id="创建方法">创建方法</h2>
<p>首先取出标准每个关键字及其对应的权值，采用如下公式计算出每个关键字对应的一个值： <span class="math inline">\(\triangle P_i= \left|\sum\limits_{j=i+1}^hw_j-\sum\limits_{j=1}^{i-1}w_j\right|\)</span> 其中 wj 表示每个关键字的权值（被查找到的概率），h 表示关键字的个数。 表中有多少关键字，就会有多少个 △Pi ，取其中最小的做为次优查找树的根结点，然后将表中关键字从第 i 个关键字的位置分成两部分，分别作为该根结点的左子树和右子树。同理，左子树和右子树也这么处理，直到最后构成次优查找树完成。 ## 代码实现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int KeyType;　　// 定义关键字类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ElemType;　　// 定义元素类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">// 定义变量</span><br><span class="line">int i;</span><br><span class="line">int min;</span><br><span class="line">int dw;</span><br><span class="line"></span><br><span class="line">//创建次优查找树，R数组为查找表，sw数组为存储的各关键字的概率（权值），low和high表示的sw数组中的权值的范围</span><br><span class="line">void SecondOptimal(BiTree T, ElemType R[], float sw[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    // 由有序表R[low...high]及其累计权值表sw（其中sw[0]==0）递归构造次优查找树</span><br><span class="line">    i = low;</span><br><span class="line">    min = abs(sw[high] - sw[low]);</span><br><span class="line">    dw = sw[high] + sw[low - 1];</span><br><span class="line">    // 选择最小的△Pi值</span><br><span class="line">    for (int j = low+1; j &lt;=high; j++)</span><br><span class="line">　　&#123;</span><br><span class="line">        if (abs(dw - sw[j] - sw[j-1]) &lt; min)</span><br><span class="line">　　　　 &#123;</span><br><span class="line">            i = j;</span><br><span class="line">            min = abs(dw - sw[j] - sw[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    T = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">    T-&gt;data = R[i];　　// 生成结点（第一次生成根）</span><br><span class="line">    if (i == low) </span><br><span class="line">　　 　　T-&gt;lchild = NULL;　　// 左子树空</span><br><span class="line">    else SecondOptimal(T-&gt;lchild, R, sw, low, i - 1);　　// 构造左子树</span><br><span class="line">    if (i == high) </span><br><span class="line">　　 　　T-&gt;rchild = NULL;　　//右子树空</span><br><span class="line">    else </span><br><span class="line">　　　　SecondOptimal(T-&gt;rchild, R, sw, i + 1, high);　　//构造右子树   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 具体实例 <img src="https://s2.loli.net/2022/05/03/PduZa8y5MegBIEp.png" alt="次优生成树.png"> <strong>注意</strong> 在建立次优查找树时，由于只根据各关键字的P的值进行构建，没有考虑单个关键字的相应权值大小，有时会出现根节点权值比孩子节点权值还小，这时需要适当调整二者位置</p>
<h2 id="总结">总结</h2>
<p>由于使用次优查找树和最优查找树的性能差距很小，构造次优查找树的算法的时间复杂度为 O(nlogn)，因此可以使用次优查找树表示概率不等的查找表对应的静态查找表（又称为静态树表）。 ## 参考资料 <a href="https://www.cnblogs.com/lishanlei/p/10707664.html">如是说的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树(Prim算法，Kruskcal算法)</title>
    <url>/2022/05/11/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>最小生成树由一个经典的架电线的问题引出：在n个村庄间架电线，现在已经知道各村庄的相对距离，如果你是工程师，请问如何设计能使得总造价最小</p>
<h2 id="解决思路">解决思路</h2>
<p>首先可以分析得到这显然是一个带权值的图，即网结构，我们的目标可以抽象为用n-1条边把一个连通图连接起来，并使得权值最小，这就是我们常说的最小生成树问题，最经典的两种算法是：prim算法和kruskcal算法，下文将一一介绍 <img src="https://s2.loli.net/2022/05/12/9SoUqmLdXEpjTGz.png" alt="最小生成树.png"></p>
<span id="more"></span>
<h2 id="prim算法">prim算法</h2>
<h3 id="算法思路">算法思路</h3>
<p><strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，因为这里涉及到顶点与顶点的带权值边信息，所以我们考虑使用邻接矩阵作为储存结构来实现，如果不清楚邻接矩阵，请戳<a href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> <img src="https://s2.loli.net/2022/05/12/4B8ck6RtxqHmw9u.png" alt="最小生成树-邻接矩阵.png"> 这样一来，我们已经有了一个以邻接矩阵为存储结构的网，我们下面该如何求最小生成树呢?其实很简单，我们在prim算法的开头就说过，<strong>该算法的核心是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树</strong>，我们就先去一个顶点来研究，默认为v0，然后把v0在邻接矩阵中所对应的那一行信息取出(用一个lowcost数组保存)，目的是研究以v0为起点，与其相连最近的顶点。然后我们遍历一遍lowcost数组，找到其数组中除了本节点(即v0-0)外的最小值，记录下它的值与下标-<em>此时的low cost数组中lowcost[0]=0,表示该位置对应节点已加入最小生成树</em>，连接该下标所对应的顶点与v0，构成第一条电线，在这里对应的是v1，在找到v1后，我们把lowcost该位置的值设为0，表示该节点已经被纳入了最小生成树，然后我们再去取出v1在邻接矩阵中对应行的信息，将其与lowcost数组的对应值相比较，若更小则修改lowcost值，<strong>该操作的目的是找到v0,v1这两行连接信息中的最小值来形成第二根电线</strong>，接下来的操作也和上面的操作类似了，直到所有节点都添加到最小生成树中，lowcost数组全部置为0，表明最小生成树生成完毕。</p>
<h3 id="实现代码">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Prim算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree_Prim(MGraph G)&#123;</span><br><span class="line">	int min, i, j, k;</span><br><span class="line">	int adjvex[MAXVEX];	//保存相关顶点下标</span><br><span class="line">	int lowcost[MAXVEX];	//保存相关顶点间边的权值</span><br><span class="line">	lowcast[0] = 0;	//初始化第一个权值为0，即v0加入生成树，lowcost的值为0，在这里就是此下标的顶点已经加入生成树</span><br><span class="line">	adjvex[0] = 0;	//初始化第一个顶点下标为0</span><br><span class="line">	for(i = 1;i&lt;G.numVertexes;i++)&#123;	//循环除下标为0外的全部顶点</span><br><span class="line">		lowcost[i] = G.arc[0][i];		//将v0顶点与之有边的权值存入数组</span><br><span class="line">		adjvex[i] = 0;	//初始化都为v0的下标</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=1;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">		min = INFINITY;	//初始化最小权值为无穷大，通常设置为很大的数字</span><br><span class="line">		j = 1;</span><br><span class="line">		k = 0;</span><br><span class="line">		while(j&lt;G.numVertexes)&#123;		//循环全部顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min)&#123;	//如果权值不为0且权值小于min</span><br><span class="line">				min = lowcost[j];		//让当前权值成为最小值</span><br><span class="line">				k = j;		//将当前最小值的下标存入k</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;(%d,%d)&quot;,adjvex[k],k);	//打印当前顶点边中权值最小边</span><br><span class="line">		lowcost[k] = 0;	//将当前顶点的权值设置为0，表示此顶点已经完成任务</span><br><span class="line">		for(j=1;j&lt;G.numVertexes;j++)&#123;	//循环所有顶点</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;	//若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值</span><br><span class="line">				lowcost[j] = G.arc[k][j];		//将较小权值存入lowcost</span><br><span class="line">				adjvex[j] = k;	//将下标为k的顶点存入adjvex</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由算法代码中的循环嵌套可知该算法时间复杂度为O(<span class="math inline">\(n^2\)</span>)</p>
<h2 id="kruskal算法">Kruskal算法</h2>
<h3 id="算法思路-1">算法思路</h3>
<p>与prim算法不同的是，prim算法以顶点为目标构造最小生成树，而Kruskal算法直接以边的目标去构造，每次找最小权值的边来构成最小生成树，但是，<strong>因为我们在构建时是以边为目标，必须要考虑边的闭环问题,因为可能出现要铺设九个村庄的电线，但在三个村庄间就出现了闭环，导致存在环与环之间无法互联的现象，这个问题出现的原因是因为我们如果只研究边的权值大小，会忽略顶点与顶点互联的要求</strong>，因为是对边的权值大小直接进行研究，这里我们最好使用边集数组作为存储结构，不会请戳<a href="https://xiazhi.icu/2022/05/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">图的存储结构</a> 这里我们需要先将边集数组按照权值从小到大进行下转换。 <img src="https://s2.loli.net/2022/05/12/n4ofahW37AziSxJ.png" alt="最小生成树-边集数组.png"> 我们对边集数组做循环遍历，每当你要添加一个边时，必须先调用一个find函数来判断该边对应的起点和终点在当前的最小生成树数组中是否会构成闭环，如果会，则舍弃接着往后，不会则添加，这个find函数借助了一个parent数组，我们将其初始化为0，每当添加一条边，就将对应起点的parent数组值修改为该边的终点，然后find函数判断连线顶点的尾部下标，如果和原来尾部对应下标经find函数处理返回值一致，说明形成了环，舍弃该边</p>
<h3 id="实现代码-1">实现代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* kruskal算法生成最小生成树 */</span><br><span class="line">void MiniSpanTree(MGraph G)&#123;	//生成最小生成树</span><br><span class="line">	int i, n, m;</span><br><span class="line">	Edge edges[MAXEDGE];	//定义边集数组</span><br><span class="line">	int parent[MAXVEX];	//定义一数组用来判断边与边是否形成环路</span><br><span class="line">	/* 此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码 */</span><br><span class="line">	for(i = 0;i&lt;G.numVertexes;i++)</span><br><span class="line">		parent[i] = 0;	//初始化数组值为0</span><br><span class="line">	for(i = 0;i&lt;G.numEdges;i++)&#123;	//循环每一条边</span><br><span class="line">		n = Find(parent, edges[i].begin);</span><br><span class="line">		m = Find(parent, edges[i].end);</span><br><span class="line">		if(n != m)&#123;		//假如n与m不等，说明此边没有与现有生成树形成环路</span><br><span class="line">			parent[n] = m;	//将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中</span><br><span class="line">			printf(&quot;(%d,%d) %d&quot;, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int* parent, int f)&#123;	//查找连线顶点的尾部下标</span><br><span class="line">	while(parent[f] &gt; 0)</span><br><span class="line">		f = parent[f];</span><br><span class="line">	return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为O(eloge),e为边数</p>
<h2 id="总结">总结</h2>
<p>对比两个算法来说，Kruskcal算法主要针对边来展开，边数少的时候效率会非常高，对于稀疏图有很大的优势，而Prim算法对于稠密图，边上非常多的情况会更好一些(个人认为是因为边数少是Kruskcal出现闭环的可能性小，在这种情况下，其效率会比Prim算法高很多，然后边数多了以后，出现闭环的可能性大大增加，导致其效率反而不如Prim算法了)</p>
<h2 id="参考资料">参考资料</h2>
<p>《大话数据结构》程杰</p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵的三元组表示</title>
    <url>/2022/05/17/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>在学习邻接矩阵时，我们会发现一个有意思的现象，有时100*100的矩阵中只储存了10个数据，我们把这种矩阵称为稀疏矩阵，其适用于一个阶数较大的矩阵中的非零元素个数相对于矩阵元素的总个数很小，如果这种稀疏矩阵用邻接矩阵来储存，这是浪费了很多空间的，那么我们应当如何在保留其矩阵信息的前提下，用一个好的结构来节省空间的开支呢？ <span id="more"></span> # 三元组 ## 定义 三元组是一种稀疏矩阵的压缩储存方式，其储存策略是只储存非零元素，它的储存方案是： 1. 储存非零元素 2. 同时储存该非零元素所对应的行下标和列下标 3. 稀疏矩阵中的每一个非零元素由一个三元组元素唯一确定，稀疏矩阵的所有非零元素构成三元组线性表，三元组的i为行下标，j为列下标，data域是对应的元素值 <img src="https://s2.loli.net/2022/05/17/iWxeFrpmwKM6jOB.png" alt="三元组.png"> ## 储存结构 下面直接上代码，注释写的比较清楚 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 100</span><br><span class="line"></span><br><span class="line">//定义三元组线性表中的数据元素存储结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int row;        //行号</span><br><span class="line">    int col;        //列号</span><br><span class="line">    ElemType d;     //元素值，ElemType为数据元素类型</span><br><span class="line"></span><br><span class="line">&#125; TupNode; //三元组定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义三元组线性表存储结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int rows;                   //行数值</span><br><span class="line">    int cols;                   //列数值</span><br><span class="line">    int nums;                   //非零元素个数</span><br><span class="line">    TupNode data[MaxSize];      //data数据域</span><br><span class="line"></span><br><span class="line">&#125; TSMatrix; //三元组顺序表定义</span><br></pre></td></tr></table></figure> ## 基本运算 ### 扫描二维矩阵，创建三元组 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以行序方式扫描二维矩阵A，将其非零的元素加入到三元组t</span><br><span class="line">//以3行4列的稀疏矩阵为例</span><br><span class="line">void CreatMat(TSMatrix *t, int arr[3][4])</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j;</span><br><span class="line">    t-&gt;rows = 3;</span><br><span class="line">    t-&gt;cols = 4;</span><br><span class="line">    t-&gt;nums = 0;</span><br><span class="line"></span><br><span class="line">    //扫描矩阵中的非零元素</span><br><span class="line">    for(i = 0; i &lt; 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; 4; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            //只存非零值，以三元组方式</span><br><span class="line">            if(arr[i][j] != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;data[t-&gt;nums].row = i;</span><br><span class="line">                t-&gt;data[t-&gt;nums].col = j;</span><br><span class="line">                t-&gt;data[t-&gt;nums].d = arr[i][j];</span><br><span class="line">                t-&gt;nums++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 将三元组指定位置元素值赋给对象 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将三元组线性表中指定位置的元素值赋值给变量x</span><br><span class="line">void arr_Assign(TSMatrix t , int *data , int i , int j)</span><br><span class="line">&#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    //i和j是否合法</span><br><span class="line">    if(i &gt;= t.rows || j &gt;= t.cols)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找到指定元素的行下标</span><br><span class="line">    while(k &lt; t.nums &amp;&amp; i &gt; t.data[k].row)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当找到指定元素的行下标后，再找到指定元素的列下标</span><br><span class="line">    while (k &lt; t.nums &amp;&amp; i == t.data[k].row &amp;&amp; j &gt; t.data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果指定元素的行和列都相等，说明找到了</span><br><span class="line">    if(t.data[k].row == i &amp;&amp; t.data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        *data = t.data[k].d;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //说明没找到</span><br><span class="line">        *data = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 对三元组元素赋值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//修改三元组元素中的值：执行A[i][j]=x</span><br><span class="line">void arr_Value(TSMatrix *t , int data , int i , int j)</span><br><span class="line">&#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    int k1;</span><br><span class="line">    //指定的行和列是否合法</span><br><span class="line">    if(i &gt;= t-&gt;rows || j &gt;= t-&gt;cols)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //先查找行</span><br><span class="line">    while(k &lt; t-&gt;nums &amp;&amp; i &gt; t-&gt;data[k].row)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找列</span><br><span class="line">    while(k &lt; t-&gt;nums &amp;&amp; i == t-&gt;data[k].row &amp;&amp; j &gt; t-&gt;data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当找到指定位置时直接修改</span><br><span class="line">    if(i == t-&gt;data[k].row &amp;&amp; j == t-&gt;data[k].col)</span><br><span class="line">    &#123;</span><br><span class="line">        t-&gt;data[k].d = data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //如果指定位置不存在，则说明该元素值为0，此时插入</span><br><span class="line">        for(k1 = t-&gt;nums; k1 &gt;= k; k1--)</span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;data[k1+1].col = t-&gt;data[k1].col;</span><br><span class="line">            t-&gt;data[k1+1].row = t-&gt;data[k1].row;</span><br><span class="line">            t-&gt;data[k1+1].d = t-&gt;data[k1].d;</span><br><span class="line">        &#125;</span><br><span class="line">        //插入数据</span><br><span class="line">        t-&gt;data[k].row = i;</span><br><span class="line">        t-&gt;data[k].col = j;</span><br><span class="line">        t-&gt;data[k].d = data;</span><br><span class="line">        t-&gt;nums++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 参考资料 <a href="https://blog.csdn.net/qq_35733751/article/details/80843589">songly_的博客</a></p>
]]></content>
      <categories>
        <category>数据结构学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络考前拾遗</title>
    <url>/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文只针对华中科技大学电子信息与通信学院计算机网络考试要求进行知识点归纳总结与提炼，内容不保证能满足各位读者的需求。</p>
<h2 id="第一章绪论">第一章：绪论</h2>
<h3 id="计算机网络的定义和发展历史了解">计算机网络的定义和发展历史(了解)</h3>
<p>网络:网络由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成</p>
<p>互联网：多个网络通过路由器互连起来，构成一个覆盖范围更大的网络，即互联网,互联网是网络的网络</p>
<p>因特网：因特网是世界上最大的互连网络</p>
<p>发展历史：计算机网络最早的起源来自美国军方搭建的APANET</p>
<span id="more"></span>
<p><strong>简答：列表对比说明互联网(Internet)和互连网(internet)两个概念的异同。</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-35-18.png"></p>
<h3 id="理解设计计算机网络的技术需求理解">理解设计计算机网络的技术需求(理解)</h3>
<ol type="1">
<li>可扩展的连通性</li>
<li>高性价比的资源共享</li>
<li>支持通用服务</li>
<li>可管理性</li>
</ol>
<h3 id="电路交换与分组交换掌握">电路交换与分组交换(掌握)</h3>
<p><strong>简答：简要说明电路交换的要点</strong></p>
<p>电路交换的要点包括:通信时需要经历三个阶段:建立连接、传送数据、释放连接;通信的双方之间需要建立一个专用的链路;通信过程中,沿着建立链路传输的数据无需路由;通信结束后,连接断开,链路资源被释放</p>
<p><strong>简答：简要说明分组交换的要点</strong></p>
<p>分组交换的要点包括:将完整的报文分割成为较小的数据段,在每个数据段前面加上必要的控制信息组成首部,就构成了分组;通信过程中,沿途交换机采用“存储-转发”方式,根据分组首部中的目的地信息进行转发;通信过程中,各数据分组被独立路由和转发。</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-20-45-41.png"></p>
<h2 id="第二章网络体系结构">第二章：网络体系结构</h2>
<h3 id="层次化体系结构的原理掌握">层次化体系结构的原理(掌握)</h3>
<p><strong>简答：简述网络体系结构采用分层设计的好处</strong></p>
<p>采用分层的网络体系结构的优势包括但不限于:</p>
<ol type="1">
<li>各层之间可以独立设计,便于分工协作,实现产业标准化;</li>
<li>层次化设计的灵活性好,一层发生变化不影响上下层;</li>
<li>层次化设计的扩展性好,各层可选用不同的技术来适应不同的应用需求。</li>
</ol>
<h3 id="网络体系结构的相关概念理解">网络体系结构的相关概念(理解)</h3>
<ol type="1">
<li>实体：任何可发送或接收数据的硬件或软件进程</li>
<li>对等实体：收发双方相同层次中的实体</li>
<li>协议：控制两个对等实体进行逻辑通信的规则的集合</li>
<li>协议的三要素：
<ol type="1">
<li>语法,即数据与控制信息的结构或格式。</li>
<li>语义,即需要发出何种控制信息、完成何种动作以及做出何种响应。</li>
<li>同步,即事件实现顺序的详细说明。</li>
</ol></li>
</ol>
<p><strong>简答：层次化网络体系结构中的服务与协议有何区别?</strong></p>
<p>层次化网络体系结构中,服务是垂直的,定义了该层能够代表它的用户完成的操作。上层是服务用户,下层是服务提供者。协议是水平的,定义的是对等实体间交换数据的格式、内容、时序,协议的实现保证了能够向上层提供服务。</p>
<h3 id="三种体系架构的模型与差异掌握">三种体系架构的模型与差异(掌握)</h3>
<figure>
<img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-00-22.png" alt="三种体系架构"><figcaption aria-hidden="true">三种体系架构</figcaption>
</figure>
<p><strong>简答：简述ISO/OSI参考模型各层功能与协议数据单元</strong></p>
<p>ISO/OSI参考模型各层功能自底向上分别为:</p>
<ol type="1">
<li>物理层:实现数据bitt在物理链路上的传输;数据单元：数据位(Bit)</li>
<li>数据链路层:处理相邻网络结点之间数据帧的传输;数据单元：数据帧</li>
<li>网络层:处理互联网络中主机之间的分组传输;数据单元：数据分组</li>
<li>传输层:实现终端主机进程之间的通信;数据单元：数据段</li>
<li>会话层:实现通信的会话管理等功能;数据单元：数据</li>
<li>表示层:实现不同表达形式数据之间的转换;数据单元：数据</li>
<li>应用层:实现应用特定操作,向用户提供相应的服务.数据单元：数据</li>
</ol>
<p><strong>简答：自上而下简述计算机网络体系结构的五层参考模型</strong></p>
<p>网络体系结构的五层模型,自上向下依次为应用层、传输层、网络层、数据链路层、物理层。</p>
<p>应用层:为用户的应用进程提供服务</p>
<p>传输层:为两个主机中进程之间的通信提供端到端服务</p>
<p>网络层:为分组交换网上的不同主机提供通信服务</p>
<p>数据链路层:在相邻结点间的链路上透明传送数据</p>
<p>物理层:在传输媒质上实现透明的比特流传送</p>
<h3 id="计算机网络的性能指标的计算方法掌握">计算机网络的性能指标的计算方法(掌握)</h3>
<p><strong>首先要区分比特和字节的概念</strong></p>
<p>1Byte(字节)=8bit(比特)</p>
<ol type="1">
<li>速率：连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率，基本单位：bit/s（bps），常用单位:kbps/Mbps <strong>这里的换算需要与计算机存储里面换算做区分，计算速率时:1k=1000,计算内存时：1k=1024</strong></li>
<li>带宽：表示网络的通信线路传送数据的能力，表示单位时间内从网络中某一点到另一点所能通过的<strong>最高数据率</strong>,单位与速率单位相同</li>
<li>吞吐量：表示单位时间内通过某个网络(或信道、接口)的数据量；用于测量实际上到底由多少数据量能通过网络，其受<strong>网络带宽或额定速率的限制</strong>,在部分习题中提出了<strong>计算网络最大吞吐率</strong>的要求：其计算公式可表述如下：<span class="math inline">\(最大吞吐量=\frac{发送窗口大小}{往返时延}\)</span></li>
<li>时延：
<ul>
<li>发送时延：<span class="math inline">\(\frac{分组长度}{发送速率}\)</span></li>
<li>传播时延：<span class="math inline">\(\frac{信道长度}{电磁波传播速率}\)</span></li>
<li>处理时延：一般不便于计算</li>
<li>排队时延：一般不考虑</li>
<li>总时延=发送时延+传播时延+处理时延+排队时延</li>
</ul></li>
<li>时延带宽积：其值等于传播时延*带宽，时延带宽积可视为以比特为单位的链路长度,等效于第一个比特到达接收方时发送方可以发送的比特数(链路满载)。</li>
<li>往返时延(RTT):链路双向交互一次的时间</li>
<li><span class="math inline">\(信道利用率=\frac{发送数据量}{信道总带宽\times往返时延}=\frac{有效传输时间}{往返传输时延（\ne RTT）}\)</span></li>
</ol>
<h2 id="第三章直连网络">第三章：直连网络</h2>
<h3 id="直连网络的概念了解">直连网络的概念(了解)</h3>
<p>直连网络：所有的主机通过某种物理媒质直接连接，是最简单的网络形式</p>
<p><strong>物理层的四个特性</strong>：</p>
<p>机械特性：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p>
<p>电气特性：指明在接口电缆的各条线上出现的电压的范围。</p>
<p>功能特性：指明某条线上出现的某一电平的电压表示何意。</p>
<p>规程特性：指明对于不同功能的各种可能事件的出现顺序。</p>
<h3 id="不同组帧方法了解">不同组帧方法(了解)</h3>
<p>组帧方法主要分为以下两种：</p>
<ol type="1">
<li>面向字节的协议：把每一帧看作一个字节集合，两种方法：字符计数法，起止标记法。</li>
<li>面向比特的协议：把数据帧看作比特的集合</li>
</ol>
<h3 id="差错控制的概念理解">差错控制的概念(理解)</h3>
<p>为什么进行差错检测？ 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错，这称为比特差错，使用差错检测码来检测是否产生比特差错，是数据链路层的重要问题之一。</p>
<p>常用的差错检测方法：</p>
<ol type="1">
<li>奇偶校验：添加一位奇偶校验位，能检测奇数个比特差错</li>
<li>循环冗余校验(CRC)：检测出一定数量的差错，其主要步骤如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-23-16.png"></li>
</ol>
<h3 id="可靠传输的概念和基本实现机制掌握">可靠传输的概念和基本实现机制(掌握)</h3>
<p>可靠传输：上文提到的比特差错只是传输差错的一种，传输差错还包括分组丢失，分组失序，分组重复</p>
<p>可靠传输的协议实现主要有以下几种：</p>
<ol type="1">
<li>停止等待协议（ARQ协议）</li>
<li>连续ARQ协议：包含两种策略：GO-BACK-N 和 选择性重传</li>
<li>滑动窗口协议</li>
</ol>
<p>停止等待协议示意图 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-40-13.png" alt="停止等待协议示意图"></p>
<p>连续ARQ协议两种策略的优缺点分析： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-44-52.png"></p>
<p><strong>注意，Go-Back-N协议如果帧序号为n个bit，其每次最多连续能传的帧数=<span class="math inline">\(2^{n}-1\)</span>，因为如果传<span class="math inline">\(2^n\)</span>个帧，如果接收方确认帧丢失，则会导致接收方无法辨别发送方发送的帧的新旧，GO-BACK-N也可以看为滑动窗口策略的一种特殊情况，即接收窗口为1</strong></p>
<p>滑动窗口协议的示意图： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-15.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-46-40.png"></p>
<p>三种协议的对比 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-11-11-19-01.png"></p>
<p><strong>简答：简述数据链路层实现可靠传输的基本方法。</strong></p>
<p>数据链路层实现可靠传输的基本设计方法包括:</p>
<ol type="1">
<li>确认机制:接收方给发送方发送ACK,反馈已正确接收的数据帧;</li>
<li>超时机制:发送方启动计时器,一旦出现超时则自动重传未确认的数据帧;</li>
<li>帧序号:标记数据帧,以便识别重复的数据帧</li>
</ol>
<h3 id="滑动窗口参数的计算方法掌握">滑动窗口参数的计算方法(掌握)</h3>
<p>选择重传策略的滑动窗口参数的要求如下图所示 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-09-21-48-38.png"></p>
<p><strong>广义来说：滑动窗口对于窗口的大小的限制可表述为：<span class="math inline">\(发送窗口+接收窗口\le2^{帧序号bit数}\)</span></strong></p>
<p><strong>具体细分到Go-Back-N协议和选择重传协议有：<span class="math display">\[Go-Back-N 发送窗口大小\le 2^{帧序号比特数}-1,\\
选择重传发送窗口大小\le 2^{帧序号比特数-1} \]</span></strong></p>
<h3 id="传统共享介质mac协议的设计要点理解">传统共享介质MAC协议的设计要点(理解)</h3>
<p><strong>简答：为什么在传统以太网的协议设计中,数据帧存在最短帧长的限制?</strong></p>
<p>传统以太网的MAC层协议为CSMA/CD,其中CD称为冲突检测,主要解决信号传播时延导致的媒质接入问题。在争用信道过程中,结点边发送数据边监听信道,如果在一个争用周期范围内未检测到冲突发生,则成功占用信道。IEEE 802.3规定当某个结点完成一帧数据接收后,首先要判断接收的帧长度,如果接收帧长度小于规定的帧最小长度,则表明冲突发生。</p>
<h3 id="csmacd协议的原理掌握">CSMA/CD协议的原理(掌握)</h3>
<p><strong>简答：简述传统以太网的CSMA/CD算法要点</strong></p>
<p>CSMA/CD全称为带有冲突检测的载波侦听多路接入(Carrier Sense Multiple Access with Collision Detect)。其基本思想是载波监听,多点接入,碰撞检测。每个站点发送数据之前必须侦听信道的忙、闲状态;如果信道空闲,立即发送数据,同时进行冲突检测;如果信道忙,站点继续侦听总线,直到信道变成空闲。如果在数据发送过程中检测到冲突,将立即停止发送数据并等待一段随机长的时间,然后重复上述过程。</p>
<h3 id="无线局域网mac协议设计要点理解">无线局域网MAC协议设计要点(理解)</h3>
<p><strong>简答：CSMA/CD算法为何不能应用于无线局域网</strong></p>
<p>CSMA/CD算法需要硬件一边发送数据一边监听共享链路的占用情况,在冲突窗口时间内没有检测出冲突就确定为发送成功。这些设计在无线链路上难以满足。首先,在无线网卡实现信号的同时发送和接收的难度和代价较高;其次,无线通信环境中信号传输路径复杂,存在绕射、折射、反射等多径,难以估算传输延时和判断是否存在冲突。</p>
<h3 id="csmaca协议的原理理解">CSMA/CA协议的原理(理解)</h3>
<p><strong>简答：无线局域网CSMA/CA如何实现冲突避免?</strong></p>
<p>冲突避免 Collision Avoidance,又称为虚拟载波侦听 (Virtual Carrier Sense),通过信令协商达到实际载波侦听的效果。协议约定在发送数据帧之前交换控制信息,发送方询问“Request to Send” (RTS),接收方收到 RTS后响应 “Clear to Send” (CTS),发送方收到 CTS, 则开始发送数据。在此过程中,如果其他结点收到 RTS或者 CTS,则停止发送,避免冲突。</p>
<h2 id="第四章分组交换网络">第四章：分组交换网络</h2>
<h3 id="数据报交换虚电路交换的原理理解">数据报交换、虚电路交换的原理(理解)</h3>
<p><strong>虚电路交换方法的健壮性不如数据报交换方法</strong></p>
<p><strong>简答：对比虚电路和数据报两种分组交换技术</strong></p>
<p>数据报交换的思想是网络不负责提供可靠传输保证,分组中包括源/目的地址,沿途交换机根据该地址独立处理和转发分组。 虚电路交换的思想是网络提供可靠传输保证,传输过程包括连接建立、数据传输、连接释放等阶段。在连接建立过程中,交换机协商分配局部的虚电路号并预留资源;数据传输过程中,分组首部内包含有本地交换所需的虚电路号,交换机根据虚电路号转发分组。</p>
<h3 id="局域网扩展网桥生成树算法的基本概念理解">局域网扩展，网桥，生成树算法的基本概念(理解)</h3>
<p><strong>局域网扩展的基本概念</strong>：局域网（LAN）扩展是指通过不同的技术手段，将原有的局域网范围进行扩大，以覆盖更大的区域或连接更多的设备。这种扩展可以通过多种方式实现：</p>
<ol type="1">
<li>无线局域网扩展：如Wi-Fi</li>
<li>有线局域网扩展：使用更长的网线等传输媒介，扩大局域网范围</li>
<li>虚拟局域网(VLAN)：通过在网络交换机上配置虚拟局域网，可以将原有的物理局域网划分为多个逻辑上独立的虚拟局域网，实现不同部门或功能的隔离和管理，同时在逻辑上连接它们，形成一个扩展的网络。</li>
<li>子网划分： 将原有的单一子网划分为多个子网，每个子网可以有自己的IP地址范围和路由规则，使得网络可以更有效地支持不同的设备和服务</li>
<li>中继器和网桥： 使用中继器和网桥等设备，可以将原有的局域网连接到其他局域网，实现不同物理位置之间的网络扩展。</li>
<li>广域网连接： 通过使用广域网（WAN）连接技术，如专线、VPN（虚拟专用网络）等，将不同地理位置的局域网连接起来，形成一个更大范围的网络。</li>
</ol>
<p><strong>网桥的基本概念</strong>：网桥工作在数据链路层，对接收到的帧进行过滤转发，通过网桥可以连接多个局域网，以建立更大的局域网</p>
<p>网桥可分为基本网桥和学习网桥，基本网桥将收到的帧向所有端口转发，这样效率很低，不能隔离碰撞域，常用的是学习网桥，采用选择性转发的方法，维护一个转发表，根据转发表（站表）确定转发端口，不向无关端口转发（能有效隔离碰撞域，效率高）。</p>
<p><strong>生成树算法的基本概念</strong>：生成树算法是为了解决广播风暴的问题而提出的一种算法，因为根据网桥的工作原理，帧有可能在环形网络中兜圈子而产生广播风暴。生成树算法通过从网络中剪掉一些链路，构造出该网络的生成树来解决广播风暴问题</p>
<p><strong>简答：简述透明网桥的要点?其在环状拓扑结构下可能发生什么问题?</strong></p>
<p>透明网桥通过逆向自主学习方式构建MAC转发表 透明网桥在环状拓扑结构下可能发生广播风暴(绕弯子)现象,生成树算法可以有效解决该问题。</p>
<p><strong>简答：什么是广播风暴</strong></p>
<p>网桥工作在数据链路层。网桥根据数据帧的源地址与目的地址来决定是否接收和转发该帧。随着网络规模的扩大与用户结点数的增加,可能出现“端口-结点地址表”中没有的结点地址信息,此时网桥无从决定应该从哪个端口转发,只能在所有端口广播。这种盲目广播会使帧的数量按指数规律增长,造成网络中无用的通信量剧增,形成“广播风暴”。</p>
<p><strong>简答：虚拟局域网是不是一种新的局域网?</strong></p>
<p>虚拟局域网是局域网交换机给用户提供的一种服务,并不是一种新型局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符,称为VLAN标记,用来指明发送该帧的工作站属于哪一个VLAN。局域网交换机根据VLAN标记,对于到来流量进行转发。属于同一个VLAN标记的工作站可以相互访问。</p>
<p><strong>数据帧转发过程中IP地址和MAC地址的变化情况</strong></p>
<ol type="1">
<li>当帧经过交换机时不会更改其源MAC地址和目标MAC地址</li>
<li>当帧通过路由器时，进行路由转发，IP地址是不会变的，MAC地址一定会变</li>
<li>当帧在同一个子网的主机之间进行转发，IP和MAC地址都不会改变</li>
<li>当帧在不同子网的主机进行转发时(使用NAT技术将内网IP转为外网公用IP)时，IP地址和MAC地址会发生改变</li>
</ol>
<h3 id="共享式以太网与交换式以太网的区别理解">共享式以太网与交换式以太网的区别(理解)</h3>
<p><strong>简答：共享式局域网与交换式局域网有哪些区别?</strong></p>
<p>共享式局域网的核心设备是集线器,在任何一个时刻只能有一个结点通过共享信道发送数据。该网络内每个结点处于同一个冲突域内,结点得到的平均带宽约等于总带宽/结点数。 交换式局域网的核心设备是交换机,可以在它的多个端口之间建立多个并发连接,从而实现了结点之间数据的并发传输。该网络内结点的通信不存在冲突,结点得到接近总带宽的带宽。</p>
<h3 id="以太网中继器集线器网桥交换机的功能与区别掌握">以太网中继器、集线器、网桥、交换机的功能与区别(掌握)</h3>
<p><strong>简答：简述中继器、集线器、网桥、交换机等设备的区别</strong></p>
<p>这4 种设备都是用于互联、扩展局域网的连接设备,但它们工作的层次和实现的功能不同:</p>
<ol type="1">
<li>中继器(Repeater),工作在物理层,解决数字信号在长距离基带传输中的失真和衰减问题,通过信号再生提升信号波形和强度的质量。</li>
<li>集线器(Hub),工作在物理层,相当于一个多端口的中继器。集线器可以将多个结点连接成为一个共享式以太网。</li>
<li>网桥(Network Bridge),工作在数据链路层,可以互联不同的物理层、不同的 MAC 子层以及不同速率的以大网,具有过滤帧、存储转发帧的功能。</li>
<li>交换机(Switch),,工作在数据链路层,相当于一个多端口的网桥。允许端口之间建立多个并发的连接,实现多个结点之间的并发传输。</li>
</ol>
<h2 id="第五章网络互联">第五章：网络互联</h2>
<h3 id="ip尽力服务的服务模型ip数据包转发原理理解">IP尽力服务的服务模型，IP数据包转发原理(理解)</h3>
<p><strong>IP尽力服务</strong>是一种服务模型，也称为“Best Effort Service”，是指在计算机网络中，网络设备尽其所能地传输数据，但不保证数据包的可靠性、顺序或时延。这种服务模型主要用于互联网中的IP网络，其中数据包以最佳可能的方式进行传输，但网络不提供对数据包的任何特殊处理或保证。</p>
<p><strong>IP数据包转发原理</strong>：</p>
<ol type="1">
<li>数据包的封装</li>
<li>路由器查找</li>
<li>数据包转发</li>
<li>数据包到达目标设备</li>
</ol>
<p><strong>简答：解释Everything over IP和IP over Everything的含义</strong></p>
<p>Everything over IP:从协议栈来看,TCP/IP网络可以为各式各样的应用提供服务,在IP层上面可以有很多的应用程序。 IP over everything:从协议栈看,TCP/IP网络也允许IP协议在各种异构网络构成互联网上运行,在IP层以上无需关心下层的物理网络实现。</p>
<h3 id="ipv4分段与重组的概念与计算掌握">IPv4分段与重组的概念与计算(掌握)</h3>
<p>IPv4分段与重组是一种处理大数据包的机制，允许将大于网络链路允许的最大传输单元（MTU）的IPv4数据包进行分割，并在到达目的地后重新组装这些分段。这是为了适应网络链路上的不同MTU和确保数据的正确传输。</p>
<p>在了解如何计算IPv4的分段和重组之前，我们需要了解IPv4数据报的首部格式 其示意图如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-38-31.png"></p>
<p>各参数含义如下：</p>
<ol type="1">
<li>版本：表示IP协议版本</li>
<li>首部长度，取值以4为单位，最小值为5，20字节，最大值为15，表明首部包含20字节固定部分和最大40字节可变部分</li>
<li>可选字段：用于排错，很少使用</li>
<li>填充字段：确保首部长度为4的整数倍，用全0填充</li>
<li>区分服务：很少使用</li>
<li>总长度：表示IP数据报总长度</li>
<li>标识：属于同一数据包的各分片应该具有相同标识</li>
<li>标志：各比特定义为:
<ul>
<li>DF位：1/0 表示是否允许分片</li>
<li>MF位：1/0 表示后面是否还有分片</li>
<li>保留位：必须为0</li>
</ul></li>
<li>片偏移：指出其数据载荷部分在原数据基础上偏移了多少位，以八个字节为单位</li>
</ol>
<p>其计算常涉及到如何将大数据包分为更小的片段进行传输，具体操作可以通过下图来理解 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-34-47.png"></p>
<p>值得注意的是：<strong>在IP层的计算中，IP实际的数据段需要减去首部长度，但如果题目说的是TCP传输层的报文传入下层IP层传输，则不需要减去TCP传输层的首部长度，因为IP层的数据载荷就是整个TCP报文</strong></p>
<h3 id="ipv4地址以及cidr设计和规划的概念与计算方法掌握">IPv4地址以及CIDR设计和规划的概念与计算方法(掌握)</h3>
<h4 id="ipv4的分类编址">IPv4的分类编址</h4>
<p>IP地址往往进行分类编址 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-56-24.png"></p>
<p><strong>且在每个网络的主机号中，全0的最小地址作为网络地址，全1的最大地址作为广播地址不可分配</strong></p>
<p>常用的3类网络的网络数和主机数的关系如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-18-59-13.png"></p>
<h4 id="ipv4划分子网">IPv4划分子网</h4>
<p>对于网络中的网络，我们往往是直接在该网络中分配子网，而不是申请新的网络号，这可表述为<strong>借用主机地址作为网络地址</strong></p>
<p>我们可以用IP地址与子网掩码相与得到网络地址，其计算如下： <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-04-24.png"></p>
<p><strong>给定一个分类的IP地址和子网掩码，即可计算子网划分细节</strong>：</p>
<ol type="1">
<li><span class="math inline">\(子网数量=2^{子网掩码1数-网络号}\)</span></li>
<li><span class="math inline">\(子网可分配给主机的IP地址数量=2^{子网掩码0数}-2\)</span></li>
<li><span class="math inline">\(子网网络地址=子网地址，子网广播地址=下一个子网地址-1\)</span></li>
<li><span class="math inline">\(子网分配给主机的最小地址=子网地址+1，子网分配给主机的最大地址=下一个子网地址-2\)</span></li>
</ol>
<h4 id="ipv4无分类编址超网--cidr">IPv4无分类编址(超网)--CIDR</h4>
<p>CIDR使用斜线记法，在<strong>斜线后面写上网络前缀所占比特数量</strong> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-12-35.png"></p>
<p><strong>CIDR的最长前缀匹配原则</strong></p>
<p>在路由器间进行转发时，我们采用最长前缀匹配原则将到来的IP分组进行转发，如果一个IP分组与两个网络的网络号都匹配，选择两个网络号中，长度最长的那个网络作为IP地址的下一跳路由器</p>
<p><strong>简答：说明IP地址与硬件地址的区别</strong></p>
<p>IP地址是连接互联网上的主机标识符;IP地址也被称为逻辑地址,其分配可以被静态指定也可以被动态分配;IPv4是32bit的,IPv6是128bit的。 硬件地址也被称为物理地址,用于标识每个网络接口设备;IEEE系列标准规定了MAC地址的格式,由48bit构成,由网卡制造商在生产时内置。</p>
<h3 id="arp协议dhcp协议nat协议icmp协议了解">ARP协议，DHCP协议，NAT协议，ICMP协议(了解)</h3>
<ol type="1">
<li>ARP协议用于将IP地址映射到MAC地址</li>
<li>DHCP协议用于将域名映射到IP地址(<strong>域名与IP地址不是一一对应的关系</strong>)</li>
<li>NAT协议用于在私有网络和公共网络中映射IP地址，允许多个设备享有一个IP地址</li>
<li>ICMP用于IP网络上的检错</li>
</ol>
<p><strong>简答：ARP协议向网络层提供了转换地址的服务,是否属于数据链路层?</strong></p>
<p>这种说法是错误的。ARP 不是向网络层提供服务,它本身就是网络层的一部分,帮助向传输层提供服务。数据链路层不存在IP地址问题,数据链路层协议把比特串从线路的一端传送到另一端。</p>
<h3 id="基于距离向量和基于链路状态的路由算法的原理与计算掌握">基于距离向量和基于链路状态的路由算法的原理与计算(掌握)</h3>
<p><strong>简答：简述距离向量路由算法原理,该算法有哪些不足?</strong></p>
<p>该算法定义距离向量信息为当前结点到达每一个其他结点的代价,通过邻结点之间多轮次两两交换距离向量信息,基于Bellman-ford算法逐步更新到全网其它结点的最短路径下一跳。 该算法的不足包括,构造距离向量需要知道全网结点数量规模,可能产生无穷计算问题。</p>
<p><strong>简答：“好消息传得快,坏消息传得慢”描述的是哪个路由算法,如何克服?</strong></p>
<p>这是距离向量路由算法的缺点。其原因是,路由交换时依赖两两信息交换,无法得到全局准确信息,导致计算到无穷。该问题无法通过算法改进彻底解决,在该算法对应的RIP协议中,通过设定路由跳数最大值来加以克服。RIP约定值为16即表示不可达,避免计算到无穷。</p>
<p><strong>简答：对比距离向量路由算法和链路状态路由算法的差异。</strong></p>
<p>距离向量路由算法:与邻结点交互全局信息,每个结点仅与直接相连的结点通信,交互的信息是到达其余所有结点的距离,路由计算采用Bellman-ford算法。 链路状态路由算法:与全局结点交互局部信息,每个结点通过洪泛方式与其他所有结点通信,交互的信息是该结点相连链路的状态,路由计算采用Dijkstra算法。</p>
<h3 id="路由器与交换机的区别掌握">路由器与交换机的区别(掌握)</h3>
<p><strong>简答：作为中间设备,转发器、网桥、路由器和网关有何区别?</strong></p>
<p>将网络互相连接起来要使用一些中间设备:</p>
<ol type="1">
<li>物理层使用的中间设备叫做转发器。</li>
<li>数据链路层使用的中间设备叫做网桥或桥接器。</li>
<li>网络层使用的中间设备叫做路由器。</li>
<li>在网络层以上使用的中间设备叫做网关。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li>
</ol>
<h3 id="自治系统的概念域内路由与域间路由的概念理解">自治系统的概念，域内路由与域间路由的概念(理解)</h3>
<h4 id="自治系统">自治系统</h4>
<p>因特网将整个互联网划分为许多较小的自治系统 AS。</p>
<p>一个自治系统是一个互联网，其最重要的特点就是自治系统有权自主地决定在本系统内应采用何种路由选择协议。</p>
<p>一个自治系统内的所有网络都属于一个行政单位(例如，一个公司，一所大学，政府的一个部门，等等)来管辖。</p>
<p>一个自治系统的所有路由器在本自治系统内都必须是连通的。</p>
<h4 id="域内路由与域间路由">域内路由与域间路由</h4>
<p><strong>简答：IGP和EGP这两类协议的主要区别是什么?</strong></p>
<p>IGP是内部网关协议,即在一个自治系统内部使用的路由选择协议,代表性的包括RIP和OSPF协议。IGP的路由选择主要采用最短路径的算法。 EGP是外部网关协议,用于自治系统之间路由选择,目前使用最多的外部网关协议是BGP协议。EGP的路由选择受多种因素影响,通常不使用最短路径。</p>
<h3 id="路径向量路由算法的原理与bgp协议实现理解">路径向量路由算法的原理与BGP协议实现(理解)</h3>
<p><strong>路径向量路由算法</strong></p>
<p>想法：</p>
<ul>
<li>对距离向量进行扩展使其能够快速检测环路</li>
<li>支持灵活的路由策略</li>
<li>避免无穷计算问题</li>
</ul>
<p>核心思想 : 通告整条路径</p>
<p>距离向量 : 发送到每一个目的地 d 的距离向量</p>
<p>路径向量 : 发送到每一个目的地 d 的路径向量</p>
<p><strong>BGP协议</strong></p>
<ol type="1">
<li>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 （不能兜圈子），而并非要寻找一条最佳路由</li>
<li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 BGP 发言人</li>
<li>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换BGP 报文以建立 BGP 会话 ( session)，利用 BGP 会话交换路由信息。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站 。</li>
</ol>
<p><strong>简答：RIP、OSPF、BGP的承载协议有何不同,有何考虑?</strong></p>
<ol type="1">
<li>RIP采用UDP协议。RIP在1980年代早期开发,其只需要与邻结点交互信息。UDP虽然无可靠性保证,但传输开销较小,可以满足RIP的需求。</li>
<li>OSPF采用IP协议。OSPF在1980年代末期开发,其需要在全网交互信息。当时TCP/IP架构已经形成,直接使用IP协议,易于在路由器上实现链路状态信息的洪泛。</li>
<li>BGP采用TCP协议。BGP协议在不同的自治系统之间交换路由信息,交换域间路由信息需要可靠传输保证,所以选择TCP。</li>
</ol>
<h3 id="ipv6协议了解">IPv6协议(了解)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-23-41.png"></p>
<h2 id="第六章端到端协议">第六章：端到端协议</h2>
<h3 id="传输协议udp与tcp的实现要点和对比理解">传输协议UDP与TCP的实现要点和对比(理解)</h3>
<p>UDP协议的实现要点：</p>
<ol type="1">
<li>无连接的</li>
<li>支持单播、多播和广播</li>
<li>面向应用报文</li>
<li>向上传提供无连接不可靠传输服务(适用于IP电话，视频会议等实时应用)</li>
<li>首部短，仅8字节</li>
</ol>
<p>TCP协议实现要点：</p>
<ol type="1">
<li>面向连接</li>
<li>一对一可靠通信</li>
<li>面向字节流</li>
<li>可靠传输，使用流量控制和拥塞控制</li>
<li>首部最小20字节，最大60字节</li>
</ol>
<p>UDP与TCP的对比 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-32-56.png"></p>
<p><strong>简答：为什么说UDP是面向报文的,而TCP是面向字节流的?</strong></p>
<p>UDP对应用程序交下来的报文,在添加首部后就向下交付IP层。UDP待交付的报文,既不合并,也不拆分,因此UDP是面向报文的。</p>
<p>TCP将应用层发送的报文看成是一串字节流,并对把每一个字节都进行编号,传输保证每一个字节都正确无误地传送到对方。因此TCP是面向字节流的。</p>
<h3 id="tcp连接的三次握手与四次挥手掌握">TCP连接的三次握手与四次挥手(掌握)</h3>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-47-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-48-36.png"></p>
<p><strong>简答：为什么在TCP连接建立时要使用三报文握手?</strong></p>
<p>如果不采用三报文握手,而是仅仅两报文握手。一旦滞留在网络中某处的陈旧的SYN报文段抵达接收方,就会让接收方误以为这是一个新的连接而进入连接等待状态,导致接收方资源被占用而无法释放。</p>
<p><strong>简答：为什么TCP连接释放比连接建立过程多一次交互?</strong></p>
<p>TCP三次握手是确保两个站点都对当前建立连接进行确认,避免两个站点过去发送的连接建立请求延后到达后导致一方进入资源等待状态而空等。 TCP四次挥手在三次握手基础上增加一次,原因是接收方需要等待上层应用将数据取走,因此接收方一次表示确认收到释放请求,一次再发起释放请求。</p>
<h3 id="tcp流量控制滑动窗口掌握">TCP流量控制(滑动窗口)(掌握)</h3>
<p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收 一般我们采用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制</p>
<p><img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-46-04.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-45-43.png"></p>
<p><strong>简答：TCP发送窗口的大小取决于流量控制还是拥塞控制?</strong></p>
<p>TCP发送窗口的上限值是Min [rwnd,cwnd],即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。当接收窗口小于拥塞窗口时,发送窗口的大小取决于流量控制,即取决于接收端的接收能力;当拥塞窗口小于接收窗口时,则发送窗口的大小取决于拥塞控制,即取决于整个网络的拥塞状况。</p>
<h2 id="第七章拥塞控制">第七章：拥塞控制</h2>
<h3 id="拥塞控制的概念以及与流量控制的区别理解">拥塞控制的概念以及与流量控制的区别(理解)</h3>
<p><strong>简答：流量控制和拥塞控制的最主要的区别是什么?</strong></p>
<p>流量控制是在一条TCP连接中的接收端采用的措施,用来限制对方(发送端)发送报文段的速率,以免在接收端来不及接收。流量控制只控制一个发送端。 拥塞控制是用来控制TCP连接中发送端发送报文段的速率,以免使互联网中的某处产生过载。拥塞控制可能会同时控制许多个发送端,限制它们的发送速率。</p>
<h3 id="tcp拥塞控制的主要机制掌握">TCP拥塞控制的主要机制(掌握)</h3>
<p>常用的机制主要是慢开始和拥塞避免 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-52-05.png"></p>
<p>为了进一步改进性能，又提出了快重传和快恢复算法 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-54-26.png"> <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-55-01.png"></p>
<h3 id="tcp拥塞控制与流量控制的综合计算掌握">TCP拥塞控制与流量控制的综合计算(掌握)</h3>
<p>仅举一例 <img src="/2023/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E5%89%8D%E6%8B%BE%E9%81%97/2023-11-10-19-56-31.png"></p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">湖科大计算机网络微课堂</a></li>
<li>Computer Networks: A Systems Approach, 5th Edition</li>
<li>华中科技大学电子信息与通信学院计算机网络课程组提供的优秀课件和资料</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法</title>
    <url>/2022/02/01/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="递归算法">递归算法</h2>
<h2 id="什么是递归">什么是递归？</h2>
<p>递归，在计算机科学中是指一种通过重复把问题分解为同类的子问题而解决问题的方法，通俗来讲，递归表现为函数调用函数本身。在知乎上有一个比喻递归非常形象的例子。 “递归最恰当的比喻，就是查词典。我们使用的词典，本身就是递归，为了解释一个词，需要使用更多的词。当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。”. <span id="more"></span> ### 递归的特点 事实上，递归有两个显著的特征，终止条件和自身调用： * <strong>自身调用</strong>：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，都是调用自身的同一个函数 * <strong>终止条件</strong>：递归必须有一个终止的条件，即不能无线循环的调用自己</p>
<h3 id="递归与栈的关系">递归与栈的关系</h3>
<p>递归的过程也可以理解为出入栈的过程 比如说我们利用递归计算3的阶乘，因为3&gt;1,所以进入下一个递归，2&gt;1，再进入下一个递归，1=1，开始计算，依序返回，在这里，我们可以发现先进去的3反而是最后执行的，这就类似于栈的性质</p>
<h3 id="递归的经典应用场景">递归的经典应用场景</h3>
<ul>
<li>阶乘问题</li>
<li>二叉树深度</li>
<li>汉诺塔问题</li>
<li>斐波那契数列</li>
<li>快速排序，归并排序（分治算法中体现递归）</li>
<li>遍历文件，解析xml文件</li>
</ul>
<h3 id="递归解题思路">递归解题思路</h3>
<ol type="1">
<li>定义函数功能</li>
<li>寻找递归终止条件</li>
<li>递推函数的等价关系式</li>
</ol>
<h3 id="递归存在的问题">递归存在的问题</h3>
<ol type="1">
<li>递归调用层级太多，导致栈溢出问题</li>
<li>递归重复计算，导致效率低下</li>
</ol>
<h4 id="栈溢出问题">栈溢出问题：</h4>
<ul>
<li>每一次函数调用在内存栈中分配空间，然而每个进程的栈容量是有限的</li>
<li>当递归调用的层级太多时就会，就会超出栈的容量，从而导致调用栈溢出</li>
<li>其实，我们在前面小节也讨论了。递归过程类似于出栈入栈，如果递归次数过多，栈的深度就需要越深，最后栈容量就不够了</li>
</ul>
<h4 id="重复计算导致效率低下">重复计算导致效率低下</h4>
<p>递归处理时，有些问题如果不加以处理，会造成多次重复计算，降低程序的运行效率</p>
<p>参考：https://mp.weixin.qq.com/s/tqGKHZzSyDBgEp-oWsOztQ</p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>通信原理第七章知识小结</title>
    <url>/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<p>数字调制是指用数字基带信号控制载波某个参数的过程，数字带通传输系统是指包括调制/解调过程的数字传输系统</p>
<h2 id="二进制数字调制原理">7.1 二进制数字调制原理</h2>
<h3 id="二进制振幅键控2ask">7.1.1 二进制振幅键控(2ASK)</h3>
<p>原理<span class="math inline">\(s(t)\rightarrow\)</span>载波幅度，表达式<span class="math display">\[e_{2ASK}(t)=s(t)cosw_ct,s(t)=\sum_na_ng(t-nT_s)\\a_n=\begin{cases}
    +1,P\\0,(1-P)
\end{cases}\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-32-10.png"></p>
<p>2ASK的产生主要是采用模拟调制法和键控法，其解调可以采用包络检波法和相干解调法，包络检波法的各点波形如下： <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-33-45.png"></p>
<h3 id="二进制频移键控2fsk">7.1.2 二进制频移键控(2FSK)</h3>
<p>原理<span class="math inline">\(s(t)\rightarrow\)</span>载波频率，表达式<span class="math display">\[e_{2FSK}=s_1(t)cosw_1t+s_2(t)cosw_2t\\s_1(t)=\sum_na_ng(t-nT_s),s_2(t)=\sum_n\overline{a_n}g(t-nT_s)\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-36-08.png"></p>
<p>2FSK的产生主要也是采用模拟调频法和键控法，其解调也采用包络检波法和相干解调法 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-37-30.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-38-02.png"></p>
<h3 id="二进制相移键控2psk">7.1.3 二进制相移键控(2PSK)</h3>
<p>原理<span class="math inline">\(s(t)\rightarrow\)</span>载波相位，表达式<span class="math display">\[e_{2PSK}(t)=Acos(w_ct+\psi_n),\psi_n=\begin{cases}
    0,发0时,P\\
    \pi,发1时,1-P
\end{cases}\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-41-02.png"> 2PSK产生主要采用模拟调制法和键控法，解调采用相干解调 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-44-46.png"></p>
<h3 id="二进制差分相移键控">7.1.4 二进制差分相移键控</h3>
<p>原理：利用前后相邻码元的载波相对相位表示信息，<span class="math display">\[\delta \psi=\psi_n-\psi_{n-1}=\begin{cases}
    0\rightarrow0\\
    \pi\rightarrow1
\end{cases}\]</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-48-04.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-11-48-28.png"> 2DPSK的解调有以下两种方法 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-14-54-32.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-14-54-52.png"></p>
<h3 id="二进制数字已调信号的功率谱psd">7.1.5 二进制数字已调信号的功率谱(PSD)</h3>
<ol type="1">
<li>2ASK信号的功率谱密度：<span class="math inline">\(P_{2ASK}(f)=\frac{1}{4}[P_s(f+f_c)+P_s(f-f_c)]\)</span>，可见<span class="math inline">\(P_{2ASK}(f)\)</span>是<span class="math inline">\(P_s(f)\)</span>的线性搬移(属于线性调制)，且其带宽是基带信号带宽的两倍<span class="math inline">\(B_{2ASK}=2f_B=2R_B\)</span> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-14-58-38.png"></li>
<li>2PSK信号的功率谱密度与2ASK一致，频谱的区别仅在于当P=0.5时，谱中无离散谱(载波分量)，且其带宽也是基带信号带宽的两倍 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-01-51.png"></li>
<li>2FSK信号的功率谱密度：<span class="math inline">\(P_{2FSK}(f)=\frac{1}{4}[P_{s_1}(f-f_1)+P_{s_1}(f+f_1)+P_{s_2}(f-f_2)+P_{s_2}(f+f_2)]\)</span>,谱零点带宽<span class="math inline">\(B_{2FSK}\approx|f_2-f_1|+2f_B\)</span></li>
</ol>
<h2 id="二进制数字调制系统的抗噪声性能">7.2 二进制数字调制系统的抗噪声性能</h2>
<p>性能指标:系统的误码率<span class="math inline">\(P_e\)</span>,分析方法借用数字基带系统方法与结论，分析条件时恒参信道，信道噪声是加性高斯白噪声，分析过程与基带信号类似，在7.3中直接给出结论</p>
<h2 id="二进制数字调制系统的性能比较">7.3 二进制数字调制系统的性能比较</h2>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-07-54.png"></p>
<ol type="1">
<li>在r一定时，相同解调方式下，抗高斯白噪声性能优劣顺序为2PSK,2DPSK,2FSK,2ASK</li>
<li><span class="math inline">\(P_e\)</span>一定时，所需的信噪比:<span class="math inline">\(r_{2ASK}=2r_{2FSK}=4r_{2PSK}\)</span></li>
<li>r一定时,相同调制方式下：<span class="math inline">\(P_{e相干}&lt;P_{e非相关}\)</span>，大信噪比时(r&gt;&gt;1)，二者性能 相差不大</li>
</ol>
<p><strong>频带带宽--有效性</strong>：设基带信号的谱零点带宽<span class="math inline">\(R_B=1/T_s\)</span>，则有<span class="math display">\[B_{2ASK}=B_{2PSK}=B_{2DPSK}=2R_B=\frac{2}{T_s},B_{2FSK}=|f_2-f_1|+\frac{2}{T_s}\]</span>只有2FSK的带宽不仅与基带信号带宽有关，还与两个载频之差有关，在<span class="math inline">\(R_B\)</span>一定时，2FSK的频带利用率最低，有效性最差</p>
<p><strong>对信道特性变化的敏感性</strong>：2ASK易受信道参数变化的影响，不适于在变参信道中传输，2PSK不易受信道参数变化的影响，2FSK不需要认为设置判决门限，对信道变化不敏感，适用于变参信道传输场合</p>
<p><strong>设备复杂度</strong>：非相干方式一般比相干方式简单</p>
<h2 id="多进制数字调制原理">7.4 多进制数字调制原理</h2>
<p>因为在<span class="math inline">\(R_b\)</span>一定时，增加进制数M，可以降低<span class="math inline">\(R_B\)</span>，从而减小信号带宽，节约信道频率资源，<span class="math inline">\(R_B\)</span>一定时，增加进制数M，可以增大<span class="math inline">\(R_b\)</span>,从而在相同带宽内传输更多比特的信息，<strong>本质上使用多进制数字调制的原因是为了提高信道的频带利用率</strong>，代价是会导致误码率增大，系统变复杂，种类有MASK,MFSK,MDPSK,MQAM</p>
<h3 id="多进制振幅键控mask">7.4.1 多进制振幅键控(MASK)</h3>
<p>MASK可看为二进制振幅键控(2ASK)的推广，其可表示为<span class="math display">\[e_{MASK}(t)=\sum_{n=1}^Ma_ng(t-nT_s)cosw_ct,a_n=\begin{cases}
    0,以频率P_1\\
    1,以频率P_2\\
    \vdots\\
    M_1,以频率P_M
\end{cases},\sum_{i=1}^MP_i=1\]</span> MASK调制：与2ASK产生方法相似，区别在于发送端输入的二进制基带信号需要先经过电平变换器转换为M电平的基带脉冲，然后再去调制，MASK解调与2ASK解调也相似，功率谱与2ASK形式相似，谱零点带宽<span class="math inline">\(B=2R_B=\frac{2R_b}{log_2 M},B=\frac{2}{T_B}=\frac{2}{T_b\cdot log_2M}\)</span>,在<span class="math inline">\(R_b\)</span>相同时，MASK信号带宽是2ASK的<span class="math inline">\(1/log_2M\)</span>倍，但其抗噪能力差，常用多进制正交振幅调制(MQAM)代替</p>
<h3 id="多进制频移键控mfsk">7.4.2 多进制频移键控(MFSK)</h3>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-35-17.png"> MFSK可视为2FSK方式的推广，要求载频之间距离足够大，以便用滤波器分离不同频率的谱，其占用较宽的频带，但其信道频带利用率不高，<span class="math inline">\(B=|f_M-f_1|+\frac{2}{T_B}\)</span>,一般被用于调制速率不高的衰落信道传输</p>
<h3 id="多进制相移键控mpsk">7.4.3 多进制相移键控(MPSK)</h3>
<p>利用载波的M种不同相位表示数字信息，也可用信号矢量图(星座图)来表示 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-39-13.png"> M增大，多相制信号可在相同的带宽中传输更多比特的信息，从而提高频带利用率，且相邻信号点的距离会逐渐减小，导致抗噪性能下降，设备复杂</p>
<p>4PSK也叫正交相移键控(QPSK),利用载波四种不同相位表示数字信息，可视为两个互为正交的2PSK信号合成，其调制可用正交调相法和相位选择法，解调的原理则是分解为两路PSK信号的相干解调，但存在90°的相位模糊，解决方法采用四相相对相位调制QDPSK <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-43-28.png"> <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-20-15-44-01.png"> 缺点是最大相位跳变180°，使得包络起伏很大，出现包络零点，频谱扩展大，旁瓣对邻道干扰大，改进思路是改为OQPSK(不要求)</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>电波传播知识小结</title>
    <url>/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>参考田加胜老师的课件和电波传播理论课本整理</p>
<span id="more"></span>
<h2 id="第一章电波传播的理论基础">第一章：电波传播的理论基础</h2>
<h3 id="电波的反射绕射和散射">电波的反射、绕射和散射</h3>
<p>当电波入射到不同电特性的媒质分界面上时首先会发生<strong>反射</strong>，当电波遇到的物体大小与波长可比拟时会发生<strong>绕射</strong>，而当电波遇到的物体小于波长且单位体积的空间内此类物体数量很多时会发生<strong>散射</strong></p>
<h3 id="电波的绕射">电波的绕射</h3>
<ul>
<li>在发送端与接收端之间有障碍物遮挡的情况下，电波绕过遮挡物进行传播的过程称为电波绕射</li>
<li>绕射使得电波可以绕地球表面传播，能够传播到障碍物的后面(阴影区中)。所以，尽管障碍物的阻挡使电波在接收点的场强迅速衰减，但是绕射场依然存在并且常常具有足够大的场强</li>
<li>绕射现象可用惠更斯原理来解释，惠更斯原理认为所有的波前点都可作为产生次级波的电源，这些次级波叠加起来形成传播方向上新的波前。绕射由次级波传播进入阴影区而形成。在围绕障碍物的空间中，阴影区绕射波场强是所有次级波电场部分的矢量和</li>
</ul>
<h2 id="第二章电波传播的菲涅尔区">第二章：电波传播的菲涅尔区</h2>
<h3 id="惠更斯-菲涅尔原理">惠更斯-菲涅尔原理</h3>
<ul>
<li>惠更斯原理：允许用球面波的二次辐射源来代替波前。根据惠更斯原理，波前上的每一个点都可以看为二次辐射源辐射球面波，相应地，波前的移动导致这些二次球面波的传播，移动过后的波前好像是二次球面波的包络。</li>
<li>惠更斯原理的数学表达式：$(M)=-_{S'} (-)ds $</li>
</ul>
<h3 id="菲涅尔区">菲涅尔区</h3>
<ul>
<li>基尔霍夫积分：$(M)=_{S_0} (-)ds $，其说明在均匀无边界的媒质内，观察点的电场可以用无限大平面的二次源积分来表示，该平面位于波源和观察点之间。</li>
</ul>
<h4 id="菲涅尔带与菲涅尔区">菲涅尔带与菲涅尔区</h4>
<ul>
<li>按照下列等式可将<span class="math inline">\(S_0\)</span>面划分为菲涅尔带，图中的圆环称为菲涅尔带 <img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-14-46-21.png"> <span class="math display">\[(\rho_n+r_n)-(\rho_0+r_0) = n\frac{\lambda}{2}\]</span> 通过这种方式划分的每一个菲涅尔带的电波射线将有附加的传播路径，其长度为<span class="math inline">\(n\frac{\lambda}{2}\)</span>,其中n为整数 由此可见，分布在相邻菲涅尔带边界上的二次波源在观察点M产生的场是反相的，进一步研究分析可得<span class="math inline">\(B\approx \frac{B_1}{2}\)</span>,这意味着观察点的合成场基本是由分布在前几个菲涅尔带内的二次波源产生的，其他菲涅尔带内的二次波源对观察点的影响很小</li>
<li>菲涅尔带半径：<span class="math inline">\(R_n=\sqrt{\frac{n\lambda\rho_0 r_0}{\rho_0+r_0}}(m)\)</span>,所有菲涅尔带的面积都相等，均为<span class="math inline">\(\frac{\pi\lambda\rho_0r_0}{\rho_0+r_0}\)</span>，菲涅尔带半径的大小决定了菲涅尔带的大小</li>
<li>当<span class="math inline">\(S_0\)</span>面沿着直线OM移动时，每一个菲涅尔带的边界将画出一个旋转椭球体的表面部分，从而构成了一簇椭球，这些椭球所包围的空间就表示了<strong>电波传播的空间菲涅尔区</strong>，所以菲涅尔区就是以发射天线和接收天线为焦点的椭球。该椭球的方程为<span class="math inline">\((\rho_n+r_n)-(\rho_0+r_0)-n\frac{\lambda}{2}=常数\)</span>,如果<span class="math inline">\(S_0\)</span>面正好移动到发射天线和接收天线的中间，即OM中点，菲涅尔区有最大半径，移到发射天线或接收天线时，菲涅尔半径减小 <img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-15-01-57.png"></li>
<li>第n个菲涅尔区的最大半径为<span class="math inline">\(R_{max}=\frac{1}{2}\sqrt{n\lambda d}\)</span>,最小菲涅尔半径<span class="math inline">\(R_0=0.577R_1\)</span></li>
</ul>
<h3 id="传播余隙">传播余隙</h3>
<ul>
<li>定义：直射波射线与地面障碍物最高点之间的距离为传播余隙h
<ol type="1">
<li><span class="math inline">\(h/R_0\ge 1\)</span>，直射波的最小菲涅尔带没有被阻挡，在接收点能接收到自由空间场强</li>
<li><span class="math inline">\(0\le h/R_0&lt;1\)</span>，直射波的最小菲涅尔带的面积部分被阻挡，产生了较大传播损耗</li>
<li><span class="math inline">\(h/R_0 &lt;0\)</span>,直射波的最小菲涅尔带的面积全部被阻挡，产生较大传播损耗</li>
<li>设计准则：只要55%的第一菲涅尔区保持无阻挡，其他菲涅尔区的情况基本不影响绕射损耗。</li>
</ol></li>
</ul>
<h2 id="第三章自由空间和空间波传播模式">第三章：自由空间和空间波传播模式</h2>
<h3 id="电波传播的基本模式">电波传播的基本模式</h3>
<ul>
<li>电波主要在地球周围的大气空间中传播或沿地球表面传播，根据大气和大地对电波传播的影响，可以将电波的传播方式分为空间波、地表面波和天波三种基本模式 <img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-15-19-00.png">
<ol type="1">
<li>空间波传播：在<strong>大气对流层</strong>中进行的电波传播称为空间波传播，工作频率多位于超短波和微波</li>
<li>地表面波：沿<strong>地球表面</strong>进行的电波传播称为地表面波，工作频率多位于超长，长，中波和短波</li>
<li>天波：电波利用<strong>电离层</strong>的折射、反射和散射作用进行传播的模式称为天波，工作频率多位于中波，短波，尤其以短波为主</li>
</ol></li>
</ul>
<h3 id="电波在自由空间中的传播">电波在自由空间中的传播</h3>
<ul>
<li>电波在理想的、均匀地、各向同性的介质内传播时，不会出现折射、绕射、反射、吸收和散射等现象，电波传播的损耗仅仅需要考虑由于电波的扩散引起的损耗，像这样的介质空间就称为<strong>自由空间</strong>，特点是<strong>各向同性，电导率为0</strong></li>
</ul>
<h4 id="电波在自由空间传播时接收场强的计算">电波在自由空间传播时接收场强的计算</h4>
<ul>
<li>设电波电源在O点，均匀向外辐射，辐射功率为<span class="math inline">\(P_{\Sigma}\)</span>,求距离天线为d的M点处的接收场强<span class="math inline">\(E_0\)</span></li>
<li>距离天线d处的辐射场的功率密度为<span class="math inline">\(S=\frac{P_{\Sigma}}{4\pi d^2}=\frac{E_0^2}{120\pi}\rightarrow E_0=\frac{\sqrt{30P_{\Sigma}}}{d}:(V/m)=74.77+10lgP_{\Sigma}(w)-20lgd(km):dB\)</span>,如果方向性天线 则还要加一个D 天线效率为1,D=G，<strong>自由空间中的全向天线的表达无需加G/D</strong>,此处的场强与发射天线的辐射功率和距发射天线的距离有关，而与发射频率无关。</li>
</ul>
<h4 id="电波在自由空间传播时接收功率的计算">电波在自由空间传播时接收功率的计算</h4>
<ul>
<li>接收端输入功率：<span class="math inline">\(P_A=SA=\frac{E_0^2}{120\pi}\frac{\lambda^2}{4\pi}=\frac{E_0^2\lambda^2}{480\pi^2}=\frac{P_{\Sigma}\lambda^2}{(4\pi d)^2}\)</span>,如果发射天线和接收天线有方向性系数<span class="math inline">\(D_1D_2\)</span>，直接乘上去即可</li>
<li>如果全部将单位换算为dB,能构建出<span class="math inline">\(P_A，E_0\)</span>之间的表达式<span class="math inline">\(P_A=-126.75+E_0+20lg\lambda\)</span>(dBm)</li>
</ul>
<h4 id="电波在自由空间传播时传播损耗的计算">电波在自由空间传播时传播损耗的计算</h4>
<ul>
<li>传播损耗又称系统损耗，定义为辐射功率与接收功率之比，用<span class="math inline">\(L_0\)</span>表示，即<span class="math inline">\(L_0=\frac{P_{\Sigma}}{P_A}=(\frac{4\pi d}{\lambda})^2\frac{1}{D_1D_2}\)</span>,如果上式d的单位为km，f的单位为Mhz，<span class="math inline">\(L_0\)</span>的单位为dB，<span class="math inline">\(D_1、D_2\)</span>的单位为dB，则可得到<span class="math inline">\(L_0=32.45+20lgf+20lgd-D_1-D_2\)</span>,定义<span class="math inline">\(L_{bs}=32.45+20lgf+20lgd\)</span>为自由空间的路径损耗</li>
</ul>
<h3 id="空间波传播模式">空间波传播模式</h3>
<ul>
<li>在平面地面上传播的波具有两种传播模式：一种是空间波传播模式，即直射波与反射波的叠加；另一种是地表面波传播模式，当天线架设较低时，地表面波起主要作用。地表面波起支配作用时的天线高度称为最小有效天线高度<span class="math inline">\(h_0\)</span></li>
<li>当f&lt;30Mhz时，地表面波起主要作用，30Mhz&lt;f&lt;300Mhz时，空间波和地表面波两种模式共存，f&gt;300Mhz时，电波主要以空间波模式传播，地表面波可以忽略不计。</li>
</ul>
<h4 id="光滑平面地面上电波传播的双线反射模型">光滑平面地面上电波传播的双线反射模型</h4>
<p>主要就是接收机收到的场强是直射波场强和反射波场强的合成，然后根据几何关系可求出直射波与反射波的路程差 <img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-16-31-20.png" style="width:50.0%;height:50.0%"> <img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-16-33-05.png" style="width:50.0%;height:50.0%"> 经过一系列繁杂的数学推导和化简后有<span class="math inline">\(|E_{TOT}(d)=2\frac{E_0d_0}{d}sin(\frac{\theta_\Delta}{2})|\)</span></p>
<p>进一步在场强计算的基础上进行简化有<span class="math inline">\(P_A=P_{\Sigma}(\frac{h_1h_2}{d^2})^2D_1D_2\)</span>，其中<span class="math inline">\(h_1=(h_t^2+h_0^2)^{0.5},h_2=(h_r^2+h_0^2)^{0.5},h_0\)</span>为最小有效天线高度，这意味着光滑平面地面上的电波传播，其接收功率与天线高度的二次方成正比，与距离的四次方成反比，与频率无关，频率主要影响电波传播模式</p>
<h3 id="光滑球面反射模型">光滑球面反射模型</h3>
<p><img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-16-54-16.png"></p>
<ul>
<li>当天线高度<span class="math inline">\(h_1,h_2\)</span>一定时，以<span class="math inline">\(h_1\)</span>顶点A作一直线与地球相切，变动<span class="math inline">\(h_2\)</span>位置，使<span class="math inline">\(h_2\)</span>顶点B正好落在切线上，此时两天线之间的<strong>球面距离</strong><span class="math inline">\(r_0\)</span>称为视距</li>
<li><span class="math inline">\(r&gt;1.2r_0\)</span>称为阴影区，<span class="math inline">\(r&lt;0.7r_0\)</span>称为视区(照明区)，<span class="math inline">\(0.7r_0\le r \le 1.2r_0\)</span>为半阴影区。</li>
<li>通过三角关系有弧长<span class="math inline">\(r_1=\sqrt{2Rh_1},r_2=\sqrt{2Rh_2},r_0=r_1+r_2=3.57(\sqrt{h_1}+\sqrt{h_2})\)</span>,式中，<span class="math inline">\(h_1,h_2\)</span>单位为m,<span class="math inline">\(r_0,r_1,r_2\)</span>单位为km</li>
</ul>
<h4 id="照明区内的光滑球面反射模型">照明区内的光滑球面反射模型</h4>
<p><img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-17-48-51.png"></p>
<p>相对于前面平面地面上的场强计算流程只需要将最后结果改为<span class="math inline">\(r_1=\sqrt{2R\Delta h_1},\Delta h_1=\frac{r_1^2}{2R}\)</span></p>
<h3 id="瑞利准则">瑞利准则</h3>
<ul>
<li>地球表面的起伏不平会影响电波传播特性，但地面起伏不平对电波传播的影响程度取决于地表起伏不平的幅度与波长的比值 <img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-17-54-13.png"> 通常取两个射线的相位差<span class="math inline">\(\Delta \psi=\pi/2\)</span>,即相应的路程差为<span class="math inline">\(\Delta r=\lambda/4\)</span>作为地面平坦与粗糙的分界线，对应的推导得到瑞利准则判别式<span class="math inline">\(h_R=\frac{\lambda}{8sin\theta}\approx\frac{\lambda}{8\theta}\)</span>,其中<span class="math inline">\(\theta\)</span>的单位为弧度(rad)</li>
<li>粗糙表面传播损耗的特点：损耗与频率相关，随频率升高而增大；损耗不是一个恒定的值，而是随空间时间变化的随机变量，在一个均值上下波动，服从对数正态分布</li>
</ul>
<h2 id="第四章地表面波传播模式">第四章：地表面波传播模式</h2>
<h3 id="地表面波传播的特性">地表面波传播的特性</h3>
<ul>
<li>地表面波传播模式是指沿地球表面主要以绕射方式进行的电波传播，其特点是信号比较稳定，主要需要考虑地球表面对电波传播的影响。在实际情况下，只有长波、中波以及短波波段中较长的部分能绕射到地表面较远的地方，其他的都是按直线传播</li>
<li>定义将<span class="math inline">\(E_{1z}\)</span>降低至最大值的一半时的高度<span class="math inline">\(\Delta z\)</span>作为地表面波传播的适用范围，在高度不超过<span class="math inline">\(\Delta z\)</span>的范围内，认为电波沿地表面以表面波传播，当高度超过则以空间波传播</li>
</ul>
<h3 id="球面绕射模型">球面绕射模型</h3>
<h4 id="阴影点内接收点场强的求解">阴影点内接收点场强的求解</h4>
<p>当接收天线位于阴影区时，不能直接收到来自发射天线的直射波和反射波，只能收到绕射波的信号，因此无法直接应用前面所导出的求场强的公式，工程上都采用列线图来计算因电波绕射引起的附加传播损耗 <img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-23-18-14-36.png"></p>
<h3 id="对流层对电波传播的影响">对流层对电波传播的影响</h3>
<ul>
<li>对流层对电波传播的影响表现在两个方面：一是对流层大气的吸收损耗，二是由于对流层的非均匀性导致电波的传播方向偏离直线方向</li>
<li>等效地球半径：为了能直接应用从电波直线传播导出的场强计算公式，引入等效地球半径的概念，设电波为半径R'的等效地面上空为直线传播，以等效在实际地面上的折射</li>
<li>等效地球半径因子：<span class="math inline">\(K=\frac{1}{1+R\frac{dn}{dh}}\)</span>,其表示等效地球半径与实际地球半径之比，对于相当均匀的大气，取<span class="math inline">\(K=\frac{4}{3}\)</span>,称为标准大气，此时的大气折射率称为标准大气折射率</li>
<li>正常情况下<span class="math inline">\(\frac{dn}{dh}&lt;0\)</span>，射线总是弯向地球。但在异常情况下，也有可能出现<span class="math inline">\(\frac{dn}{dh}\ge 0\)</span>,此时电波射线向远离地球方向弯曲，当<span class="math inline">\(\frac{dn}{dh}=-\frac{1}{K}\)</span>,电波射线平行于实际地球表面</li>
<li>当考虑大气不均匀性时，计算阴影区和非阴影区时视距<span class="math inline">\(r_0=\sqrt{2KRh_1}+\sqrt{2KRh_2}=3.57(\sqrt{Kh_1}+\sqrt{Kh_2})\)</span></li>
</ul>
<h2 id="第五章天波传播模式">第五章：天波传播模式</h2>
<ul>
<li>天波传播模式就是一定范围内的无线电波利用电离层的反射和折射作用进行远距离传输的方式</li>
</ul>
<h3 id="电波在电离层中的传播">电波在电离层中的传播</h3>
<h4 id="电波在非色散媒质和色散媒质中的传播">电波在非色散媒质和色散媒质中的传播</h4>
<ul>
<li>电波传播的相速和群速的概念是不同的，电波等相位面传播的速度称为相速，能量传播的速度称为群速</li>
<li>电波在非色散媒质中传播时，相速和群速相等，在色散媒质中传播时，相速不等于群速；在非色散媒质中，每个单色波的相速都相等，整个合成波也以同样的相速传播，在色散媒质中，每个单色波的相速都不一样，因此合成波在传播过程中将发生变形</li>
<li>在电离层中<span class="math inline">\(V_g=nc,V_p=\frac{c}{n}\)</span>,因为n&lt;1，所以电波在电离层中群速恒小于光速，相速则大于光速。</li>
<li>当入射角<span class="math inline">\(i_0=0°\)</span>，即电波垂直地面发射时，被反射回来的最高频率称为临界频率<span class="math inline">\(f_c=\sqrt{80.8N_m}\)</span>,如果大于临界频率就无法反射回来</li>
<li>电波如果斜投射，能反射回来的最高频率为<span class="math inline">\(f_{max}(i_0)=\sqrt{80.8N_m}seci_0=f_cseci_0\)</span>,可见<span class="math inline">\(f_{max}&gt;f_c\)</span>，即斜投射波的最高反射频率大于垂直投射波</li>
<li>对于同一<span class="math inline">\(i_0\)</span>,随着频率的升高，反射高度随之增加，通信距离变远，当f大于<span class="math inline">\(f_{max}\)</span>，电波将穿透电离层，且当f接近<span class="math inline">\(f_{max}\)</span>，通信距离最远。</li>
<li>寂静区：在有些地区接收不到由电离层反射回来的天波信号，而地表面波传播又达不到该距离，所以这些地方天波地波都收不到，被称为寂静区，哑区，开始收不到地波的距离为寂静区内边界，开始出现天波的距离为寂静区外边界</li>
</ul>
<h3 id="各波段电波在电离层中传播特性">各波段电波在电离层中传播特性</h3>
<ul>
<li>衰落：是接收信号强度的一种突然的无规则的差异</li>
<li>干涉衰落：不同传播路径的电波间的相互干涉引起的衰落，各路电波受电离层变动的影响不同以及相位发生的变化，引起了衰落</li>
<li>极化衰落：由于经过电离层反射的电波改变了天线辐射的平面波性质，平面波转变为椭圆极化波，而椭圆轴的方向和长度是经常变化的，从而影响接收点场强的稳定。</li>
<li>吸收衰落：由电离层D层衰减特性的缓慢变化所引起的</li>
<li>抗衰落方法：提高接收信号噪声比，选择最佳的工作频率等 最广泛使用的是分集接收法，设置多个接收点，使其分布在相距若干个波长的地方</li>
<li>回波：在适当条件下，有电波连续在电离层中多次反射，或在地面与电离层之间来回反射，这就有可能环绕地球一周，这种电波传播称为环球回波。与正常传播方向一致的是正向回波，反之则为反向回波。</li>
</ul>
<h2 id="第六章移动通信电波传播的大尺度路径损耗特性">第六章：移动通信电波传播的大尺度路径损耗特性</h2>
<p>传统的研究移动通信电波传播特性的方法是基于实际测量，研究电波传播的场强均值随传播距离的变化特性或电波传播的路径损耗均值(衰减均值)随传播距离的变化特性，此即电波传播的大尺度路径损耗特性</p>
<h3 id="移动通信电波传播的特点">移动通信电波传播的特点</h3>
<ul>
<li>随着移动体的行进，由于障碍物的变化，接受信号场强会产生两种衰落，即多径衰落和地形衰落。多径衰落是快速的微观变化，又称为<strong>小尺度衰落或简单衰落</strong>，用来描述一小段时间内或与波长相比很小的一段传播距离信号在幅度、相位或多径延迟上的快速波动，地形衰落是缓慢的宏观变化，又称<strong>大尺度衰落或阴影效应</strong></li>
</ul>
<h3 id="地形特征和传播环境的分类和定义">地形特征和传播环境的分类和定义</h3>
<ul>
<li>传播环境可分为三类：开阔区，郊区，市区</li>
<li>天线有效高度的定义：
<ol type="1">
<li>移动台天线有效高度<span class="math inline">\(h_m\)</span>:天线在当地地面以上的高度</li>
<li>基站天线有效高度<span class="math inline">\(h_b\)</span>:沿通信方向，距发射天线3-15km范围内地面平均高度以上的高度</li>
</ol></li>
</ul>
<h3 id="大尺度路径损耗特性">大尺度路径损耗特性</h3>
<ul>
<li>大尺度路径损耗/地形衰落是由移动体运动过程中电波传播路径的随机变化引起的，主要包括建筑物和起伏地形的阴影效应和大气折射情况的平缓变化</li>
<li>地形衰落的速度与工作频率无关，仅取决于移动体的速度，而衰落深度随工作频率而变化，较高频率的信号更易穿透建筑物，较低频率的信号绕射能力则比较高频率强。</li>
</ul>
<h3 id="场强均值和传播损耗预测模型">场强均值和传播损耗预测模型</h3>
<ul>
<li>准平坦地形大城市区路径损耗均值<span class="math inline">\(L_M=L_{bs}+A_M(f,d)\)</span>,<span class="math inline">\(L_{bs}\)</span>为自由空间路径损耗，<span class="math inline">\(A_M{f,d}\)</span>为中等起伏地市区传播损耗基本中值。</li>
<li>校正因子：天线高度增益因子<span class="math inline">\(H_b(h_b,d)和H_m(h_m,f)\)</span></li>
<li>郊区和开阔去校正因子<span class="math inline">\(K_s,Q_o,Q_r\)</span>,这里是需要先求出市区的路径损耗均值，再减去校正因子</li>
<li>路径损耗均值的预测：
<ol type="1">
<li>准平坦地形大城市区路径损耗均值:<span class="math inline">\(L_M=L_{bs}+A_M(f,d)-H_b(h_b,d)-H_m(h_m,f)\)</span>,</li>
<li>不同环境及不规则地形的路径损耗均值：<span class="math inline">\(L_M=L_{bs}+A_M(f,d)-H_b(h_b,d)-H_m(h_m,f)-K_s-K_h-K_A-K_{is}\)</span>,<span class="math inline">\(K_s,K_h,K_A,K_{is}\)</span>分别为郊区校正因子，丘陵地形校正因子，斜坡地形校正因子，水陆混合传播路径校正因子(dB)</li>
</ol></li>
<li>求得路径损耗均值后，可进一步求出移动台从基站接收到的信号功率均值为：<span class="math inline">\(P_r=P_t-L_M+G_b+G_m-l_b-l_m-l_d\)</span>,式中，<span class="math inline">\(P_r\)</span>为接收机所接收到的信号概率均值(dBw),<span class="math inline">\(P_t\)</span>为发射机发射概率(dBw),<span class="math inline">\(L_M\)</span>为路径损耗均值(dB),<span class="math inline">\(G_b\)</span>为基站天线增益(dB),<span class="math inline">\(G_m\)</span>为移动台天线增益(dB),<span class="math inline">\(l_b,l_m,l_d\)</span>分别为基站馈线损耗，移动台馈线损耗，基站天线多频道公用器损耗(dB)</li>
</ul>
<h2 id="第七章移动通信电波传播的小尺度衰落特性">第七章：移动通信电波传播的小尺度衰落特性</h2>
<p>移动通信电波传播的小尺度衰落，或称为简单衰落、多径衰落，是用来描述一小段时间内或一小段传播距离内信号在幅度、相位或多径延迟上的快速波动。</p>
<h3 id="小尺度衰落多径衰落">小尺度衰落(多径衰落)</h3>
<ul>
<li>来自不同传播路径的电波在接收天线处相互干涉而使接收天线接收到的场强矢量在振幅以及相位上随时间急骤变化，使信号很不稳定的现象称为衰落现象。小尺度衰落或称简单衰落、多径衰落，用来描述一小段时间内或与波长相比一小段传播距离内信号在幅度、相位或多径延迟上的快速波动，它取决于场强分布、电波的相对传播时间和传输信号的带宽。</li>
<li>影响小尺度衰落的因素包括：多径传播，移动台的速度，周围物体的移动速度，信号的传输带宽。</li>
</ul>
<h3 id="小尺度衰落的类型">小尺度衰落的类型</h3>
<p><img src="/2024/06/15/%E7%94%B5%E6%B3%A2%E4%BC%A0%E6%92%AD%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2024-06-24-00-11-03.png"></p>
<ul>
<li>对调角信号，相关带宽工程估算式为<span class="math inline">\(B_c=1/2\pi\Delta,\Delta\)</span>为实验扩展</li>
</ul>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>电波传播</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第五章知识小结</title>
    <url>/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="幅度调制线性调制原理">5.1 幅度调制(线性调制)原理</h2>
<p>线性调制原理与通信电子线路课程中大致类似，可参见<a href="https://xiazhi1.github.io/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/">通信电子线路第六章知识小结</a></p>
<h3 id="单边带调制ssb">5.1.3 单边带调制(SSB)</h3>
<p>通信原理课程中详细讲述了SSB信号的产生，而通信电子线路课程对此要求不高，故进行补充</p>
<p>SSB信号的产生主要可以分为滤波法和相移法</p>
<ol type="1">
<li>滤波法 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-24-10-17-57.png"> 原理是需要先形成DSB信号，边带滤波即可得上或下边带信号，这要求滤波器<span class="math inline">\(H_{SSB}(w)\)</span>在载频处具有陡峭的截止特性，这也是滤波法的技术难点之一</li>
<li>相移法 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-24-10-20-11.png"> 要求掌握推导流程，设<span class="math inline">\(m(t)=A_mcosw_mt\)</span>,载波<span class="math inline">\(c(t)=cosw_ct\)</span>,则<span class="math inline">\(S_{DSB}(t)=A_mcosw_mt\cdot cosw_ct=\frac{1}{2}A_mcos(w_c-w_m)t+\frac{1}{2}A_mcos(w_c+w_m)t\\S_{USB(LSB)}(t)=\frac{1}{2}A_mcos(w_c\pm w_m)t=\frac{1}{2}m(t)cosw_ct\mp \frac{1}{2}\widehat{m(t)}sinw_ct\)</span>,<span class="math inline">\(\widehat{m(t)}\)</span>是<span class="math inline">\(m(t)\)</span>的希尔伯特变换--幅度不变，相移<span class="math inline">\(\pi/2\)</span> <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-24-10-30-46.png"> 相移法的技术难点是<span class="math inline">\(H_h(w)\)</span>难以对<span class="math inline">\(m(t)\)</span>的所有频率分量精确相移$/2 $</li>
</ol>
<p>其中DSB/SSB/VSB均是抑制载波的已调信号，不能采用简单的包络检波解调，AM信号可以采用，以上所有提到的线性调制方式都可以用相干解调方式解调</p>
<h2 id="线性调制系统的抗噪声性能">5.2 线性调制系统的抗噪声性能</h2>
<h3 id="模型与指标">5.2.1 模型与指标</h3>
<p>分析模型 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-18-21-44-04.png"></p>
<p>性能指标：</p>
<p>输出信噪比：<span class="math inline">\(\frac{S_o}{N_o}=\frac{\overline{s_i^2(t)}}{\overline{n_i^2(t)}}\)</span> 制度增益：<span class="math inline">\(G=\frac{S_o/N_o}{S_i/N_i}\)</span>,G越大，该调制系统的抗噪性能越好</p>
<h3 id="dsb-相干解调系统的抗噪性能">5.2.2 DSB-相干解调系统的抗噪性能</h3>
<p>推导过程不要求，故略过，直接给出结论，注意下面所有的<span class="math inline">\(n_0\)</span>都表示白噪声的单边功率谱密度，若题目给出的是双边功率谱密度，则需要乘2得到单边功率谱密度</p>
<p><span class="math inline">\(S_i=\frac{1}{2}\overline{m^2(t)},N_i=n_0B,S_o=\frac{1}{4}\overline{m^2(t)},N_o=\frac{1}{4}N_i\Rightarrow G_{DSB}=2\)</span></p>
<h3 id="ssb-相干解调系统的抗噪性能">5.2.3 SSB-相干解调系统的抗噪性能</h3>
<p>推导过程不要求，故略过，直接给出结论</p>
<p><span class="math inline">\(S_i=\frac{1}{4}\overline{m^2(t)},N_i=n_0B,S_o=\frac{1}{16}\overline{m^2(t)},N_o=\frac{1}{4}N_i\Rightarrow G_{SSB}=1\)</span></p>
<p>但是不能说DSB系统的抗噪声性能优于SSB系统，因为DSB的带宽是SSB带宽的两倍，换算到相同的<span class="math inline">\(S_i,n_0,f_H\)</span>条件下，DSB与SSB的抗噪声性能相同</p>
<h3 id="am包络检波系统的抗噪声性能">5.2.4 AM包络检波系统的抗噪声性能</h3>
<ol type="1">
<li><p>大信噪比时有<span class="math inline">\(G_{AM}=\frac{2\overline{m^2(t)}}{A_0^2+\overline{m^2(t)}}\)</span>,因为<span class="math inline">\(|m(t)|_{max}\le A_0\rightarrow G_{AM}&lt;1\)</span>,当100%调制时，且<span class="math inline">\(m(t)\)</span>为单频正弦时，<span class="math inline">\(G_{AM}=\frac{2}{3}\)</span></p></li>
<li><p>小信噪比时，信号被扰乱成噪声，导致输出信噪比急剧恶化--门限效应，其是由包络检波器的非线性解调作用引起的</p></li>
</ol>
<h2 id="非线性调制角度调制原理">5.3 非线性调制(角度调制)原理</h2>
<p>其基本原理与通信电子线路课程要求一致，可参见<a href="https://xiazhi1.github.io/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/">通信电子线路第七章知识小结</a></p>
<p>其中主要补充一下窄带调频和宽带调频，窄带调频是指当调频信号的瞬时相偏满足<span class="math inline">\(|\psi(t)|_{max}=|K_F\int m(t)\, {\rm d}t|_{max}\le\frac{\pi}{6}\)</span>,反之则为宽带调频</p>
<h2 id="调频系统的抗噪声性能">5.4 调频系统的抗噪声性能</h2>
<p>大信噪比时，经过推导可得<span class="math inline">\(G_{FM}=3m_f^2(m_f+1)\)</span>，又因为B与<span class="math inline">\(m_f\)</span>成正比,所以可用通过增加传输带宽来改善FM系统的抗噪声性能，但是这种做法并不是无止境的</p>
<p>小信噪比时也会产生门限效应，在门限值以上时，<span class="math inline">\((S_o/N_o)_{FM},(S_i/N_i)_{FM}\)</span>呈线性关系，且<span class="math inline">\(m_f\)</span>越大，输出信噪比改善越明显，在门限值以下，二者不再是线性关系，而是随<span class="math inline">\((S_i/N_i)_{FM}\)</span>的下降而急剧下降</p>
<p>为了提高高频信号的信噪比，往往在FM系统两端应用预加重和去加重技术</p>
<h2 id="各种模拟调制系统的比较">5.5 各种模拟调制系统的比较</h2>
<p>所有系统在“同等条件”下进行比较：解调器输入功率均为<span class="math inline">\(S_i\)</span>,信道噪声均值为0,单边功率谱密度为<span class="math inline">\(n_0\)</span>,基带信号带宽为<span class="math inline">\(f_m\)</span>,其中AM调幅度为100%,正弦型调制信号</p>
<p><img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-09-58-55.png"> <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-09-59-15.png"> <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-09-59-27.png"></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第一四章知识小结</title>
    <url>/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第一，四章内容较少，故将两章合并。本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="第一章绪论">第一章：绪论</h2>
<h3 id="信息及其度量">1.4 信息及其度量</h3>
<p>在通信原理中对信息的度量与先修课程信息论的度量方式一致，信息量<span class="math inline">\(I=-log_aP(x)\)</span>,平均信息量(熵)<span class="math inline">\(H=\sum_{i=1}^M p(x_i)log_2\frac{1}{p(x_i)}\)</span></p>
<h3 id="通信系统主要性能指标">1.5 通信系统主要性能指标</h3>
<p>通信系统的性能指标一般从两方面考虑：有效性与可靠性，其中有效性是指传输一定信息量时所占用的信道资源--“传输速度”，可靠性是指接收信息的准确程度--“传输质量”</p>
<h4 id="数字通信系统的有效性指标">1.5.1 数字通信系统的有效性指标</h4>
<ol type="1">
<li>码元传输速率<span class="math inline">\(R_B\)</span>
<ul>
<li>定义：每秒传输的码元个数</li>
<li>单位：波特(Baud)</li>
<li>计算：如一个码元的时间长度为<span class="math inline">\(T_s\)</span>秒，则<span class="math inline">\(R_B=\frac{1}{T_s}\)</span></li>
</ul></li>
<li>信息传输速率<span class="math inline">\(R_b\)</span>
<ul>
<li>定义：每秒传递的比特数(信息量)</li>
<li>单位：比特/秒(bit/s)简记为b/s,bps</li>
<li><span class="math inline">\(R_b与R_B\)</span>的关系：<span class="math inline">\(R_b=R_B\cdot log_2 M\)</span>(信息等概)，非等概时有<span class="math inline">\(R_b=R_B\cdot H\)</span></li>
</ul></li>
<li>频带利用率
<ul>
<li>定义：单位带宽内的传输速率</li>
<li><span class="math inline">\(\eta=\frac{R_B}{B}\)</span></li>
<li><span class="math inline">\(\eta_b=\frac{R_b}{B}\)</span></li>
<li><span class="math inline">\(\eta_b=\eta\cdot log_2M\)</span></li>
</ul></li>
</ol>
<h4 id="数字通信系统的可靠性指标">1.5.2 数字通信系统的可靠性指标</h4>
<ol type="1">
<li>误码率<span class="math inline">\(P_e=\frac{错误码元数}{传输总码元数}=\frac{N_e}{N}\)</span></li>
<li>误信率<span class="math inline">\(P_b=\frac{错误比特数}{传输总比特数}=\frac{I_e}{I_b}\)</span></li>
<li>在二进制中有<span class="math inline">\(P_b=P_e\)</span>,M进制有<span class="math inline">\(P_b&lt;P_e\)</span></li>
</ol>
<h2 id="第四章信道">第四章：信道</h2>
<p>信道可以分为物理信道和逻辑信道，本章主要讨论的是物理信道，物理信道可以从物理形态分类为有线信道和无线信道，按信道特性可以分为恒参信道和变参信道,其中恒参信道的特性不随时间变化，而随参信道的特性随时间随机变化。<strong>各种有线信道以及无线信道中的无线电中继和卫星通信等视线传播的信道属于恒参信道，其他各种无线信道都属于随参信道 </strong></p>
<h3 id="无有线信道信道的数学模型">4.1~3 无/有线信道&amp;信道的数学模型</h3>
<p>无线信道的的电磁波传播方式可分为地波，天波，视线传播，主要划分依据是频率的大小，其中为了增大视线传播距离，采用微波中继，卫星中继，平流层通信等手段。</p>
<p>若讨论自由空间中电磁波在发射天线和接受天线间的传播损耗<span class="math inline">\(L_{fr}\)</span>，可以不加证明的给出如下公式 <span class="math display">\[L_{fr}=\frac{P_T}{P_R}=\frac{16\pi^2d^2}{\lambda^2G_TG_R},\lambda:波长,P_{T/R}:发射机输出/入功率,d:距离\]</span></p>
<p>有线信道主要包括明线/对称电缆/同轴电缆/光纤</p>
<p>信道进一步可分为侠义信道和广义信道，前面提到的无线/有限信道均属于狭义信道，而广义信道则可分为调制信道与编码信道，分别研究调制/解调问题与编码/译码问题。 <img src="/2023/12/18/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-28-21-38-03.png"></p>
<p>信道的数学模型也可进一步分为以下几类：</p>
<ol type="1">
<li>调制信道模型：叠加有噪声的线性时变/时不变网络</li>
<li>编码信道模型：可用转移概率来描述</li>
</ol>
<h3 id="信道特性对信号传输的影响">4.4 信道特性对信号传输的影响</h3>
<p>对于恒参信道而言，其可认为为一个线性时不变系统，传输特性可表述为<span class="math inline">\(H(w)=|H(w)e^{j\psi(w)}|\)</span>,若想实现无失真传输，则幅频特性<span class="math inline">\(|H(w)|=K\)</span>,相频特性<span class="math inline">\(\psi(w)=wt_d\)</span>,当系统不满足上面的条件时，会对应的产生幅频失真和相频失真(也叫色散)</p>
<p>当信道的振幅-频率特性不理想，则信号发生的失真称为频率失真，信号的频率失真会使信号的波形发生畸变，这种畸变会引起相邻码元间发生部分重叠，造成码间串扰</p>
<p>对于随参信道(传输特性随时间随机快变)而言，主要会产生多径效应，具体来说是多径传播会使信号产生瑞利型衰落，并引起频率弥散，多径传播对一个复杂信号来说会导致信道对信号不同的频率成分有不同的衰减--频率选择性衰落，对于宽带信号来说，若信号带宽大于<span class="math inline">\(1/\tau,\tau\)</span>:信道最大相关带宽，则必然出现强烈的衰落，为了使信号基本不受多径传播的影响，要求信号的带宽小于多径信道的相关带宽，减小衰落的措施一般是使信号带宽<span class="math inline">\(B_s=(1/3\sim 1/5)\Delta f\)</span>(工程上公式)</p>
<h3 id="信道噪声">4.5 信道噪声</h3>
<p>噪声类型按噪声来源可分为人为噪声，自然噪声，内部噪声；按噪声性质可分为脉冲噪声，窄带/单频噪声，起伏噪声</p>
<h3 id="信道容量">4.6 信道容量</h3>
<p>离散信道容量不做要求，主要讲述连续信道容量，有信息论知识可知，白噪声背景下的连续信道容量为<span class="math inline">\(C=Blog_2(1+\frac{S}{N})(b/s)==Blog_2(1+\frac{S}{n_0B})(b/s),when \quad B\rightarrow \infty, C\approx1.44\frac{S}{n_0}\)</span>,S:信号平均功率(W),带宽B(Hz),<span class="math inline">\(n_0\)</span>:噪声单边功率谱密度,<span class="math inline">\(N=n_0B\)</span>:噪声功率(W)</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第十十三章知识小结</title>
    <url>/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第十三章知识点较少，将其与第十章合并，本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="第十章信源编码">第十章：信源编码</h2>
<h3 id="引言">10.1 引言</h3>
<p>信源编码的作用十进行压缩编码和模数转换，进行数字化编码的技术主要有波形编码和参量编码，我们主要讨论的是波形编码，波形编码的三个步骤包括：抽样，量化和编码，不常用的方法是PCM,DPCM,<span class="math inline">\(\Delta M\)</span> <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-20-23-43.png"></p>
<h3 id="模拟信号的抽样">10.2 模拟信号的抽样</h3>
<h4 id="低通模拟信号的抽样定理">10.2.1 低通模拟信号的抽样定理</h4>
<p>最高频率小于<span class="math inline">\(f_H\)</span>的模拟信号m(t)可由其等间隔的抽样值唯一确定，抽样间隔<span class="math inline">\(T_S\)</span>或抽样速率<span class="math inline">\(f_S\)</span>应满足:<span class="math inline">\(T_S\le\frac{1}{2f_H},f_s\ge 2f_H\)</span>其中<span class="math inline">\(T_s,f_s\)</span>分别被称为奈奎斯特间隔与奈奎斯特速率</p>
<h4 id="带通模拟信号的抽样定理">10.2.2 带通模拟信号的抽样定理</h4>
<p>设带通型模拟信号m(t)的频率范围限制在<span class="math inline">\(f_L\le f\le f_H,且f_L&gt;B\)</span>,则最小抽样速率为<span class="math inline">\(f_s=2B(1+\frac{k}{n})\)</span>,其中<span class="math inline">\(B=f_H-f_L\)</span>,n为商<span class="math inline">\(f_H/B\)</span>的整数部分，k为商<span class="math inline">\(f_H/B\)</span>的小数部分</p>
<p>当<span class="math inline">\(f_L=0\)</span>时，<span class="math inline">\(f_s=2B=2f_H\)</span>--低通抽样情况，<span class="math inline">\(f_L\)</span>很大时，<span class="math inline">\(f_s\approx 2B\)</span></p>
<h3 id="模拟脉冲调制">10.3 模拟脉冲调制</h3>
<p>模拟脉冲调制主要可以分为PAM,PDM,PPM,分别变化脉冲高度，宽度，位置，本章主要讨论的是PAM,PAM可分为两种实际抽样，自然抽样的PAM和平顶抽样的PAM,自然抽样的特点是样值脉冲的幅度随原信号m(t)的幅度而变，平顶抽样的特点是每个样值脉冲的顶部是平坦的</p>
<h3 id="模拟信号的量化">10.4 模拟信号的量化</h3>
<h4 id="量化原理">10.4.1 量化原理</h4>
<p>量化原理可表述为用有限个量化电平表示无限个抽样值 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-20-44-10.png"></p>
<h4 id="均匀量化">10.4.2 均匀量化</h4>
<p>均匀量化意味着等间隔的划分输入信号的取值域 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-20-45-29.png"></p>
<p>量化器的性能指标中，信号量噪比<span class="math inline">\(S/N_q\)</span>是重要的一个设计指标</p>
<p>量化噪声概率<span class="math inline">\(N_q=E[(m_k-m_q)^2]=\int_a^b(x-m_q)^2f(x)dx\)</span></p>
<p>信号<span class="math inline">\(m_k\)</span>的平均功率<span class="math inline">\(S=E[(m_k)^2]=\int_a^bx^2f(x)dx\)</span></p>
<p>信号量噪比--信号功率与量化噪声功率之比<span class="math inline">\(\frac{S}{N_q}=\frac{E[m_k^2]}{E[(m_k-m_q)^2]}\)</span></p>
<p>输入信号均匀分布的最佳量化器是均匀量化器，其特点是<span class="math inline">\(N_q\)</span>与信号统计特性无关，仅取决于<span class="math inline">\(\Delta\)</span>,其缺点体现在当信号小时，信号量噪比也小，往往达不到要求，相当于限制了输入信号的动态范围，在电话传输中需要信号量噪比较高，这意味着需要的编码位数多，导致编码信号的带宽增大，且编码设备复杂，为了解决这些问题，引入了下一节的非均匀量化</p>
<h4 id="非均匀量化">10.4.3 非均匀量化</h4>
<p>设计思想：信号样值小，<span class="math inline">\(\Delta V\)</span>也小，信号样值大，<span class="math inline">\(\Delta V\)</span>也大；实现方法是对信号先压缩再进行均匀量化然后进行扩张，压缩的目的是提高小信号的量噪比</p>
<p>其实现均采用对数量化，实现方法是先压缩原始抽样值(非线性变换)，再均匀量化，国际上用的两种对数压缩特性标准，<span class="math inline">\(\mu\)</span>率和A率，本章主要讨论A率，二者间的区别是A压缩率采用的是13折线近似法，而<span class="math inline">\(\mu\)</span>率采用的是15折线近似法</p>
<p>A压缩率的表达式为 <span class="math display">\[y=\begin{cases}
    \frac{Ax}{1+lnA},0\le x\le \frac{1}{A}\\
    \frac{1+lnAx}{1+lnA},\frac{1}{A}\le x \le 1
\end{cases}\]</span> A用于决定压缩程度，A=1时无压缩效果，实用中A=87.6，用87.6的原因时使压缩曲线在原点附近斜率凑成16，使13折线逼近时，x的八个段落量化分界点近似于按2的幂次递减分割，有利于数字化 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-26-30.png"></p>
<h3 id="脉冲编码调制">10.5 脉冲编码调制</h3>
<h4 id="pcm的基本原理">10.5.1 PCM的基本原理</h4>
<p>PCM系统原理框图如下 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-29-02.png"> 模拟信号数字化过程包括抽样、量化和编码</p>
<h4 id="常用二进制码">10.5.2 常用二进制码</h4>
<ol type="1">
<li>自然二进码：一般的十进制正整数的二进制表示，特点是编码简单，译码可以逐比特独立进行</li>
<li>格雷二进码：相邻码字的距离恒为1</li>
<li>折叠二进码：由极性码(最高位)和幅度码组成，幅度码从零电平-大电平按自然码规则编码，当正负绝对值相同时，幅度吗相对于零电平呈现映像关系，或称折叠关系</li>
</ol>
<p>码位的选择与安排关乎通信质量和设备复杂度，在A率13折线PCM编码中，共计<span class="math inline">\(2^8=256\)</span>个量化极，需要将每个样值脉冲<span class="math inline">\(I_s\)</span>编成8位二进制码，其编码规则如下，<span class="math inline">\(C_1-极性码，C_2C_3C_4-段落码，C_5C_6C_7C_8-段内码\)</span>,其中极性码表示样值的极性，正编"1",负编"0",段落码表示样值的幅度所处的段落，段内码表示16种可能状态对应代表各段内的16个量化级</p>
<p>起始电平和量化间隔用于确定样值所在的段落和量化级 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-45-16.png"> <span class="math inline">\(\Delta = \frac{1}{2048}\)</span> 段内码对应的权值关系如下 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-10-46-28.png"></p>
<h4 id="电话信号的编译码器">10.5.3 电话信号的编译码器</h4>
<p>非线性码对应非均匀量化，只需要7位非线性编码，称为非线性/对数PCM编码，线性码对应均匀量化，需要11位线性编码，称为线性PCM编码</p>
<p>PCM信号的比特率和带宽：设模拟信号的最高频率为<span class="math inline">\(f_H\)</span>,抽样速率为<span class="math inline">\(f_S=2f_H\)</span>,二进制编码位数为N，则PCM信号的比特率<span class="math inline">\(R_b=f_s\cdot N=2f_H\cdot N\)</span>，传输带宽：若采用非归零矩形脉冲传输，谱零点带宽<span class="math inline">\(B=R_B=R_b=f_s\cdot N\)</span></p>
<h4 id="pcm系统中噪声的影响">10.5.4 PCM系统中噪声的影响</h4>
<p>PCM系统中的噪声来源于两方面，一方面是量化噪声<span class="math inline">\(N_q\)</span>，一方面是加性噪声<span class="math inline">\(N_a\)</span>，两者产生机理不同，所以相互独立，性能指标方面，抗加性噪声性能可表述为 <span class="math display">\[\frac{S_o}{N_a}=\frac{E[m^2(t)]}{E[n_a^2(t)]}=\frac{1}{4P_e}\]</span> 抗量化噪声性能 <span class="math display">\[\frac{S_o}{N_q}=\frac{E[m^2(t)]}{E[n_q^2(t)]}=M^2=2^{2N}=2^{2B/f_H}\]</span> 总输出信噪比 <span class="math display">\[\frac{S_o}{N_o}=\frac{E[m^2(t)]}{E[n_q^2(t)]+E[n_a^2(t)]}=\frac{2^{2N}}{1+4P_e2^{2N}}\\若N_a&lt;&lt;N_q,则\frac{S_o}{N_o}\approx 2^{2N},若N_a&gt;&gt;N_q,则\frac{S_o}{N_o}\approx\frac{1}{4P_e}\]</span></p>
<h3 id="时分复用tdm">10.8 时分复用(TDM)</h3>
<p>对于时分复用数字电话通信系统，ITU制定了两种准同步数字题型的建议，E体系和T体系，主要讨论E体系</p>
<p><img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-11-22-53.png"></p>
<h2 id="第十三章同步原理">第十三章：同步原理</h2>
<h3 id="概述">13.1 概述</h3>
<p>同步是数字通信系统中不可或缺的关键技术，是保证信息可靠、有序传输的前提和必要，同步性能的好坏直接影响着通信系统的质量</p>
<p>同步的类型可分为载波同步，码元同步，帧/群同步，网同步，其中载波同步负责在相干解调时，提供同频同相的本地载波(相干载波)，码元同步负责在抽样判决，差分/编译码，PCM编译码时，提供时钟同步脉冲序列，帧/群同步负责在发端插入每帧起止标记，并从收信端检测并获取这一标记，以便对接受的数字序列正确分组</p>
<p>同步获取方法可分为外同步法(插入导频法)与自同步法(直接法)，二者的区别可以直接通过是否发送导频来辨别</p>
<h3 id="载波同步">13.2 载波同步</h3>
<p>作用：提供本地载波用于相干解调，要求：本地载波应与接受信号载波同频同相，方法有插入导频法和直接法</p>
<h4 id="有辅助导频的载波提取">13.2.1 有辅助导频的载波提取</h4>
<p>一般采用一个锁相环(PLL)来提取载波 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-12-55-35.png"></p>
<h4 id="无辅助导频的载波提取">13.2.2 无辅助导频的载波提取</h4>
<p>一般解决思路是通过非线性变换，产生载波的谐波分量，然后提取分频得到载波同步信号</p>
<p>常用的解决方法可分为平方变换法和平方环法，同向正交环(costas环),再调制器 <img src="/2023/12/22/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%8D%81%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-23-12-57-44.png"></p>
<h4 id="载波同步的性能">13.2.3 载波同步的性能</h4>
<p>追求效率高，精度高，同步建立时间快，保持时间长</p>
<h3 id="码元同步">13.3 码元同步</h3>
<p>作用是在数字图像的抽样判决，差分编译码，PCM编译码器中，提供所需的同步时钟序列，要求抽样判决时，接收端需提供码元同步(位定时)序列，应满足重复频率与接收码元速率相同，相位与最佳抽判时刻一致，方法也分为外同步法和自同步法</p>
<h4 id="外同步法">13.3.1 外同步法</h4>
<p>就是在发送信号的频域进行插入同步信号，优点是设备较简单，缺点是需要占用一定的频带宽度和发送速率</p>
<h4 id="自同步法">13.3.2 自同步法</h4>
<ol type="1">
<li>开环码元同步法：将解调后的基带接受码元先进行某种非线性变换，窄带滤波，从而移除码元速率的频率分量，采用的方案一般为延迟相乘法和微分整流法</li>
<li>闭环码元同步法：将接受信号与本地产生的码元定时信号相比较，使本地产生的定时信号和接收码元波形的转变点保存同步，方案是超前/滞后门同步器</li>
</ol>
<h3 id="群同步">13.4 群同步</h3>
<p>作用是在码元同步的基础上，识别每个数字信息群的起止时刻</p>
<p>一般采用的方法有集中插入法与分散插入法</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第八九章知识小结</title>
    <url>/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第八章知识点较少，将其与第九章合并，本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="第八章新型数字带通调制技术">第八章：新型数字带通调制技术</h2>
<h3 id="正交振幅调制">8.1 正交振幅调制</h3>
<p>正交振幅调制(QAM)是一种振幅与相位联合键控的数字调制技术，宽带通信采用高阶调制的原因是因为在有限带宽下增大M能提升频带利用率，所以要想在有限带宽下实现高速率通信，必须采用高阶调制，高阶调制采用QAM的原因是因为如果简单的采用MPSK，在信号幅度相等即概率相等的条件下，进制数M增加，星座图相邻信号点的距离减小，意味着在相同噪声条件下，系统误码率增大，而QAM的设计就是通过重新安排信号点的位置，增大相邻信号点的距离 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-28-42.png"></p>
<p><span class="math display">\[d_1=\frac{\sqrt{2}A_M}{3}=0.47A_M,d_2=2A_Msin(\frac{\pi}{16})=0.39A_M\]</span> 从上式看出<span class="math inline">\(d_1&gt;d_2\)</span>,表明16QAM比16PSK的噪声容限大，抗噪能力强 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-31-31.png"></p>
<p>在QAM中，其码元可表示为 <span class="math display">\[e_k(t)=A_kcos(w_ct+\theta_k),kT_B&lt;t\le(k+1)T_B\\\rightarrow e_k(t)=X_kcosw_ct+Y_ksinw_ct,X_k=A_kcos\theta_k,Y_k=-A_ksin\theta_k\]</span> 这表明MQAM信号可由两路载波正交<span class="math inline">\(\sqrt{M}\)</span>的ASK信号叠加而成 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-36-52.png"> 由上图可知16QAM编码与星座坐标的关系，如果将四位编码记为<span class="math inline">\({a_1a_2b_1b_2}\)</span>,可知任意相邻两点编码的码距达到最小值；横坐标相同的点，<span class="math inline">\(a_1a_2\)</span>编码相同;纵坐标相同的点，其<span class="math inline">\(b_1b_2\)</span>编码相同</p>
<p>16QAM信号调制的原理框图如下图所示 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-21-19-40-28.png"></p>
<p>其产生可大致划分为两种方法</p>
<ol type="1">
<li>正交调幅法：用两路正交的4ASK信号叠加，即可形成16QAM信号</li>
<li>复合相移法：用两路独立的QPSK信号叠加，即可形成16QAM信号</li>
</ol>
<p>16QAM信号的解调往往采用正交相干解调</p>
<p>MQAM信号的谱零点带宽:<span class="math inline">\(B_{MQAM}=2R_B=\frac{2R_b}{log_2M}\)</span>,频带利用率<span class="math inline">\(\eta_{MQAM}=\frac{R_b}{B}=\frac{1}{2}log_2M(bps/Hz)\)</span></p>
<p>在实际中，往往需要对转换后的信号进行脉冲成形滤波，以抑制已调信号的带外辐射，滤波器通常采用滚降系数为<span class="math inline">\(\alpha\)</span>的升余弦滤波器，此时MQAM的带宽可表述为<span class="math inline">\(B=(1+\alpha)R_B=\frac{(1+\alpha)R_b}{log_2M}\)</span>,频带利用率<span class="math inline">\(\eta_b=\frac{log_2M}{(1+\alpha)}\)</span></p>
<h3 id="最小频移键控">8.2 最小频移键控</h3>
<p>最小频移键控MSK是2FSK的改进型，是一种包络恒定，相位连续，带宽最小且严格正交的2FSK信号，使频差最小的目的是为了减小带宽，提高频带利用率，使相位连续的目的是为了实现恒定包络，从而加速带外功率谱密度下降速度</p>
<h4 id="正交2fsk信号的最小频率间隔">8.3.1 正交2FSK信号的最小频率间隔</h4>
<p>有前面的学习，我们知道<span class="math inline">\(B_{2FSK}=|f_2-f_1|+2f_b\)</span>,可见在码元速率不变的时候,<span class="math inline">\(|f_2-f_1|\)</span>越小越好，单不能无限小，因为在接收端要能区分<span class="math inline">\(f_1,f_2\)</span>才能正确解调，通常区分的方法有两种，滤波器法和正交法</p>
<p>经过推导可知非相干接收方法下，满足正交条件的最小频率间隔为<span class="math inline">\((f_1-f_0)_{min}=1/T_B\)</span>，而对于相干接受方法，保证正交的2FSK信号的最小频率间隔为<span class="math inline">\((f_1-f_0)_{min}=1/2T_B\)</span></p>
<h3 id="正交频分复用">8.3 正交频分复用</h3>
<h4 id="概述">8.3.1 概述</h4>
<p>由于单载波调制存在高速数据信号的码元持续时间<span class="math inline">\(T_B\)</span>短，但占用带宽B大，容易产生码间串扰和频率选择性衰落，而多载波调制能通过将信道划分为N个子信道，高速的在N路低速子数据流上串并传输，并分别调制到各子载波上并行传输</p>
<p>OFDM(正交频分复用)就是一种多载波并行调制体制，设计思路是将高速数据流分散到多个子载波上并行传输，从而使各子载波的信号速率大为降低，且因为子信道带宽小于信道相关带宽，意味着每个子信道可以看出平坦性衰落，从而可以消除ISI，提高抗多径和抗衰落能力，缺点是对信道频率偏移和相位噪声非常敏感，信号峰值频率与平均功率比值较大，将会降低射频功率放大器效率，对同步要求严格</p>
<h4 id="ofdm的基本原理">8.3.2 OFDM的基本原理</h4>
<ol type="1">
<li>表示式：<span class="math inline">\(e(t)=\sum_{k=0}^{N-1}B_ke^{j(2\pi f_kt+\psi_k)},B_k\)</span>为复数，第k路子信道复输入数据</li>
<li>正交条件：只要满足最小子载频间隔为<span class="math inline">\(\Delta f_{min}=1/T_B\)</span></li>
<li>频域特性：频谱相互重叠，但在一个码元持续时间内正交，即减小子载波间相互干扰又提高了频谱利用率，可按照各个子载波所处频段的信道特性采用不同的调制制度，有很大的灵活性</li>
<li>频带利用率：设OFDM系统有N路子载波，子信道码元间隔为<span class="math inline">\(T_B\)</span>，均采用M进制调制，则其占用的频带宽度为<span class="math inline">\(B_{OFDM}=\frac{N+1}{T_B}\)</span>,频带利用率为<span class="math inline">\(\eta_{OFDM}=\frac{R_b}{B_{OFDM}}=\frac{N}{N+1}log_2M(bps/Hz)\)</span>,当N很大，<span class="math inline">\(\eta_{OFDM}\approx log_2M(bps/Hz)\)</span>,若是单载波，频带利用率为<span class="math inline">\(\eta_b=\frac{1}{2}log_2M\)</span>，这表明并行OFDM比串行单载波频带利用率大约提高一倍</li>
</ol>
<h2 id="第九章数字信号的最佳接收">第九章：数字信号的最佳接收</h2>
<p>信道特性不理想与信道噪声等会直接影响接收系统的性能，一个通信系统质量的优劣在很大程度上取决于接收系统的性能</p>
<p>本章节的研究目的就是在噪声的干扰下，如何最佳地接收有用信号，使接受性能达到最优</p>
<h3 id="确知数字信号的最佳接收机">9.3 确知数字信号的最佳接收机</h3>
<p>本节主要是关注构建二进制最佳接收机的原理方框图 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-12-35-04.png"> <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-12-35-29.png"></p>
<h3 id="确知数字信号最佳接收的误码率">9.4 确知数字信号最佳接收的误码率</h3>
<p>推导过程不要求，只研究其误码率公式以及推出的结论 总误码率可表示为<span class="math display">\[P_e=P(1)\frac{1}{\sqrt{2\pi}\sigma_\xi}\int_{-\infty}^a e^{-\frac{x^2}{2\sigma^2_\xi}}dx+P(0)\frac{1}{\sqrt{2\pi}\sigma_\xi}\int_{-\infty}^b e^{-\frac{x^2}{2\sigma^2_\xi}}dx\]</span> 当先验概率P(0),P(1)有一个为1，一个为0时，总误码率都为0，当先验概率相等为0.5时，a=b,则上式可简化为 <span class="math display">\[P_e=\frac{1}{\sqrt{2\pi}\sigma_\xi}\int_{-\infty}^c e^{-\frac{x^2}{2\sigma^2_\xi}}dx,c=-\frac{1}{2}\int_0^{T_B}[s_0(t)-s_1(t)]^2dt\]</span> 可见：误码率仅和两种码元的波形之差的能量有关，而与波形本身无关，差别越大，c值越小，误码率<span class="math inline">\(P_e\)</span>也越小</p>
<p>进一步推导有如下表格 <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-13-01-54.png"></p>
<p>对于多进制通信系统而言，其误码率的计算与二进制类似，每个比特的能量<span class="math inline">\(E_b=E/log_2M\)</span>,每个比特的信噪比<span class="math inline">\(\frac{E_b}{n_0}=\frac{E}{n_0k}\)</span></p>
<h3 id="实际接收机与最佳接收机的性能比较">9.7 实际接收机与最佳接收机的性能比较</h3>
<p><img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-13-03-45.png"></p>
<p>实际接收机:<span class="math inline">\(r=\frac{S}{N}=\frac{S}{n_0B}\)</span>,最佳接收机:<span class="math inline">\(\frac{E_b}{n_0}=\frac{ST}{n_0}=\frac{S}{n\frac{1}{T_B}}\)</span></p>
<p>在S和<span class="math inline">\(n_0\)</span>相同的条件下，<span class="math inline">\(r\sim \frac{E_b}{n_0}\rightarrow B\sim \frac{1}{T_B}\)</span></p>
<p>极限时，<span class="math inline">\(B=\frac{1}{T_B}\)</span>,最佳接收机与实际接收机性能相同，实际上不可能实现，<span class="math inline">\(B&gt;\frac{1}{T_B}\)</span>，这意味着最佳接收机优于实际接收机的性能</p>
<h3 id="数字信号的匹配滤波接收法">9.8 数字信号的匹配滤波接收法</h3>
<h4 id="匹配滤波器的传输特性">9.8.1 匹配滤波器的传输特性</h4>
<p>匹配滤波器是一种能在抽样时刻上获得最大输出信噪比的线性滤波器，其设计目标是通过设计<span class="math inline">\(H(w)\)</span>使其输出信噪比<span class="math inline">\(r_o\)</span>在抽样时刻<span class="math inline">\(t_0\)</span>有最大值</p>
<p>经过一系列复杂的推导，得出的结论是当且仅当<span class="math inline">\(H(f)=kS^*(f)e^{-j2\pi ft_0}\)</span>获得最大信噪比<span class="math inline">\(r_{omax}=\frac{2E}{n_o}\)</span>,此时的H(f)即为最佳接收滤波器的传输特性，等于输入信号码元频谱S(f)的复共轭，故称此滤波器为匹配滤波器，此时的<span class="math inline">\(h(t)=ks(t_0-t)\)</span>,这表明h(t)就是输入信号s(t)的镜像s(-t)在时间轴上平移(右移<span class="math inline">\(t_0\)</span>)--通常取<span class="math inline">\(t_0=T_B\rightarrow h(t)=s(T_B-t)\)</span></p>
<h4 id="匹配滤波器的输出信号">9.8.2 匹配滤波器的输出信号</h4>
<p><span class="math inline">\(s_o(t)=kR(t-t_0),k=1\rightarrow R(t-t_0)\)</span>,当<span class="math inline">\(t=t_0\)</span>时，<span class="math inline">\(max[s_o(t)]=s_o(t_0)=R(0)=E\)</span>,这意味着匹配滤波器可看成是一个计算输入信号自相关函数的相关器，在上面的讨论中并没有涉及信号的波形，这意味着最大信噪比与信号波形无关，所以匹配滤波接收法对基带数字信号和已调数字信号都适用</p>
<h4 id="匹配滤波形式的最佳接收机">9.8.3 匹配滤波形式的最佳接收机</h4>
<p><img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-14-04-53.png"></p>
<h3 id="最佳基带传输系统">9.9 最佳基带传输系统</h3>
<h4 id="理想信道下的最佳基带系统">9.9.1 理想信道下的最佳基带系统</h4>
<p>设理想信道<span class="math inline">\(C(w)=1\)</span>,则系统传输总特性<span class="math inline">\(H(w)=G_T(w)C(w)G_R(w)=G_T(w)G_R(w)\)</span>,最佳化的两个条件，H(w)满足无码间串扰的频域条件，<span class="math inline">\(\sum_i H(w+\frac{2\pi i}{T_B})=C(常数),|w|\le\frac{\pi}{T_B}\)</span>;使系统输出差错概率最小，联立两个条件，可解出<span class="math inline">\(G_R(w)=H^{1/2}(w),G_T(w)=H^(1/2)(w)\)</span> <img src="/2023/12/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E4%B9%9D%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-22-14-10-02.png"></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第一二章知识小结</title>
    <url>/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第一章内容较少，故将一二章合并。本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="通信系统导论">通信系统导论</h2>
<p>通信系统组成框图如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-34-42.png"> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-36-08.png"></p>
<p><strong>超外差接收机框图</strong>： <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-08-22-07-22.png"></p>
<h2 id="通信电子线路分析基础">通信电子线路分析基础</h2>
<h3 id="选频网络">选频网络</h3>
<p><strong>选频网络的作用是选出我们需要的频率分量并滤除不需要的频率分量。选频网络可分 为谐振回路和滤波器两大类</strong></p>
<p>谐振回路 由电感和电容元件组成的振荡回路，振荡回路包含单振荡回路和耦合振荡回路，而单振荡回路又包含串联谐振回路和并联谐振回路。 滤波器滤波器包含LC集中滤波器 、石英晶体滤波器 、陶瓷滤波器和声表面波滤波器 等 。 滤波器的优点是稳定性好，电性能好，品质因数高，利于微型化，便于大量生产</p>
<h4 id="串联谐振回路">串联谐振回路</h4>
<p>电感电容信号源三者串联称为串联回路，其在谐振频率或谐振频率附近工作时，称为串联谐振回路，下面将归纳串联谐振回路的参量进行分析 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-42-33.png"></p>
<ol type="1">
<li><p>回路阻抗 设z为回路阻抗，则回路阻抗可表述为<span class="math inline">\(z=R+j(wL-\frac{1}{wC})\)</span>,进一步化简即可的其阻抗模与阻抗幅角为<span class="math inline">\(|z|=\sqrt{R^2+(wL-\frac{1}{wC})^2},\psi_z=arctan\frac{wL-\frac{1}{wC}}{R}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-10-47-38.png"> 又上图可知，当<span class="math inline">\(w&gt;w_0\)</span>时，回路成感性，电流滞后电压，反之则成容性，电流超前电压，<span class="math inline">\(w=w_0，|z|=R\)</span>，回路串联谐振，当回路谐振时的感抗或容抗,称为特性阻抗，用<span class="math inline">\(\rho\)</span>表示，<span class="math inline">\(\rho=w_0L=\frac{1}{w_0C}=\sqrt{\frac{L}{C}}\)</span></p></li>
<li><p>谐振频率<span class="math inline">\(f_0\)</span> 由上一小节的推导知，串联谐振回路的谐振频率就是当<span class="math inline">\(wL-\frac{1}{wC}=0\)</span>的信号频率<span class="math inline">\(w_0=\frac{1}{\sqrt{LC}},f_0=\frac{1}{2\pi\sqrt{LC}}\)</span></p></li>
<li><p>品质因数Q 谐振时回路感抗值(或容抗值)与回路电阻R 的比值称为回路的品质因数，以Q表示,表示回路损耗大小 <span class="math display">\[Q=\frac{w_0L}{R}=\frac{1}{w_0CR}=\frac{\rho}{R}=\frac{1}{R}\cdot\sqrt{\frac{L}{C}}\]</span> 且在串联谐振时，电感L和电容C上的电压达到最大值且为输入信号电压的Q倍,故串联谐振也称为电压谐振。因此，必须预先注意回路元件的耐压问题</p></li>
<li><p>广义失谐系数<span class="math inline">\(\xi\)</span> 广义失谐是表示回路失谐大小的量，谐振时为0 <span class="math display">\[\xi=\frac{失谐时电抗}{谐振时电阻}=\frac{X}{R}=Q_0(\frac{w}{w_0}-\frac{w_0}{w}),when\quad w\approx w_0,\xi\approx Q_0\cdot\frac{2\Delta f}{f_0}\]</span></p></li>
<li><p>谐振曲线 串联谐振回路中电流幅值与外加电动势频率之间的关系曲线称为谐振曲线,可用<span class="math inline">\(N(f)\)</span>表示谐振曲线函数, <span class="math display">\[N(f)=\frac{失谐处电流}{谐振点电流}=\frac{1}{1+j\xi}\]</span> Q 值不同即损耗R 不同时，对曲线有很大的影响,Q值大，曲线尖锐，选择性好 ;Q小 ，曲线钝,通带宽<img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-03-37.png"></p></li>
<li><p>通频带 当回路外加电压的幅值不变时，改变频率，回路电流下降到<span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>时所对应的频率范围称为谐振回路的通频带，用B表示 <span class="math display">\[B=2\Delta f_{0.7}=\frac{f_0}{Q}\]</span> 所以B与Q成反比,Q增大,B减小,B的推导用到了广义失谐函数辅助推导，在这里省略</p></li>
<li><p>相频特性曲线 其用于表示回路电流相角<span class="math inline">\(\psi_i\)</span>随频率w变化的曲线,<span class="math inline">\(\psi_i=-arctan\frac{x}{R}=-arctan\xi\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-10-59.png"></p></li>
<li><p>信号源内阻及负载对串联谐振回路的影响 若考虑信号内阻<span class="math inline">\(R_s\)</span>与负载<span class="math inline">\(R_L\)</span>，则有载Q值可表述为<span class="math inline">\(Q_L=\frac{w_0L}{R+R_s+R_L}\)</span>,可以看出串联谐振回路适合<span class="math inline">\(R_s\)</span>很小和<span class="math inline">\(R_L\)</span>不大的电路，这样<span class="math inline">\(Q_L\)</span>不会太低，有较好的选择性</p></li>
</ol>
<h4 id="并联谐振回路">并联谐振回路</h4>
<p>由电感、电容、信号源三者并联组成的回路称为并联谐振回路，其中<span class="math inline">\(R_p=\frac{L}{RC}\)</span>，是把电感的R转换到独立支路上得到的等效电阻 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-14-03.png"></p>
<ol type="1">
<li>回路阻抗 对于并联回路来说，一般采用导纳分析比较方便，其导纳 <span class="math display">\[Y=\frac{1}{z}=\frac{CR}{L}+j(wc-\frac{1}{wL})=G+jB\]</span></li>
<li>谐振频率 与串联谐振回路一致为：<span class="math inline">\(w_p=\frac{1}{\sqrt{LC}},f_p=\frac{1}{2\pi\sqrt{LC}}\)</span>，其阻抗特性如下，<span class="math inline">\(w&gt;w_p\)</span>,回路呈容性，反之为感性 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-18-28.png"></li>
<li>品质因数 与串联谐振回路类似为 <span class="math display">\[Q_p=\frac{w_pL}{R}=\frac{R_p}{w_pL}=\frac{R_p}{\rho}=R_p\cdot\sqrt{\frac{C}{L}}\]</span> 式中,R为串联在电感支路的损耗电阻;<span class="math inline">\(R_P\)</span>为并联谐振回路的谐振电阻,且在并联谐振时，电感L和电容C上的电流达到最大值且为输入信号电流的Q倍,故串联谐振也称为电流谐振。</li>
<li>广义失谐系数<span class="math inline">\(\xi\)</span> 广义失谐是表示回路失谐大小的量，谐振时为0 <span class="math display">\[\xi=\frac{失谐时电纳}{谐振时电导}=\frac{B}{G}=\frac{w_pC}{G}(\frac{w}{w_p}-\frac{w_p}{w}),when\quad w\approx w_p,\xi\approx Q_p\cdot\frac{2\Delta f}{f_p}\]</span></li>
<li>谐振曲线 并联谐振回路中电压幅值与外加电动势频率之间的关系曲线称为谐振曲线,可用<span class="math inline">\(N(f)\)</span>表示谐振曲线函数, <span class="math display">\[N(f)=\frac{失谐处电压}{谐振点电压}=\frac{1}{1+j\xi}\]</span> Q 值不同时，对曲线有很大的影响,Q值大，曲线尖锐，选择性好 ;Q值小，曲线钝,通带宽<img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-25-22.png"></li>
<li>通频带 当回路外加电流的幅值不变时，改变频率，回路电压下降到<span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>时所对应的频率范围称为谐振回路的通频带，用B表示 <span class="math display">\[B=2\Delta f_{0.7}=\frac{f_p}{Q_p}\]</span> 所以B与Q成反比,Q增大,B减小,B的推导用到了广义失谐函数辅助推导，在这里省略</li>
<li>相频特性曲线 其用于表示回路电压相角<span class="math inline">\(\psi_v\)</span>随频率w变化的曲线,<span class="math inline">\(\psi_v\approx-arctan\xi\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-29-05.png"></li>
<li>信号源内阻及负载对串联谐振回路的影响 若考虑信号内阻<span class="math inline">\(R_s\)</span>与负载<span class="math inline">\(R_L\)</span>，则有载Q值可表述为<span class="math inline">\(Q_L=\frac{Q_p}{1+\frac{R_p}{R_s}+\frac{R_p}{R_L}}\)</span>,可以看出并联谐振回路适合<span class="math inline">\(R_s\)</span>很大和<span class="math inline">\(R_L\)</span>很大的电路，这样<span class="math inline">\(Q_L\)</span>不会太低，有较好的选择性，适用于恒流源。</li>
</ol>
<h4 id="串并联阻抗等效互换与回路抽头阻抗互换">串并联阻抗等效互换与回路抽头阻抗互换</h4>
<h5 id="串并阻抗的等效互换">串并阻抗的等效互换</h5>
<p><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-31-23.png"> 在实际电路中有时为了分析电路方便需进行串、并联电路的等效互换，若<span class="math inline">\(Z_{AB}=Z_{A&#39;B&#39;}\)</span>,则经过推导可得 <span class="math display">\[R_2=(1+Q_L^2)(R_1+R_x),x_2=x_1(1+\frac{1}{Q_{L}^2})\\when\quad Q_L&gt;&gt;1,R_2\approx(R_1+R_2)Q_L^2,x_2\approx x_1\]</span></p>
<h5 id="回路抽头时阻抗的变化折合关系">回路抽头时阻抗的变化（折合）关系</h5>
<p>从前面分析可知,<span class="math inline">\(R_s,R_L\)</span>对回路Q值有影响，实际应用中为了减小信号源内阻和负载对回路的影响。采用抽头接入方式如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-36-21.png"> 其接入系数P定义为抽头点电压与端电压之比，利用能量等效原则有如下关系 <span class="math display">\[P=\frac{L_1}{L_1+L_2}=\frac{N_1}{N_1+N_2}\]</span> 若为电容抽头，则有 <span class="math display">\[P=\frac{C}{C_2}=\frac{C_1}{C_1+C_2}\]</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-39-25.png"> 根据以上分析得出结论: 1. 抽头改变时，接入系数p改变 2. 由低抽头折合到回路高端，等效导纳降低为原来的<span class="math inline">\(P^2\)</span>,等效电阻提升<span class="math inline">\(\frac{1}{P^2}\)</span>,Q提升很多 3. 对电流源来说与阻抗导纳的区别是低抽头向高抽头转换，电流源减小为原来的P，电压源减小为原来的<span class="math inline">\(\frac{1}{P}\)</span> 4. 负载电容的折合则是等于原来的<span class="math inline">\(P^2\)</span>，折合后电容减小，阻抗加大</p>
<p><strong>插入损耗</strong>：<span class="math inline">\(K=\frac{无损输出功率P_1}{有损输出功率P_1&#39;}=(\frac{1}{1-\frac{Q_L}{Q_0}})^2\)</span></p>
<h4 id="耦合回路">耦合回路</h4>
<h5 id="耦合回路的形式">耦合回路的形式</h5>
<p>耦合回路是由相互间有影响的两个回路组成的，其中接入信号源的回路称为初级回路,与它相互耦合的第二个回路连接负载，称 为次级回路。如果初、次级回路都是谐振回路，则称为耦合振荡回路。耦合振荡回路可以改善谐振曲线,使其选频特性更接近理想的矩形曲线 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-11-43-37.png"> 为了说明回路间耦合程度的强弱，引入耦合系数的概念并以k表示，对于电感耦合回路有<span class="math inline">\(k=\frac{C_M}{\sqrt{C_1+C_M}\sqrt{C_2+C_M}}\)</span>,对于电感耦合回路<span class="math inline">\(k=\frac{M}{\sqrt{L_1L_2}}\)</span></p>
<h5 id="反射阻抗与耦合回路的等效阻抗">反射阻抗与耦合回路的等效阻抗</h5>
<p>一般来说我们更关心的是反射阻抗与耦合回路的等效阻抗，其中反射阻抗用来说明一个回路对另一回路电流的影响，对初次级回路的相互影响，可以用一个反射阻抗来表示 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-14-37-04.png"> 根据上图进行推导，可以求出次级回路对初级回路的反射阻抗<span class="math inline">\(Z_{f1}=\frac{(wM)^2}{Z_{22}}\)</span>,初级回路对次级回路的反射阻抗<span class="math inline">\(Z_{f2}=\frac{(wM)^2}{Z_{11}}\)</span>,经过上述分析可得到等效电路如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-14-39-26.png"> 将自阻抗分解为电阻分量和电抗分量后可得 <span class="math display">\[Z_{f1}=\frac{(wM)^2}{R_{22}^2+X_{22}^2}R_{22}+-j\frac{(wM)^2}{R_{22}^2+X_{22}^2}X_{22}\\Z_{f2}=\frac{(wM)^2}{R_{11}^2+X_{11}^2}R_{22}+-j\frac{(wM)^2}{R_{11}^2+X_{11}^2}X_{11}\]</span> 由上式可知：反射电阻永远是正值。这是因为，无论是初级回路反射到次级回路，还是从次级回路反射到初级回路，反射电阻总是代表一定能量的损耗；反射电抗的性质与原回路总电抗的性质总是相反的；反射电阻和反射电抗的值与耦合阻抗的平方值<span class="math inline">\((wM)^2\)</span>成正比</p>
<h5 id="耦合回路的调谐">耦合回路的调谐</h5>
<p>对于耦合谐振回路，凡是达到了初级等效电路的电抗为零，或次级等效电路的电抗为零或初、次级回路的电抗同时为零，都称为回路达到了谐振，根据调谐参数不同，可分为部分谐振、复谐振和全谐振三种情况</p>
<ol type="1">
<li>部分谐振：如果固定次级回路参数与耦合量不变，调节初级回路的电抗使初级回路达到电抗和为0，称初级回路达到部分谐振，也可调节次级回路电抗使初级回路达到部分谐振</li>
<li>复谐振：在部分谐振的条件下，再改变互感量使得反射电阻等于回路本身电阻，即满足最大功率传输条件，使次级回路电流达到最大值，称为复谐振，<strong>此时单独对两个回路来看都失谐，但是他们的等效回路都对信号源频率谐振</strong></li>
<li>全谐振：调节初级回路的电抗及次级回路的电抗,使两个回路都单独地达到与信号源频率谐振(电抗为0)，即耦合回路达到全谐振，如果进一步改变M使得<span class="math inline">\(R_{11}=R_{f1},R_{22}=R_{f2}\)</span>,则称为最近全谐振，此时有<span class="math inline">\(M_c=\frac{\sqrt{R_{11}R_{22}}}{w},k_c\approx\frac{1}{\sqrt{Q_1Q_2}}\)</span>:临界耦合系数，且注意耦合回路的通频带<span class="math inline">\(B=\sqrt{2}\frac{f_0}{Q}\)</span></li>
</ol>
<h4 id="石英谐振器">石英谐振器</h4>
<p>石英晶体的特点如下：等效电感特别大，等效电容特别小，所以Q值很大；外电路影响很小。</p>
<p>电路有两个谐振角频率，串联谐振角频率和并联谐振角频率，其中，串联谐振频率<span class="math inline">\(w_q=\frac{1}{L_qC_q}\)</span>,并联谐振频率<span class="math inline">\(w_p=\frac{1}{\sqrt{L_q\frac{C_0C_q}{C_0+C_q}}}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-07-08-27-52.png"> 由石英谐振器设计出来的石英晶体滤波器的电抗曲线如下 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-07-08-28-46.png"></p>
<h3 id="非线性电路分析基础">非线性电路分析基础</h3>
<p>非线性元件的参数与通过它的电流或施加于其上的电压有关，非线性元件构成的电路就是非线性电路</p>
<p>非线性电路中至少包含一个非线性元件，其输出输入关系用非线性函数或微分方程表达，不具备叠加型和均匀性，是其与线性电路的主要区别</p>
<p>非线性电路的输入输出关系是非线性函数关系，当信号通过非线性电路后，在输出 信号中将会产生输入信号所没有的频率成分,也可能不再出现输入信号中的某些频率成分。 这是非线性电路的重要特性</p>
<p>非线性电路的分析方法主要有以下三种：</p>
<ol type="1">
<li>幂函数分析法</li>
<li>折线分析法</li>
<li>线性时变参量电路分析法</li>
</ol>
<p>非线性电路主要可以应用在：</p>
<ol type="1">
<li>实现信号频谱的线性变换(频谱搬移)</li>
<li>实现信号频谱的非线性变换</li>
<li>实现变参量电路</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理第六章知识小结</title>
    <url>/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信原理》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="数字基带信号及其频谱特性">6.1 数字基带信号及其频谱特性</h2>
<h3 id="数字基带信号">6.1.1 数字基带信号</h3>
<p>数字基带信号是指未经调制的数字信号，所占据的频谱从零频或很低频率开始的，数字基带传输系统是指不经载波调制而直接传输数字基带信号的系统，而下一章将讲述的数字带通传输系统则是包括调制和解调过程的传输系统 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-15-30-49.png"></p>
<p>在基带传输中的主要技术问题有以下几个：</p>
<ol type="1">
<li>基带传输系统通常存在隔直流电容或传输变压器，基带信号中的直流分量不能通过隔直流电容和变压器，克服措施--研究基带码的码型，寻求基本无直流分量的基带码</li>
<li>码元同步</li>
<li>码间串扰:前一码元波形拖尾干扰到后面若干个码元，克服措施--寻求合适的码元波形，使码间串扰不会引起接收判决错误；采用均衡技术，改善码元波形，减小码间串扰</li>
</ol>
<p>具体来说，数字基带信号又可分为单/双极性波形，单/双归零码，差分波形</p>
<h3 id="数字基带信号的频谱特性">6.1.2 数字基带信号的频谱特性</h3>
<p>数字基带信号可表示为<span class="math inline">\(s(t)=u(t)+v(t)\)</span>，其功率密度可表示为 <span class="math display">\[双边谱：P_s(f)=P_u(f)+P_v(f)=f_BP(1-P)|G_1(f)-G_2(f)|^2+\\\sum_{m=-\infty}^\infty|f_B[PG_1(mf_B)+(1-P)G_2(mf_B)]|^2\delta(f-mf_B)\]</span> <span class="math display">\[单边谱：P_s(f)=2f_BP(1-P)|G_1(f)-G_2(f)|^2+f_B^2|PG_1(0)+(1-P)G_2(0)|^2\delta(f)+\\2f_B^2\sum_{m=1}^\infty|[PG_1(mf_B)+(1-P)G_2(mf_B)]|^2\delta(f-mf_B)\]</span> 由此可以得出以下结论：1. 二进制随机脉冲序列的功率谱包含连续谱和离散谱(可能包含)；连续谱总是存在的，谱的形状取决于<span class="math inline">\(g_1(t),g_2(t)\)</span>频谱和出现概率P；离散谱是否存在也主要取决于以上三者</p>
<p>对于单极性NRZ和RZ矩形脉冲序列的功率谱，不加证明的给出结论(以下均默认P=0.5)</p>
<ol type="1">
<li>单极性NRZ频谱函数为<span class="math inline">\(P_s(f)=\frac{T_s}{4}Sa^2(\pi fT_s)+\frac{1}{4}\delta(f)\)</span></li>
<li>单极性RZ频谱函数为<span class="math inline">\(P_s(f)=\frac{T_s}{16}Sa^2(\frac{\pi fT_s}{2})+\frac{1}{16}\sum_{m=-\infty}^\infty Sa^2(\frac{m\pi}{2})\delta(f-mf_s)\)</span></li>
<li>双极性NRZ频谱函数为<span class="math inline">\(P_s(f)=T_BSa^2(\pi fT_B)\)</span></li>
<li>双极性RZ频谱函数为<span class="math inline">\(P_s(f)=\frac{T_B}{4}Sa^2(\frac{\pi}{2}fT_B)\)</span></li>
</ol>
<h2 id="基带传输的常用码型">6.2 基带传输的常用码型</h2>
<p>选码原则：无直流分量，且低频分量小；定时信息丰富；高频分量小；不受信源统计特性的影响；有自检能力；编译码简单</p>
<p>常用的传输波形有AMI码,<span class="math inline">\(HDB_3\)</span>码，双相码，CMI码，nBmB码，nBmT码</p>
<h2 id="数字基带信号传输与码间串扰">6.3 数字基带信号传输与码间串扰</h2>
<h3 id="系统组成与传输模型">6.3.1 系统组成与传输模型</h3>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-19-24-49.png"></p>
<h3 id="定量分析">6.3.2 定量分析</h3>
<p><img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-19-25-41.png"> 基带传输总特性:<span class="math inline">\(H(w)=G_T(w)C(w)G_R(w)\)</span>,基带信号<span class="math inline">\(d(t)=\sum_{n=-\infty}^\infty a_n\delta(t-nT_B)\)</span>,接受滤波器输出信号为<span class="math inline">\(y(t)=d(t)*h(t)+n_R(t)=\sum_{n=-\infty}^\infty a_nh(t-nT_B)+n_R(t)\)</span>,设抽样时刻为<span class="math inline">\(t=kT_B+t_0\rightarrow a_kh(t_0)+\sum_{n\neq k}a_nh[(k-n)T_B+t_0]+n_R(kT_B+t_0)\)</span>,后两项为ISI值和噪声</p>
<h2 id="无码间串扰的基带传输特性">6.4 无码间串扰的基带传输特性</h2>
<h3 id="五码间串扰的条件">6.4.2 五码间串扰的条件</h3>
<p>消除码间串扰的基本思想是使得其他码元在当前码元的抽样判决点处值为0，由奈奎斯特准则知接收波形满足抽样值无失真传输的充要条件是码元仅在本码元的抽样时刻上有最大值，而其他所有码元在该时刻的串扰值均为0，其对应的时域条件为<span class="math display">\[h(kT_B)=\begin{cases}
    1,k=0\\
    0,else
\end{cases}\]</span> 频域条件<span class="math display">\[\sum_iH(w+\frac{2\pi i}{T_B})=T_B,|w|\le\frac{\pi}{T_B}\]</span></p>
<h3 id="hw的设计">6.4.3 H(w)的设计</h3>
<ol type="1">
<li><p>理想低通特性 <span class="math display">\[H(w)=\begin{cases}
 T_B,|w|\le\frac{\pi}{T_B}\\
 0,|w|&gt;\frac{\pi}{T_B}
\end{cases},h(t)=Sa(\frac{\pi}{T_B}t),B=\frac{1}{2T_B}=f_N,R_B=\frac{1}{T_B}=2f_N\]</span>其中B又被称为奈奎斯特带宽：无失真传输码元周期为<span class="math inline">\(T_B\)</span>的序列是所需的最小频带宽度，<span class="math inline">\(R_B\)</span>又被称为奈奎斯特速率：在带宽为<span class="math inline">\(f_N\)</span>的信道中无码间串扰的最高波特率,由此易得，无ISI基带系统的最高频带利用率<span class="math inline">\(\eta=R_B/B=2,\eta_b=R_b/B=2log_2M\)</span>,由上述公式可得以下重要结论：<strong>在无ISI的要求下，WHz宽的基带信道每秒最多只能传输2W个符号，无码间串扰要求<span class="math inline">\(\eta\le2 \quad or\quad\eta_b\le 2log_2M\)</span></strong>,理想低通传输特性主要存在的问题是特性陡峭不易实现，工程上广泛使用的是余弦滚降特性</p></li>
<li><p>余弦滚降特性 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-19-57-21.png"> 引入滚降系数来描述滚降程度<span class="math inline">\(\alpha=\frac{f_\Delta}{f_N}(0\sim1)\)</span>,进而可推出<span class="math display">\[B=f_N+f_\Delta=(1+\alpha)f_N,\eta=\frac{R_B}{B}=\frac{2}{1+\alpha},\eta_b=\frac{R_b}{B}=\frac{2log_2M}{1+\alpha}\]</span> <span class="math inline">\(\alpha\)</span>越大，<span class="math inline">\(h(t)\)</span>的拖尾衰减越快,<span class="math inline">\(\alpha=0\)</span>：理想低通特性，<span class="math inline">\(\alpha=1\)</span>，升余弦频谱特性，其特点为特性易实现，代价是带宽增加，频率利用率降低</p></li>
</ol>
<h2 id="基带系统的抗噪声性能">6.5 基带系统的抗噪声性能</h2>
<p>本节主要讨论：在无码间串扰的条件下， 噪声对基带信号传输的影响， 即计算噪声引起的误码率，公式考试使会给出，主要掌握其结论 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-20-03-24.png"> 上图表面，当比值<span class="math inline">\(A/\sigma_n\)</span>一定时，双极性基带系统的误码率比单极性的低，抗噪声性能好；在等概条件下，双极性的最佳判决门限电平为0，与信号幅度无关，因而不随信道特性变化而变，故能保持最佳状态。而单极性的最佳判决门限电平为A/2，它易受信道特性变化的影响，从而导致误码率增大；双极性基带系统比单极性基带系统应用更为广泛</p>
<h2 id="时域均衡">6.7 时域均衡</h2>
<p>均衡是指对信号在传输过程的非线性失真进行校正，均衡器设计的两个基本途径分别是频域均衡和时域均衡，分别处理频域与时域，使系统无码间串扰，目的都是消除或减小码间串扰</p>
<p>具体来说，时域均衡的目标使调整各增益加权系数<span class="math inline">\(C_i\)</span>,使得除<span class="math inline">\(k=0\)</span>外，y(t)在奈氏各取样点上的值均为0，消除了码间干扰,<span class="math display">\[y_k=\sum_{i=-N}^Nc_ix_{k-i}=\begin{cases}
    1,k=0\\
    0,k\neq0
\end{cases}\]</span> 均衡效果的评价一般采用峰值失真和均方失真<span class="math display">\[D=\frac{1}{y_0}\sum_{k=-\infty,k\neq0}^\infty|y_k|,e^2=\frac{1}{y_0^2}\sum_{k=-\infty,k\neq0}^\infty y_k^2\]</span>,实际应用中常用迫零调整法 <img src="/2023/12/19/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-19-20-13-57.png"></p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信原理》（第七版）：樊昌信，曹丽娜</li>
<li>老师课件</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第七章知识小结</title>
    <url>/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="本章知识小结">本章知识小结</h2>
<h3 id="概述">概述</h3>
<p>角度调制是用调制信号去控制载波信号角度(频率或相位)变化的一种信号变换方式。如果受控的是载波信号的频率，则称频率调制，简称调频，以FM表示；若受控的是载波信号的相位，则称为相位调制，简称调相，以PM表示。无论是FM还是PM，载频信号的幅度都不受调制信号的影响。调频波的解调称为鉴频或频率检波，调相波的解调称鉴相或相位检波。与调幅波的检波一样，鉴频和鉴相也是从已调信号中还原出原调制信号 <span id="more"></span> <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-13-43-54.png" style="width:50.0%;height:50.0%"> <strong>角度调制与解调和振幅调制与解调最大的区别在频率变换前后频谱结构的变化不同。</strong></p>
<ol type="1">
<li>角度调制:频率变换前后频谱结构发生了变化，属于非线性频率变换。</li>
<li>角度调制的主要优点: 抗干扰性强.FM广泛应用于广播、电视、通信以及遥测方面，PM主要应用于数字通信。</li>
<li>角度调制的主要缺点: 占据频带宽，频带利用不经济。</li>
</ol>
<h3 id="调角波的性质">调角波的性质</h3>
<h4 id="调频波和调相波的波形和数学表达式">调频波和调相波的波形和数学表达式</h4>
<p>FM波和PM波的相关性质在这里省略推导，不加证明的附上二者的对比图 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-13-52-23.png"> 由上表知，此时调频波的调制指数为<span class="math inline">\(m_f=\frac{K_fV_\Omega}{\Omega}\)</span>,调相波的调制指数为<span class="math inline">\(m_p=K_pV_\Omega\)</span>,进而得到调频波最大频移为<span class="math inline">\(\Delta w_f=K_fV_\Omega\)</span>，调相波最大频移为<span class="math inline">\(\Delta w_p=K_pV_\Omega\Omega\)</span>,下面分析当调制信号<span class="math inline">\(V_\Omega(t)=V_\Omega cos\Omega t\)</span>时，调频波的数学表达式为<span class="math inline">\(a_f(t)=V_mcos(w_0t+m_fsin\Omega t)\)</span>,调相波的数学表达式为<span class="math inline">\(a_p(t)=V_mcos(w_0t+m_pcos\Omega t)\)</span></p>
<p>从上面的表达式和对比表格可以看出的是，调频波的频偏与调制频率<span class="math inline">\(\Omega\)</span>无关，调频指数<span class="math inline">\(m_f\)</span>则与<span class="math inline">\(\Omega\)</span>成反比，调相波的频偏<span class="math inline">\(\Delta w_p\)</span>与<span class="math inline">\(\Omega\)</span>成正比，调相指数则与<span class="math inline">\(\Omega\)</span>无关 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-14-49-00.png"> 对比上图中的表达式可以看出，无论调频还是调相，最大频移(频偏)与调制指数之间的关系都是相同的，若频偏都用<span class="math inline">\(\Delta w_m\)</span>表示，调制指数都用m表示，则<span class="math inline">\(\Delta w_m\)</span>与m之间满足以下关系 <span class="math display">\[\Delta w_m=m\Omega\qquad \Delta f_m=mF\\\Delta f =\frac{\Delta w}{2\pi}\qquad F=\frac{\Omega}{2\pi}\]</span> <strong>在幅度调制中，调幅度<span class="math inline">\(m_a\le1\)</span>,否则会产生过调制失真，在角度调制中，无论调频还是调相，调制指数均可大于1</strong></p>
<h4 id="调角信号的频谱与有效频带宽度">调角信号的频谱与有效频带宽度</h4>
<p>由于调频波和调相波的方程式相似,因此要分析其中一种频谱,则另一种也完全适用</p>
<p>调频波的表达式<span class="math inline">\(a_f(t)=V_mcos(w_0t+m_fsin\Omega t)\)</span>利用三角函数关系改写并求解，发现其解只能用贝塞尔函数求解，展开后发现，在单频调制情况下，调频波和调相波可分解为载频和无穷多对上下边频分量之和，各频率分量之间的距离均等于调制频率，且奇数次的上下边频相位相反，包括载频分量在内的各频率分量的振幅均由贝塞尔函数值决定。 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-14-57-47.png"> 由图可知，无论<span class="math inline">\(m_f\)</span>为何值，随着阶数n的增大，边频分量的增幅总的趋势是减小的，<span class="math inline">\(m_f\)</span>越大，具有较大振幅的边频分量就越多</p>
<p>调频波和调相波的平均功率与调幅波一样，也为载频功率和各边频功率之和。单频调制时，调频波和调相波的平均功率利用第一类贝塞尔函数性质求和得到<span class="math inline">\(P_{av}=\frac{1}{2}\frac{V_o^2}{R_L}\)</span>,这表明调频波和调相波的平均功率与调制前的等幅载波功率相等。<strong>说明，调制的作用仅是将原来的载频功率重新分配到各个边频上，而总的功率不变。这一点与调幅波完全不同。</strong></p>
<p>通常将振幅小于载波振幅10%的边频分量忽略不计，有效的上下边频分量总数则为2(m+1)个，即调频波和调相波的有效频带宽度定为<span class="math inline">\(BW=2(m+1)F=2(\Delta f+F)\)</span></p>
<p>根据FM与PM的表达式，我们发现调频波可以看出调制信号为<span class="math inline">\(\int_{0}^{t} v_\Omega(t)\, {\rm d}t\)</span>,而调相波可以看出调制信号为<span class="math inline">\(\frac{dv_\Omega(t)}{dt}\)</span>,<strong>这为间接调频方法奠定了理论基础</strong></p>
<p>当调制信号频率F发生变化时，调频波的调制指数<span class="math inline">\(m_f\)</span>与F成反比变化，其频宽宽度基本不变，故称恒带调制</p>
<p>当调制信号频率F变化时，调相波的调制指数<span class="math inline">\(m_p\)</span>与F无关，其频带宽度随调制频率F变化 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-04-41.png"></p>
<h3 id="调频方法和电路">调频方法和电路</h3>
<h4 id="实现调频的方法和基本原理">实现调频的方法和基本原理</h4>
<p>频率调制是对调制信号频谱进行非线性频率变换，而不是线性搬移，因而不能简单地用乘法器和滤波器来实现。<strong>实现调频的方法分为两大类：直接调频法和间接调频法</strong>。</p>
<ol type="1">
<li>直接调频法
<ol type="1">
<li>用调制信号直接控制振荡器的瞬时频率变化的方法称为直接调频法</li>
<li>优点：原理简单，频偏较大</li>
<li>缺点：中心频率不易稳定</li>
</ol></li>
<li>间接调频法
<ol type="1">
<li>先将调制信号进行积分处理，然后用它控制载波的瞬时相位变化，从而实现间接控制载波的瞬时频率变化的方法，称为间接调频法</li>
<li>优点：实现调相的电路独立于高频载波振荡器以外，所以这种调频波突出的优点是载波中心频率的稳定性可以做得较高。</li>
<li>缺点：可能得到的最大频偏较小</li>
</ol></li>
<li>无论是直接调频还是间接调频，主要技术要求是：
<ol type="1">
<li>频偏尽量大，并且与调制信号保持良好的线性关系(频偏增大与调制线性度之间是矛盾的)</li>
<li>中心频率的稳定性尽量高</li>
<li>寄生调幅尽量小</li>
<li>调制灵敏度尽量高</li>
</ol></li>
</ol>
<h4 id="直接调频电路">直接调频电路</h4>
<ol type="1">
<li>变容二极管：优点：电路简单，工作频率较高，容易获得较大的频偏，在频偏不需很大的情况下，非线性失真可以做得很小。缺点：变容管的一致性较差，大量生产时会给调试带来某些麻烦；另外偏置电压的漂移、温度的变化会引起中心频率漂移，因此调频波的载波频率稳定度不高</li>
<li>晶体管直接调频：用于稳定调频波的中心频率</li>
</ol>
<h4 id="间接调频方法">间接调频方法</h4>
<p>间接调频法的频稳度高，广泛用于广播发射机和电视伴音发射机，关键在于如何实现调相，常用的调相方法有移相法，可变时延调相，矢量合成调相</p>
<ol type="1">
<li>移相法调相 将载频信号<span class="math inline">\(Vcosw_0t\)</span>通过一个相移受调制信号<span class="math inline">\(V_\Omega\)</span>线性控制的移相网络，即可实现调相 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-33-38.png" style="width:60.0%;height:60.0%"> 常用移相网络：如RC移相网络、LC调谐回路移相网络 但是单极LC回路线性相位变化范围小，一般在<span class="math inline">\(30°\)</span>以下，为了增大调相系数，可以用多级单调谐回路构成的变容管调相电路</li>
<li>可变时延法调相 周期信号在经过一个网络后，如果在时间轴上有所移动，则此信号的相角必然发生变化，时延法调相就是利用调制信号控制时延大小而实现调相的一种方法 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-36-11.png" style="width:60.0%;height:60.0%"> 最大优点：调制线性好，相位偏移大</li>
<li>矢量合成调相法</li>
</ol>
<h3 id="调角信号解调">调角信号解调</h3>
<p>调频波的解调简称鉴频；调相波的解调简称鉴相。本节讨论的重点在鉴频。对调频波而言，调制信息包含在已调信号瞬时频率的变化中，所以<strong>解调的任务就是把已调信号瞬时频率的变化不失真地转变成电压变化，即实现“频率—电压”转换。</strong></p>
<h4 id="鉴频方法">鉴频方法</h4>
<ol type="1">
<li><p>实现鉴频的方法 实现鉴频的方法很多，但常用的方法有以下几种：</p>
<ol type="1">
<li>利用波形变换进行鉴频</li>
<li>相移乘法鉴频</li>
<li>脉冲计数式鉴频</li>
<li>利用锁相环路鉴频</li>
</ol></li>
<li><p>利用波形变换进行鉴频 将调频信号先通过一个线性变换网络，<strong>使调频波变换成调频调幅波</strong>，其幅度正比于瞬时频率的变化，经变换网络输出的调频调幅信号再作振幅检波即可恢复出原调制信号</p></li>
<li><p>相移乘法鉴频 将<strong>调频波经过移相电路变成调频调相波</strong>，其相位的变化正好与调频波瞬时频率的变化成线性关系；将此调频调相波与未相移调频波(为参考信号)进行相位比较，即可得到鉴频电路的解调输出。由于相位比较器一般都选用乘法电路，故此类鉴频电路称为相移乘法电路。 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-54-57.png" style="width:60.0%;height:60.0%"></p></li>
<li><p>脉冲计数式鉴频器 <strong>利用调频波单位时间内过零信息的不同来实现解调,优点是线性良好</strong> <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-56-16.png" style="width:60.0%;height:60.0%"></p></li>
<li><p>鉴频器的主要技术指标 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-15-58-19.png" style="width:30.0%;height:30.0%"> 鉴频特性：鉴频器输出电压和输入调频波频率之间的关系</p>
<ol type="1">
<li>鉴频跨导S：中心频率附近，单位频偏引起的输出电压的变化量S，<span class="math inline">\(S=\frac{\Delta v_o}{\Delta f}|_{f-f_o}\)</span>,S越大，意味着鉴频特性曲线越陡峭，鉴频能力越强</li>
<li>线性范围：指鉴频特性曲线近似于直线段的频率范围，用<span class="math inline">\(2\Delta f_{max}\)</span>表示，表明鉴频器不失真解调时所允许的频率变化范围<span class="math inline">\(\rightarrow\)</span>要求<span class="math inline">\(2\Delta f_{max}\)</span>应大于调频波最大频偏的两倍，又被称为鉴频器的带宽</li>
<li>鉴频灵敏度：主要是指为使鉴频器正常工作所需的输入调频波的幅度，其值越小，鉴频器灵敏度越高。</li>
</ol></li>
</ol>
<h4 id="相位鉴频">相位鉴频</h4>
<p>相位鉴频器:利用波形变换来鉴频。原理：利用回路的相位频率特性，将调频波变为调幅—调频波，然后用振幅检波恢复调制信号，常有两种，电感/电容耦合相位鉴频器,本届主要介绍电感耦合相位鉴频器 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-03-22.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>电路说明：输入电路的初级回路C1、L1和次级回路C2、L2均调谐于调频波的中心频率<span class="math inline">\(f_0\)</span>,z负责完成波形变换，等幅调频波<span class="math inline">\(\rightarrow\)</span>调幅-调频波</li>
<li>工作原理：初级回路电流经过互感耦合，在次级回路两端感应产生次级回路电压。加在两个振幅检波器的输入信号分别为 <span class="math display">\[\dot{V_{D1}}=\dot{V_{ac}}+\dot{V_{12}}=\frac{1}{2}\dot{V_{ab}}+\dot{V_{12}}\\\dot{V_{D2}}=\dot{V_{bc}}+\dot{V_{12}}=-\frac{1}{2}\dot{V_{ab}}+\dot{V_{12}}\]</span> 只要加在二极管上的电压为FM-AM波，后面就是振幅检波。这里关键是弄清<span class="math inline">\(\dot{V_{12}}\)</span>与<span class="math inline">\(\dot{V_{ab}}\)</span>间的相位关系，二者的相位关系需要利用到耦合电路化简，这里略过，最后可以得到的结论是 <span class="math display">\[\dot{V_{ab}}=j\frac{M}{L_1}\frac{X_{C2}}{R_2+jX_2}\dot{V_{12}}\]</span> <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-12-05.png" style="width:60.0%;height:60.0%"> 由上图可以看出：
<ol type="1">
<li>当信号频率等于中心频率时，<span class="math inline">\(X_2=0\)</span>,次级电路电压<span class="math inline">\(\dot{V_{ab}}\)</span>比初级电路电压<span class="math inline">\(\dot{V_{12}}\)</span>超前<span class="math inline">\(\frac{\pi}{2}\)</span></li>
<li>当信号频率高于中心频率时，<span class="math inline">\(X_2&gt;0\)</span>,次级电路电压<span class="math inline">\(\dot{V_{ab}}\)</span>比初级电路电压<span class="math inline">\(\dot{V_{12}}\)</span>超前<span class="math inline">\(\frac{\pi}{2}-\theta\)</span></li>
<li>当信号频率高于中心频率时，<span class="math inline">\(X_2&gt;0\)</span>,次级电路电压<span class="math inline">\(\dot{V_{ab}}\)</span>比初级电路电压<span class="math inline">\(\dot{V_{12}}\)</span>超前<span class="math inline">\(\frac{\pi}{2}+\theta\)</span></li>
</ol></li>
<li>由于鉴频器的输出电压等于两个检波器输出电压之差，而每个检波器的输出电压(峰值或平均值)正比于其输入电压的振幅,所以鉴频器输出电压为<span class="math inline">\(V_o=k_d(V_{D1}-V_{D2}),k_d\)</span>为检波器的电压传输系数，结合上面矢量图，有如下结论 <span class="math display">\[f_{in}=f_0,V_{a&#39;b&#39;}=0\\f_{in}&gt;f_0,V_{a&#39;b&#39;}&gt;0\\f_{in}&lt;f_0,V_{a&#39;b&#39;}&lt;0\]</span> 因此，输出电压<span class="math inline">\(V_{a&#39;b&#39;}\)</span>反映了输入信号瞬时频率的偏移<span class="math inline">\(\Delta f\)</span>。而<span class="math inline">\(\Delta f\)</span>与原调制信号<span class="math inline">\(V_\Omega(t)\)</span>成正比，即<span class="math inline">\(V_{a&#39;b&#39;}\)</span>与<span class="math inline">\(V_\Omega(t)\)</span>成正比。亦即实现了调频波的解调,若将二者关系画成曲线，则得到下图 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-21-31.png" style="width:60.0%;height:60.0%"></li>
</ol>
<h4 id="比例鉴频器">比例鉴频器</h4>
<p>前面介绍的相位鉴频器，当输入调频信号的振幅发生变化时，输出电压也会发生变化，因此由各种噪声和干扰引起的输入信号寄生调幅，都将在其输出端反映出来。为了抑制噪声及干扰，在鉴频器前必须增设限幅器，比例鉴频器具有自限幅功能，因而可省去外加限幅器 <img src="/2023/11/26/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-16-22-51.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>原理电路 其波形变换部分与相位鉴频器基本相同，电路上差别主要有以下几点：
<ol type="1">
<li>R1，R2连接点N接地，负载RL接在MN之间，输出电压由M，N引出</li>
<li>R1和R2两端并接大电容C6，使得在检波过程中<span class="math inline">\(a&#39;b&#39;\)</span>间的端电压基本保持不变</li>
<li>D1和D2按环路顺接，以保持直流通路，因此C3和C4上的电压极性一致,<span class="math inline">\(V_{a&#39;b&#39;}=V_{c3}+V_{c4}\)</span>,输出电压为<span class="math inline">\(v_o=\frac{1}{2}(V_{a&#39;b&#39;}-\frac{2V_{a&#39;b&#39;}}{1+\frac{V_{D1}}{V_{D2}}})\)</span></li>
</ol></li>
<li>自限幅特性分析 比例鉴频器不需要前置限幅器，它本身就具有抑制寄生调幅所产生的干扰的能力，在比例鉴频器中，由于C6的电容量很大，因此电压<span class="math inline">\(V_{a&#39;b&#39;}\)</span>基本稳定不变，它只决定于调频波的载波振幅，而与其频偏及寄生调幅都无关. 当输入信号振幅由于干扰突然变大时，由于电压<span class="math inline">\(V_{a&#39;b&#39;}\)</span>基本恒定，就使得检波管的电流明显加大，加重了对输入回路的负载，即回路Q值下降,可迫使信号振幅减小。反之亦然。因而很好地起到了稳幅的作用</li>
</ol>
<h2 id="自问自答">自问自答</h2>
<ol type="1">
<li><p>采用角度调制与解调和振幅调制与解调的区别在哪里？ 角度调制与解调和振幅调制与解调最大的区别在频率变换前后频谱结构的变化不同。角度调制是频率变换前后频谱结构发生了变化，属于非线性频率变换。角度调制的主要优点是抗干扰性强，FM广泛应用于广播、电视、通信以及遥测方面，PM主要应用于数字通信。但是角度调制的主要缺点是占据频带宽，频带利用不经济。</p></li>
<li><p>实现鉴频电路的方法主要有哪些？</p>
<ol type="1">
<li>利用波形变换进行鉴频</li>
<li>相移乘法鉴频</li>
<li>脉冲计数式鉴频器</li>
<li>利用锁相环路实现鉴频</li>
</ol></li>
<li><p>从表面看，增加带宽将使更多的噪声信号进入接收机，但是，为什么宽带的调频信号反而可以提高信噪比呢？ 这是因为调频信号的频谱是有规律地扩展的，各旁频分量是相关的，经解调后宽带信号可以凝聚为窄带的原始调制信号频谱。噪声各频率是彼此独立的，不能凝聚，解调后仍分布在宽带内，大部分 将被滤波器滤除，这就使输出信噪比得以提高。</p></li>
</ol>
<h2 id="未解答的疑惑">未解答的疑惑</h2>
<ol type="1">
<li>在调相电路尤其是阿姆斯特朗法（矢量合成调相法）中如何将电路分析与矢量建立联系？</li>
<li>如何能够进一步不把FM和PM弄混？</li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第三章知识小结</title>
    <url>/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>中心频率在几百千赫兹至几百兆赫兹，信号频谱宽度在几千赫兹至几十兆赫兹,放大微弱 信号的放大器称为<strong>高频小信号放大器</strong>。高频小信号放大器工作在电子器件的线性区域，放大器输入与输出信号的频谱完全相同，因此可采用前面的有源线性四端网络来分析</p>
<p>高频小信号放大器的分类：高频小信号放大器按器件分可分为晶体管放大器，场效应管放大器，集成电路放大器，按通带分可分为窄带放大器和宽带放大器，按负载分可分为谐振放大器和非谐振放大器</p>
<p>高频小信号放大器的质量指标：</p>
<ol type="1">
<li>增益(放大系数)：放大器输出电压与输入电压之比，称为放大器的增益或放大倍数，电压增益<span class="math inline">\(A_V=\frac{V_o}{V_i}\)</span>,功率增益<span class="math inline">\(A_p=\frac{P_o}{P_i}\)</span>,分贝表示<span class="math inline">\(A_V=20lg\frac{V_o}{V_i}\)</span>,分贝表示<span class="math inline">\(A_p=10lg\frac{P_o}{P_i}\)</span></li>
<li>通频带：放大器电压增益下降到最大值的<span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>时，对应的频率范围称为放大器的通频带，用<span class="math inline">\(B=2\Delta f_{0.7}\)</span>表示，也被称为3dB带宽</li>
<li>选择性：从各种不同频率信号的总和（有用的和有害的）中选出有用信号，抑制干扰信号的能力称为放大器的选择性,选择性常采用矩形系数和抑制比来表示
<ul>
<li>矩形系数：按理想情况，谐振曲线应为一个矩形。即在通带内放大量均匀，在通带外 不需要的信号得到完全衰减，但实际上不可能。为了表示实际曲线接近理想曲线的程度，引入矩形系数，它表示对邻道干扰的抑制能力：<span class="math display">\[K_{r0.1}=\frac{2\Delta f_{0.1}}{2\Delta f_{0.7}},K_{r0.01}=\frac{2\Delta f_{0.01}}{2\Delta f_{0.7}}\]</span> <span class="math inline">\(K_r\)</span>越接近1越好</li>
<li>抑制比：表示对某个干扰信号<span class="math inline">\(f_n\)</span>的抑制能力，用<span class="math inline">\(d_n\)</span>表示：<span class="math inline">\(d_n=\frac{A_{V0}}{A_n}\)</span>,<span class="math inline">\(A_n\)</span>干扰信号放大倍数，<span class="math inline">\(A_{V0}\)</span>谐振点<span class="math inline">\(f_0\)</span>放大倍数 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-31-23.png"></li>
</ul></li>
<li>工作稳定性：指在电源电压变化或器件参数变化时,以上三个参数的稳定程度。一般的不稳定现象是增益变化，中心频率偏移，通频带变窄，不稳定状态的极端是放大器自激，导致放大器完全不能工作</li>
<li>噪声系数：放大器的噪声性能可用噪声系数表示<span class="math display">\[N_F=\frac{P_{si}/P_{ni}(输入信号噪声比)}{P_{so}/P_{no}(输出信号噪声比)},N_F\]</span>越接近1越好</li>
</ol>
<h2 id="晶体管高频小信号等效电路和参数">晶体管高频小信号等效电路和参数</h2>
<p>晶体管在高频运用时，它的等效电路不仅包含着一些和频率基本没有关系的电阻，而且 还包含着一些与频率有关的电容,这些电容在频率较高时的作用是不能忽略的。</p>
<p>在电路分析中 ，等效电路是一种很有用的方法,晶体管在高频运用时，它的等效电路主要有两种表示方法，形式等效电路(Y参数等效电路)和物理模拟等效电路(混合<span class="math inline">\(\pi\)</span>型等效电路)-不是考试要求，不介绍</p>
<h3 id="形式等效电路y参数等效电路">形式等效电路(Y参数等效电路)</h3>
<p>形式等效电路将晶体管看出有源四端网络，高频等效电路主要采用y参数分析，即<span class="math inline">\(V_1,V_2\)</span>为自变量，<span class="math inline">\(I_1,I_2\)</span>为参变量 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-37-33.png"> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-38-39.png"> 根据右图等效电路可写出电路方程 <span class="math display">\[\begin{cases}
    \dot{I_1}=y_{ie}\dot{V_1}+y_{re}\dot{V_2}\\
    \dot{I_2}=y_{fe}\dot{V_1}+y_{oe}\dot{V_2}
\end{cases}\]</span>其中<span class="math inline">\(y_{ie}=\frac{\dot{I_1}}{\dot{V_1}}|_{\dot{V_2}=0}\)</span>为输出短路的输入导纳，<span class="math inline">\(y_{re}=\frac{\dot{I_1}}{\dot{V_2}}|_{\dot{V_1}=0}\)</span>为输入短路的反向传输导纳，<span class="math inline">\(y_{fe}=\frac{\dot{I_2}}{\dot{V_1}}|_{\dot{V_2}=0}\)</span>为输出短路的正向传输导纳，<span class="math inline">\(y_{oe}=\frac{\dot{I_2}}{\dot{V_2}}|_{\dot{V_1}=0}\)</span>为输入短路的输出导纳，</p>
<h2 id="晶体管谐振放大器">晶体管谐振放大器</h2>
<h3 id="单级单调谐回路谐振放大器">单级单调谐回路谐振放大器</h3>
<p><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-47-52.png"> 上图是一个典型的单级单调谐放大器，<span class="math inline">\(R_1,R_2,R_3\)</span>为偏置电阻，<span class="math inline">\(L_F,C_F\)</span>为滤波电路，该电路采用负压供电，C,L组成LC谐振回路，<span class="math inline">\(R_4\)</span>加宽回路频带，<span class="math inline">\(y_{ie2}\)</span>是下一组输入导纳</p>
<ol type="1">
<li>等效电路分析： 因为讨论的是小信号，略去直流参数元件即可用Y参数等效电路模拟 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-16-50-53.png"> 由上图可知 <span class="math display">\[\begin{cases}
 \dot{I_b}=y_{ie}\dot{V_i}+y_{re}\dot{V_c}\\
 \dot{I_c}=y_{fe}\dot{V_i}+y_{oe}\dot{V_c}\\
 \dot{I_c}=-\dot{V_C}Y_L&#39;
\end{cases}\\ \]</span> <span class="math inline">\(Y_L&#39;\)</span>代表从集电极c向右看去的回路导纳<span class="math inline">\(Y_L&#39;=\frac{1}{P_1^2}(g_p+jwC+\frac{1}{jwL}+P_2^2y_{ie2})\)</span>，代入化简得放大器的输入导纳可表示为 <span class="math display">\[Y_i=\frac{\dot{I_b}}{\dot{V_i}}=y_{ie}-\frac{y_{re}y_{fe}}{y_{oe}+Y_L&#39;}\]</span></li>
<li>分析质量指标
<ol type="1">
<li>电压增益：按找第一节提到指标并集合电路分析得到电压增益可表示为 <span class="math display">\[\dot{A_V}=\frac{-P_1P_2y_{fe}}{g_\Sigma[1+j\frac{2Q_L\Delta f}{f_0}]},Q_L=\frac{w_0C_\Sigma}{g_\Sigma},f_0=\frac{1}{2\pi\sqrt{LC_\Sigma}}\Delta f=f-f_0\\g_\Sigma=P_1^2g_{oe}+g_p+P_2^2g_{ie2},C_\Sigma=C+P_1^2C_{oe}+P_2^2C_{ie2}\]</span> 注意当谐振回路并联R时，<span class="math inline">\(g_\Sigma\)</span>中要加入一个<span class="math inline">\(g_R\)</span>,当谐振时，<span class="math inline">\(\Delta f=0\)</span>,此时小信号单级单调谐放大器谐振电压增益为 <span class="math display">\[\dot{A_{V0}}=-\frac{P_1P_2y_{fe}}{g_\Sigma}=-\frac{P_1P_2y_{fe}}{P_1^2g_{oe}+g_p+P_2^2g_{ie2}}\]</span> 由上式可知，输出电压与输入电压相差180度，但由于<span class="math inline">\(y_{fe}\)</span>本身是复数也有相角，实际相位差为180°+<span class="math inline">\(\psi_{fe}\)</span>,当工作频率较低时，其相角约等于0，此时才相差180°；要求电压增益增大时，应选择正向传输导纳较大的管子；当谐振时，电压增益达到最大；有载<span class="math inline">\(Q_L=\frac{w_0C_\Sigma}{g_\Sigma}\)</span>，所以<span class="math inline">\(Q_L\)</span>不能太低，否则增益<span class="math inline">\(A_V\)</span>较低</li>
<li>功率增益：<span class="math inline">\(A_{P_0}=\frac{负载获得功率P_0}{信号源传输功率P_i}\)</span>，谐振时可以把等效电路图进一步简化为 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-17-59-02.png"> 推导得出功率增益表达式为<span class="math display">\[A_{po}=\frac{P_1^2P_2^2g_{ie2}|y_{fe}|^2}{g_{ie1}g_\Sigma^2}=(A_{Vo}^2\frac{g_{ie2}}{g_{ie1}})\]</span> 若<span class="math inline">\(g_{ie1}=g_{ie2}\)</span>，则<span class="math inline">\(A_{Po}=A_{Vo}^2\)</span>，当<span class="math inline">\(P_1^2g_{oe}=P_2^2g_{ie2}\)</span>时达到功率匹配，若不考虑<span class="math inline">\(g_p\)</span>，则最大功率增益为<span class="math inline">\((A_{Po})_{max}=\frac{|y_{fe}|^2}{4g_{ie}g_{oe}}\)</span></li>
<li>放大器的通频带：结合第二章知识和前面分析可将带宽表示为 <span class="math display">\[B=\frac{f_0}{Q_L}=\frac{g_\Sigma}{2\pi C_\Sigma}=f_0g_\Sigma w_0L(求不出C时用)\\A_{Vo}=-\frac{P_1P_2y_{fe}}{4\pi\Delta f_{0.7}\cdot C_\Sigma}\]</span> 可知带宽与增益的乘积取决于<span class="math inline">\(C_\Sigma,|y_{fe}|\)</span>且为一固定值</li>
<li>选择性：有第一节中提到的矩形系数表达式推出<span class="math inline">\(K_{r0.1}=\frac{2\Delta f_{0.1}}{2\Delta f_{0.7}}\)</span>,化简得<span class="math inline">\(K_{r0.1}=\sqrt{10^2-1}\)</span>,所以单调谐放大器矩形系数比1大得多，选择性比较差</li>
</ol></li>
</ol>
<h3 id="多级单调谐回路谐振放大器">多级单调谐回路谐振放大器</h3>
<p>若单级放大器的增益不能满足要求，就可以采用多级级联放大器，多级放大器的电压增益可表述为各级增益乘积，若多级放大器是由完全相同的单级放大器组成则有<span class="math inline">\(A_m=A_{v1}^m\)</span>,谐振曲线可表述为<span class="math inline">\(\frac{A_m}{A_{m0}}=\frac{1}{[1+(\frac{Q_L2\Delta f}{f_0})]^{\frac{m}{2}}}\)</span>,等于各单级谐振曲线乘积，级数越多，谐振曲线越尖锐，多级放大器的通频带则可表示为<span class="math inline">\((2\Delta f_{0.7})_m=\sqrt{2^{\frac{1}{m}}-1}\cdot2\Delta f_{0.7}=\sqrt{2^{\frac{1}{m}}-1}\frac{f_0}{Q_L}\)</span>,矩形系数可表示为<span class="math inline">\(K_{r0.1}=\frac{\sqrt{100^{\frac{1}{m}}-1}}{\sqrt{2^{\frac{1}{m}}-1}}\)</span></p>
<p>单调谐回路放大器的优点是电路简单，调试容易，缺点是选择性差，增益与通频带矛盾比较突出</p>
<h2 id="谐振放大器的稳定性">谐振放大器的稳定性</h2>
<p>放大器的工作稳定性是重要的质量指标之一，实际上前面讨论<span class="math inline">\(A_{V0}\)</span>时忽略了内部反馈<span class="math inline">\(y_{re}\)</span>,实际上由于<span class="math inline">\(y_{re}\)</span>存在，放大器可能产生自激,<strong>自激产生的原因主要是由于晶体管内部存在反向传输导纳<span class="math inline">\(y_{re}\)</span>,使晶体管成为双向器件，在一定频率下使得回路总电导为0，此时产生自激振荡</strong>。一般采用稳定系数S表示放大器稳定工作的条件，当S=1，放大器自激，S&lt;1,放大器更自激，S&gt;&gt;1时内部反馈最小，放大器才工作稳定，一般工程中取S=5-10，且电压增益与S满足如下关系<span class="math inline">\(A_{Vo}=\sqrt{\frac{2|y_{fe}|}{Sw_0C_{re}}}\)</span></p>
<p>为了克服自激，一般采用以下两种方法： 1. 中和法：在晶体管的输出端和输入端之间插入一个外加的反馈电路，使它的作用恰好和晶体管的内反馈互相抵消。 2. 失配法：基本思想是信号源内阻不与晶体管输入阻抗匹配，晶体管输出端负载阻抗不与本级晶体管的输出阻抗匹配 3. 优缺点比较：中和法的优点是电路简单，增益不受影响;其缺点是只能在一个频率上完全中和，不适合宽带，因为晶体管离散性大,实际调整麻烦，不适于批量生产。采用中和法对放大器由于温度等原因引起各种参数变化没有改善效果。失配法的优点是性能稳定,能改善各种参数变化的影响;频带宽,适合宽带放大，适于波段工作;生产过程中无须调整,适于大量生产。失配法的缺点是增益较低</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第五章知识小结</title>
    <url>/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="本章知识小结">本章知识小结</h2>
<h3 id="概述">概述</h3>
<p>本章主要讨论自激式振荡器，它是在无须加激励信号的情况下，能将直流电能转换为具有一定波形、频率、幅度的交变能量电路。振荡器又可根据波形不同分为正弦波振荡器和非正弦波振荡器。正弦波振荡器根据工作方式不同又可分为反馈型振荡器和负阻型振荡器。<strong>反馈型振荡器主要由决定振荡频率的选频网络和维持振荡的正反馈放大器组成</strong>，本章主要讨论反馈型正弦波振荡器</p>
<h3 id="反馈式振荡器的基本工作原理">反馈式振荡器的基本工作原理</h3>
<p>反馈式振荡器由反馈放大器演变而来，根据下图可以分析器起振的物理过程和基本组成，简单来说，当开关拨向1，电路未调谐放大器，若在电路稳定后，迅速将开关拨向2点。这是调谐放大器就变为自激振荡器 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-10-41-34.png"></p>
<p>由自激振荡建立的过程可知，反馈型自激振荡器的电路构成必须由以下三部分组成：</p>
<ol type="1">
<li>包含两个(或以上)储能元件的振荡回路，这两个元件中，一个释放能量时，另一个就接收能量。释放和接收能量可以往返进行，其频率取决于元件数值。</li>
<li>可以补充由振荡回路电阻产生损耗的能量来源，在晶体管振荡器中，能源就是直流电源<span class="math inline">\(V_{CC}\)</span></li>
<li>使能量在正确的时间内补充道电路中的控制设备，由有源器件和正反馈电路完成。</li>
</ol>
<p>在上述分析中，反馈式振荡器至少包含一个基本放大器和把能量一部分反馈到放大器输入端的反馈网络F。由模电知识可知，反馈环闭环增益表示为:<span class="math display">\[\dot{A_f}=\frac{\dot{A_o}}{1-\dot{A_o}\cdot \dot{F}}\]</span> <span class="math inline">\(\dot{A_o}=\frac{\dot{V_o}}{\dot{V_i}}|_{\dot{V_f}=0}\)</span>为基本放大器小信号开环增益，<span class="math inline">\(\dot{F}=\frac{\dot{V_f}}{\dot{V_i}}\)</span>为反馈网络小信号电压反馈系数 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-10-51-49.png"> 反馈型正弦波的起振条件为<span class="math display">\[\dot{A_o}\dot{F}&gt;1({A_o}F&gt;1.\phi_A+\phi_F=2n\pi,n=0,\pm1,\dots)\]</span>上式为振幅起振条件和相位起振条件，放大器增益A和输出电压幅度<span class="math inline">\(V_o\)</span>的关系称为振荡特性,<span class="math inline">\(\frac{1}{F}\)</span>与<span class="math inline">\(V_o\)</span>之间的关系称为反馈特性，起振的幅度条件如下图所示 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-04-47.png"> 但在实际设计中，由于静态工作点太低，振荡器电路无法自行起振，必须给一个较大幅度的初始激励，使动态点越过不稳定平衡点B才能起振，这称为硬激励起振，设计电路时要尽量避免 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-06-34.png"> 起振后，为了确保维持自激振荡，必须满足平衡条件，平衡条件可表述为：<span class="math display">\[A\cdot F=1,\phi_A+\phi_F=2n\pi,n=0,1,2\dots\]</span></p>
<p>若用电路参数表示振幅平衡条件和相位平衡条件则有 <span class="math display">\[|\overline{y_{fe}}|\cdot|Z_{p1}|\cdot F=1\\\phi_Y+\phi_Z+\phi_F=2n\pi,n=0,1,2...\]</span></p>
<p>振荡器平衡状态的稳定条件是指在外因作用下平衡条件被破坏后，振荡器能自动恢复到原来平衡状态的能力，稳定条件也分为振幅稳定和相位稳定两种： 1. 振幅稳定:<strong>在平衡点附近，放大倍数随振幅的变化特性具有负的斜率</strong><span class="math display">\[\frac{\partial A}{\partial V_{om}}|_{V_{om}=V_{omQ}}&lt;0\]</span> 2. 相位稳定：<strong>振荡器相位稳定条件要求谐振回路的相频特性曲线<span class="math inline">\(\phi_z=f(w)\)</span>在工作频率附近具有负的斜率</strong><span class="math display">\[\frac{\partial \phi}{\partial w}\approx\frac{\partial \phi_Z}{\partial w}&lt;0\]</span></p>
<h3 id="反馈型lc振荡器线路">反馈型LC振荡器线路</h3>
<p>采用LC谐振回路作为选频网络的反馈振荡器统称为LC振荡器。LC振荡器按其反馈网络的不同，可分为互感耦合振荡器、电感反馈式振荡器和电容反馈式振荡器三种类型，其中后两种通常统称为三端式振荡器</p>
<h3 id="互感耦合振荡器">互感耦合振荡器</h3>
<p>互感耦合振荡器是依靠线圈之间的互感耦合实现正反馈的，因此，耦合线圈同名端的正确位置至关重要。同时,耦合量M要选择合适,使其满足振幅起振条件。</p>
<p>互感耦合振荡器有三种形式:调集电路、调基电路和调发电路，具体根据振荡回路是在集电极电路、基极电路和发射极电路来区分的 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-29-41.png"></p>
<p>由于基极和发射极之间的输入阻抗比较低，为了避免过多地影响回路的Q 值，故在调基和调发这两个电路中，晶体管与振荡回路进行部分耦合。调集电路在高频输出方面比其他两种电路稳定,而且幅度较大,谐波成分较小。调基电路振荡频率在较宽的范围改变时，振幅比较平稳。</p>
<p><strong>互感耦合振荡器在调整反馈（改变M）时，基本上不影响振荡频率。但由于分布电容的存在,在频率较高时，难于做出稳定性高的变压器。因此，它们的工作频率不宜过高，一般应用于中、短波波段</strong></p>
<p>根据h 参数等效电路分析可知互感耦合振荡器的振荡频率 <span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\]</span></p>
<h3 id="三端式振荡器">三端式振荡器</h3>
<p>1 .电感反馈三端式振荡器（哈特莱电路） <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-11-44-13.png"></p>
<ul>
<li>线路特点：它的反馈电压<span class="math inline">\(\dot{v_f}\)</span>是由电感<span class="math inline">\(L_2\)</span>上获得的，晶体管的三个电极分别与回路电感的三个端点相连接，<strong>故称为电感反馈三端式振荡器</strong>。电路中集电极馈电采取串联馈电方式，基极则采取并联馈电方式, <span class="math inline">\(C_b\)</span>为隔直流电容，防止<span class="math inline">\(V_{CC}\)</span>通过电感， 加到基极，以免高压击穿管子。</li>
<li>振荡频率与反馈系数：<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\\L=L_1+L_2+2M，F=\frac{L_2+M}{L_1+M}\]</span></li>
<li>电路的优缺点：<strong>优点</strong>：<span class="math inline">\(L_1,L_2\)</span>之间有互感，反馈较强，容易起振;振荡频率调节方便,只要调整电容C的大小即可，而且C的改变基本上不影响电路的反馈系数。<strong>缺点</strong>:振荡波形不好，因为反馈电压是在电感上获得的，而电感对高次谐波呈高阻抗，因此对高次谐波的反馈较强，使波形失真大;另外，电感反馈三端电路的振荡频率不能做得太高，这是因为频率太高, L太小,不宜制造且分布参数的影响太大。电感三端式振荡器的工作频率一般在几十兆赫兹以下。</li>
</ul>
<ol start="2" type="1">
<li>电容反馈三端式振荡器(考比次电路) <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-40-21.png"></li>
</ol>
<ul>
<li>线路特点：它的反馈电压<span class="math inline">\(\dot{v_f}\)</span>是由电容<span class="math inline">\(C_2\)</span>上获得的，晶体管的三个电极分别与回路电容的三个端点相连接，故称为电容反馈三端式振荡器。电路中集电极和基极均采取并联馈电方式。<span class="math inline">\(C_b,C_c\)</span>均为隔直电容。</li>
<li>振荡频率与反馈系数：<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\\C=\frac{C_1C_2}{C_1+C_2},F=\frac{C_1}{C_2}\]</span></li>
<li>电路的优缺点：<strong>优点</strong>：振荡波形好，因为它的反馈电压<span class="math inline">\(\dot{v_f}\)</span>是靠电容获得的，而电容元件对信号的高次谐波呈低阻抗，因此，对高次谐波反馈较弱,使振荡波形更接近正弦波;另外,这种电路的频率稳定度较高，由于电路中的不稳定电容均与回路电容<span class="math inline">\(C_1,C_2\)</span>相并联,因此，适当加大回路的电容量，就可以减小不稳定因素对振荡频率的影响。电容三端电路的工作频率可以做得较高，因为它可直接利用振荡管的输出、输入电容作为回路的振荡电容。它的工作频率可做到几十兆赫兹到几百兆赫兹的甚高频波段范围。<strong>缺点</strong>:调<span class="math inline">\(C_1\)</span> 或<span class="math inline">\(C_2\)</span> 来改变振荡频率时,反馈系数也将改变。但只要在L两端并上一个可变电容器，并令<span class="math inline">\(C_1\)</span>与<span class="math inline">\(C_2\)</span>为固定电容，则在调整频率时,基本上不会影响反馈系数。</li>
</ul>
<ol start="3" type="1">
<li><p>三端式LC振荡器组成法则（相位平衡条件的判断准则） <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-47-42.png"> 电路要振荡必须满足条件：<span class="math display">\[x_{be}+x_{ce}+x_{cb}=0\]</span></p>
<p>且由电路分析可以得到，为了满足正反馈条件，<span class="math inline">\(x_{eb},x_{ce}\)</span>必须性质相同，为同名电抗，<span class="math inline">\(x_{cb}\)</span>则为异名电抗，<strong>以此准则可以迅速判断振荡电路组成是否合理，能否起振</strong></p></li>
<li><p>串联型改进电容三端式振荡器(克拉泼电路) <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-52-39.png"> 与电容三端式电路比较，克拉泼电路的特点是在回路中增加了一个与L串联的电容<span class="math inline">\(C_3\)</span>。各电容取值必须满足：<span class="math inline">\(C_3&lt;&lt;C_1,C_3&lt;&lt;C_2,C_3\)</span>为可变电容。这样可使电路的振荡频率近似只与<span class="math inline">\(C_3,L\)</span>有关。该电路的振荡频率为<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC_3}}\]</span>可见，该电路的振荡频率几乎与<span class="math inline">\(C_1,C_2\)</span>无关，<strong>所以克拉泼电路的频率稳定性比电容三端式要好</strong>，其缺点为<strong>不适于用作波段振荡器</strong>。所以克拉泼电路只适于用作固定频率振荡器或波段覆盖系数较小的可变频率振荡器</p></li>
<li><p>并联型改进电容三端式振荡器(西勒电路) <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-14-58-59.png"> 西勒电路是在克拉泼电路基础上,在电感L两端并联了一个小电容<span class="math inline">\(C_4\)</span>,且满足<span class="math inline">\(C_1,C_2\)</span>远大于<span class="math inline">\(C_3\)</span> ，所以其回路等效电容<span class="math display">\[C=\frac{C_1C_2C_3}{C_1C_2+C_2C_3+C_1C_3}+C_4\approx C_3+C_4\]</span> 振荡频率为:<span class="math display">\[f_o\approx\frac{1}{2\pi}\sqrt{\frac{1}{LC}}\\C=C_3+C_4\]</span></p>
<p>在西勒电路中，由于<span class="math inline">\(C_4\)</span>与L并联，所以<span class="math inline">\(C_4\)</span>大小不影响回路接入系数，在振荡频率变化时基本保持不变，从而使输出振幅稳定，因此其可用作波段振荡器</p></li>
</ol>
<h3 id="振荡器的频率稳定问题">振荡器的频率稳定问题</h3>
<p>振荡器的频率稳定度是振荡器的一个关键指标。频率稳定，就是在各种外界条件发生变化的情况下，要求振荡器的实际工作频率与标称频率间的偏差及偏差的变化最小。<strong>评价振荡器频率的主要指标有两个,即准确度与稳定度。</strong></p>
<p><strong>振荡器的实际工作频率f与标称频率<span class="math inline">\(f_0\)</span>之间的偏差，称为振荡频率的准确度</strong>。它通常分为绝对频率准确度与相对频率准确度两种，其表达式如下。 <span class="math display">\[绝对准确度：\Delta f=|f-f_0|\\相对准确度：\frac{\Delta f}{f_0}=\frac{|f-f_0|}{f_0}\]</span></p>
<p><strong>振荡器的频率稳定度则是指在一定时间间隔内，由于各种因素变化，引起的振荡频率相对于标称频率变化的程度</strong><span class="math display">\[频率稳定度：\delta=\frac{\Delta f_{max}}{f_0}|_{t=\Delta t}\]</span></p>
<h3 id="石英振荡器">石英振荡器</h3>
<p><img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-15-15-03.png"> 上图是石英晶振的符号和等效电路，石英晶振的Q值和特性阻抗<span class="math inline">\(\rho\)</span>都非常高。这是因为其<span class="math inline">\(L_q\)</span>较大，<span class="math inline">\(C_q\)</span>与<span class="math inline">\(r_q\)</span>很小的缘故。</p>
<p>由上图(b)可知，石英晶振可等效为一个串联谐振回路和一个并联谐振回路，若忽略<span class="math inline">\(r_q\)</span>,则晶振两端呈现纯电抗，其电抗频率特性曲线如下图实线所示 <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-15-15-15-22.png"> 其串联谐振频率为<span class="math inline">\(f_q=\frac{1}{2\pi\sqrt{L_qC_q}}\)</span>,并联谐振频率为<span class="math inline">\(f_p=\frac{1}{2\pi\sqrt{L_q\frac{C_0C_q}{C_0+C_q}}}\\=\frac{f_0}{\sqrt{\frac{C_0}{C_0+C_q}}}=f_q\sqrt{1+\frac{C_q}{C_0}}\)</span></p>
<p>由于<span class="math inline">\(C_q/C_0\)</span>很小，所以<span class="math inline">\(f_p,f_q\)</span>间隔很小，因而在<span class="math inline">\(f_p-f_q\)</span>感性区间, 石英晶振具有陡峭的电抗频率特性，曲线斜率大，利于稳频。若外部因素使谐振频率增大，则根据晶振电抗特性,必然使等效电感L增大，但由于振荡频率与L的平方根成反比,所以又促使谐振频率下降,趋近于原来的值。</p>
<h4 id="晶体谐振器电路">晶体谐振器电路</h4>
<p>将石英晶振作为高Q 值谐振回路元件接入正反馈电路中，就组成了晶体振荡器。根据石英晶振在振荡器中的作用原理，晶体振荡器可分成两类:<strong>一类是将其作为等效电感元件用在三端式电路中，工作在感性区间，称为并联型晶体振荡器;另一类是将其作为一个短路元件串接于正反馈支路上,工作在它的串联谐振频率上，称为串联型晶体振荡器</strong></p>
<h2 id="自问自答">自问自答</h2>
<ol type="1">
<li><p>如何化简正弦波振荡器电路？ 在正弦波振荡电路中我们考虑的往往是正反馈产生振荡的电路，因此在简化电路的过程中只需要聚焦正反馈部分即可。不妨对振荡电路中的R、L、C分别讨论。 对于R，在电路化简过程中我们认为其开路，因为R在电路中起到的作用与正反馈无关。 对于L，在高频电路中L的阻抗<span class="math inline">\(jwL\)</span>很高，尤其是L充当高频扼流圈时往往认为L开路。 对于C，在高频电路中C的阻抗<span class="math inline">\(\frac{1}{jwL}\)</span>很低，尤其是C充当旁路电容、耦合电容、电源滤波电容时往往认为C短路。</p></li>
<li><p>为什么要对电容反馈三端式振荡电路进行改进呢？ 当我们利用电容反馈三端式电路，调<span class="math inline">\(C_1\)</span>或<span class="math inline">\(C_2\)</span>来改变振荡频率时，由于反馈系数为<span class="math inline">\(\frac{C_1}{C_2}\)</span>，易知反馈系数将改变。但是如果给电路串联一个小电容<span class="math inline">\(C_3\)</span>，因为C3远远小于C1和C2，所以三电容串联后的等效电容可以约等于<span class="math inline">\(C_3\)</span>。此时振荡角频率和反馈系数独立，可以有效调整并控制电路。<span class="math display">\[w_0\approx\frac{1}{LC_3},F=\frac{C_1}{C_2}\]</span></p></li>
<li><p>电感反馈三端式振荡器与电容反馈三端式振荡器各有何优缺点？ <img src="/2023/11/14/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-05-15-00-09.png"></p></li>
</ol>
<h2 id="未解答的疑惑">未解答的疑惑</h2>
<ol type="1">
<li>对泛音晶体振荡电路的原理不太理解。</li>
<li>石英振荡器的作用和设计思路不理解</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第六章知识小结</title>
    <url>/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="本章知识小结">本章知识小结</h2>
<h3 id="频谱搬移电路的特性">频谱搬移电路的特性</h3>
<p>非线性电路具有频率变换的功能（乘法器）<br>
线性频率变换：频率变换前后，信号的频谱结构不变. 频谱搬移电路: 信号频谱无失真的在频率轴上搬移 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-37-29.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>它们的实现框图几乎是相同的，都是利用非线性器件对输入信号频谱实行变换以产生新的有用频率成分后，滤除无用频率分量。</li>
<li>从频谱结构看，上述频率变换电路都只是对输入信号频谱实行横向搬移而不改变原来的谱结构，因而都属于所谓的线性频率变换。</li>
<li>频谱的横向平移从时域角度看相当于输入信号与一个参考正弦信号相乘，而平移的距离由此参考信号的频率决定，它们可以用乘法电路实现。</li>
</ol>
<h3 id="振幅调制原理">振幅调制原理</h3>
<p>调制:将要传送的信息装载到某一高频载频信号上去的过程 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-56-11.png" style="width:60.0%;height:60.0%"></p>
<p>调制可分为连续波调制和脉冲波调制 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-57-02.png" style="width:60.0%;height:60.0%"> 本章主要介绍的是调幅，调频与调相将在第七章中讲述。 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-20-58-10.png" style="width:60.0%;height:60.0%"></p>
<h4 id="调幅波的性质">调幅波的性质</h4>
<p>普通调幅波的数学表达式(一般考虑单音调制) <span class="math display">\[\begin{cases}
    载波信号：v_0=V_0cosw_0t\\
    调制信号：v_\Omega=V_\Omega cos\Omega t\\
    调幅信号(已调波)：v_{AM}=V_m(t)cosw_0t
\end{cases}\]</span> 因为调幅信号的振幅与调制信号成线性关系，所以<span class="math inline">\(V_m(t)=V_0+k_aV_\Omega cos\Omega t,k为比例常数\\\rightarrow V_m(t)=V_0(1+\frac{k_aV_\Omega}{V_0}cos\Omega t)=V_0(1+m_acos\Omega t),m_a=\frac{k_aV_\Omega}{V_0}:调幅度\in (0,1]\)</span> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-06-02.png" style="width:60.0%;height:60.0%"> 波形特点： 1. 调幅波的振幅（包络）变化规律与调制信号波形一致 2. 调幅度<span class="math inline">\(m_a\)</span>反映了调幅的强弱度 <span class="math display">\[\begin{cases}
    m_a=0,未调幅\\
    m_a=1,最大调幅\\
    m_a&gt;1,过调幅，包络失真
   \end{cases}\]</span></p>
<p>将调幅波的数学表达式展开，可得<span class="math inline">\(v(t)=V_0cosw_0t+\frac{1}{2}m_aV_0cos(w_0+\Omega)t+\frac{1}{2}m_aV_0cos(w_0-\Omega)t\)</span> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-14-07.png" style="width:60.0%;height:60.0%"> 调幅波包含三个频率分量，载波分量<span class="math inline">\(w_0\)</span>不含传输信息，上边频分量<span class="math inline">\(w_0+\Omega\)</span>,下边频分量<span class="math inline">\(w_0-\Omega\)</span>均含传输信息</p>
<p><strong>调幅过程实际上是 频谱搬移过程，即将调制信号的频谱搬移到载波附近，成为对称排列在载波频率两侧的上、下边频，幅度均等于<span class="math inline">\(\frac{1}{2}m_aV_0\)</span></strong></p>
<p>将普通调幅波输送功率至电阻R上时,载波与边频的功率有： 1. 载波频率<span class="math inline">\(P_{oT}=\frac{1}{2}\frac{V_o^2}{R}\)</span> 2. 上(小)边频<span class="math inline">\(P_{SB1}=P_{SB2}=\frac{1}{4}m_a^2P_{oT}\)</span> 3. 一周期平均输出功率<span class="math inline">\(P_AM=(1+\frac{1}{2}m_a^2)P_{oT}\)</span></p>
<p><strong>载波不含信号，但功率却占整个调幅波功率的绝大部分,效率很低</strong></p>
<h4 id="抑制载波的双边带调幅波与单边带调幅波">抑制载波的双边带调幅波与单边带调幅波</h4>
<p>为了克服普通调幅波效率低的缺点，提高设备的功率利用率，可以不发送载波，而只发送边带信号<span class="math inline">\(\rightarrow\)</span>抑制载波的双边带调幅波(DSB AM)</p>
<p>上边频与下边频的频谱分量对称含有相同的信息。 可仅发送单个边带信号<span class="math inline">\(\rightarrow\)</span>单边带通信(SSB) <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-23-38.png" style="width:60.0%;height:60.0%"> 残留边带调幅(记为VSB AM)它在发射端发送一个完整的边带信号、载波信号和另一个部分被抑制的边带信号.既保留了单边带调幅节省频带的优点，且具有滤波器易于实现、解调电路简单的特点</p>
<h3 id="振幅调整方法和电路">振幅调整方法和电路</h3>
<h4 id="概述">概述</h4>
<p>调幅波的共同之处都是在调幅前后产生了新的频率分量，均需用非线性器件来完成频率变换 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-25-21-25-06.png" style="width:60.0%;height:60.0%"> 按调制电路输出功率的高低分类： 1. 高电平调幅电路 　　一般置于发射机的最后一级，是在功率电平较高的情况下进行调制。 2. 低电平调幅电路 　　一般置于发射机的前级，再由线性功率放大器放大已调幅信号，得到所要求功率的调幅波。 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-08-35-28.png" style="width:60.0%;height:60.0%"></p>
<h4 id="低电平调幅电路">低电平调幅电路</h4>
<ol type="1">
<li>简单二极管调幅电路：
<ul>
<li>平方律调幅--二极管小信号时的工作状态</li>
<li>开关调幅--二极管大信号时的工作状态</li>
</ul></li>
<li>平衡调幅器 平衡调制是由两个简单的二极管调幅电路对称连接组成。载波成分由于对称而被抵消，在输出中不再出现。
<ol type="1">
<li>用处：产生DSB和SSB信号的基本电路<br>
</li>
<li>优点：可抑制单管调幅器频谱中所含的直流分量、载波分量以及载波的各次谐波分量</li>
<li>缺点：它虽然是调幅波，但因失去了载波，因而包络不能完全反映调制信号变化的规律，这就给以后的解调工作带来困难；普通调幅波的高频振荡是连续的，可是双边带调幅波在调制信号极性变化时，它的高频振荡的相位要发生180°的突变</li>
</ol></li>
<li>环形调制器 平衡调幅器加上两个二极管，并将四个二极管首尾相接构成环形，<strong>优点：振幅比平衡调制器提高了一倍，并抑制了低频<span class="math inline">\(\Omega\)</span>分量</strong></li>
<li>模拟相乘器 输出电压与输入电压关系：<span class="math inline">\(v_o(t)=kv_1(t)v_2(t)\)</span>，如果<span class="math inline">\(v_1(t)\)</span>为高频载波，<span class="math inline">\(v_2(t)\)</span>为低频调制信号，则输出为抑制载波的双边带调幅信号，若在调制信号上<span class="math inline">\(v_2(t)\)</span>叠加一直流电压，则可以得普通调幅信号的输出</li>
<li>单边带通信
<ol type="1">
<li>优点：
<ol type="1">
<li>节约频带</li>
<li>节省功率</li>
<li>受传播条件影响小,抗选择性衰落能力强</li>
<li>提高了信噪比</li>
</ol></li>
<li>缺点：
<ol type="1">
<li>单边带通信设备复杂、价格昂贵</li>
<li>收发信机需要很高的频率稳定度及其它技术措施 参数单边带方法</li>
</ol></li>
<li>产生单边带方法
<ol type="1">
<li>滤波法：DSB信号经过带通滤波器后，滤除下边带，就得到了SSB信号</li>
<li>移项法：利用移相的方法，消去不需要的边带</li>
<li>修正的移相滤波法</li>
</ol></li>
</ol></li>
</ol>
<h4 id="高电平调幅电路">高电平调幅电路</h4>
<ol type="1">
<li>集电极调幅 工作在过压区，调制信号经低频变压器加载集电极与直流电源串馈，高频载波经高频变压器加到基极回路</li>
<li>基极调幅 工作在欠压区，将基极供电电压与调制信号相加</li>
</ol>
<h3 id="振幅解调检波原理与电路">振幅解调（检波）原理与电路</h3>
<h4 id="概述-1">概述</h4>
<p>振幅解调(又称检波)：振幅调制的逆过程 作用：从已调制的高频振荡中恢复出原来的调制信号 检波器也属于频谱搬移 从频谱看，检波是将幅度调制波中的边带信号不失真地从载波频率附近搬移到零频率附近 　 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-09-40-46.png"> 检波器分类： 1. 包络检波：平方率检波，峰值包络检波，平均包络检波 2. 同步检波：乘积型，叠加型</p>
<h4 id="二极管峰值包络检波器">二极管峰值包络检波器</h4>
<p><img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-09-46-16.png" style="width:60.0%;height:60.0%"></p>
<ol type="1">
<li>大信号检波原理：
<ul>
<li>二极管单向导电特性</li>
<li>检波负载RC的充放电过程(充电时间常数小，放电时间常数大) 通过调节电路中的R,C,可改变充电时间常数，最后让<span class="math inline">\(v_C\)</span>接近<span class="math inline">\(v_i\)</span> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-09-44-44.png"></li>
</ul></li>
<li>包络检波器的质量指标
<ol type="1">
<li>电压传输系数(检波效率)<span class="math inline">\(K_d=\frac{输出电压V_\Omega}{输入包络振幅m_aV_i}\)</span>,<span class="math inline">\(K_d=cos\theta,\theta\approx\sqrt[3]{\frac{3\pi R_d}{R}}\\\theta:电流通角，R：检波器负载电阻，R_d：检波器二极管内阻\)</span></li>
<li>等效输入电阻<span class="math inline">\(R_{id}=\frac{R}{2K_d}\approx R/2\)</span>,即大信号二极管的输入电阻约等于负载电阻的一半</li>
</ol></li>
<li>失真
<ol type="1">
<li>惰性失真(对角线切割失真)
<ul>
<li>原因：时间常数RC太大，当调幅波包络朝较低值变化时，电容上的电荷来不及释放以跟踪其变化，所造成的失真</li>
<li>不产生失真的条件：<span class="math inline">\(RC\Omega_{max}&lt;\frac{\sqrt{1-m_a^2}}{m_a}\)</span>,工程上按<span class="math inline">\(RC\Omega_{max}\le1.5\)</span>计算</li>
</ul></li>
<li>负峰切割失真(底部切割失真)
<ul>
<li>原因：由于<span class="math inline">\(C_c\)</span>的存在使得检波器的交直流电阻不一样,产生了<span class="math inline">\(V_R\)</span>反偏压，它有可能阻止二极管导通，从而产生失真</li>
<li>不产生失真的条件:<span class="math inline">\(m_a&lt;\frac{R_g}{R+R_g}=\frac{R_\smile}{R},R_\smile:交流电阻，R:直流电阻\)</span></li>
</ul></li>
<li>非线性失真 由检波二极管伏安特性曲线的非线性所引起</li>
<li>频率失真
<ul>
<li>原因：滤波电容<span class="math inline">\(C\)</span>影响检波上限频率<span class="math inline">\(\Omega_{max}\)</span>和耦合电容<span class="math inline">\(C_c\)</span>影响检波下限频率<span class="math inline">\(\Omega_{min}\)</span></li>
<li>不产生失真条件：<span class="math inline">\(C_c&gt;&gt;\frac{1}{\Omega_{min}R_g},C&lt;&lt;\frac{1}{\Omega_{max}R}\)</span></li>
</ul></li>
</ol></li>
</ol>
<h4 id="同步检波电路">同步检波电路</h4>
<p>同步检波：不含载频分量，解调时必须在检波器输入端另加一个与发射载波同频同相并保持同步变化的参考信号，此参考信号与调幅信号共同作用于非线性器件电路，经过频率变换，恢复出调制信号 同步检波也可应用于普通调幅信号的解调<span class="math inline">\(\rightarrow\)</span>为了改善性能 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-05-16.png" style="width:60.0%;height:60.0%"> 产生本地振荡信号的方法:</p>
<ol type="1">
<li>由发送端发出导频信号，控制本地振荡器，使本地振荡器的频率和相位与发送端一致。</li>
<li>对于双边带调制来说，可以从双边带调制信号中提取所需的同频同相的载波信号作本地振荡信号。对于单边带调制信号来说，无法直接从单边带信号中提取载波信号，因此在发射单边带信号的同时，还发射受到一定程度抑制的载波信号（称为导频信号）。在接收端，用导频信号控制本机振荡信号使其同步。</li>
<li>采用锁相方法从抑制载波的信号中提取载波 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-08-59.png"> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-09-28.png" style="width:60.0%;height:60.0%"></li>
</ol>
<h3 id="混频器原理与电路">混频器原理与电路</h3>
<h4 id="概述-2">概述</h4>
<p>混频器作用：混频即对信号进行频率变换，将其载频变换到某一固定的频率上(常称为中频)，而保持原信号的特征(如调幅规律)不变。<strong>变频的优点</strong>：变频可提高接收机的灵敏度，提高接收机的选择性，工作稳定性好，波段工作时其质量指标一致性好。<strong>变频的缺点</strong>：容易产生镜像干扰、中频干扰等干扰 <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-25-48.png" style="width:60.0%;height:60.0%"> <img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-26-42.png"> 1. 叠加型混频器: 根据所用非线性器件的不同，叠加型混频器有下列几种： - 晶体三极管混频器：具有一定混频增益 - 场效应管混频器：交调、互调干扰少 - 二极管平衡混频器和环形混频器 ：动态范围大，组合频率干扰少 2. 乘积型混频器：模拟乘法器＋带通滤波器</p>
<h4 id="晶体三极管混频器">晶体三极管混频器</h4>
<p><img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-29-39.png"> 主要采用变跨导分析法：在混频时，混频管可看成一个参数(跨导)在改变的线性元件，即变跨导线件元件。其变频跨导被定义为<span class="math inline">\(g_c=\frac{输出中频电流振幅I_i}{输入高频电压振幅V_{Sm}}=\frac{1}{2}g_1\)</span></p>
<h4 id="晶体管二极管混频器">晶体管二极管混频器</h4>
<p><img src="/2023/11/25/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-11-26-10-33-16.png" style="width:60.0%;height:60.0%"> 1. 平衡混频器<br>
2. 环形混频器</p>
<h4 id="混频器的干扰">混频器的干扰</h4>
<ol type="1">
<li><p>有用信号谐波和本振信号谐波产生的干扰--组合频率干扰(干扰哨声) 混频器输出信号中所包含的各种频率分量为<span class="math inline">\(f_k=|\pm pf_o\pm qf_s|\)</span>,p,q为任意正整数，分别代表本振频率和信号频率的谐波次数，只有p=q=1时对应的频率<span class="math inline">\(f_o-f_s\)</span>为所需要的中频信号，这意味着<span class="math inline">\(f_o=f_i+f_s\)</span></p>
<p>如果某些组合频率落在谐振回路的通频带内，这些组合频率分量就和有用的中频分量一样，通过中放进入检波器，并在检波电路中与有用信号产生差拍，这时在接收机的输出端将产生哨叫声，形成有害的干扰。这种干扰又称为干扰哨叫，产生条件<span class="math inline">\(f_s=\frac{p\pm1}{q-p}f_i\)</span></p></li>
<li><p>外来干扰信号和本振产生的干扰</p>
<ol type="1">
<li>组合副波道干扰 如果混频器之前的输入回路和高频放大器的选择性不够好，除了要接收的有用信号外，干扰信号也会进入混频器。当干扰频率<span class="math inline">\(f_n\)</span>与本振频率<span class="math inline">\(f_o\)</span>满足 <span class="math display">\[\begin{cases}
  -pf_o+qf_n\approx f_i\\
  pf_o-qf_n\approx f_i
 \end{cases}\]</span> 会产生组合副波道干扰</li>
<li>副波道干扰 在组合副波道干扰中，某些特定频率形成的干扰称为副波道干扰。这种干扰主要有中频干扰和镜像干扰。
<ol type="1">
<li>中频干扰：当干扰信号的频率等于或接近<span class="math inline">\(f_i\)</span>时的干扰。</li>
<li>镜像频率干扰:当外来干扰信号的频率<span class="math inline">\(f_n=f_o+f_i=f_s&#39;\)</span>时的干扰，<span class="math inline">\(f_n=f_o+f_i=f_s+2f_i\)</span></li>
</ol></li>
</ol></li>
<li><p>其他类型的干扰</p>
<ol type="1">
<li>交叉调制(交调)干扰 当所接收电台的信号和干扰电台同时进入接收机输入端时，如果接收机调谐于信号频率，可以清楚地收到干扰信号电台的声音，若接收机对接收信号频率失谐，干扰台的声音也消失,<strong>原因：由混频器3次方以上的非线性传输特性产生的。</strong></li>
<li>互相调制(互调)干扰 当两个或两个以上的干扰进入到混频器的输入端时，它们与本振电压<span class="math inline">\(v_0\)</span>一起加到混频管的发射结。由于器件的非线性作用，它们将产生一系列组合频率分量。如果某些分量的频率等于或接近于中频时，就会形成干扰，称为互调干扰。假设有两个干扰信号进入到混频器，若两干扰信号形成的新的组合频率<span class="math inline">\(|\pm mf_1\pm nf_2|\)</span>与信号频率<span class="math inline">\(f_s\)</span>相近，即组合频率与本振频率<span class="math inline">\(f_0\)</span>之差落在中频范围<span class="math inline">\(f_0-|\pm mf_1\pm nf_2|=f_i\)</span>,就会造成强烈干扰</li>
<li>阻塞干扰 当一个强干扰信号进入接收机输入端后，由于输入电路抑制不良，会使前端电路内放大器或混频器的晶体管处于严重的非线性区域，使输出信噪比大大下降。这种现象称为阻塞干扰。</li>
<li>相互混频 由于本振源内存在杂散边带功率，强干扰与杂散边带噪声混频产生的频率分量落在中频通带内形成中频噪声</li>
</ol></li>
</ol>
<p>综上所述，减小各种干扰的措施可归纳为： 1. 提高混频级前端电路(天线回路和高放)的选择性 2. 合理地选择中频，能有效地减小组合频率干扰 3. 采用各种平衡电路 4. 合理地选择混频管的静态工作点 5. 采用倍频程滤波器抑制二阶互调</p>
<h2 id="自问自答">自问自答</h2>
<ol type="1">
<li><p>为什么在信号传播过程中需要对信号进行调制？</p>
<p>在信号传输过程中，不妨从切实可行的天线选择出发思考。为使天线能有效地发送和接收电磁波，天线的几何尺寸必须和信号波长相比拟，一般不宜短于1／4波长。对于音频信号，一般频率在20Hz～20kHz，其波长为15～15000km，如果使用天线传输天线长度应在3.75～3750km，不容易实现。因此需要将信号调制到高频，使用小尺寸天线处理。</p></li>
<li><p>在同步检波电路中，产生本地信号的方法往往有哪些呢？</p>
<ol type="1">
<li>由发送端发出导频信号，控制本地振荡器，使本地振荡器的频率和相位与发送端一致。</li>
<li>对于双边带调制来说，可以从双边带调制信号中提取所需的同频同相的载波信号作本地振荡信号。</li>
<li>对于单边带调制信号来说，无法直接从单边带信号中提取载波信号，因此在发射单边带信号的同时，还发射受到一定程度抑制的载波信号（称为导频信号）。在接收端，用导频信号控制本机振荡信号使其同步</li>
</ol></li>
<li><p>为什么要对电路进行变频处理？</p>
<ol type="1">
<li>变频可提高接收机的灵敏度</li>
<li>提高接收机的选择性</li>
<li>工作稳定性好</li>
<li>波段工作时其质量指标一致性好</li>
</ol></li>
</ol>
<h2 id="未解答的疑惑">未解答的疑惑</h2>
<ol type="1">
<li>如何理解混频器和变频器的区别</li>
<li>如何区分不同干扰的类型</li>
<li>如何判断不同混频器的优缺点</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>通信电子线路第四章知识小结</title>
    <url>/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本知识小结只针对华中科技大学电子信息与通信学院课程《通信电子线路》进行总结，不保证满足所有读者需求 <span id="more"></span></p>
<h2 id="概述">概述</h2>
<p>谐振功率放大器的主要任务是用来放大高频大信号，主要用于发射机的末级，使其获得 足够的高频功率并馈送到天线辐射出去，谐振功率放大器主要解决的问题是高效率和高功率输出</p>
<p><strong>谐振功率放大器与小信号谐振放大器以及非谐振功率放大器有什么异同之处呢？</strong>：谐振 功率放大器与小信号谐振放大器相同之处是,它们放大的信号均为高频信号,而且放大器的 负载均为谐振回路。而不同之处为，激励信号幅度大小不同，放大器工作点不同，晶体管动 态范围不同。小信号谐振放大器的激励信号幅度小,工作点取在特性曲线的中间，放大后电流为完整的正弦波，小信号谐振放大器也称为线性谐振放大器。谐振功率放大器的激励信号通常大于IV ,工作点一般取在截止偏压以下，只有当信号幅度大于管子的截止偏压时管子才导通，它放大后的电流为余弦脉冲状电流波形 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-19-11.png"> 谐振功率放大器与非谐振功率放大器都要求输出功率大和效率高。功率放大器实质上是一个能量转换器，即把电源供给的直流能量转化为交流能量,能量转换的能力即功率放大器的效率。谐振功率放大器通常用来放大窄带高频信号（信号的通带宽度只有其中心频率的 1%或更小）,其工作状态通常选为丙类工作状态,为了不失真地放大信号，它的负载必须是谐振回路。而非谐振放大器又可分为低频功率放大器和宽带高频功率放大器。低频功率放大器的负载为无调谐负载,如电阻、变压器等,通常工作在甲类或乙类工作状态；宽带高频功率放大器则是以频率响应很宽的传输线作负载，放大器可在很宽的范围内变换工作频率，而不必重新调谐 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-20-57.png"> 由于谐振功率放大器通常工作于丙类工作状态，属于非线性电路。因此,不能采用线性 等效电路进行分析，<strong>通常采用折线近似分析法进行分析</strong></p>
<h2 id="谐振功率放大器的工作原理">谐振功率放大器的工作原理</h2>
<h3 id="谐振功率放大器的原理及电压电流波形">谐振功率放大器的原理及电压电流波形</h3>
<p><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-21-42.png"> 如上图所示，谐振功率放大器电路由晶体管，LC谐振回路和直流供电回路组成，晶体管负责将供电电源的直流能量转换为交流能量的过程中其开关控制左右，谐振回路则是晶体管的负载，直流供电电路为各级提供适当工作状态和能源，<span class="math inline">\(V_{BB}\)</span>为基极偏置，<span class="math inline">\(V_{CC}\)</span>为集电极电源，由于基极为负偏压，晶体管工作状态为丙类工作状态，在此电路中外部电路关系式为 <span class="math display">\[v_{BE}=-V_{BB}+V_{bm}coswt\\v_{CE}=V_{CC}-V_{cm}coswt\]</span>,晶体管内部特性为<span class="math inline">\(i_c=g_c(v_{BE}-V_{BZ})\)</span>,上式为晶体管的转移特性曲线表达式，由下图可以进一步得到<span class="math display">\[V_{bm}cos\theta_c=|V_{BB}|+V_{BZ}\rightarrow cos\theta_c=\frac{|V_{BB}|+V_{BZ}}{V_{bm}}\]</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-28-35.png"></p>
<h3 id="谐振功率放大器的功率关系和放大器的效率">谐振功率放大器的功率关系和放大器的效率</h3>
<p>功率放大器的作用原理是利用输入到基极的信号来控制集电极的直流电源所供给的直流功率，使其转变为交流信号功率输出。这种转换不可能是百分之百的，因为直流电源所供给的功率<span class="math inline">\(P_=\)</span>除了转变为交流输出功率<span class="math inline">\(P_o\)</span>的那一部分外，还有一部分功率以热能的形式消耗在集电极上，成为集电极耗散功率<span class="math inline">\(P_c\)</span>,由能量守恒定律有<span class="math inline">\(P_==P_o+P_c\)</span>,为了说明晶体管放大器转换能力，采用集电极效率<span class="math inline">\(\eta_c=\frac{P_o}{P_=}=\frac{P_o}{P_o+P_c}\)</span>,由此可得出以下结论：1. 尽量降低集电极耗散功率<span class="math inline">\(P_c\)</span>,集电极效率<span class="math inline">\(\eta_c\)</span>自然会提高，这样给定<span class="math inline">\(P_=\)</span>，<span class="math inline">\(P_o\)</span>就会增大。2. 如果维持<span class="math inline">\(P_c\)</span>不超过规定值，提高集电极效率会使交流输出功率增加</p>
<p>谐振功率放大器工作在丙类工作状态时<span class="math inline">\(\theta_c&lt;90°,\theta_c:\)</span>半通角，集电极余弦电流脉冲可分解为傅里叶级数<span class="math display">\[i_c=I_{C0}+I_{cm1}coswt+I_{cm2}cos2wt+\dots\]</span> 因此，谐振功率放大器各功率关系如下：<span class="math display">\[P_==V_{CC}\cdot I_{C0},P_o=\frac{1}{2}I_{cm1}^2R_p,P_c=P_=-P_o,\eta_c=\frac{1}{2}\xi g_1(\theta_c)\]</span>,式中<span class="math inline">\(\xi=\frac{V_{cm}}{V_{CC}}\)</span>称为集电极电压利用系数，<span class="math inline">\(g_1(\theta_c)=\frac{I_{cm1}}{I_{c0}}\)</span>称为波形系数，他是半通角的函数,<span class="math inline">\(\theta_c\)</span>越小，<span class="math inline">\(g_1(\theta_c)\)</span>越大，由以上分析可知：<strong>谐振功率放大器的工作特点是，基极偏置为负值;半通角<span class="math inline">\(\theta_c&lt;90°\)</span>,即丙类工作状态;负载为LC谐振回路</strong></p>
<h2 id="晶体管谐振功率放大器的折线近似分析法">晶体管谐振功率放大器的折线近似分析法</h2>
<h3 id="晶体管特性曲线的理想化及其解析式">晶体管特性曲线的理想化及其解析式</h3>
<p>通常在谐振功率放大器的分析计算时需要对晶体管的转移特性和输出特性的实际特性进行折线理想化,根据理想化原理,晶体管的静态转移特性可用交横轴于<span class="math inline">\(V_{BZ}\)</span>的一条直线来表示(<span class="math inline">\(V_{BZ}\)</span>为截止偏压),若用<span class="math inline">\(g_c\)</span>代表这条直线的斜率，则<span class="math inline">\(i_c=g_c(v_{BE}-V_{BZ}),v_{BE}&gt;V_{BZ},g_c=\frac{\Delta i_c}{\Delta v_{BE}}|_{v_{CE}为常数}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-20-46-27.png"> 由上图可见，在饱和区，根据理想化原理，集电极电流只受集电极电压的控制,而与基极电压无关，理想化特性曲线对不同的<span class="math inline">\(V_{BE}\)</span>值 ，重合为一条通过原点的斜线。我们称此斜线为临界线。<strong>临界线的左侧为饱和区,在此也称为过压区;临界线的右侧为放大区,也称为欠压区</strong>,<strong>若临界线的斜率为<span class="math inline">\(g_{cr}\)</span>,则临界线方程可写为<span class="math inline">\(i_c=g_{cr}v_{CE}\)</span></strong>,因此,在非线性谐振功率放大器中，常常根据集电极电流是否进入饱和区，将放大区的工作状态分为欠压工作状态、过压工作状态和临界工作状态</p>
<h3 id="集电极余弦电流脉冲的分解">集电极余弦电流脉冲的分解</h3>
<p>不论是工作在哪个区域，集电极电流都是周期性脉冲序列，可以用傅里叶级数求系数的方法，来求出它的直流、基波与各次谐波的数值。下面只讨论尖顶余弦脉冲电流的分解，将上一节的<span class="math inline">\(i_C,v_{BE},v_{CE}\)</span>的表达式联立化简可以得到以下表达式 <span class="math display">\[cos\theta_c=\frac{V_{BB}+V_{BZ}}{V_{bm}},\frac{i_C}{i_{C_{max}}}=\frac{coswt-cos\theta_c}{1-cos\theta_c}\\i_{C_{max}}=g_cV_{bm}(1-cos\theta_c)=g_{cr}(V_{CC}-V_{cm})(V_{cm}=\xi V_{CC})=g_{cr}(1-\xi)V_{CC}\]</span>,若将尖顶脉冲分解为傅里叶级数，则有<span class="math display">\[i_C=I_{C0}+I_{cm1}coswt+I_{cm2}cos2wt+...+I_{cmn}cosnwt\\I_{C0}=i_{C_{max}}\alpha_0(\theta_c),I_{cm1}=i_{C_{max}}\alpha_1(\theta_c),I_{cmn}=i_{C_{max}}\alpha_n(\theta_c)\]</span>,<span class="math inline">\(\alpha_n\)</span>是<span class="math inline">\(\theta_c\)</span>的函数，称为尖顶余弦脉冲的分解系数，通常为了兼顾功率与效率，最佳通角取70°左右，考试时一般会给出<span class="math inline">\(\alpha_0(70°)=0.253，\alpha_1(70°)=0.436\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-00-56.png"></p>
<h3 id="谐振功率放大器的动态特性与负载特性">谐振功率放大器的动态特性与负载特性</h3>
<ol type="1">
<li>动态特性 动态特性是在考虑了负载的反作用后,晶体管的集电极电流<span class="math inline">\(i_c\)</span>与<span class="math inline">\(v_{CE},v_{BE}\)</span>同时变化时的关系曲线，常称为交流负载线或工作路,将上一节的<span class="math inline">\(i_C,v_{BE},v_{CE}\)</span>的表达式联立化简可以得到在<span class="math inline">\(i_C-v_{CE}\)</span>坐标平面上的动态特性曲线方程<span class="math display">\[i_c=-g_c(\frac{V_{bm}}{V_{cm}})[v_{CE}-\frac{V_{bm}V_{CC}-V_{BZ}V_{cm}-V_{BB}V_{cm}}{V_{bm}}]\\=g_d(v_{CE}-V_0),g_d=-g_c(\frac{V_{bm}}{V_{cm}}),V_0=\frac{V_{bm}V_{CC}-V_{BZ}V_{cm}-V_{BB}V_{cm}}{V_{bm}}\]</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-07-42.png"></li>
<li>负载特性 根据以上动态特性曲线的分析，当谐振功放的负载<span class="math inline">\(R_p\)</span>变化时，由于<span class="math inline">\(V_{cm}\)</span>与<span class="math inline">\(R_p\)</span>有关,则动态特性曲线的斜率<span class="math inline">\(g_d\)</span>也发生变化，当负载电阻<span class="math inline">\(R_p\)</span>由小至大变化时,动态特性曲线的斜率也由小到大变化 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-10-04.png">
<ol type="1">
<li>欠压工作状态：当负载变大时，集电极电流脉冲的幅值和半通角变化不大，因此其直流分量，基波分量也变化不大，但其交流输出电压明显增大 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-13-23.png"></li>
<li>临界工作状态：工作在临界工作状态时，集电极电流脉冲波形仍为一个尖顶余弦脉冲，直流分量、基波分量与欠压工作状态时相差不大,而此时对应的交流输出电压<span class="math inline">\(V_{cm}\)</span>较大，管子的压降<span class="math inline">\(v_{CE_{max}}\)</span>较小 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-15-21.png"></li>
<li>过压工作状态:此时集电极电流脉冲波形由尖顶脉冲变为凹顶脉冲，其幅值与下凹点随负载变化均发生明显变化，但输出电压变化不明显 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-18-45.png"> 根据以上分析可以做出谐振功率放大器的负载特性曲线，并进一步得到功率效率随负载的变化趋势 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-18-58.png"></li>
</ol></li>
</ol>
<h3 id="各极电压对工作状态的影响">各极电压对工作状态的影响</h3>
<p>在实际应用中，放大器的各极电压发生改变时，放大器的工作状态也会发生改变,下面的分析主要是结合图像分析其电流电压变化趋势，然后根据前面讲述的功率与电压电流的关系，进一步推导得到功率的变化趋势，具体一点可以概括为：<span class="math inline">\(P_=\)</span>曲线形状与<span class="math inline">\(I_{c0}\)</span>曲线相同，<span class="math inline">\(P_o\)</span>曲线形状与<span class="math inline">\(I_{cm1}^2\)</span>曲线相同，<span class="math inline">\(P_c\)</span>则由两者之差求出</p>
<ol type="1">
<li>改变<span class="math inline">\(V_{CC}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-24-33.png"><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-24-41.png"></li>
<li>改变<span class="math inline">\(V_{bm}\)</span> <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-25-22.png"><img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-04-21-25-33.png"></li>
<li>改变<span class="math inline">\(V_{BB}\)</span>:改变<span class="math inline">\(V_{BB}\)</span> ，其工作状态的变化与改变<span class="math inline">\(V_{bm}\)</span>对工作状态的影响是一样的。这是因为无论是<span class="math inline">\(V_{BB}\)</span>还是<span class="math inline">\(V_{bm}\)</span>的变化，其结果都是引起<span class="math inline">\(v_{BE}\)</span>的变化,增加<span class="math inline">\(V_{bm}\)</span>等效于减少<span class="math inline">\(V_{BB}\)</span>的绝对值，所以改变<span class="math inline">\(V_{BB}\)</span>的图只需要将<span class="math inline">\(V_{bm}\)</span>增加的反向改为<span class="math inline">\(|V_{BB}|\)</span>减小的方向即可</li>
</ol>
<h3 id="谐振功率放大器的计算">谐振功率放大器的计算</h3>
<p>谐振功率放大器的主要指标是功率和效率，精确计算较为困难,一般只做工程估算</p>
<ol type="1">
<li>计算功率放大器的指标时，首先要求得集电极电流脉冲的两个主要参量<span class="math inline">\(i_{C_{max}}\)</span>和<span class="math inline">\(\theta_c\)</span></li>
<li>计算电流余弦脉冲的各谐波分量</li>
<li>利用上列数据求出对应的功率和效率</li>
<li>求出最佳负载电阻<span class="math inline">\(R_P=\frac{(\xi V_{CC})^2}{2P_o}\)</span></li>
</ol>
<h2 id="谐振功率放大器电路">谐振功率放大器电路</h2>
<p>在实际的谐振功率放大器电路中，为了使放大器正常工作且输出功率大,传输效率高, 都有相应的输入、输出匹配电路以及合适的直流馈电电路</p>
<ol type="1">
<li><p>直流馈电电路：直流馈电电路包括集电极馈电电路和基极馈电电路，且馈电方式均可分为串联馈电和并联馈电两种,由下图可见串联馈电就是指晶体管，谐振回路，电源三者串联连接，并联则是并联连接 <img src="/2023/12/03/%E9%80%9A%E4%BF%A1%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/2023-12-07-08-49-24.png"></p></li>
<li><p>输出匹配电路：在实际功放电路中，为了使谐振功率放大器有效地放大信号，在负载上获得最大功率输出，常在晶体管和负载之间加接输出四端网络，<strong>输出四端网络的作用主要是匹配、滤波和隔离</strong>，其主要可以分为<span class="math inline">\(\pi\)</span>型匹配网络和复合输出回路(将天线（负载）回 路通过互感或其他形式与集电极调谐回路相耦合),中介回路效率<span class="math inline">\(\eta_k=1-\frac{Q_L}{Q_0}\)</span>,天线功率<span class="math inline">\(P_A=P_o\cdot\eta_k,\eta_k=1-\frac{Q_L}{Q_0}\)</span></p></li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《通信电子线路》（第三版）：严国平，龙占超</li>
<li>老师课件</li>
<li><a href="https://www.icourse163.org/course/HUST-1003157002">通信电子线路mooc</a></li>
</ol>
]]></content>
      <categories>
        <category>大学功课</category>
      </categories>
      <tags>
        <tag>通信电子线路</tag>
      </tags>
  </entry>
  <entry>
    <title>锦标赛排序</title>
    <url>/2022/05/03/%E9%94%A6%E6%A0%87%E8%B5%9B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="锦标赛排序">锦标赛排序</h1>
<h2 id="前言">前言</h2>
<p>这种排序方式的经典应用来自百度的一道面试题：给出一个长度是N的数组，现在要找出最小的两个元素，最少要多少次比较？</p>
<span id="more"></span>
<h2 id="原理">原理</h2>
<p>竞标赛排序又叫树型排序，属于选择排序的一种，其目的是克服直接选择排序不能保留比较结果，不断重复比较的缺点，它的基本思想是首先取得n个元素的关键词，进行两两比较，得到n/2个比较优胜者，然后再两两比较找到第一小的那个，然后把最小那个元素对应的叶子节点的值变为无穷大，那么在搜索第二小值时，我们就只需要比较最小值叶子节点所在的子树即可，就达到了logn次比较的目标，然后一直重复该过程，所以其时间复杂度为O(n*log2n),空间复杂度为O（N）(需要2n-1个节点存放树) <strong>示意图</strong> <img src="https://s2.loli.net/2022/05/03/Igw4nbJCiX7SLDY.png" alt="锦标赛排序-1.png"> <img src="https://s2.loli.net/2022/05/03/rfcWwBUMAl7uzgp.png" alt="锦标赛排序-2.png"> ## 代码实现（python） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, _data, _id):</span><br><span class="line">        self.data = _data</span><br><span class="line">        self.id = _id</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.id, self.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Adjust(data, idx):</span><br><span class="line">    while (idx != 0):</span><br><span class="line">        if (idx % 2 == 1):</span><br><span class="line">            if (data[idx].data &lt; data[idx + 1].data):</span><br><span class="line">                data[(idx - 1) // 2] = data[idx]</span><br><span class="line">            else:</span><br><span class="line">                data[(idx - 1) // 2] = data[idx + 1]</span><br><span class="line">            idx = (idx - 1) // 2</span><br><span class="line">        else:</span><br><span class="line">            if (data[idx - 1].data &lt; data[idx].data):</span><br><span class="line">                data[idx // 2 - 1] = data[idx - 1]</span><br><span class="line">            else:</span><br><span class="line">                data[idx // 2 - 1] = data[idx]</span><br><span class="line">            idx = idx // 2 - 1</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Sort(data):</span><br><span class="line">    length = len(data)</span><br><span class="line">    n = 1</span><br><span class="line">    while n &lt; length:</span><br><span class="line">        n &lt;&lt;= 1</span><br><span class="line">        # print(&quot;n=&quot;,n)</span><br><span class="line">    nTreeSize = 2 * n - 1</span><br><span class="line">    nodes = []</span><br><span class="line">    for i in range(nTreeSize):</span><br><span class="line">        nodes.append(Node(0, 0))</span><br><span class="line">    # 初始化竞赛数数据</span><br><span class="line">    for i in range(n - 1, nTreeSize):</span><br><span class="line">        idx = i - (n - 1)</span><br><span class="line">        if idx &lt; length:</span><br><span class="line">            nodes[i] = Node(data[idx], i)</span><br><span class="line">        else:</span><br><span class="line">            nodes[i] = Node(9999, -1)</span><br><span class="line">    for i in range(n - 2, -1, -1):</span><br><span class="line">        if (nodes[i * 2 + 1].data &lt; nodes[i * 2 + 2].data):</span><br><span class="line">            nodes[i] = nodes[i * 2 + 1]</span><br><span class="line">        else:</span><br><span class="line">            nodes[i] = nodes[i * 2 + 2]</span><br><span class="line">    # 实现排序</span><br><span class="line">    B = []</span><br><span class="line">    for i in range(0, length):</span><br><span class="line">        # 取出最小的</span><br><span class="line">        B.append(nodes[0].data)</span><br><span class="line">        nodes[nodes[0].id].data = 9999</span><br><span class="line">        Adjust(nodes, nodes[0].id)</span><br><span class="line">    return B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    Arr = [2,5,9,1,11,20,15,7,4,6]</span><br><span class="line">    Arr2 = Sort(Arr)</span><br><span class="line">    print(&quot;newArr=&quot;,Arr2)</span><br><span class="line"></span><br></pre></td></tr></table></figure> ## 参考资料 <a href="https://www.cnblogs.com/james1207/p/3323115.html">james1207</a> <a href="https://blog.csdn.net/mmmmmmmmzw/article/details/105216255">mmmmmmmmzw</a></p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
